var __defProp=Object.defineProperty,__defNormalProp=(e,t,n)=>t in e?__defProp(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,__markAsModule=e=>__defProp(e,"__esModule",{value:!0}),__require=(e=>"undefined"!=typeof require?require:"undefined"!=typeof Proxy?new Proxy(e,{get:(e,t)=>("undefined"!=typeof require?require:e)[t]}):e)((function(e){if("undefined"!=typeof require)return require.apply(this,arguments);throw new Error('Dynamic require of "'+e+'" is not supported')})),__export=(e,t)=>{for(var n in __markAsModule(e),t)__defProp(e,n,{get:t[n],enumerable:!0})},__publicField=(e,t,n)=>(__defNormalProp(e,"symbol"!=typeof t?t+"":t,n),n),__accessCheck=(e,t,n)=>{if(!t.has(e))throw TypeError("Cannot "+n)},__privateGet=(e,t,n)=>(__accessCheck(e,t,"read from private field"),n?n.call(e):t.get(e)),__privateAdd=(e,t,n)=>{if(t.has(e))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(e):t.set(e,n)},__privateSet=(e,t,n,a)=>(__accessCheck(e,t,"write to private field"),a?a.call(e,n):t.set(e,n),n);function log(...e){const t=new Date,n=`${t.getHours().toString().padStart(2,"0")}:${t.getMinutes().toString().padStart(2,"0")}:${t.getSeconds().toString().padStart(2,"0")}.${t.getMilliseconds().toString().padStart(3,"0")}`;e&&console.log(n,"Human:",...e)}function join(e,t){const n=e.endsWith("/")?"":"/",a=t.startsWith(".")||t.startsWith("/")||t.startsWith("http:")||t.startsWith("https:")||t.startsWith("file:")?`${t}`:`${e}${n}${t}`;if(!a.toLocaleLowerCase().includes(".json"))throw new Error(`modelpath error: expecting json file: ${a}`);return a}var now=()=>"undefined"!=typeof performance?performance.now():parseInt((Number(process.hrtime.bigint())/1e3/1e3).toString());function validate(e,t,n="config",a=[]){for(const r of Object.keys(t))if("object"==typeof t[r])validate(e[r],t[r],r,a);else{const s=e&&void 0!==e[r];s||a.push({reason:"unknown property",where:`${n}.${r} = ${t[r]}`});const o=e&&typeof e[r]==typeof t[r];s&&!o&&a.push({reason:"property type mismatch",where:`${n}.${r} = ${t[r]}`,expected:typeof e[r]})}return t.debug&&"config"===n&&a.length>0&&log("invalid configuration",a),a}function mergeDeep(...e){const t=e=>e&&"object"==typeof e;return e.reduce(((e,n)=>(Object.keys(n||{}).forEach((a=>{const r=e[a],s=n[a];Array.isArray(r)&&Array.isArray(s)?e[a]=r.concat(...s):t(r)&&t(s)?e[a]=mergeDeep(r,s):e[a]=s})),e)),{})}var config={backend:"",modelBasePath:"",wasmPath:"",debug:!0,async:!0,warmup:"full",cacheSensitivity:.7,skipAllowed:!1,deallocate:!1,filter:{enabled:!0,equalization:!1,width:0,height:0,flip:!1,return:!0,brightness:0,contrast:0,sharpness:0,blur:0,saturation:0,hue:0,negative:!1,sepia:!1,vintage:!1,kodachrome:!1,technicolor:!1,polaroid:!1,pixelate:0},gesture:{enabled:!0},face:{enabled:!0,detector:{modelPath:"blazeface.json",rotation:!0,maxDetected:1,skipFrames:99,skipTime:2500,minConfidence:.2,iouThreshold:.1,cropFactor:1.6,mask:!1,return:!1},mesh:{enabled:!0,modelPath:"facemesh.json"},iris:{enabled:!0,modelPath:"iris.json"},emotion:{enabled:!0,minConfidence:.1,skipFrames:99,skipTime:1500,modelPath:"emotion.json"},description:{enabled:!0,modelPath:"faceres.json",skipFrames:99,skipTime:3e3,minConfidence:.1},antispoof:{enabled:!1,skipFrames:99,skipTime:4e3,modelPath:"antispoof.json"},liveness:{enabled:!1,skipFrames:99,skipTime:4e3,modelPath:"liveness.json"}},body:{enabled:!0,modelPath:"movenet-lightning.json",detector:{modelPath:""},maxDetected:-1,minConfidence:.3,skipFrames:1,skipTime:200},hand:{enabled:!0,rotation:!0,skipFrames:99,skipTime:1e3,minConfidence:.5,iouThreshold:.2,maxDetected:-1,landmarks:!0,detector:{modelPath:"handtrack.json"},skeleton:{modelPath:"handlandmark-full.json"}},object:{enabled:!1,modelPath:"mb3-centernet.json",minConfidence:.2,iouThreshold:.4,maxDetected:10,skipFrames:99,skipTime:2e3},segmentation:{enabled:!1,modelPath:"selfie.json",blur:8}},tfjs_esm_exports={};__export(tfjs_esm_exports,{Abs:()=>Abs,Acos:()=>Acos,Acosh:()=>Acosh,AdadeltaOptimizer:()=>AdadeltaOptimizer,AdagradOptimizer:()=>AdagradOptimizer,AdamOptimizer:()=>AdamOptimizer,AdamaxOptimizer:()=>AdamaxOptimizer,Add:()=>Add,AddN:()=>AddN,All:()=>All,Any:()=>Any,ArgMax:()=>ArgMax,ArgMin:()=>ArgMin,Asin:()=>Asin,Asinh:()=>Asinh,Atan:()=>Atan,Atan2:()=>Atan2,Atanh:()=>Atanh,AvgPool:()=>AvgPool,AvgPool3D:()=>AvgPool3D,AvgPool3DGrad:()=>AvgPool3DGrad,AvgPoolGrad:()=>AvgPoolGrad,BackendWasm:()=>BackendWasm,BatchMatMul:()=>BatchMatMul,BatchToSpaceND:()=>BatchToSpaceND,Bincount:()=>Bincount,BroadcastArgs:()=>BroadcastArgs,BroadcastTo:()=>BroadcastTo,Callback:()=>Callback,CallbackList:()=>CallbackList,Cast:()=>Cast,Ceil:()=>Ceil,ClipByValue:()=>ClipByValue,Complex:()=>Complex,ComplexAbs:()=>ComplexAbs,Concat:()=>Concat,Conv2D:()=>Conv2D,Conv2DBackpropFilter:()=>Conv2DBackpropFilter,Conv2DBackpropInput:()=>Conv2DBackpropInput,Conv3D:()=>Conv3D,Conv3DBackpropFilterV2:()=>Conv3DBackpropFilterV2,Conv3DBackpropInputV2:()=>Conv3DBackpropInputV2,Cos:()=>Cos,Cosh:()=>Cosh,CropAndResize:()=>CropAndResize,Cumsum:()=>Cumsum,CustomCallback:()=>CustomCallback,DataStorage:()=>DataStorage,DenseBincount:()=>DenseBincount,DepthToSpace:()=>DepthToSpace,DepthwiseConv2dNative:()=>DepthwiseConv2dNative,DepthwiseConv2dNativeBackpropFilter:()=>DepthwiseConv2dNativeBackpropFilter,DepthwiseConv2dNativeBackpropInput:()=>DepthwiseConv2dNativeBackpropInput,Diag:()=>Diag,Dilation2D:()=>Dilation2D,Dilation2DBackpropFilter:()=>Dilation2DBackpropFilter,Dilation2DBackpropInput:()=>Dilation2DBackpropInput,ENV:()=>ENV,EarlyStopping:()=>EarlyStopping,Einsum:()=>Einsum,Elu:()=>Elu,EluGrad:()=>EluGrad,Environment:()=>Environment,Equal:()=>Equal,Erf:()=>Erf,Exp:()=>Exp,ExpandDims:()=>ExpandDims,Expm1:()=>Expm1,FFT:()=>FFT,Fill:()=>Fill,FlipLeftRight:()=>FlipLeftRight,Floor:()=>Floor,FloorDiv:()=>FloorDiv,FromPixels:()=>FromPixels,FusedBatchNorm:()=>FusedBatchNorm,FusedConv2D:()=>FusedConv2D,FusedDepthwiseConv2D:()=>FusedDepthwiseConv2D,GPGPUContext:()=>GPGPUContext,GatherNd:()=>GatherNd,GatherV2:()=>GatherV2,GraphModel:()=>GraphModel,Greater:()=>Greater,GreaterEqual:()=>GreaterEqual,History:()=>History,IFFT:()=>IFFT,Identity:()=>Identity,Imag:()=>Imag,InputSpec:()=>InputSpec,IsFinite:()=>IsFinite,IsInf:()=>IsInf,IsNan:()=>IsNan,KernelBackend:()=>KernelBackend,LRN:()=>LRN,LRNGrad:()=>LRNGrad,LayerVariable:()=>LayerVariable,LayersModel:()=>LayersModel,LeakyRelu:()=>LeakyRelu,Less:()=>Less,LessEqual:()=>LessEqual,LinSpace:()=>LinSpace,Log:()=>Log,Log1p:()=>Log1p,LogSoftmax:()=>LogSoftmax,LogicalAnd:()=>LogicalAnd,LogicalNot:()=>LogicalNot,LogicalOr:()=>LogicalOr,MathBackendCPU:()=>MathBackendCPU,MathBackendWebGL:()=>MathBackendWebGL,Max:()=>Max,MaxPool:()=>MaxPool,MaxPool3D:()=>MaxPool3D,MaxPool3DGrad:()=>MaxPool3DGrad,MaxPoolGrad:()=>MaxPoolGrad,MaxPoolWithArgmax:()=>MaxPoolWithArgmax,Maximum:()=>Maximum,Mean:()=>Mean,Min:()=>Min,Minimum:()=>Minimum,MirrorPad:()=>MirrorPad,Mod:()=>Mod,MomentumOptimizer:()=>MomentumOptimizer,Multinomial:()=>Multinomial,Multiply:()=>Multiply,Neg:()=>Neg,NonMaxSuppressionV3:()=>NonMaxSuppressionV3,NonMaxSuppressionV4:()=>NonMaxSuppressionV4,NonMaxSuppressionV5:()=>NonMaxSuppressionV5,NotEqual:()=>NotEqual,OP_SCOPE_SUFFIX:()=>OP_SCOPE_SUFFIX,OneHot:()=>OneHot,OnesLike:()=>OnesLike,Optimizer:()=>Optimizer,OptimizerConstructors:()=>OptimizerConstructors,Pack:()=>Pack,PadV2:()=>PadV2,Pool:()=>Pool,Pow:()=>Pow,Prelu:()=>Prelu,Prod:()=>Prod,RMSPropOptimizer:()=>RMSPropOptimizer,RNN:()=>RNN,Range:()=>Range,Rank:()=>Rank,Real:()=>Real,RealDiv:()=>RealDiv,Reciprocal:()=>Reciprocal,Reduction:()=>Reduction,Relu:()=>Relu,Relu6:()=>Relu6,Reshape:()=>Reshape,ResizeBilinear:()=>ResizeBilinear,ResizeBilinearGrad:()=>ResizeBilinearGrad,ResizeNearestNeighbor:()=>ResizeNearestNeighbor,ResizeNearestNeighborGrad:()=>ResizeNearestNeighborGrad,Reverse:()=>Reverse,RotateWithOffset:()=>RotateWithOffset,Round:()=>Round,Rsqrt:()=>Rsqrt,SGDOptimizer:()=>SGDOptimizer,ScatterNd:()=>ScatterNd,Select:()=>Select,Selu:()=>Selu,Sequential:()=>Sequential,Sigmoid:()=>Sigmoid,Sign:()=>Sign,Sin:()=>Sin,Sinh:()=>Sinh,Slice:()=>Slice,Softmax:()=>Softmax,Softplus:()=>Softplus,SpaceToBatchND:()=>SpaceToBatchND,SparseFillEmptyRows:()=>SparseFillEmptyRows,SparseReshape:()=>SparseReshape,SparseSegmentMean:()=>SparseSegmentMean,SparseSegmentSum:()=>SparseSegmentSum,SparseToDense:()=>SparseToDense,SplitV:()=>SplitV,Sqrt:()=>Sqrt,Square:()=>Square,SquaredDifference:()=>SquaredDifference,Step:()=>Step,StridedSlice:()=>StridedSlice,StringNGrams:()=>StringNGrams,StringSplit:()=>StringSplit,StringToHashBucketFast:()=>StringToHashBucketFast,Sub:()=>Sub,Sum:()=>Sum,SymbolicTensor:()=>SymbolicTensor,Tan:()=>Tan,Tanh:()=>Tanh,Tensor:()=>Tensor,TensorBuffer:()=>TensorBuffer,Tile:()=>Tile,TopK:()=>TopK,Transform:()=>Transform,Transpose:()=>Transpose,Unique:()=>Unique,Unpack:()=>Unpack,UnsortedSegmentSum:()=>UnsortedSegmentSum,Variable:()=>Variable,ZerosLike:()=>ZerosLike,_FusedMatMul:()=>_FusedMatMul,abs:()=>abs,acos:()=>acos,acosh:()=>acosh,add:()=>add2,addN:()=>addN,all:()=>all,any:()=>any,argMax:()=>argMax,argMin:()=>argMin,asin:()=>asin,asinh:()=>asinh,atan:()=>atan,atan2:()=>atan2,atanh:()=>atanh,avgPool:()=>avgPool,avgPool3d:()=>avgPool3d,backend:()=>backend,backend_util:()=>backend_util_exports,basicLSTMCell:()=>basicLSTMCell,batchNorm:()=>batchNorm,batchNorm2d:()=>batchNorm2d,batchNorm3d:()=>batchNorm3d,batchNorm4d:()=>batchNorm4d,batchToSpaceND:()=>batchToSpaceND,bincount:()=>bincount,booleanMaskAsync:()=>booleanMaskAsync,broadcastArgs:()=>broadcastArgs,broadcastTo:()=>broadcastTo,broadcast_util:()=>broadcast_util_exports,browser:()=>browser_exports,buffer:()=>buffer,callbacks:()=>callbacks,cast:()=>cast,ceil:()=>ceil,clipByValue:()=>clipByValue,clone:()=>clone,complex:()=>complex,concat:()=>concat,concat1d:()=>concat1d,concat2d:()=>concat2d,concat3d:()=>concat3d,concat4d:()=>concat4d,constraints:()=>exports_constraints_exports,conv1d:()=>conv1d,conv2d:()=>conv2d,conv2dTranspose:()=>conv2dTranspose,conv3d:()=>conv3d,conv3dTranspose:()=>conv3dTranspose,copyRegisteredKernels:()=>copyRegisteredKernels,cos:()=>cos,cosh:()=>cosh,cosineWindow:()=>cosineWindow,cumsum:()=>cumsum,customGrad:()=>customGrad,data:()=>src_exports,denseBincount:()=>denseBincount,deprecationWarn:()=>deprecationWarn,depthToSpace:()=>depthToSpace,depthwiseConv2d:()=>depthwiseConv2d,deregisterOp:()=>deregisterOp,device_util:()=>device_util_exports,diag:()=>diag,dilation2d:()=>dilation2d,disableDeprecationWarnings:()=>disableDeprecationWarnings,dispose:()=>dispose,disposeVariables:()=>disposeVariables,div:()=>div,divNoNan:()=>divNoNan,dot:()=>dot,dropout:()=>dropout,einsum:()=>einsum,elu:()=>elu,enableDebugMode:()=>enableDebugMode,enableProdMode:()=>enableProdMode,enclosingPowerOfTwo:()=>enclosingPowerOfTwo,engine:()=>engine,env:()=>env,equal:()=>equal,erf:()=>erf,exp:()=>exp,expandDims:()=>expandDims,expm1:()=>expm1,eye:()=>eye,fft:()=>fft,fill:()=>fill,findBackend:()=>findBackend,findBackendFactory:()=>findBackendFactory,floor:()=>floor,floorDiv:()=>floorDiv,forceHalfFloat:()=>forceHalfFloat,fused:()=>fused_ops_exports,gather:()=>gather,gatherND:()=>gatherND,gather_util:()=>gather_nd_util_exports,getBackend:()=>getBackend,getGradient:()=>getGradient,getKernel:()=>getKernel,getKernelsForBackend:()=>getKernelsForBackend,getThreadsCount:()=>getThreadsCount,gpgpu_util:()=>gpgpu_util_exports,grad:()=>grad,grads:()=>grads,greater:()=>greater,greaterEqual:()=>greaterEqual,ifft:()=>ifft,imag:()=>imag,image:()=>image,inTopKAsync:()=>inTopKAsync,initializers:()=>exports_initializers_exports,input:()=>input,io:()=>io_exports,irfft:()=>irfft,isFinite:()=>isFinite2,isInf:()=>isInf,isNaN:()=>isNaN2,keep:()=>keep,kernel_impls:()=>kernel_impls_exports,layers:()=>exports_layers_exports,leakyRelu:()=>leakyRelu,less:()=>less,lessEqual:()=>lessEqual,linalg:()=>linalg,linspace:()=>linspace,loadGraphModel:()=>loadGraphModel,loadLayersModel:()=>loadLayersModel,localResponseNormalization:()=>localResponseNormalization,log:()=>log4,log1p:()=>log1p,logSigmoid:()=>logSigmoid,logSoftmax:()=>logSoftmax,logSumExp:()=>logSumExp,logicalAnd:()=>logicalAnd,logicalNot:()=>logicalNot,logicalOr:()=>logicalOr,logicalXor:()=>logicalXor,losses:()=>losses,matMul:()=>matMul,math:()=>math_exports,max:()=>max,maxPool:()=>maxPool,maxPool3d:()=>maxPool3d,maxPoolWithArgmax:()=>maxPoolWithArgmax,maximum:()=>maximum,mean:()=>mean,memory:()=>memory,meshgrid:()=>meshgrid,metrics:()=>exports_metrics_exports,min:()=>min,minimum:()=>minimum,mirrorPad:()=>mirrorPad,mod:()=>mod,model:()=>model,models:()=>exports_models_exports,moments:()=>moments,movingAverage:()=>movingAverage,mul:()=>mul,multiRNNCell:()=>multiRNNCell,multinomial:()=>multinomial,neg:()=>neg,nextFrame:()=>nextFrame,norm:()=>norm,notEqual:()=>notEqual,oneHot:()=>oneHot,ones:()=>ones2,onesLike:()=>onesLike,op:()=>op,outerProduct:()=>outerProduct,pad:()=>pad,pad1d:()=>pad1d,pad2d:()=>pad2d,pad3d:()=>pad3d,pad4d:()=>pad4d,pool:()=>pool,pow:()=>pow,prelu:()=>prelu,print:()=>print2,prod:()=>prod,profile:()=>profile,rand:()=>rand,randomGamma:()=>randomGamma,randomNormal:()=>randomNormal,randomUniform:()=>randomUniform,range:()=>range,ready:()=>ready,real:()=>real,reciprocal:()=>reciprocal,registerBackend:()=>registerBackend,registerCallbackConstructor:()=>registerCallbackConstructor,registerGradient:()=>registerGradient,registerKernel:()=>registerKernel,registerOp:()=>registerOp,regularizers:()=>exports_regularizers_exports,relu:()=>relu,relu6:()=>relu6,removeBackend:()=>removeBackend,reshape:()=>reshape,reverse:()=>reverse,reverse1d:()=>reverse1d,reverse2d:()=>reverse2d,reverse3d:()=>reverse3d,reverse4d:()=>reverse4d,rfft:()=>rfft,round:()=>round2,rsqrt:()=>rsqrt,scalar:()=>scalar,scatterND:()=>scatterND,scatter_util:()=>scatter_nd_util_exports,selu:()=>selu,separableConv2d:()=>separableConv2d,sequential:()=>sequential,serialization:()=>serialization_exports,setBackend:()=>setBackend,setPlatform:()=>setPlatform,setThreadsCount:()=>setThreadsCount,setWasmPath:()=>setWasmPath,setWasmPaths:()=>setWasmPaths,setWebGLContext:()=>setWebGLContext,setdiff1dAsync:()=>setdiff1dAsync,shared:()=>shared_exports,sigmoid:()=>sigmoid,sign:()=>sign,signal:()=>signal,sin:()=>sin,sinh:()=>sinh,slice:()=>slice,slice1d:()=>slice1d,slice2d:()=>slice2d,slice3d:()=>slice3d,slice4d:()=>slice4d,slice_util:()=>slice_util_exports,softmax:()=>softmax,softplus:()=>softplus,spaceToBatchND:()=>spaceToBatchND,sparse:()=>sparse,sparseToDense:()=>sparseToDense,spectral:()=>spectral,split:()=>split,sqrt:()=>sqrt,square:()=>square,squaredDifference:()=>squaredDifference,squeeze:()=>squeeze,stack:()=>stack,step:()=>step,stridedSlice:()=>stridedSlice,string:()=>string,sub:()=>sub,sum:()=>sum2,sumOutType:()=>sumOutType,tan:()=>tan,tanh:()=>tanh2,tensor:()=>tensor,tensor1d:()=>tensor1d,tensor2d:()=>tensor2d,tensor3d:()=>tensor3d,tensor4d:()=>tensor4d,tensor5d:()=>tensor5d,tensor6d:()=>tensor6d,tensor_util:()=>tensor_util_exports,test_util:()=>test_util_exports,tidy:()=>tidy,tile:()=>tile,time:()=>time,topk:()=>topk,train:()=>train,transpose:()=>transpose,truncatedNormal:()=>truncatedNormal,unique:()=>unique,unregisterGradient:()=>unregisterGradient,unregisterKernel:()=>unregisterKernel,unsortedSegmentSum:()=>unsortedSegmentSum,unstack:()=>unstack,upcastType:()=>upcastType,util:()=>util_exports,valueAndGrad:()=>valueAndGrad,valueAndGrads:()=>valueAndGrads,variable:()=>variable,variableGrads:()=>variableGrads,version:()=>version8,version_converter:()=>version3,version_core:()=>version_core,version_cpu:()=>version5,version_layers:()=>version2,version_wasm:()=>version7,version_webgl:()=>version6,webgl:()=>webgl,webgl_util:()=>webgl_util_exports,webgpu:()=>webgpu_exports,where:()=>where,whereAsync:()=>whereAsync,zeros:()=>zeros,zerosLike:()=>zerosLike});var __require2=(e=>void 0!==__require?__require:"undefined"!=typeof Proxy?new Proxy(e,{get:(e,t)=>(void 0!==__require?__require:e)[t]}):e)((function(e){if(void 0!==__require)return __require.apply(this,arguments);throw new Error('Dynamic require of "'+e+'" is not supported')})),__create=Object.create,__defProp2=Object.defineProperty,__getOwnPropDesc=Object.getOwnPropertyDescriptor,__getOwnPropNames=Object.getOwnPropertyNames,__getProtoOf=Object.getPrototypeOf,__hasOwnProp=Object.prototype.hasOwnProperty,__markAsModule2=e=>__defProp2(e,"__esModule",{value:!0}),__require22=(e=>void 0!==__require2?__require2:"undefined"!=typeof Proxy?new Proxy(e,{get:(e,t)=>(void 0!==__require2?__require2:e)[t]}):e)((function(e){if(void 0!==__require2)return __require2.apply(this,arguments);throw new Error('Dynamic require of "'+e+'" is not supported')})),__commonJS=(e,t)=>function(){return t||(0,e[Object.keys(e)[0]])((t={exports:{}}).exports,t),t.exports},__export2=(e,t)=>{for(var n in __markAsModule2(e),t)__defProp2(e,n,{get:t[n],enumerable:!0})},__reExport=(e,t,n)=>{if(t&&"object"==typeof t||"function"==typeof t)for(let a of __getOwnPropNames(t))__hasOwnProp.call(e,a)||"default"===a||__defProp2(e,a,{get:()=>t[a],enumerable:!(n=__getOwnPropDesc(t,a))||n.enumerable});return e},__toModule=e=>__reExport(__markAsModule2(__defProp2(null!=e?__create(__getProtoOf(e)):{},"default",e&&e.__esModule&&"default"in e?{get:()=>e.default,enumerable:!0}:{value:e,enumerable:!0})),e),require_long=__commonJS({"node_modules/.pnpm/long@4.0.0/node_modules/long/src/long.js"(e,t){t.exports=a;var n=null;try{n=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(e){}function a(e,t,n){this.low=0|e,this.high=0|t,this.unsigned=!!n}function r(e){return!0===(e&&e.__isLong__)}a.prototype.__isLong__,Object.defineProperty(a.prototype,"__isLong__",{value:!0}),a.isLong=r;var s={},o={};function i(e,t){var n,a,r;return t?(r=0<=(e>>>=0)&&e<256)&&(a=o[e])?a:(n=u(e,(0|e)<0?-1:0,!0),r&&(o[e]=n),n):(r=-128<=(e|=0)&&e<128)&&(a=s[e])?a:(n=u(e,e<0?-1:0,!1),r&&(s[e]=n),n)}function l(e,t){if(isNaN(e))return t?y:x;if(t){if(e<0)return y;if(e>=m)return S}else{if(e<=-f)return w;if(e+1>=f)return k}return e<0?l(-e,t).neg():u(e%h|0,e/h|0,t)}function u(e,t,n){return new a(e,t,n)}a.fromInt=i,a.fromNumber=l,a.fromBits=u;var c=Math.pow;function d(e,t,n){if(0===e.length)throw Error("empty string");if("NaN"===e||"Infinity"===e||"+Infinity"===e||"-Infinity"===e)return x;if("number"==typeof t?(n=t,t=!1):t=!!t,(n=n||10)<2||36<n)throw RangeError("radix");var a;if((a=e.indexOf("-"))>0)throw Error("interior hyphen");if(0===a)return d(e.substring(1),t,n).neg();for(var r=l(c(n,8)),s=x,o=0;o<e.length;o+=8){var i=Math.min(8,e.length-o),u=parseInt(e.substring(o,o+i),n);if(i<8){var p=l(c(n,i));s=s.mul(p).add(l(u))}else s=(s=s.mul(r)).add(l(u))}return s.unsigned=t,s}function p(e,t){return"number"==typeof e?l(e,t):"string"==typeof e?d(e,t):u(e.low,e.high,"boolean"==typeof t?t:e.unsigned)}a.fromString=d,a.fromValue=p;var h=4294967296,m=h*h,f=m/2,g=i(1<<24),x=i(0);a.ZERO=x;var y=i(0,!0);a.UZERO=y;var A=i(1);a.ONE=A;var b=i(1,!0);a.UONE=b;var v=i(-1);a.NEG_ONE=v;var k=u(-1,2147483647,!1);a.MAX_VALUE=k;var S=u(-1,-1,!0);a.MAX_UNSIGNED_VALUE=S;var w=u(0,-2147483648,!1);a.MIN_VALUE=w;var C=a.prototype;C.toInt=function(){return this.unsigned?this.low>>>0:this.low},C.toNumber=function(){return this.unsigned?(this.high>>>0)*h+(this.low>>>0):this.high*h+(this.low>>>0)},C.toString=function(e){if((e=e||10)<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(w)){var t=l(e),n=this.div(t),a=n.mul(t).sub(this);return n.toString(e)+a.toInt().toString(e)}return"-"+this.neg().toString(e)}for(var r=l(c(e,6),this.unsigned),s=this,o="";;){var i=s.div(r),u=(s.sub(i.mul(r)).toInt()>>>0).toString(e);if((s=i).isZero())return u+o;for(;u.length<6;)u="0"+u;o=""+u+o}},C.getHighBits=function(){return this.high},C.getHighBitsUnsigned=function(){return this.high>>>0},C.getLowBits=function(){return this.low},C.getLowBitsUnsigned=function(){return this.low>>>0},C.getNumBitsAbs=function(){if(this.isNegative())return this.eq(w)?64:this.neg().getNumBitsAbs();for(var e=0!=this.high?this.high:this.low,t=31;t>0&&0==(e&1<<t);t--);return 0!=this.high?t+33:t+1},C.isZero=function(){return 0===this.high&&0===this.low},C.eqz=C.isZero,C.isNegative=function(){return!this.unsigned&&this.high<0},C.isPositive=function(){return this.unsigned||this.high>=0},C.isOdd=function(){return 1==(1&this.low)},C.isEven=function(){return 0==(1&this.low)},C.equals=function(e){return r(e)||(e=p(e)),(this.unsigned===e.unsigned||this.high>>>31!=1||e.high>>>31!=1)&&(this.high===e.high&&this.low===e.low)},C.eq=C.equals,C.notEquals=function(e){return!this.eq(e)},C.neq=C.notEquals,C.ne=C.notEquals,C.lessThan=function(e){return this.comp(e)<0},C.lt=C.lessThan,C.lessThanOrEqual=function(e){return this.comp(e)<=0},C.lte=C.lessThanOrEqual,C.le=C.lessThanOrEqual,C.greaterThan=function(e){return this.comp(e)>0},C.gt=C.greaterThan,C.greaterThanOrEqual=function(e){return this.comp(e)>=0},C.gte=C.greaterThanOrEqual,C.ge=C.greaterThanOrEqual,C.compare=function(e){if(r(e)||(e=p(e)),this.eq(e))return 0;var t=this.isNegative(),n=e.isNegative();return t&&!n?-1:!t&&n?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1},C.comp=C.compare,C.negate=function(){return!this.unsigned&&this.eq(w)?w:this.not().add(A)},C.neg=C.negate,C.add=function(e){r(e)||(e=p(e));var t=this.high>>>16,n=65535&this.high,a=this.low>>>16,s=65535&this.low,o=e.high>>>16,i=65535&e.high,l=e.low>>>16,c=0,d=0,h=0,m=0;return h+=(m+=s+(65535&e.low))>>>16,d+=(h+=a+l)>>>16,c+=(d+=n+i)>>>16,c+=t+o,u((h&=65535)<<16|(m&=65535),(c&=65535)<<16|(d&=65535),this.unsigned)},C.subtract=function(e){return r(e)||(e=p(e)),this.add(e.neg())},C.sub=C.subtract,C.multiply=function(e){if(this.isZero())return x;if(r(e)||(e=p(e)),n)return u(n.mul(this.low,this.high,e.low,e.high),n.get_high(),this.unsigned);if(e.isZero())return x;if(this.eq(w))return e.isOdd()?w:x;if(e.eq(w))return this.isOdd()?w:x;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(g)&&e.lt(g))return l(this.toNumber()*e.toNumber(),this.unsigned);var t=this.high>>>16,a=65535&this.high,s=this.low>>>16,o=65535&this.low,i=e.high>>>16,c=65535&e.high,d=e.low>>>16,h=65535&e.low,m=0,f=0,y=0,A=0;return y+=(A+=o*h)>>>16,f+=(y+=s*h)>>>16,y&=65535,f+=(y+=o*d)>>>16,m+=(f+=a*h)>>>16,f&=65535,m+=(f+=s*d)>>>16,f&=65535,m+=(f+=o*c)>>>16,m+=t*h+a*d+s*c+o*i,u((y&=65535)<<16|(A&=65535),(m&=65535)<<16|(f&=65535),this.unsigned)},C.mul=C.multiply,C.divide=function(e){if(r(e)||(e=p(e)),e.isZero())throw Error("division by zero");var t,a,s;if(n)return this.unsigned||-2147483648!==this.high||-1!==e.low||-1!==e.high?u((this.unsigned?n.div_u:n.div_s)(this.low,this.high,e.low,e.high),n.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?y:x;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return y;if(e.gt(this.shru(1)))return b;s=y}else{if(this.eq(w))return e.eq(A)||e.eq(v)?w:e.eq(w)?A:(t=this.shr(1).div(e).shl(1)).eq(x)?e.isNegative()?A:v:(a=this.sub(e.mul(t)),s=t.add(a.div(e)));if(e.eq(w))return this.unsigned?y:x;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();s=x}for(a=this;a.gte(e);){t=Math.max(1,Math.floor(a.toNumber()/e.toNumber()));for(var o=Math.ceil(Math.log(t)/Math.LN2),i=o<=48?1:c(2,o-48),d=l(t),h=d.mul(e);h.isNegative()||h.gt(a);)h=(d=l(t-=i,this.unsigned)).mul(e);d.isZero()&&(d=A),s=s.add(d),a=a.sub(h)}return s},C.div=C.divide,C.modulo=function(e){return r(e)||(e=p(e)),n?u((this.unsigned?n.rem_u:n.rem_s)(this.low,this.high,e.low,e.high),n.get_high(),this.unsigned):this.sub(this.div(e).mul(e))},C.mod=C.modulo,C.rem=C.modulo,C.not=function(){return u(~this.low,~this.high,this.unsigned)},C.and=function(e){return r(e)||(e=p(e)),u(this.low&e.low,this.high&e.high,this.unsigned)},C.or=function(e){return r(e)||(e=p(e)),u(this.low|e.low,this.high|e.high,this.unsigned)},C.xor=function(e){return r(e)||(e=p(e)),u(this.low^e.low,this.high^e.high,this.unsigned)},C.shiftLeft=function(e){return r(e)&&(e=e.toInt()),0==(e&=63)?this:e<32?u(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):u(0,this.low<<e-32,this.unsigned)},C.shl=C.shiftLeft,C.shiftRight=function(e){return r(e)&&(e=e.toInt()),0==(e&=63)?this:e<32?u(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):u(this.high>>e-32,this.high>=0?0:-1,this.unsigned)},C.shr=C.shiftRight,C.shiftRightUnsigned=function(e){if(r(e)&&(e=e.toInt()),0===(e&=63))return this;var t=this.high;return e<32?u(this.low>>>e|t<<32-e,t>>>e,this.unsigned):u(32===e?t:t>>>e-32,0,this.unsigned)},C.shru=C.shiftRightUnsigned,C.shr_u=C.shiftRightUnsigned,C.toSigned=function(){return this.unsigned?u(this.low,this.high,!1):this},C.toUnsigned=function(){return this.unsigned?this:u(this.low,this.high,!0)},C.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()},C.toBytesLE=function(){var e=this.high,t=this.low;return[255&t,t>>>8&255,t>>>16&255,t>>>24,255&e,e>>>8&255,e>>>16&255,e>>>24]},C.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,255&e,t>>>24,t>>>16&255,t>>>8&255,255&t]},a.fromBytes=function(e,t,n){return n?a.fromBytesLE(e,t):a.fromBytesBE(e,t)},a.fromBytesLE=function(e,t){return new a(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)},a.fromBytesBE=function(e,t){return new a(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)}}}),require_node_fetch=__commonJS({"(disabled):node-fetch"(){}}),require_util=__commonJS({"(disabled):util"(){}}),require_alea=__commonJS({"node_modules/.pnpm/seedrandom@3.0.5/node_modules/seedrandom/lib/alea.js"(e,t){!function(e,t,n){function a(e){var t,n=this,a=(t=4022871197,function(e){e=String(e);for(var n=0;n<e.length;n++){var a=.02519603282416938*(t+=e.charCodeAt(n));a-=t=a>>>0,t=(a*=t)>>>0,t+=4294967296*(a-=t)}return 2.3283064365386963e-10*(t>>>0)});n.next=function(){var e=2091639*n.s0+2.3283064365386963e-10*n.c;return n.s0=n.s1,n.s1=n.s2,n.s2=e-(n.c=0|e)},n.c=1,n.s0=a(" "),n.s1=a(" "),n.s2=a(" "),n.s0-=a(e),n.s0<0&&(n.s0+=1),n.s1-=a(e),n.s1<0&&(n.s1+=1),n.s2-=a(e),n.s2<0&&(n.s2+=1),a=null}function r(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function s(e,t){var n=new a(e),s=t&&t.state,o=n.next;return o.int32=function(){return 4294967296*n.next()|0},o.double=function(){return o()+11102230246251565e-32*(2097152*o()|0)},o.quick=o,s&&("object"==typeof s&&r(s,n),o.state=function(){return r(n,{})}),o}t&&t.exports?t.exports=s:n&&n.amd?n((function(){return s})):this.alea=s}(0,"object"==typeof t&&t,"function"==typeof define&&define)}}),require_xor128=__commonJS({"node_modules/.pnpm/seedrandom@3.0.5/node_modules/seedrandom/lib/xor128.js"(e,t){!function(e,t,n){function a(e){var t=this,n="";t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(0|e)?t.x=e:n+=e;for(var a=0;a<n.length+64;a++)t.x^=0|n.charCodeAt(a),t.next()}function r(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function s(e,t){var n=new a(e),s=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,s&&("object"==typeof s&&r(s,n),o.state=function(){return r(n,{})}),o}t&&t.exports?t.exports=s:n&&n.amd?n((function(){return s})):this.xor128=s}(0,"object"==typeof t&&t,"function"==typeof define&&define)}}),require_xorwow=__commonJS({"node_modules/.pnpm/seedrandom@3.0.5/node_modules/seedrandom/lib/xorwow.js"(e,t){!function(e,t,n){function a(e){var t=this,n="";t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^e^e<<1)|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(0|e)?t.x=e:n+=e;for(var a=0;a<n.length+64;a++)t.x^=0|n.charCodeAt(a),a==n.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function r(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function s(e,t){var n=new a(e),s=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,s&&("object"==typeof s&&r(s,n),o.state=function(){return r(n,{})}),o}t&&t.exports?t.exports=s:n&&n.amd?n((function(){return s})):this.xorwow=s}(0,"object"==typeof t&&t,"function"==typeof define&&define)}}),require_xorshift7=__commonJS({"node_modules/.pnpm/seedrandom@3.0.5/node_modules/seedrandom/lib/xorshift7.js"(e,t){!function(e,t,n){function a(e){var t=this;t.next=function(){var e,n,a=t.x,r=t.i;return e=a[r],n=(e^=e>>>7)^e<<24,n^=(e=a[r+1&7])^e>>>10,n^=(e=a[r+3&7])^e>>>3,n^=(e=a[r+4&7])^e<<7,e=a[r+7&7],n^=(e^=e<<13)^e<<9,a[r]=n,t.i=r+1&7,n},function(e,t){var n,a=[];if(t===(0|t))a[0]=t;else for(t=""+t,n=0;n<t.length;++n)a[7&n]=a[7&n]<<15^t.charCodeAt(n)+a[n+1&7]<<13;for(;a.length<8;)a.push(0);for(n=0;n<8&&0===a[n];++n);for(8==n?a[7]=-1:a[n],e.x=a,e.i=0,n=256;n>0;--n)e.next()}(t,e)}function r(e,t){return t.x=e.x.slice(),t.i=e.i,t}function s(e,t){null==e&&(e=+new Date);var n=new a(e),s=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,s&&(s.x&&r(s,n),o.state=function(){return r(n,{})}),o}t&&t.exports?t.exports=s:n&&n.amd?n((function(){return s})):this.xorshift7=s}(0,"object"==typeof t&&t,"function"==typeof define&&define)}}),require_xor4096=__commonJS({"node_modules/.pnpm/seedrandom@3.0.5/node_modules/seedrandom/lib/xor4096.js"(e,t){!function(e,t,n){function a(e){var t=this;t.next=function(){var e,n,a=t.w,r=t.X,s=t.i;return t.w=a=a+1640531527|0,n=r[s+34&127],e=r[s=s+1&127],n^=n<<13,e^=e<<17,n^=n>>>15,e^=e>>>12,n=r[s]=n^e,t.i=s,n+(a^a>>>16)|0},function(e,t){var n,a,r,s,o,i=[],l=128;for(t===(0|t)?(a=t,t=null):(t+="\0",a=0,l=Math.max(l,t.length)),r=0,s=-32;s<l;++s)t&&(a^=t.charCodeAt((s+32)%t.length)),0===s&&(o=a),a^=a<<10,a^=a>>>15,a^=a<<4,a^=a>>>13,s>=0&&(o=o+1640531527|0,r=0==(n=i[127&s]^=a+o)?r+1:0);for(r>=128&&(i[127&(t&&t.length||0)]=-1),r=127,s=512;s>0;--s)a=i[r+34&127],n=i[r=r+1&127],a^=a<<13,n^=n<<17,a^=a>>>15,n^=n>>>12,i[r]=a^n;e.w=o,e.X=i,e.i=r}(t,e)}function r(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function s(e,t){null==e&&(e=+new Date);var n=new a(e),s=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,s&&(s.X&&r(s,n),o.state=function(){return r(n,{})}),o}t&&t.exports?t.exports=s:n&&n.amd?n((function(){return s})):this.xor4096=s}(0,"object"==typeof t&&t,"function"==typeof define&&define)}}),require_tychei=__commonJS({"node_modules/.pnpm/seedrandom@3.0.5/node_modules/seedrandom/lib/tychei.js"(e,t){!function(e,t,n){function a(e){var t=this,n="";t.next=function(){var e=t.b,n=t.c,a=t.d,r=t.a;return e=e<<25^e>>>7^n,n=n-a|0,a=a<<24^a>>>8^r,r=r-e|0,t.b=e=e<<20^e>>>12^n,t.c=n=n-a|0,t.d=a<<16^n>>>16^r,t.a=r-e|0},t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(t.a=e/4294967296|0,t.b=0|e):n+=e;for(var a=0;a<n.length+20;a++)t.b^=0|n.charCodeAt(a),t.next()}function r(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function s(e,t){var n=new a(e),s=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,s&&("object"==typeof s&&r(s,n),o.state=function(){return r(n,{})}),o}t&&t.exports?t.exports=s:n&&n.amd?n((function(){return s})):this.tychei=s}(0,"object"==typeof t&&t,"function"==typeof define&&define)}}),require_crypto=__commonJS({"(disabled):crypto"(){}}),require_seedrandom=__commonJS({"node_modules/.pnpm/seedrandom@3.0.5/node_modules/seedrandom/seedrandom.js"(e,t){!function(e,n,a){var r,s=256,o=a.pow(s,6),i=a.pow(2,52),l=2*i,u=255;function c(t,u,c){var g=[],x=m(h((u=1==u?{entropy:!0}:u||{}).entropy?[t,f(n)]:null==t?function(){try{var t;return r&&(t=r.randomBytes)?t=t(s):(t=new Uint8Array(s),(e.crypto||e.msCrypto).getRandomValues(t)),f(t)}catch(t){var a=e.navigator,o=a&&a.plugins;return[+new Date,e,o,e.screen,f(n)]}}():t,3),g),y=new d(g),A=function(){for(var e=y.g(6),t=o,n=0;e<i;)e=(e+n)*s,t*=s,n=y.g(1);for(;e>=l;)e/=2,t/=2,n>>>=1;return(e+n)/t};return A.int32=function(){return 0|y.g(4)},A.quick=function(){return y.g(4)/4294967296},A.double=A,m(f(y.S),n),(u.pass||c||function(e,t,n,r){return r&&(r.S&&p(r,y),e.state=function(){return p(y,{})}),n?(a.random=e,t):e})(A,x,"global"in u?u.global:this==a,u.state)}function d(e){var t,n=e.length,a=this,r=0,o=a.i=a.j=0,i=a.S=[];for(n||(e=[n++]);r<s;)i[r]=r++;for(r=0;r<s;r++)i[r]=i[o=u&o+e[r%n]+(t=i[r])],i[o]=t;(a.g=function(e){for(var t,n=0,r=a.i,o=a.j,i=a.S;e--;)t=i[r=u&r+1],n=n*s+i[u&(i[r]=i[o=u&o+t])+(i[o]=t)];return a.i=r,a.j=o,n})(s)}function p(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function h(e,t){var n,a=[],r=typeof e;if(t&&"object"==r)for(n in e)try{a.push(h(e[n],t-1))}catch(e){}return a.length?a:"string"==r?e:e+"\0"}function m(e,t){for(var n,a=e+"",r=0;r<a.length;)t[u&r]=u&(n^=19*t[u&r])+a.charCodeAt(r++);return f(t)}function f(e){return String.fromCharCode.apply(0,e)}if(m(a.random(),n),"object"==typeof t&&t.exports){t.exports=c;try{r=require_crypto()}catch(e){}}else"function"==typeof define&&define.amd?define((function(){return c})):a.seedrandom=c}("undefined"!=typeof self?self:e,[],Math)}}),require_seedrandom2=__commonJS({"node_modules/.pnpm/seedrandom@3.0.5/node_modules/seedrandom/index.js"(e,t){var n=require_alea(),a=require_xor128(),r=require_xorwow(),s=require_xorshift7(),o=require_xor4096(),i=require_tychei(),l=require_seedrandom();l.alea=n,l.xor128=a,l.xorwow=r,l.xorshift7=s,l.xor4096=o,l.tychei=i,t.exports=l}}),require_string_decoder=__commonJS({"(disabled):src/node_modules/string_decoder/index.js"(){}}),require_tfjs_backend_wasm_threaded_simd=__commonJS({"src/tfjs-backend-wasm/wasm-out/tfjs-backend-wasm-threaded-simd.js"(e,t){var n,a=(n="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0,"undefined"!=typeof __filename&&(n=n||__filename),function(e){function t(){return P.buffer!=F&&J(P.buffer),D}function a(){return P.buffer!=F&&J(P.buffer),O}function r(){return P.buffer!=F&&J(P.buffer),z}function s(){return P.buffer!=F&&J(P.buffer),L}function o(){return P.buffer!=F&&J(P.buffer),$}var i,l,u=void 0!==(e=e||{})?e:{};u.ready=new Promise((function(e,t){i=e,l=t}));var c,d={};for(c in u)u.hasOwnProperty(c)&&(d[c]=u[c]);var p=[],h=function(e,t){throw t},m=!1,f=!1,g=!1,x=!1;m="object"==typeof window,f="function"==typeof importScripts,g="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,x=!m&&!g&&!f;var y=u.ENVIRONMENT_IS_PTHREAD||!1;y&&(F=u.buffer);var A,b,v,k,S,w="";function C(e){return u.locateFile?u.locateFile(e,w):w+e}if(g){var I;w=f?__require22("path").dirname(w)+"/":__dirname+"/",A=function(e,t){return k||(k=__require22("fs")),S||(S=__require22("path")),e=S.normalize(e),k.readFileSync(e,t?null:"utf8")},v=function(e){var t=A(e,!0);return t.buffer||(t=new Uint8Array(t)),V(t.buffer),t},process.argv.length>1&&process.argv[1].replace(/\\/g,"/"),p=process.argv.slice(2),process.on("uncaughtException",(function(e){if(!(e instanceof hn))throw e})),process.on("unhandledRejection",ye),h=function(e){process.exit(e)},u.inspect=function(){return"[Emscripten Module object]"};try{I=__require22("worker_threads")}catch(e){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),e}global.Worker=I.Worker}else x?("undefined"!=typeof read&&(A=function(e){return read(e)}),v=function(e){var t;return"function"==typeof readbuffer?new Uint8Array(readbuffer(e)):(V("object"==typeof(t=read(e,"binary"))),t)},"undefined"!=typeof scriptArgs?p=scriptArgs:void 0!==arguments&&(p=arguments),"function"==typeof quit&&(h=function(e){quit(e)}),"undefined"!=typeof print&&("undefined"==typeof console&&(console={}),console.log=print,console.warn=console.error="undefined"!=typeof printErr?printErr:print)):(m||f)&&(f?w=self.location.href:"undefined"!=typeof document&&document.currentScript&&(w=document.currentScript.src),void 0!==n&&n&&(w=n),w=0!==w.indexOf("blob:")?w.substr(0,w.lastIndexOf("/")+1):"",g?(A=function(e,t){return k||(k=__require22("fs")),S||(S=__require22("path")),e=S.normalize(e),k.readFileSync(e,t?null:"utf8")},v=function(e){var t=A(e,!0);return t.buffer||(t=new Uint8Array(t)),V(t.buffer),t}):(A=function(e){var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},f&&(v=function(e){var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),b=function(e,t,n){var a=new XMLHttpRequest;a.open("GET",e,!0),a.responseType="arraybuffer",a.onload=function(){200==a.status||0==a.status&&a.response?t(a.response):n()},a.onerror=n,a.send(null)}));g&&"undefined"==typeof performance&&(global.performance=__require22("perf_hooks").performance);var T,N=u.print||console.log.bind(console),_=u.printErr||console.warn.bind(console);for(c in d)d.hasOwnProperty(c)&&(u[c]=d[c]);function E(e){E.shown||(E.shown={}),E.shown[e]||(E.shown[e]=1,_(e))}d=null,u.arguments&&(p=u.arguments),u.thisProgram&&u.thisProgram,u.quit&&(h=u.quit),Atomics.load,Atomics.store,Atomics.compareExchange,u.wasmBinary&&(T=u.wasmBinary);var P,R,M=u.noExitRuntime||!0;"object"!=typeof WebAssembly&&ye("no native wasm support detected");var F,D,O,z,L,$,B=!1;function V(e,t){e||ye("Assertion failed: "+t)}function U(e){var t=u["_"+e];return V(t,"Cannot call unknown function "+e+", make sure it is exported"),t}function G(e,t,n,a,r){var s={string:function(e){var t=0;if(null!=e&&0!==e){var n=1+(e.length<<2);K(e,t=ln(n),n)}return t},array:function(e){var t=ln(e.length);return Z(e,t),t}},o=U(e),i=[],l=0;if(a)for(var u=0;u<a.length;u++){var c=s[n[u]];c?(0===l&&(l=sn()),i[u]=c(a[u])):i[u]=a[u]}var d,p=o.apply(null,i);return d=p,p="string"===t?q(d):"boolean"===t?Boolean(d):d,0!==l&&on(l),p}function W(e,t,n,a){var r=(n=n||[]).every((function(e){return"number"===e}));return"string"!==t&&r&&!a?U(e):function(){return G(e,t,n,arguments)}}function H(e,t,n){for(var a=t+n,r="";!(t>=a);){var s=e[t++];if(!s)return r;if(128&s){var o=63&e[t++];if(192!=(224&s)){var i=63&e[t++];if((s=224==(240&s)?(15&s)<<12|o<<6|i:(7&s)<<18|o<<12|i<<6|63&e[t++])<65536)r+=String.fromCharCode(s);else{var l=s-65536;r+=String.fromCharCode(55296|l>>10,56320|1023&l)}}else r+=String.fromCharCode((31&s)<<6|o)}else r+=String.fromCharCode(s)}return r}function q(e,t){return e?H(a(),e,t):""}function j(e,t,n,a){if(!(a>0))return 0;for(var r=n,s=n+a-1,o=0;o<e.length;++o){var i=e.charCodeAt(o);if(i>=55296&&i<=57343&&(i=65536+((1023&i)<<10)|1023&e.charCodeAt(++o)),i<=127){if(n>=s)break;t[n++]=i}else if(i<=2047){if(n+1>=s)break;t[n++]=192|i>>6,t[n++]=128|63&i}else if(i<=65535){if(n+2>=s)break;t[n++]=224|i>>12,t[n++]=128|i>>6&63,t[n++]=128|63&i}else{if(n+3>=s)break;t[n++]=240|i>>18,t[n++]=128|i>>12&63,t[n++]=128|i>>6&63,t[n++]=128|63&i}}return t[n]=0,n-r}function K(e,t,n){return j(e,a(),t,n)}function X(e){for(var t=0,n=0;n<e.length;++n){var a=e.charCodeAt(n);a>=55296&&a<=57343&&(a=65536+((1023&a)<<10)|1023&e.charCodeAt(++n)),a<=127?++t:t+=a<=2047?2:a<=65535?3:4}return t}function Z(e,n){t().set(e,n)}function Y(e,t){return e%t>0&&(e+=t-e%t),e}function J(e){F=e,u.HEAP8=D=new Int8Array(e),u.HEAP16=new Int16Array(e),u.HEAP32=z=new Int32Array(e),u.HEAPU8=O=new Uint8Array(e),u.HEAPU16=new Uint16Array(e),u.HEAPU32=L=new Uint32Array(e),u.HEAPF32=new Float32Array(e),u.HEAPF64=$=new Float64Array(e)}var Q,ee=u.INITIAL_MEMORY||16777216;if(y)P=u.wasmMemory,F=u.buffer;else if(u.wasmMemory)P=u.wasmMemory;else if(!((P=new WebAssembly.Memory({initial:ee/65536,maximum:32768,shared:!0})).buffer instanceof SharedArrayBuffer))throw _("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),g&&console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)"),Error("bad memory");P&&(F=P.buffer),ee=F.byteLength,J(F);var te=[],ne=[],ae=[],re=[],se=[];function oe(){if(!y){if(u.preRun)for("function"==typeof u.preRun&&(u.preRun=[u.preRun]);u.preRun.length;)de(u.preRun.shift());Ee(te)}}function ie(){y||Ee(ne)}function le(){y||Ee(ae)}function ue(){}function ce(){if(!y){if(u.postRun)for("function"==typeof u.postRun&&(u.postRun=[u.postRun]);u.postRun.length;)pe(u.postRun.shift());Ee(se)}}function de(e){te.unshift(e)}function pe(e){se.unshift(e)}y||ne.push({func:function(){Wt()}});var he=0,me=null,fe=null;function ge(e){V(!y,"addRunDependency cannot be used in a pthread worker"),he++,u.monitorRunDependencies&&u.monitorRunDependencies(he)}function xe(e){if(he--,u.monitorRunDependencies&&u.monitorRunDependencies(he),0==he&&(null!==me&&(clearInterval(me),me=null),fe)){var t=fe;fe=null,t()}}function ye(e){u.onAbort&&u.onAbort(e),y&&console.error("Pthread aborting at "+(new Error).stack),_(e+=""),B=!0,e="abort("+e+"). Build with -s ASSERTIONS=1 for more info.";var t=new WebAssembly.RuntimeError(e);throw l(t),t}function Ae(e,t){return String.prototype.startsWith?e.startsWith(t):0===e.indexOf(t)}u.preloadedImages={},u.preloadedAudios={};var be="data:application/octet-stream;base64,";function ve(e){return Ae(e,be)}var ke="file://";function Se(e){return Ae(e,ke)}var we="tfjs-backend-wasm-threaded-simd.wasm";function Ce(e){try{if(e==we&&T)return new Uint8Array(T);if(v)return v(e);throw"both async and sync fetching of the wasm failed"}catch(e){ye(e)}}function Ie(){if(!T&&(m||f)){if("function"==typeof fetch&&!Se(we))return fetch(we,{credentials:"same-origin"}).then((function(e){if(!e.ok)throw"failed to load wasm binary file at '"+we+"'";return e.arrayBuffer()})).catch((function(){return Ce(we)}));if(b)return new Promise((function(e,t){b(we,(function(t){e(new Uint8Array(t))}),t)}))}return Promise.resolve().then((function(){return Ce(we)}))}function Te(){var e={a:Gt};function t(e,t){var n=e.exports;if(u.asm=n,Q=u.asm.kb,R=t,!y){var a=ze.unusedWorkers.length;ze.unusedWorkers.forEach((function(e){ze.loadWasmModuleToWorker(e,(function(){--a||xe()}))}))}}function n(e){t(e.instance,e.module)}function a(t){return Ie().then((function(t){return WebAssembly.instantiate(t,e)})).then(t,(function(e){_("failed to asynchronously prepare wasm: "+e),ye(e)}))}if(y||ge(),u.instantiateWasm)try{return u.instantiateWasm(e,t)}catch(e){return _("Module.instantiateWasm callback failed with error: "+e),!1}return(T||"function"!=typeof WebAssembly.instantiateStreaming||ve(we)||Se(we)||"function"!=typeof fetch?a(n):fetch(we,{credentials:"same-origin"}).then((function(t){return WebAssembly.instantiateStreaming(t,e).then(n,(function(e){return _("wasm streaming compile failed: "+e),_("falling back to ArrayBuffer instantiation"),a(n)}))}))).catch(l),{}}ve(we)||(we=C(we));var Ne={10072:function(){throw"Canceled!"},10090:function(e,t){setTimeout((function(){en(e,t)}),0)}};function _e(){ze.initRuntime()}function Ee(e){for(;e.length>0;){var t=e.shift();if("function"!=typeof t){var n=t.func;"number"==typeof n?void 0===t.arg?Q.get(n)():Q.get(n)(t.arg):n(void 0===t.arg?null:t.arg)}else t(u)}}var Pe={EPERM:63,ENOENT:44,ESRCH:71,EINTR:27,EIO:29,ENXIO:60,E2BIG:1,ENOEXEC:45,EBADF:8,ECHILD:12,EAGAIN:6,EWOULDBLOCK:6,ENOMEM:48,EACCES:2,EFAULT:21,ENOTBLK:105,EBUSY:10,EEXIST:20,EXDEV:75,ENODEV:43,ENOTDIR:54,EISDIR:31,EINVAL:28,ENFILE:41,EMFILE:33,ENOTTY:59,ETXTBSY:74,EFBIG:22,ENOSPC:51,ESPIPE:70,EROFS:69,EMLINK:34,EPIPE:64,EDOM:18,ERANGE:68,ENOMSG:49,EIDRM:24,ECHRNG:106,EL2NSYNC:156,EL3HLT:107,EL3RST:108,ELNRNG:109,EUNATCH:110,ENOCSI:111,EL2HLT:112,EDEADLK:16,ENOLCK:46,EBADE:113,EBADR:114,EXFULL:115,ENOANO:104,EBADRQC:103,EBADSLT:102,EDEADLOCK:16,EBFONT:101,ENOSTR:100,ENODATA:116,ETIME:117,ENOSR:118,ENONET:119,ENOPKG:120,EREMOTE:121,ENOLINK:47,EADV:122,ESRMNT:123,ECOMM:124,EPROTO:65,EMULTIHOP:36,EDOTDOT:125,EBADMSG:9,ENOTUNIQ:126,EBADFD:127,EREMCHG:128,ELIBACC:129,ELIBBAD:130,ELIBSCN:131,ELIBMAX:132,ELIBEXEC:133,ENOSYS:52,ENOTEMPTY:55,ENAMETOOLONG:37,ELOOP:32,EOPNOTSUPP:138,EPFNOSUPPORT:139,ECONNRESET:15,ENOBUFS:42,EAFNOSUPPORT:5,EPROTOTYPE:67,ENOTSOCK:57,ENOPROTOOPT:50,ESHUTDOWN:140,ECONNREFUSED:14,EADDRINUSE:3,ECONNABORTED:13,ENETUNREACH:40,ENETDOWN:38,ETIMEDOUT:73,EHOSTDOWN:142,EHOSTUNREACH:23,EINPROGRESS:26,EALREADY:7,EDESTADDRREQ:17,EMSGSIZE:35,EPROTONOSUPPORT:66,ESOCKTNOSUPPORT:137,EADDRNOTAVAIL:4,ENETRESET:39,EISCONN:30,ENOTCONN:53,ETOOMANYREFS:141,EUSERS:136,EDQUOT:19,ESTALE:72,ENOTSUP:138,ENOMEDIUM:148,EILSEQ:25,EOVERFLOW:61,ECANCELED:11,ENOTRECOVERABLE:56,EOWNERDEAD:62,ESTRPIPE:135};function Re(e,n){if(e<=0||e>t().length||!0&e||n<0)return-28;if(0==n)return 0;n>=2147483647&&(n=1/0);var a=Atomics.load(r(),pn>>2),s=0;if(a==e&&Atomics.compareExchange(r(),pn>>2,a,0)==a&&(s=1,--n<=0))return 1;var o=Atomics.notify(r(),e>>2,n);if(o>=0)return o+s;throw"Atomics.notify returned an unexpected value "+o}function Me(e){if(y)throw"Internal Error! killThread() can only ever be called from main application thread!";if(!e)throw"Internal Error! Null pthread_ptr in killThread!";r()[e+12>>2]=0;var t=ze.pthreads[e];t.worker.terminate(),ze.freeThreadData(t),ze.runningWorkers.splice(ze.runningWorkers.indexOf(t.worker),1),t.worker.pthread=void 0}function Fe(e){if(y)throw"Internal Error! cancelThread() can only ever be called from main application thread!";if(!e)throw"Internal Error! Null pthread_ptr in cancelThread!";ze.pthreads[e].worker.postMessage({cmd:"cancel"})}function De(e){if(y)throw"Internal Error! cleanupThread() can only ever be called from main application thread!";if(!e)throw"Internal Error! Null pthread_ptr in cleanupThread!";var t=ze.pthreads[e];if(t){r()[e+12>>2]=0;var n=t.worker;ze.returnWorkerToPool(n)}}u._emscripten_futex_wake=Re;var Oe,ze={unusedWorkers:[],runningWorkers:[],initMainThreadBlock:function(){for(var e=0;e<8;++e)ze.allocateUnusedWorker()},initRuntime:function(){for(var e=Ht(228),t=0;t<57;++t)s()[e/4+t]=0;r()[e+12>>2]=e;var n=e+152;r()[n>>2]=n;var a=Ht(512);for(t=0;t<128;++t)s()[a/4+t]=0;Atomics.store(s(),e+100>>2,a),Atomics.store(s(),e+40>>2,e),rn(e,!f,1),Jt(e)},initWorker:function(){},pthreads:{},threadExitHandlers:[],setThreadStatus:function(){},runExitHandlers:function(){for(;ze.threadExitHandlers.length>0;)ze.threadExitHandlers.pop()();y&&Xt()&&Zt()},runExitHandlersAndDeinitThread:function(e,t){Atomics.store(s(),e+56>>2,1),Atomics.store(s(),e+60>>2,0),ze.runExitHandlers(),Atomics.store(s(),e+4>>2,t),Atomics.store(s(),e+0>>2,1),Re(e+0,2147483647),rn(0,0,0)},threadExit:function(e){var t=Xt();t&&(ze.runExitHandlersAndDeinitThread(t,e),y&&postMessage({cmd:"exit"}))},threadCancel:function(){ze.runExitHandlersAndDeinitThread(Xt(),-1),postMessage({cmd:"cancelDone"})},terminateAllThreads:function(){for(var e in ze.pthreads)(a=ze.pthreads[e])&&a.worker&&ze.returnWorkerToPool(a.worker);ze.pthreads={};for(var t=0;t<ze.unusedWorkers.length;++t)(n=ze.unusedWorkers[t]).terminate();for(ze.unusedWorkers=[],t=0;t<ze.runningWorkers.length;++t){var n,a=(n=ze.runningWorkers[t]).pthread;ze.freeThreadData(a),n.terminate()}ze.runningWorkers=[]},freeThreadData:function(e){if(e){if(e.threadInfoStruct){var t=r()[e.threadInfoStruct+100>>2];r()[e.threadInfoStruct+100>>2]=0,qt(t),qt(e.threadInfoStruct)}e.threadInfoStruct=0,e.allocatedOwnStack&&e.stackBase&&qt(e.stackBase),e.stackBase=0,e.worker&&(e.worker.pthread=null)}},returnWorkerToPool:function(e){ze.runWithoutMainThreadQueuedCalls((function(){delete ze.pthreads[e.pthread.threadInfoStruct],ze.unusedWorkers.push(e),ze.runningWorkers.splice(ze.runningWorkers.indexOf(e),1),ze.freeThreadData(e.pthread),e.pthread=void 0}))},runWithoutMainThreadQueuedCalls:function(e){r()[dn>>2]=0;try{e()}finally{r()[dn>>2]=1}},receiveObjectTransfer:function(e){},loadWasmModuleToWorker:function(e,t){e.onmessage=function(n){var a=n.data,r=a.cmd;if(e.pthread&&(ze.currentProxiedOperationCallerThread=e.pthread.threadInfoStruct),a.targetThread&&a.targetThread!=Xt()){var o=ze.pthreads[a.targetThread];return o?o.worker.postMessage(n.data,a.transferList):console.error('Internal error! Worker sent a message "'+r+'" to target pthread '+a.targetThread+", but that thread no longer exists!"),void(ze.currentProxiedOperationCallerThread=void 0)}if("processQueuedMainThreadWork"===r)Yt();else if("spawnThread"===r)Ft(n.data);else if("cleanupThread"===r)De(a.thread);else if("killThread"===r)Me(a.thread);else if("cancelThread"===r)Fe(a.thread);else if("loaded"===r)e.loaded=!0,t&&t(e),e.runPthread&&(e.runPthread(),delete e.runPthread);else if("print"===r)N("Thread "+a.threadId+": "+a.text);else if("printErr"===r)_("Thread "+a.threadId+": "+a.text);else if("alert"===r)alert("Thread "+a.threadId+": "+a.text);else if("exit"===r)e.pthread&&Atomics.load(s(),e.pthread.threadInfoStruct+64>>2)&&ze.returnWorkerToPool(e);else if("exitProcess"===r)try{fn(a.returnCode)}catch(e){if(e instanceof hn)return;throw e}else"cancelDone"===r?ze.returnWorkerToPool(e):"objectTransfer"===r?ze.receiveObjectTransfer(n.data):"setimmediate"===n.data.target?e.postMessage(n.data):_("worker sent an unknown command "+r);ze.currentProxiedOperationCallerThread=void 0},e.onerror=function(e){_("pthread sent an error! "+e.filename+":"+e.lineno+": "+e.message)},g&&(e.on("message",(function(t){e.onmessage({data:t})})),e.on("error",(function(t){e.onerror(t)})),e.on("exit",(function(e){}))),e.postMessage({cmd:"load",urlOrBlob:u.mainScriptUrlOrBlob||n,wasmMemory:P,wasmModule:R})},allocateUnusedWorker:function(){var e=C("tfjs-backend-wasm-threaded-simd.worker.js");ze.unusedWorkers.push(new Worker(e))},getNewWorker:function(){return 0==ze.unusedWorkers.length&&(ze.allocateUnusedWorker(),ze.loadWasmModuleToWorker(ze.unusedWorkers[0])),ze.unusedWorkers.length>0?ze.unusedWorkers.pop():null},busySpinWait:function(e){for(var t=performance.now()+e;performance.now()<t;);}};function Le(e,t){un(e,t),on(e)}function $e(){return M}function Be(e,t){return Q.get(e)(t)}function Ve(e,t,n,a){ye("Assertion failed: "+q(e)+", at: "+[t?q(t):"unknown filename",n,a?q(a):"unknown function"])}function Ue(e,t){_main(e,t)}function Ge(e){return r()[jt()>>2]=e,e}function We(e,t){if(y)return Je(1,1,e,t)}function He(e,t){if(e==t)postMessage({cmd:"processQueuedMainThreadWork"});else if(y)postMessage({targetThread:e,cmd:"processThreadQueue"});else{var n=ze.pthreads[e],a=n&&n.worker;if(!a)return;a.postMessage({cmd:"processThreadQueue"})}return 1}function qe(){ye()}function je(e,t,n){var a=tt(t,n);return Ne[e].apply(null,a)}function Ke(e,t){}function Xe(e,n,a){if(e<=0||e>t().length||!0&e)return-28;if(m){if(Atomics.load(r(),e>>2)!=n)return-6;var s=performance.now(),o=s+a;for(Atomics.exchange(r(),pn>>2,e);;){if((s=performance.now())>o)return Atomics.exchange(r(),pn>>2,0),-73;if(0==Atomics.exchange(r(),pn>>2,0))break;if(Yt(),Atomics.load(r(),e>>2)!=n)return-6;Atomics.exchange(r(),pn>>2,e)}return 0}var i=Atomics.wait(r(),e>>2,n,a);if("timed-out"===i)return-73;if("not-equal"===i)return-6;if("ok"===i)return 0;throw"Atomics.wait returned an unexpected value "+i}function Ze(e,t,n){a().copyWithin(e,t,t+n)}function Ye(){return g?__require22("os").cpus().length:navigator.hardwareConcurrency}function Je(e,t){for(var n=arguments.length-2,a=sn(),r=n,s=ln(8*r),i=s>>3,l=0;l<n;l++){var u=arguments[2+l];o()[i+l]=u}var c=nn(e,r,s,t);return on(a),c}u.establishStackSpace=Le,u.getNoExitRuntime=$e,u.invokeEntryPoint=Be,Oe=g?function(){var e=process.hrtime();return 1e3*e[0]+e[1]/1e6}:y?function(){return performance.now()-u.__performance_now_clock_drift}:"undefined"!=typeof dateNow?dateNow:function(){return performance.now()};var Qe=[],et=[];function tt(e,t){var n;for(et.length=0,t>>=2;n=a()[e++];){var s=n<105;s&&1&t&&t++,et.push(s?o()[t++>>1]:r()[t]),++t}return et}function nt(e,t,n){Qe.length=t;for(var a=n>>3,r=0;r<t;r++)Qe[r]=o()[a+r];return(e<0?Ne[-e-1]:Ut[e]).apply(null,Qe)}function at(){return a().length}function rt(e){try{return P.grow(e-F.byteLength+65535>>>16),J(P.buffer),1}catch(e){}}function st(e){var t=at();if(e<=t)return!1;var n=2147483648;if(e>n)return!1;for(var a=1;a<=4;a*=2){var r=t*(1+.2/a);if(r=Math.min(r,e+100663296),rt(Math.min(n,Y(Math.max(e,r),65536))))return!0}return!1}var ot={inEventHandler:0,removeAllEventListeners:function(){for(var e=ot.eventHandlers.length-1;e>=0;--e)ot._removeHandler(e);ot.eventHandlers=[],ot.deferredCalls=[]},registerRemoveEventListeners:function(){ot.removeEventListenersRegistered||(re.push(ot.removeAllEventListeners),ot.removeEventListenersRegistered=!0)},deferredCalls:[],deferCall:function(e,t,n){function a(e,t){if(e.length!=t.length)return!1;for(var n in e)if(e[n]!=t[n])return!1;return!0}for(var r in ot.deferredCalls){var s=ot.deferredCalls[r];if(s.targetFunction==e&&a(s.argsList,n))return}ot.deferredCalls.push({targetFunction:e,precedence:t,argsList:n}),ot.deferredCalls.sort((function(e,t){return e.precedence<t.precedence}))},removeDeferredCalls:function(e){for(var t=0;t<ot.deferredCalls.length;++t)ot.deferredCalls[t].targetFunction==e&&(ot.deferredCalls.splice(t,1),--t)},canPerformEventHandlerRequests:function(){return ot.inEventHandler&&ot.currentEventHandler.allowsDeferredCalls},runDeferredCalls:function(){if(ot.canPerformEventHandlerRequests())for(var e=0;e<ot.deferredCalls.length;++e){var t=ot.deferredCalls[e];ot.deferredCalls.splice(e,1),--e,t.targetFunction.apply(null,t.argsList)}},eventHandlers:[],removeAllHandlersOnTarget:function(e,t){for(var n=0;n<ot.eventHandlers.length;++n)ot.eventHandlers[n].target!=e||t&&t!=ot.eventHandlers[n].eventTypeString||ot._removeHandler(n--)},_removeHandler:function(e){var t=ot.eventHandlers[e];t.target.removeEventListener(t.eventTypeString,t.eventListenerFunc,t.useCapture),ot.eventHandlers.splice(e,1)},registerOrRemoveHandler:function(e){var t=function(t){++ot.inEventHandler,ot.currentEventHandler=e,ot.runDeferredCalls(),e.handlerFunc(t),ot.runDeferredCalls(),--ot.inEventHandler};if(e.callbackfunc)e.eventListenerFunc=t,e.target.addEventListener(e.eventTypeString,t,e.useCapture),ot.eventHandlers.push(e),ot.registerRemoveEventListeners();else for(var n=0;n<ot.eventHandlers.length;++n)ot.eventHandlers[n].target==e.target&&ot.eventHandlers[n].eventTypeString==e.eventTypeString&&ot._removeHandler(n--)},queueEventHandlerOnThread_iiii:function(e,t,n,a,s){var o=sn(),i=ln(12);r()[i>>2]=n,r()[i+4>>2]=a,r()[i+8>>2]=s,an(0,e,637534208,t,a,i),on(o)},getTargetThreadForEventCallback:function(e){switch(e){case 1:return 0;case 2:return ze.currentProxiedOperationCallerThread;default:return e}},getNodeNameForTarget:function(e){return e?e==window?"#window":e==screen?"#screen":e&&e.nodeName?e.nodeName:"":""},fullscreenEnabled:function(){return document.fullscreenEnabled||document.webkitFullscreenEnabled}};function it(e){var t=X(e)+1,n=Ht(t);return K(e,n,t),n}function lt(e,t,n,a){var s=sn(),o=ln(12),i=0;t&&(i=it(t)),r()[o>>2]=i,r()[o+4>>2]=n,r()[o+8>>2]=a,an(0,e,657457152,0,i,o),on(s)}function ut(e,t,n,a){lt(e,t=t?q(t):"",n,a)}function ct(e){return e>2?q(e):e}var dt=[0,"undefined"!=typeof document?document:0,"undefined"!=typeof window?window:0];function pt(e){return e=ct(e),dt[e]||("undefined"!=typeof document?document.querySelector(e):void 0)}function ht(e){return pt(e)}function mt(e,t,n){var a=ht(e);if(!a)return-4;if(a.canvasSharedPtr&&(r()[a.canvasSharedPtr>>2]=t,r()[a.canvasSharedPtr+4>>2]=n),!a.offscreenCanvas&&a.controlTransferredOffscreen)return a.canvasSharedPtr?(ut(r()[a.canvasSharedPtr+8>>2],e,t,n),1):-4;a.offscreenCanvas&&(a=a.offscreenCanvas);var s=!1;if(a.GLctxObject&&a.GLctxObject.GLctx){var o=a.GLctxObject.GLctx.getParameter(2978);s=0===o[0]&&0===o[1]&&o[2]===a.width&&o[3]===a.height}return a.width=t,a.height=n,s&&a.GLctxObject.GLctx.viewport(0,0,t,n),0}function ft(e,t,n){return y?Je(2,1,e,t,n):mt(e,t,n)}function gt(e,t,n){return ht(e)?mt(e,t,n):ft(e,t,n)}function xt(e){}function yt(e,t){}function At(e){var t=e.getExtension("ANGLE_instanced_arrays");if(t)return e.vertexAttribDivisor=function(e,n){t.vertexAttribDivisorANGLE(e,n)},e.drawArraysInstanced=function(e,n,a,r){t.drawArraysInstancedANGLE(e,n,a,r)},e.drawElementsInstanced=function(e,n,a,r,s){t.drawElementsInstancedANGLE(e,n,a,r,s)},1}function bt(e){var t=e.getExtension("OES_vertex_array_object");if(t)return e.createVertexArray=function(){return t.createVertexArrayOES()},e.deleteVertexArray=function(e){t.deleteVertexArrayOES(e)},e.bindVertexArray=function(e){t.bindVertexArrayOES(e)},e.isVertexArray=function(e){return t.isVertexArrayOES(e)},1}function vt(e){var t=e.getExtension("WEBGL_draw_buffers");if(t)return e.drawBuffers=function(e,n){t.drawBuffersWEBGL(e,n)},1}function kt(e){return!!(e.multiDrawWebgl=e.getExtension("WEBGL_multi_draw"))}var St={counter:1,buffers:[],programs:[],framebuffers:[],renderbuffers:[],textures:[],uniforms:[],shaders:[],vaos:[],contexts:{},offscreenCanvases:{},timerQueriesEXT:[],programInfos:{},stringCache:{},unpackAlignment:4,recordError:function(e){St.lastError||(St.lastError=e)},getNewId:function(e){for(var t=St.counter++,n=e.length;n<t;n++)e[n]=null;return t},getSource:function(e,t,n,a){for(var s="",o=0;o<t;++o){var i=a?r()[a+4*o>>2]:-1;s+=q(r()[n+4*o>>2],i<0?void 0:i)}return s},createContext:function(e,t){var n=e.getContext("webgl",t);return n?St.registerContext(n,t):0},registerContext:function(e,t){var n=Ht(8);r()[n+4>>2]=Xt();var a={handle:n,attributes:t,version:t.majorVersion,GLctx:e};return e.canvas&&(e.canvas.GLctxObject=a),St.contexts[n]=a,(void 0===t.enableExtensionsByDefault||t.enableExtensionsByDefault)&&St.initExtensions(a),n},makeContextCurrent:function(e){return St.currentContext=St.contexts[e],u.ctx=Tt=St.currentContext&&St.currentContext.GLctx,!(e&&!Tt)},getContext:function(e){return St.contexts[e]},deleteContext:function(e){St.currentContext===St.contexts[e]&&(St.currentContext=null),"object"==typeof ot&&ot.removeAllHandlersOnTarget(St.contexts[e].GLctx.canvas),St.contexts[e]&&St.contexts[e].GLctx.canvas&&(St.contexts[e].GLctx.canvas.GLctxObject=void 0),qt(St.contexts[e].handle),St.contexts[e]=null},initExtensions:function(e){if(e||(e=St.currentContext),!e.initExtensionsDone){e.initExtensionsDone=!0;var t=e.GLctx;At(t),bt(t),vt(t),t.disjointTimerQueryExt=t.getExtension("EXT_disjoint_timer_query"),kt(t),(t.getSupportedExtensions()||[]).forEach((function(e){e.indexOf("lose_context")<0&&e.indexOf("debug")<0&&t.getExtension(e)}))}},populateUniformTable:function(e){for(var t=St.programs[e],n=St.programInfos[e]={uniforms:{},maxUniformLength:0,maxAttributeLength:-1,maxUniformBlockNameLength:-1},a=n.uniforms,r=Tt.getProgramParameter(t,35718),s=0;s<r;++s){var o=Tt.getActiveUniform(t,s),i=o.name;n.maxUniformLength=Math.max(n.maxUniformLength,i.length+1),"]"==i.slice(-1)&&(i=i.slice(0,i.lastIndexOf("[")));var l=Tt.getUniformLocation(t,i);if(l){var u=St.getNewId(St.uniforms);a[i]=[o.size,u],St.uniforms[u]=l;for(var c=1;c<o.size;++c){var d=i+"["+c+"]";l=Tt.getUniformLocation(t,d),u=St.getNewId(St.uniforms),St.uniforms[u]=l}}}}},wt=["default","low-power","high-performance"];function Ct(e,t){var n=t>>2,a=r()[n+6],s={alpha:!!r()[n+0],depth:!!r()[n+1],stencil:!!r()[n+2],antialias:!!r()[n+3],premultipliedAlpha:!!r()[n+4],preserveDrawingBuffer:!!r()[n+5],powerPreference:wt[a],failIfMajorPerformanceCaveat:!!r()[n+7],majorVersion:r()[n+8],minorVersion:r()[n+9],enableExtensionsByDefault:r()[n+10],explicitSwapControl:r()[n+11],proxyContextToMainThread:r()[n+12],renderViaOffscreenBackBuffer:r()[n+13]},o=ht(e);return o?s.explicitSwapControl?0:St.createContext(o,s):0}function It(e,t){return Ct(e,t)}var Tt,Nt={mappings:{},buffers:[null,[],[]],printChar:function(e,t){var n=Nt.buffers[e];0===t||10===t?((1===e?N:_)(H(n,0)),n.length=0):n.push(t)},varargs:void 0,get:function(){return Nt.varargs+=4,r()[Nt.varargs-4>>2]},getStr:function(e){return q(e)},get64:function(e,t){return e}};function _t(e){return y?Je(3,1,e):0}function Et(e,t,n,a,r){if(y)return Je(4,1,e,t,n,a,r)}function Pt(e,t,n,s){if(y)return Je(5,1,e,t,n,s);for(var o=0,i=0;i<n;i++){for(var l=r()[t+8*i>>2],u=r()[t+(8*i+4)>>2],c=0;c<u;c++)Nt.printChar(e,a()[l+c]);o+=u}return r()[s>>2]=o,0}function Rt(e){var t=ze.threadExitHandlers.pop();e&&t()}function Mt(e,t){ze.threadExitHandlers.push((function(){Q.get(e)(t)}))}function Ft(e){if(y)throw"Internal Error! spawnThread() can only ever be called from main application thread!";var t=ze.getNewWorker();if(void 0!==t.pthread)throw"Internal error!";if(!e.pthread_ptr)throw"Internal error, no pthread ptr!";ze.runningWorkers.push(t);for(var n=Ht(512),a=0;a<128;++a)r()[n+4*a>>2]=0;var o=e.stackBase+e.stackSize,i=ze.pthreads[e.pthread_ptr]={worker:t,stackBase:e.stackBase,stackSize:e.stackSize,allocatedOwnStack:e.allocatedOwnStack,threadInfoStruct:e.pthread_ptr},l=i.threadInfoStruct>>2;Atomics.store(s(),l+16,e.detached),Atomics.store(s(),l+25,n),Atomics.store(s(),l+10,i.threadInfoStruct),Atomics.store(s(),l+20,e.stackSize),Atomics.store(s(),l+19,o),Atomics.store(s(),l+26,e.stackSize),Atomics.store(s(),l+28,o),Atomics.store(s(),l+29,e.detached);var u=Kt()+40;Atomics.store(s(),l+43,u),t.pthread=i;var c={cmd:"run",start_routine:e.startRoutine,arg:e.arg,threadInfoStruct:e.pthread_ptr,stackBase:e.stackBase,stackSize:e.stackSize};t.runPthread=function(){c.time=performance.now(),t.postMessage(c,e.transferList)},t.loaded&&(t.runPthread(),delete t.runPthread)}function Dt(e,t,n,a){if("undefined"==typeof SharedArrayBuffer)return _("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;if(!e)return _("pthread_create called with a null thread pointer!"),28;var o=[];if(y&&0===o.length)return tn(687865856,e,t,n,a);var i=0,l=0,u=0;t&&-1!=t?(i=r()[t>>2],i+=81920,l=r()[t+8>>2],u=0!==r()[t+12>>2]):i=2097152;var c=0==l;c?l=cn(16,i):V((l-=i)>0);for(var d=Ht(228),p=0;p<57;++p)s()[(d>>2)+p]=0;r()[e>>2]=d,r()[d+12>>2]=d;var h=d+152;r()[h>>2]=h;var m={stackBase:l,stackSize:i,allocatedOwnStack:c,detached:u,startRoutine:n,pthread_ptr:d,arg:a,transferList:o};return y?(m.cmd="spawnThread",postMessage(m,o)):Ft(m),0}function Ot(){if(y){var e=Xt();if(e&&!Atomics.load(s(),e+56>>2)&&2==Atomics.load(s(),e+0>>2))throw"Canceled!"}}function zt(){g||f||E("Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread")}function Lt(e,t,n){if(!e)return _("pthread_join attempted on a null thread pointer!"),Pe.ESRCH;if(y&&Xt()==e)return _("PThread "+e+" is attempting to join to itself!"),Pe.EDEADLK;if(!y&&Qt()==e)return _("Main thread "+e+" is attempting to join to itself!"),Pe.EDEADLK;if(r()[e+12>>2]!==e)return _("pthread_join attempted on thread "+e+", which does not point to a valid thread, or does not exist anymore!"),Pe.ESRCH;if(Atomics.load(s(),e+64>>2))return _("Attempted to join thread "+e+", which was already detached!"),Pe.EINVAL;for(n&&zt();;){var a=Atomics.load(s(),e+0>>2);if(1==a){var o=Atomics.load(s(),e+4>>2);return t&&(r()[t>>2]=o),Atomics.store(s(),e+64>>2,1),y?postMessage({cmd:"cleanupThread",thread:e}):De(e),0}if(!n)return Pe.EBUSY;Ot(),y||Yt(),Xe(e+0,a,y?100:1)}}function $t(e,t){return Lt(e,t,!0)}function Bt(e){if(y)return Je(6,1,e);switch(e){case 30:case 75:return 16384;case 85:return 131072;case 132:case 133:case 12:case 137:case 138:case 15:case 235:case 16:case 17:case 18:case 19:case 20:case 149:case 13:case 10:case 236:case 153:case 9:case 21:case 22:case 159:case 154:case 14:case 77:case 78:case 139:case 82:case 68:case 67:case 164:case 11:case 29:case 47:case 48:case 95:case 52:case 51:case 46:return 200809;case 27:case 246:case 127:case 128:case 23:case 24:case 160:case 161:case 181:case 182:case 242:case 183:case 184:case 243:case 244:case 245:case 165:case 178:case 179:case 49:case 50:case 168:case 169:case 175:case 170:case 171:case 172:case 97:case 76:case 32:case 173:case 35:case 80:case 81:case 79:return-1;case 176:case 177:case 7:case 155:case 8:case 157:case 125:case 126:case 92:case 93:case 129:case 130:case 131:case 94:case 91:return 1;case 74:case 60:case 69:case 70:case 4:return 1024;case 31:case 42:case 72:return 32;case 87:case 26:case 33:return 2147483647;case 34:case 1:return 47839;case 38:case 36:return 99;case 43:case 37:return 2048;case 0:return 2097152;case 3:return 65536;case 28:return 32768;case 44:return 32767;case 39:return 1e3;case 89:return 700;case 71:return 256;case 40:return 255;case 2:return 100;case 180:return 64;case 25:return 20;case 5:return 16;case 6:return 6;case 73:return 4;case 84:return"object"==typeof navigator&&navigator.hardwareConcurrency||1}return Ge(28),-1}y||ze.initMainThreadBlock();var Vt,Ut=[null,We,ft,_t,Et,Pt,Bt],Gt={e:Ve,r:Ue,x:He,b:qe,y:je,j:Ke,d:Xe,c:Re,f:Oe,p:Ze,A:Ye,u:nt,q:st,v:gt,i:xt,s:yt,w:It,l:_t,n:Et,g:Pt,o:_e,a:P||u.wasmMemory,z:Rt,k:Mt,h:Dt,m:$t,t:Bt},Wt=(Te(),u.___wasm_call_ctors=function(){return(Wt=u.___wasm_call_ctors=u.asm.B).apply(null,arguments)}),Ht=(u._init=function(){return(u._init=u.asm.C).apply(null,arguments)},u._init_with_threads_count=function(){return(u._init_with_threads_count=u.asm.D).apply(null,arguments)},u._get_threads_count=function(){return(u._get_threads_count=u.asm.E).apply(null,arguments)},u._register_tensor=function(){return(u._register_tensor=u.asm.F).apply(null,arguments)},u._dispose_data=function(){return(u._dispose_data=u.asm.G).apply(null,arguments)},u._dispose=function(){return(u._dispose=u.asm.H).apply(null,arguments)},u._Abs=function(){return(u._Abs=u.asm.I).apply(null,arguments)},u._Add=function(){return(u._Add=u.asm.J).apply(null,arguments)},u._AddN=function(){return(u._AddN=u.asm.K).apply(null,arguments)},u._All=function(){return(u._All=u.asm.L).apply(null,arguments)},u._Any=function(){return(u._Any=u.asm.M).apply(null,arguments)},u._ArgMax=function(){return(u._ArgMax=u.asm.N).apply(null,arguments)},u._AvgPool=function(){return(u._AvgPool=u.asm.O).apply(null,arguments)},u._BatchMatMul=function(){return(u._BatchMatMul=u.asm.P).apply(null,arguments)},u._Ceil=function(){return(u._Ceil=u.asm.Q).apply(null,arguments)},u._ClipByValue=function(){return(u._ClipByValue=u.asm.R).apply(null,arguments)},u._Conv2D=function(){return(u._Conv2D=u.asm.S).apply(null,arguments)},u._Conv2DBackpropInput=function(){return(u._Conv2DBackpropInput=u.asm.T).apply(null,arguments)},u._Cos=function(){return(u._Cos=u.asm.U).apply(null,arguments)},u._Cosh=function(){return(u._Cosh=u.asm.V).apply(null,arguments)},u._CropAndResize=function(){return(u._CropAndResize=u.asm.W).apply(null,arguments)},u._Cumsum=function(){return(u._Cumsum=u.asm.X).apply(null,arguments)},u._DepthToSpace=function(){return(u._DepthToSpace=u.asm.Y).apply(null,arguments)},u._DepthwiseConv2dNative=function(){return(u._DepthwiseConv2dNative=u.asm.Z).apply(null,arguments)},u._Elu=function(){return(u._Elu=u.asm._).apply(null,arguments)},u._Equal=function(){return(u._Equal=u.asm.$).apply(null,arguments)},u._Exp=function(){return(u._Exp=u.asm.aa).apply(null,arguments)},u._FlipLeftRight=function(){return(u._FlipLeftRight=u.asm.ba).apply(null,arguments)},u._Floor=function(){return(u._Floor=u.asm.ca).apply(null,arguments)},u._FloorDiv=function(){return(u._FloorDiv=u.asm.da).apply(null,arguments)},u._FusedBatchNorm=function(){return(u._FusedBatchNorm=u.asm.ea).apply(null,arguments)},u._FusedConv2D=function(){return(u._FusedConv2D=u.asm.fa).apply(null,arguments)},u._FusedDepthwiseConv2D=function(){return(u._FusedDepthwiseConv2D=u.asm.ga).apply(null,arguments)},u._Gather=function(){return(u._Gather=u.asm.ha).apply(null,arguments)},u._GatherNd=function(){return(u._GatherNd=u.asm.ia).apply(null,arguments)},u._Greater=function(){return(u._Greater=u.asm.ja).apply(null,arguments)},u._GreaterEqual=function(){return(u._GreaterEqual=u.asm.ka).apply(null,arguments)},u._LeakyRelu=function(){return(u._LeakyRelu=u.asm.la).apply(null,arguments)},u._Less=function(){return(u._Less=u.asm.ma).apply(null,arguments)},u._LessEqual=function(){return(u._LessEqual=u.asm.na).apply(null,arguments)},u._Log=function(){return(u._Log=u.asm.oa).apply(null,arguments)},u._LogicalAnd=function(){return(u._LogicalAnd=u.asm.pa).apply(null,arguments)},u._Max=function(){return(u._Max=u.asm.qa).apply(null,arguments)},u._MaxPool=function(){return(u._MaxPool=u.asm.ra).apply(null,arguments)},u._Maximum=function(){return(u._Maximum=u.asm.sa).apply(null,arguments)},u._Mean=function(){return(u._Mean=u.asm.ta).apply(null,arguments)},u._Min=function(){return(u._Min=u.asm.ua).apply(null,arguments)},u._Minimum=function(){return(u._Minimum=u.asm.va).apply(null,arguments)},u._MirrorPad=function(){return(u._MirrorPad=u.asm.wa).apply(null,arguments)},u._Multiply=function(){return(u._Multiply=u.asm.xa).apply(null,arguments)},u._Neg=function(){return(u._Neg=u.asm.ya).apply(null,arguments)},u._NonMaxSuppressionV3=function(){return(u._NonMaxSuppressionV3=u.asm.za).apply(null,arguments)},u._NonMaxSuppressionV4=function(){return(u._NonMaxSuppressionV4=u.asm.Aa).apply(null,arguments)},u._NonMaxSuppressionV5=function(){return(u._NonMaxSuppressionV5=u.asm.Ba).apply(null,arguments)},u._NotEqual=function(){return(u._NotEqual=u.asm.Ca).apply(null,arguments)},u._OneHot=function(){return(u._OneHot=u.asm.Da).apply(null,arguments)},u._PadV2=function(){return(u._PadV2=u.asm.Ea).apply(null,arguments)},u._Pow=function(){return(u._Pow=u.asm.Fa).apply(null,arguments)},u._Prelu=function(){return(u._Prelu=u.asm.Ga).apply(null,arguments)},u._Prod=function(){return(u._Prod=u.asm.Ha).apply(null,arguments)},u._RealDiv=function(){return(u._RealDiv=u.asm.Ia).apply(null,arguments)},u._Relu=function(){return(u._Relu=u.asm.Ja).apply(null,arguments)},u._Relu6=function(){return(u._Relu6=u.asm.Ka).apply(null,arguments)},u._ResizeBilinear=function(){return(u._ResizeBilinear=u.asm.La).apply(null,arguments)},u._Reverse=function(){return(u._Reverse=u.asm.Ma).apply(null,arguments)},u._RotateWithOffset=function(){return(u._RotateWithOffset=u.asm.Na).apply(null,arguments)},u._Round=function(){return(u._Round=u.asm.Oa).apply(null,arguments)},u._Rsqrt=function(){return(u._Rsqrt=u.asm.Pa).apply(null,arguments)},u._ScatterNd=function(){return(u._ScatterNd=u.asm.Qa).apply(null,arguments)},u._SelectV2=function(){return(u._SelectV2=u.asm.Ra).apply(null,arguments)},u._Sigmoid=function(){return(u._Sigmoid=u.asm.Sa).apply(null,arguments)},u._Sin=function(){return(u._Sin=u.asm.Ta).apply(null,arguments)},u._Softmax=function(){return(u._Softmax=u.asm.Ua).apply(null,arguments)},u._Sqrt=function(){return(u._Sqrt=u.asm.Va).apply(null,arguments)},u._Square=function(){return(u._Square=u.asm.Wa).apply(null,arguments)},u._SquaredDifference=function(){return(u._SquaredDifference=u.asm.Xa).apply(null,arguments)},u._Step=function(){return(u._Step=u.asm.Ya).apply(null,arguments)},u._StridedSlice=function(){return(u._StridedSlice=u.asm.Za).apply(null,arguments)},u._Sub=function(){return(u._Sub=u.asm._a).apply(null,arguments)},u._Sum=function(){return(u._Sum=u.asm.$a).apply(null,arguments)},u._Tan=function(){return(u._Tan=u.asm.ab).apply(null,arguments)},u._Tanh=function(){return(u._Tanh=u.asm.bb).apply(null,arguments)},u._Tile=function(){return(u._Tile=u.asm.cb).apply(null,arguments)},u._TopK=function(){return(u._TopK=u.asm.db).apply(null,arguments)},u._Transform=function(){return(u._Transform=u.asm.eb).apply(null,arguments)},u._Transpose=function(){return(u._Transpose=u.asm.fb).apply(null,arguments)},u.__FusedMatMul=function(){return(u.__FusedMatMul=u.asm.gb).apply(null,arguments)},u._malloc=function(){return(Ht=u._malloc=u.asm.hb).apply(null,arguments)}),qt=u._free=function(){return(qt=u._free=u.asm.ib).apply(null,arguments)},jt=u.___errno_location=function(){return(jt=u.___errno_location=u.asm.jb).apply(null,arguments)},Kt=u._emscripten_get_global_libc=function(){return(Kt=u._emscripten_get_global_libc=u.asm.lb).apply(null,arguments)},Xt=u._pthread_self=function(){return(Xt=u._pthread_self=u.asm.mb).apply(null,arguments)},Zt=u.___pthread_tsd_run_dtors=function(){return(Zt=u.___pthread_tsd_run_dtors=u.asm.nb).apply(null,arguments)},Yt=u._emscripten_main_thread_process_queued_calls=function(){return(Yt=u._emscripten_main_thread_process_queued_calls=u.asm.ob).apply(null,arguments)},Jt=(u._emscripten_current_thread_process_queued_calls=function(){return(u._emscripten_current_thread_process_queued_calls=u.asm.pb).apply(null,arguments)},u._emscripten_register_main_browser_thread_id=function(){return(Jt=u._emscripten_register_main_browser_thread_id=u.asm.qb).apply(null,arguments)}),Qt=u._emscripten_main_browser_thread_id=function(){return(Qt=u._emscripten_main_browser_thread_id=u.asm.rb).apply(null,arguments)},en=u.__emscripten_do_dispatch_to_thread=function(){return(en=u.__emscripten_do_dispatch_to_thread=u.asm.sb).apply(null,arguments)},tn=u._emscripten_sync_run_in_main_thread_4=function(){return(tn=u._emscripten_sync_run_in_main_thread_4=u.asm.tb).apply(null,arguments)},nn=u._emscripten_run_in_main_runtime_thread_js=function(){return(nn=u._emscripten_run_in_main_runtime_thread_js=u.asm.ub).apply(null,arguments)},an=u.__emscripten_call_on_thread=function(){return(an=u.__emscripten_call_on_thread=u.asm.vb).apply(null,arguments)},rn=(u._emscripten_tls_init=function(){return(u._emscripten_tls_init=u.asm.wb).apply(null,arguments)},u.__emscripten_thread_init=function(){return(rn=u.__emscripten_thread_init=u.asm.xb).apply(null,arguments)}),sn=u.stackSave=function(){return(sn=u.stackSave=u.asm.yb).apply(null,arguments)},on=u.stackRestore=function(){return(on=u.stackRestore=u.asm.zb).apply(null,arguments)},ln=u.stackAlloc=function(){return(ln=u.stackAlloc=u.asm.Ab).apply(null,arguments)},un=u._emscripten_stack_set_limits=function(){return(un=u._emscripten_stack_set_limits=u.asm.Bb).apply(null,arguments)},cn=u._memalign=function(){return(cn=u._memalign=u.asm.Cb).apply(null,arguments)},dn=u.__emscripten_allow_main_runtime_queued_calls=10064,pn=u.__emscripten_main_thread_futex=10268;function hn(e){this.name="ExitStatus",this.message="Program terminated with exit("+e+")",this.status=e}function mn(e){if(e=e||p,!(he>0)){if(y)return i(u),ie(),void postMessage({cmd:"loaded"});oe(),he>0||(u.setStatus?(u.setStatus("Running..."),setTimeout((function(){setTimeout((function(){u.setStatus("")}),1),t()}),1)):t())}function t(){Vt||(Vt=!0,u.calledRun=!0,B||(ie(),le(),i(u),u.onRuntimeInitialized&&u.onRuntimeInitialized(),ce()))}}function fn(e,t){if(!t||!M||0!==e){if(!t&&y)throw postMessage({cmd:"exitProcess",returnCode:e}),new hn(e);M||(ze.terminateAllThreads(),ue(),u.onExit&&u.onExit(e),B=!0),h(e,new hn(e))}}if(u.cwrap=W,u.PThread=ze,u.PThread=ze,u.wasmMemory=P,u.ExitStatus=hn,fe=function e(){Vt||mn(),Vt||(fe=e)},u.run=mn,u.preInit)for("function"==typeof u.preInit&&(u.preInit=[u.preInit]);u.preInit.length>0;)u.preInit.pop()();return y&&(M=!1,ze.initWorker()),mn(),e.ready});"object"==typeof e&&"object"==typeof t?t.exports=a:"function"==typeof define&&define.amd?define([],(function(){return a})):"object"==typeof e&&(e.WasmBackendModuleThreadedSimd=a)}}),require_tfjs_backend_wasm=__commonJS({"src/tfjs-backend-wasm/wasm-out/tfjs-backend-wasm.js"(e,t){var n,a=(n="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0,"undefined"!=typeof __filename&&(n=n||__filename),function(e){var t,a,r=void 0!==(e=e||{})?e:{};r.ready=new Promise((function(e,n){t=e,a=n}));var s,o={};for(s in r)r.hasOwnProperty(s)&&(o[s]=r[s]);var i=[],l=!1,u=!1,c=!1,d=!1;l="object"==typeof window,u="function"==typeof importScripts,c="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,d=!l&&!c&&!u;var p,h,m,f,g,x="";function y(e){return r.locateFile?r.locateFile(e,x):x+e}c?(x=u?__require22("path").dirname(x)+"/":__dirname+"/",p=function(e,t){return f||(f=__require22("fs")),g||(g=__require22("path")),e=g.normalize(e),f.readFileSync(e,t?null:"utf8")},m=function(e){var t=p(e,!0);return t.buffer||(t=new Uint8Array(t)),w(t.buffer),t},process.argv.length>1&&process.argv[1].replace(/\\/g,"/"),i=process.argv.slice(2),process.on("uncaughtException",(function(e){if(!(e instanceof _e))throw e})),process.on("unhandledRejection",ne),r.inspect=function(){return"[Emscripten Module object]"}):d?("undefined"!=typeof read&&(p=function(e){return read(e)}),m=function(e){var t;return"function"==typeof readbuffer?new Uint8Array(readbuffer(e)):(w("object"==typeof(t=read(e,"binary"))),t)},"undefined"!=typeof scriptArgs?i=scriptArgs:void 0!==arguments&&(i=arguments),"undefined"!=typeof print&&("undefined"==typeof console&&(console={}),console.log=print,console.warn=console.error="undefined"!=typeof printErr?printErr:print)):(l||u)&&(u?x=self.location.href:"undefined"!=typeof document&&document.currentScript&&(x=document.currentScript.src),n&&(x=n),x=0!==x.indexOf("blob:")?x.substr(0,x.lastIndexOf("/")+1):"",p=function(e){var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},u&&(m=function(e){var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),h=function(e,t,n){var a=new XMLHttpRequest;a.open("GET",e,!0),a.responseType="arraybuffer",a.onload=function(){200==a.status||0==a.status&&a.response?t(a.response):n()},a.onerror=n,a.send(null)});var A,b,v=r.print||console.log.bind(console),k=r.printErr||console.warn.bind(console);for(s in o)o.hasOwnProperty(s)&&(r[s]=o[s]);o=null,r.arguments&&(i=r.arguments),r.thisProgram&&r.thisProgram,r.quit&&r.quit,r.wasmBinary&&(A=r.wasmBinary),r.noExitRuntime,"object"!=typeof WebAssembly&&ne("no native wasm support detected");var S=!1;function w(e,t){e||ne("Assertion failed: "+t)}function C(e){var t=r["_"+e];return w(t,"Cannot call unknown function "+e+", make sure it is exported"),t}function I(e,t,n,a,r){var s={string:function(e){var t=0;if(null!=e&&0!==e){var n=1+(e.length<<2);O(e,t=Ne(n),n)}return t},array:function(e){var t=Ne(e.length);return z(e,t),t}},o=C(e),i=[],l=0;if(a)for(var u=0;u<a.length;u++){var c=s[n[u]];c?(0===l&&(l=Ie()),i[u]=c(a[u])):i[u]=a[u]}var d,p=o.apply(null,i);return d=p,p="string"===t?F(d):"boolean"===t?Boolean(d):d,0!==l&&Te(l),p}function T(e,t,n,a){var r=(n=n||[]).every((function(e){return"number"===e}));return"string"!==t&&r&&!a?C(e):function(){return I(e,t,n,arguments)}}var N,_,E,P,R="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function M(e,t,n){for(var a=t+n,r=t;e[r]&&!(r>=a);)++r;if(r-t>16&&e.subarray&&R)return R.decode(e.subarray(t,r));for(var s="";t<r;){var o=e[t++];if(128&o){var i=63&e[t++];if(192!=(224&o)){var l=63&e[t++];if((o=224==(240&o)?(15&o)<<12|i<<6|l:(7&o)<<18|i<<12|l<<6|63&e[t++])<65536)s+=String.fromCharCode(o);else{var u=o-65536;s+=String.fromCharCode(55296|u>>10,56320|1023&u)}}else s+=String.fromCharCode((31&o)<<6|i)}else s+=String.fromCharCode(o)}return s}function F(e,t){return e?M(E,e,t):""}function D(e,t,n,a){if(!(a>0))return 0;for(var r=n,s=n+a-1,o=0;o<e.length;++o){var i=e.charCodeAt(o);if(i>=55296&&i<=57343&&(i=65536+((1023&i)<<10)|1023&e.charCodeAt(++o)),i<=127){if(n>=s)break;t[n++]=i}else if(i<=2047){if(n+1>=s)break;t[n++]=192|i>>6,t[n++]=128|63&i}else if(i<=65535){if(n+2>=s)break;t[n++]=224|i>>12,t[n++]=128|i>>6&63,t[n++]=128|63&i}else{if(n+3>=s)break;t[n++]=240|i>>18,t[n++]=128|i>>12&63,t[n++]=128|i>>6&63,t[n++]=128|63&i}}return t[n]=0,n-r}function O(e,t,n){return D(e,E,t,n)}function z(e,t){_.set(e,t)}function L(e,t){return e%t>0&&(e+=t-e%t),e}function $(e){N=e,r.HEAP8=_=new Int8Array(e),r.HEAP16=new Int16Array(e),r.HEAP32=P=new Int32Array(e),r.HEAPU8=E=new Uint8Array(e),r.HEAPU16=new Uint16Array(e),r.HEAPU32=new Uint32Array(e),r.HEAPF32=new Float32Array(e),r.HEAPF64=new Float64Array(e)}r.INITIAL_MEMORY;var B,V=[],U=[],G=[],W=[];function H(){if(r.preRun)for("function"==typeof r.preRun&&(r.preRun=[r.preRun]);r.preRun.length;)X(r.preRun.shift());pe(V)}function q(){pe(U)}function j(){pe(G)}function K(){if(r.postRun)for("function"==typeof r.postRun&&(r.postRun=[r.postRun]);r.postRun.length;)Z(r.postRun.shift());pe(W)}function X(e){V.unshift(e)}function Z(e){W.unshift(e)}U.push({func:function(){Ce()}});var Y=0,J=null,Q=null;function ee(e){Y++,r.monitorRunDependencies&&r.monitorRunDependencies(Y)}function te(e){if(Y--,r.monitorRunDependencies&&r.monitorRunDependencies(Y),0==Y&&(null!==J&&(clearInterval(J),J=null),Q)){var t=Q;Q=null,t()}}function ne(e){r.onAbort&&r.onAbort(e),k(e+=""),S=!0,e="abort("+e+"). Build with -s ASSERTIONS=1 for more info.";var t=new WebAssembly.RuntimeError(e);throw a(t),t}function ae(e,t){return String.prototype.startsWith?e.startsWith(t):0===e.indexOf(t)}r.preloadedImages={},r.preloadedAudios={};var re="data:application/octet-stream;base64,";function se(e){return ae(e,re)}var oe="file://";function ie(e){return ae(e,oe)}var le="tfjs-backend-wasm.wasm";function ue(e){try{if(e==le&&A)return new Uint8Array(A);if(m)return m(e);throw"both async and sync fetching of the wasm failed"}catch(e){ne(e)}}function ce(){if(!A&&(l||u)){if("function"==typeof fetch&&!ie(le))return fetch(le,{credentials:"same-origin"}).then((function(e){if(!e.ok)throw"failed to load wasm binary file at '"+le+"'";return e.arrayBuffer()})).catch((function(){return ue(le)}));if(h)return new Promise((function(e,t){h(le,(function(t){e(new Uint8Array(t))}),t)}))}return Promise.resolve().then((function(){return ue(le)}))}function de(){var e={a:we};function t(e,t){var n=e.exports;r.asm=n,$((b=r.asm.h).buffer),B=r.asm.Sa,te()}function n(e){t(e.instance)}function s(t){return ce().then((function(t){return WebAssembly.instantiate(t,e)})).then(t,(function(e){k("failed to asynchronously prepare wasm: "+e),ne(e)}))}if(ee(),r.instantiateWasm)try{return r.instantiateWasm(e,t)}catch(e){return k("Module.instantiateWasm callback failed with error: "+e),!1}return(A||"function"!=typeof WebAssembly.instantiateStreaming||se(le)||ie(le)||"function"!=typeof fetch?s(n):fetch(le,{credentials:"same-origin"}).then((function(t){return WebAssembly.instantiateStreaming(t,e).then(n,(function(e){return k("wasm streaming compile failed: "+e),k("falling back to ArrayBuffer instantiation"),s(n)}))}))).catch(a),{}}function pe(e){for(;e.length>0;){var t=e.shift();if("function"!=typeof t){var n=t.func;"number"==typeof n?void 0===t.arg?B.get(n)():B.get(n)(t.arg):n(void 0===t.arg?null:t.arg)}else t(r)}}function he(){ne()}function me(e,t,n){E.copyWithin(e,t,t+n)}function fe(){return E.length}function ge(e){try{return b.grow(e-N.byteLength+65535>>>16),$(b.buffer),1}catch(e){}}function xe(e){var t=fe(),n=2147483648;if(e>n)return!1;for(var a=1;a<=4;a*=2){var r=t*(1+.2/a);if(r=Math.min(r,e+100663296),ge(Math.min(n,L(Math.max(e,r),65536))))return!0}return!1}se(le)||(le=y(le));var ye={mappings:{},buffers:[null,[],[]],printChar:function(e,t){var n=ye.buffers[e];0===t||10===t?((1===e?v:k)(M(n,0)),n.length=0):n.push(t)},varargs:void 0,get:function(){return ye.varargs+=4,P[ye.varargs-4>>2]},getStr:function(e){return F(e)},get64:function(e,t){return e}};function Ae(e){return 0}function be(e,t,n,a,r){}function ve(e,t,n,a){for(var r=0,s=0;s<n;s++){for(var o=P[t+8*s>>2],i=P[t+(8*s+4)>>2],l=0;l<i;l++)ye.printChar(e,E[o+l]);r+=i}return P[a>>2]=r,0}function ke(){return 28}var Se,we={a:he,d:me,e:xe,f:Ae,c:be,b:ve,g:ke},Ce=(de(),r.___wasm_call_ctors=function(){return(Ce=r.___wasm_call_ctors=r.asm.i).apply(null,arguments)}),Ie=(r._init=function(){return(r._init=r.asm.j).apply(null,arguments)},r._init_with_threads_count=function(){return(r._init_with_threads_count=r.asm.k).apply(null,arguments)},r._get_threads_count=function(){return(r._get_threads_count=r.asm.l).apply(null,arguments)},r._register_tensor=function(){return(r._register_tensor=r.asm.m).apply(null,arguments)},r._dispose_data=function(){return(r._dispose_data=r.asm.n).apply(null,arguments)},r._dispose=function(){return(r._dispose=r.asm.o).apply(null,arguments)},r._Abs=function(){return(r._Abs=r.asm.p).apply(null,arguments)},r._Add=function(){return(r._Add=r.asm.q).apply(null,arguments)},r._AddN=function(){return(r._AddN=r.asm.r).apply(null,arguments)},r._All=function(){return(r._All=r.asm.s).apply(null,arguments)},r._Any=function(){return(r._Any=r.asm.t).apply(null,arguments)},r._ArgMax=function(){return(r._ArgMax=r.asm.u).apply(null,arguments)},r._AvgPool=function(){return(r._AvgPool=r.asm.v).apply(null,arguments)},r._BatchMatMul=function(){return(r._BatchMatMul=r.asm.w).apply(null,arguments)},r._Ceil=function(){return(r._Ceil=r.asm.x).apply(null,arguments)},r._ClipByValue=function(){return(r._ClipByValue=r.asm.y).apply(null,arguments)},r._Conv2D=function(){return(r._Conv2D=r.asm.z).apply(null,arguments)},r._Conv2DBackpropInput=function(){return(r._Conv2DBackpropInput=r.asm.A).apply(null,arguments)},r._Cos=function(){return(r._Cos=r.asm.B).apply(null,arguments)},r._Cosh=function(){return(r._Cosh=r.asm.C).apply(null,arguments)},r._CropAndResize=function(){return(r._CropAndResize=r.asm.D).apply(null,arguments)},r._Cumsum=function(){return(r._Cumsum=r.asm.E).apply(null,arguments)},r._DepthToSpace=function(){return(r._DepthToSpace=r.asm.F).apply(null,arguments)},r._DepthwiseConv2dNative=function(){return(r._DepthwiseConv2dNative=r.asm.G).apply(null,arguments)},r._Elu=function(){return(r._Elu=r.asm.H).apply(null,arguments)},r._Equal=function(){return(r._Equal=r.asm.I).apply(null,arguments)},r._Exp=function(){return(r._Exp=r.asm.J).apply(null,arguments)},r._FlipLeftRight=function(){return(r._FlipLeftRight=r.asm.K).apply(null,arguments)},r._Floor=function(){return(r._Floor=r.asm.L).apply(null,arguments)},r._FloorDiv=function(){return(r._FloorDiv=r.asm.M).apply(null,arguments)},r._FusedBatchNorm=function(){return(r._FusedBatchNorm=r.asm.N).apply(null,arguments)},r._FusedConv2D=function(){return(r._FusedConv2D=r.asm.O).apply(null,arguments)},r._FusedDepthwiseConv2D=function(){return(r._FusedDepthwiseConv2D=r.asm.P).apply(null,arguments)},r._Gather=function(){return(r._Gather=r.asm.Q).apply(null,arguments)},r._GatherNd=function(){return(r._GatherNd=r.asm.R).apply(null,arguments)},r._Greater=function(){return(r._Greater=r.asm.S).apply(null,arguments)},r._GreaterEqual=function(){return(r._GreaterEqual=r.asm.T).apply(null,arguments)},r._LeakyRelu=function(){return(r._LeakyRelu=r.asm.U).apply(null,arguments)},r._Less=function(){return(r._Less=r.asm.V).apply(null,arguments)},r._LessEqual=function(){return(r._LessEqual=r.asm.W).apply(null,arguments)},r._Log=function(){return(r._Log=r.asm.X).apply(null,arguments)},r._LogicalAnd=function(){return(r._LogicalAnd=r.asm.Y).apply(null,arguments)},r._Max=function(){return(r._Max=r.asm.Z).apply(null,arguments)},r._MaxPool=function(){return(r._MaxPool=r.asm._).apply(null,arguments)},r._Maximum=function(){return(r._Maximum=r.asm.$).apply(null,arguments)},r._Mean=function(){return(r._Mean=r.asm.aa).apply(null,arguments)},r._Min=function(){return(r._Min=r.asm.ba).apply(null,arguments)},r._Minimum=function(){return(r._Minimum=r.asm.ca).apply(null,arguments)},r._MirrorPad=function(){return(r._MirrorPad=r.asm.da).apply(null,arguments)},r._Multiply=function(){return(r._Multiply=r.asm.ea).apply(null,arguments)},r._Neg=function(){return(r._Neg=r.asm.fa).apply(null,arguments)},r._NonMaxSuppressionV3=function(){return(r._NonMaxSuppressionV3=r.asm.ga).apply(null,arguments)},r._NonMaxSuppressionV4=function(){return(r._NonMaxSuppressionV4=r.asm.ha).apply(null,arguments)},r._NonMaxSuppressionV5=function(){return(r._NonMaxSuppressionV5=r.asm.ia).apply(null,arguments)},r._NotEqual=function(){return(r._NotEqual=r.asm.ja).apply(null,arguments)},r._OneHot=function(){return(r._OneHot=r.asm.ka).apply(null,arguments)},r._PadV2=function(){return(r._PadV2=r.asm.la).apply(null,arguments)},r._Pow=function(){return(r._Pow=r.asm.ma).apply(null,arguments)},r._Prelu=function(){return(r._Prelu=r.asm.na).apply(null,arguments)},r._Prod=function(){return(r._Prod=r.asm.oa).apply(null,arguments)},r._RealDiv=function(){return(r._RealDiv=r.asm.pa).apply(null,arguments)},r._Relu=function(){return(r._Relu=r.asm.qa).apply(null,arguments)},r._Relu6=function(){return(r._Relu6=r.asm.ra).apply(null,arguments)},r._ResizeBilinear=function(){return(r._ResizeBilinear=r.asm.sa).apply(null,arguments)},r._Reverse=function(){return(r._Reverse=r.asm.ta).apply(null,arguments)},r._RotateWithOffset=function(){return(r._RotateWithOffset=r.asm.ua).apply(null,arguments)},r._Round=function(){return(r._Round=r.asm.va).apply(null,arguments)},r._Rsqrt=function(){return(r._Rsqrt=r.asm.wa).apply(null,arguments)},r._ScatterNd=function(){return(r._ScatterNd=r.asm.xa).apply(null,arguments)},r._SelectV2=function(){return(r._SelectV2=r.asm.ya).apply(null,arguments)},r._Sigmoid=function(){return(r._Sigmoid=r.asm.za).apply(null,arguments)},r._Sin=function(){return(r._Sin=r.asm.Aa).apply(null,arguments)},r._Softmax=function(){return(r._Softmax=r.asm.Ba).apply(null,arguments)},r._Sqrt=function(){return(r._Sqrt=r.asm.Ca).apply(null,arguments)},r._Square=function(){return(r._Square=r.asm.Da).apply(null,arguments)},r._SquaredDifference=function(){return(r._SquaredDifference=r.asm.Ea).apply(null,arguments)},r._Step=function(){return(r._Step=r.asm.Fa).apply(null,arguments)},r._StridedSlice=function(){return(r._StridedSlice=r.asm.Ga).apply(null,arguments)},r._Sub=function(){return(r._Sub=r.asm.Ha).apply(null,arguments)},r._Sum=function(){return(r._Sum=r.asm.Ia).apply(null,arguments)},r._Tan=function(){return(r._Tan=r.asm.Ja).apply(null,arguments)},r._Tanh=function(){return(r._Tanh=r.asm.Ka).apply(null,arguments)},r._Tile=function(){return(r._Tile=r.asm.La).apply(null,arguments)},r._TopK=function(){return(r._TopK=r.asm.Ma).apply(null,arguments)},r._Transform=function(){return(r._Transform=r.asm.Na).apply(null,arguments)},r._Transpose=function(){return(r._Transpose=r.asm.Oa).apply(null,arguments)},r.__FusedMatMul=function(){return(r.__FusedMatMul=r.asm.Pa).apply(null,arguments)},r._malloc=function(){return(r._malloc=r.asm.Qa).apply(null,arguments)},r._free=function(){return(r._free=r.asm.Ra).apply(null,arguments)},r.stackSave=function(){return(Ie=r.stackSave=r.asm.Ta).apply(null,arguments)}),Te=r.stackRestore=function(){return(Te=r.stackRestore=r.asm.Ua).apply(null,arguments)},Ne=r.stackAlloc=function(){return(Ne=r.stackAlloc=r.asm.Va).apply(null,arguments)};function _e(e){this.name="ExitStatus",this.message="Program terminated with exit("+e+")",this.status=e}function Ee(e){function n(){Se||(Se=!0,r.calledRun=!0,S||(q(),j(),t(r),r.onRuntimeInitialized&&r.onRuntimeInitialized(),K()))}e=e||i,Y>0||(H(),Y>0||(r.setStatus?(r.setStatus("Running..."),setTimeout((function(){setTimeout((function(){r.setStatus("")}),1),n()}),1)):n()))}if(r.cwrap=T,Q=function e(){Se||Ee(),Se||(Q=e)},r.run=Ee,r.preInit)for("function"==typeof r.preInit&&(r.preInit=[r.preInit]);r.preInit.length>0;)r.preInit.pop()();return Ee(),e.ready});"object"==typeof e&&"object"==typeof t?t.exports=a:"function"==typeof define&&define.amd?define([],(function(){return a})):"object"==typeof e&&(e.WasmBackendModule=a)}}),EPSILON_FLOAT32=1e-7,EPSILON_FLOAT16=1e-4,DataStorage=class{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}},KernelBackend=class{refCount(e){return notYetImplemented("refCount")}incRef(e){return notYetImplemented("incRef")}timerAvailable(){return!0}time(e){return notYetImplemented("time")}read(e){return notYetImplemented("read")}readSync(e){return notYetImplemented("readSync")}numDataIds(){return notYetImplemented("numDataIds")}disposeData(e,t){return notYetImplemented("disposeData")}write(e,t,n){return notYetImplemented("write")}move(e,t,n,a,r){return notYetImplemented("move")}memory(){return notYetImplemented("memory")}floatPrecision(){return notYetImplemented("floatPrecision")}epsilon(){return 32===this.floatPrecision()?EPSILON_FLOAT32:EPSILON_FLOAT16}dispose(){return notYetImplemented("dispose")}};function notYetImplemented(e){throw new Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function shuffle(e){let t=e.length,n=0;for(;t>0;)n=Math.random()*t|0,t--,swap(e,t,n)}function shuffleCombo(e,t){if(e.length!==t.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${e.length}Second array length was ${t.length}`);let n=e.length,a=0;for(;n>0;)a=Math.random()*n|0,n--,swap(e,n,a),swap(t,n,a)}function clamp(e,t,n){return Math.max(e,Math.min(t,n))}function nearestLargerEven(e){return e%2==0?e:e+1}function swap(e,t,n){const a=e[t];e[t]=e[n],e[n]=a}function sum(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}function randUniform(e,t){const n=Math.random();return t*n+(1-n)*e}function distSquared(e,t){let n=0;for(let a=0;a<e.length;a++){const r=Number(e[a])-Number(t[a]);n+=r*r}return n}function assert(e,t){if(!e)throw new Error("string"==typeof t?t:t())}function assertShapesMatch(e,t,n=""){assert(arraysEqual(e,t),(()=>n+` Shapes ${e} and ${t} must match`))}function assertNonNull(e){assert(null!=e,(()=>"The input to the tensor constructor must be a non-null value."))}function flatten(e,t=[],n=!1){if(null==t&&(t=[]),Array.isArray(e)||isTypedArray(e)&&!n)for(let a=0;a<e.length;++a)flatten(e[a],t,n);else t.push(e);return t}function sizeFromShape(e){if(0===e.length)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function isScalarShape(e){return 0===e.length}function arraysEqual(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function isInt(e){return e%1==0}function tanh(e){if(null!=Math.tanh)return Math.tanh(e);if(e===1/0)return 1;if(e===-1/0)return-1;{const t=Math.exp(2*e);return(t-1)/(t+1)}}function sizeToSquarishShape(e){const t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function createShuffledIndices(e){const t=new Uint32Array(e);for(let n=0;n<e;++n)t[n]=n;return shuffle(t),t}function rightPad(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function repeatedTry(e,t=(e=>0),n){return new Promise(((a,r)=>{let s=0;const o=()=>{if(e())return void a();s++;const i=t(s);null!=n&&s>=n?r():setTimeout(o,i)};o()}))}function inferFromImplicitShape(e,t){let n=1,a=-1;for(let t=0;t<e.length;++t)if(e[t]>=0)n*=e[t];else if(-1===e[t]){if(-1!==a)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${a} and dim ${t}`);a=t}else if(e[t]<0)throw Error(`Shapes can not be < 0. Found ${e[t]} at dim ${t}`);if(-1===a){if(t>0&&t!==n)throw Error(`Size(${t}) must match the product of shape ${e}`);return e}if(0===n)throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);if(t%n!=0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`);const r=e.slice();return r[a]=t/n,r}function parseAxisParam(e,t){const n=t.length;return assert((e=null==e?t.map(((e,t)=>t)):[].concat(e)).every((e=>e>=-n&&e<n)),(()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`)),assert(e.every((e=>isInt(e))),(()=>`All values in axis param must be integers but got axis ${e}`)),e.map((e=>e<0?n+e:e))}function squeezeShape(e,t){const n=[],a=[],r=null!=t&&Array.isArray(t)&&0===t.length,s=null==t||r?null:parseAxisParam(t,e).sort();let o=0;for(let t=0;t<e.length;++t){if(null!=s){if(s[o]===t&&1!==e[t])throw new Error(`Can't squeeze axis ${t} since its dim '${e[t]}' is not 1`);(null==s[o]||s[o]>t)&&1===e[t]&&(n.push(e[t]),a.push(t)),s[o]<=t&&o++}1!==e[t]&&(n.push(e[t]),a.push(t))}return{newShape:n,keptDims:a}}function getTypedArrayFromDType(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else{if("bool"!==e)throw new Error(`Unknown data type ${e}`);n=new Uint8Array(t)}return n}function getArrayFromDType(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else if("bool"===e)n=new Uint8Array(t);else{if("string"!==e)throw new Error(`Unknown data type ${e}`);n=new Array(t)}return n}function checkConversionForErrors(e,t){for(let n=0;n<e.length;n++){const a=e[n];if(isNaN(a)||!isFinite(a))throw Error(`A tensor of type ${t} being uploaded contains ${a}.`)}}function isValidDtype(e){return"bool"===e||"complex64"===e||"float32"===e||"int32"===e||"string"===e}function hasEncodingLoss(e,t){return"complex64"!==t&&(("float32"!==t||"complex64"===e)&&(("int32"!==t||"float32"===e||"complex64"===e)&&("bool"!==t||"bool"!==e)))}function isTypedArray(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}function bytesPerElement(e){if("float32"===e||"int32"===e)return 4;if("complex64"===e)return 8;if("bool"===e)return 1;throw new Error(`Unknown dtype ${e}`)}function bytesFromStringArray(e){if(null==e)return 0;let t=0;return e.forEach((e=>t+=e.length)),t}function isString(e){return"string"==typeof e||e instanceof String}function isBoolean(e){return"boolean"==typeof e}function isNumber(e){return"number"==typeof e}function inferDtype(e){return Array.isArray(e)?inferDtype(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray?"int32":isNumber(e)?"float32":isString(e)?"string":isBoolean(e)?"bool":"float32"}function isFunction(e){return!!(e&&e.constructor&&e.call&&e.apply)}function nearestDivisor(e,t){for(let n=t;n<e;++n)if(e%n==0)return n;return e}function computeStrides(e){const t=e.length;if(t<2)return[];const n=new Array(t-1);n[t-2]=e[t-1];for(let a=t-3;a>=0;--a)n[a]=n[a+1]*e[a+1];return n}function createNestedArray(e,t,n,a=!1){const r=new Array;if(1===t.length){const s=t[0]*(a?2:1);for(let t=0;t<s;t++)r[t]=n[e+t]}else{const s=t[0],o=t.slice(1),i=o.reduce(((e,t)=>e*t))*(a?2:1);for(let t=0;t<s;t++)r[t]=createNestedArray(e+t*i,o,n,a)}return r}function toNestedArray(e,t,n=!1){if(0===e.length)return t[0];const a=e.reduce(((e,t)=>e*t))*(n?2:1);if(0===a)return[];if(a!==t.length)throw new Error(`[${e}] does not match the input size ${t.length}${n?" for a complex tensor":""}.`);return createNestedArray(0,e,t,n)}function makeOnesTypedArray(e,t){const n=makeZerosTypedArray(e,t);for(let e=0;e<n.length;e++)n[e]=1;return n}function makeZerosTypedArray(e,t){if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t)return new Uint8Array(e);throw new Error(`Unknown data type ${t}`)}function makeZerosNestedTypedArray(e,t){const n=e.reduce(((e,t)=>e*t),1);if(null==t||"float32"===t)return toNestedArray(e,new Float32Array(n));if("int32"===t)return toNestedArray(e,new Int32Array(n));if("bool"===t)return toNestedArray(e,new Uint8Array(n));throw new Error(`Unknown data type ${t}`)}function assertNonNegativeIntegerDimensions(e){e.forEach((t=>{assert(Number.isInteger(t)&&t>=0,(()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`))}))}function locToIndex(e,t,n){if(0===t)return 0;if(1===t)return e[0];let a=e[e.length-1];for(let t=0;t<e.length-1;++t)a+=n[t]*e[t];return a}function indexToLoc(e,t,n){if(0===t)return[];if(1===t)return[e];const a=new Array(t);for(let t=0;t<a.length-1;++t)a[t]=Math.floor(e/n[t]),e-=a[t]*n[t];return a[a.length-1]=e,a}function isPromise(e){return e&&e.then&&"function"==typeof e.then}var TENSORFLOWJS_FLAGS_PREFIX="tfjsflags",Environment=class{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=getQueryParams,this.populateURLFlags()}setPlatform(e,t){null!=this.platform&&(env().getBool("IS_TEST")||env().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${t}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},null!=this.urlFlags[e]){const t=this.urlFlags[e];env().getBool("IS_TEST")||env().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${t}.`),this.set(e,t)}}async getAsync(e){return e in this.flags||(this.flags[e]=await this.evaluateFlag(e)),this.flags[e]}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(isPromise(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(null==this.flagRegistry[e])throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,null!=this.flagRegistry[e].setHook&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(null==this.flagRegistry[e])throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(void 0===this.global||void 0===this.global.location||void 0===this.global.location.search)return;const e=this.getQueryParams(this.global.location.search);if(TENSORFLOWJS_FLAGS_PREFIX in e){e[TENSORFLOWJS_FLAGS_PREFIX].split(",").forEach((e=>{const[t,n]=e.split(":");this.urlFlags[t]=parseValue(t,n)}))}}};function getQueryParams(e){const t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,((e,...n)=>(decodeParam(t,n[0],n[1]),n.join("=")))),t}function decodeParam(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}function parseValue(e,t){if("true"===(t=t.toLowerCase())||"false"===t)return"true"===t;if(""+ +t===t)return+t;throw new Error(`Could not parse value flag value ${t} for flag ${e}.`)}function env(){return ENV}var globalNameSpace,ENV=null;function setEnvironmentGlobal(e){ENV=e}function getGlobalNamespace(){if(null==globalNameSpace){let e;if("undefined"!=typeof window)e=window;else if("undefined"!=typeof global)e=global;else if("undefined"!=typeof process)e=process;else{if("undefined"==typeof self)throw new Error("Could not find a global object");e=self}globalNameSpace=e}return globalNameSpace}function getGlobalMap(){const e=getGlobalNamespace();return null==e._tfGlobals&&(e._tfGlobals=new Map),e._tfGlobals}function getGlobal(e,t){const n=getGlobalMap();if(n.has(e))return n.get(e);{const a=t();return n.set(e,a),n.get(e)}}var Abs="Abs",Acos="Acos",Acosh="Acosh",Add="Add",AddN="AddN",All="All",Any="Any",ArgMax="ArgMax",ArgMin="ArgMin",Asin="Asin",Asinh="Asinh",Atan="Atan",Atanh="Atanh",Atan2="Atan2",AvgPool="AvgPool",AvgPoolGrad="AvgPoolGrad",AvgPool3D="AvgPool3D",AvgPool3DGrad="AvgPool3DGrad",BatchMatMul="BatchMatMul",BatchToSpaceND="BatchToSpaceND",Bincount="Bincount",BroadcastTo="BroadcastTo",BroadcastArgs="BroadcastArgs",Cast="Cast",Ceil="Ceil",ClipByValue="ClipByValue",Complex="Complex",ComplexAbs="ComplexAbs",Concat="Concat",Conv2D="Conv2D",Conv2DBackpropFilter="Conv2DBackpropFilter",Conv2DBackpropInput="Conv2DBackpropInput",Conv3D="Conv3D",Conv3DBackpropFilterV2="Conv3DBackpropFilterV2",Conv3DBackpropInputV2="Conv3DBackpropInputV2",Cos="Cos",Cosh="Cosh",Cumsum="Cumsum",CropAndResize="CropAndResize",DenseBincount="DenseBincount",DepthToSpace="DepthToSpace",DepthwiseConv2dNative="DepthwiseConv2dNative",DepthwiseConv2dNativeBackpropFilter="DepthwiseConv2dNativeBackpropFilter",DepthwiseConv2dNativeBackpropInput="DepthwiseConv2dNativeBackpropInput",Diag="Diag",Dilation2D="Dilation2D",Dilation2DBackpropInput="Dilation2DBackpropInput",Dilation2DBackpropFilter="Dilation2DBackpropFilter",RealDiv="RealDiv",Einsum="Einsum",Elu="Elu",EluGrad="EluGrad",Erf="Erf",Equal="Equal",Exp="Exp",ExpandDims="ExpandDims",Expm1="Expm1",FFT="FFT",Fill="Fill",FlipLeftRight="FlipLeftRight",Floor="Floor",FloorDiv="FloorDiv",FusedBatchNorm="FusedBatchNorm",GatherV2="GatherV2",GatherNd="GatherNd",Greater="Greater",GreaterEqual="GreaterEqual",Identity="Identity",IFFT="IFFT",Imag="Imag",IsFinite="IsFinite",IsInf="IsInf",IsNan="IsNan",LeakyRelu="LeakyRelu",Less="Less",LessEqual="LessEqual",LinSpace="LinSpace",Log="Log",Log1p="Log1p",LogicalAnd="LogicalAnd",LogicalNot="LogicalNot",LogicalOr="LogicalOr",LogSoftmax="LogSoftmax",LRN="LRN",LRNGrad="LRNGrad",Max="Max",Maximum="Maximum",MaxPool="MaxPool",MaxPoolGrad="MaxPoolGrad",MaxPool3D="MaxPool3D",MaxPool3DGrad="MaxPool3DGrad",MaxPoolWithArgmax="MaxPoolWithArgmax",Mean="Mean",Min="Min",Minimum="Minimum",MirrorPad="MirrorPad",Mod="Mod",Multinomial="Multinomial",Multiply="Multiply",Neg="Neg",NotEqual="NotEqual",NonMaxSuppressionV3="NonMaxSuppressionV3",NonMaxSuppressionV4="NonMaxSuppressionV4",NonMaxSuppressionV5="NonMaxSuppressionV5",OnesLike="OnesLike",OneHot="OneHot",Pack="Pack",PadV2="PadV2",Pool="Pool",Pow="Pow",Prelu="Prelu",Prod="Prod",Range="Range",Real="Real",Reciprocal="Reciprocal",Relu="Relu",Reshape="Reshape",ResizeNearestNeighbor="ResizeNearestNeighbor",ResizeNearestNeighborGrad="ResizeNearestNeighborGrad",ResizeBilinear="ResizeBilinear",ResizeBilinearGrad="ResizeBilinearGrad",Relu6="Relu6",Reverse="Reverse",Round="Round",Rsqrt="Rsqrt",ScatterNd="ScatterNd",Select="Select",Selu="Selu",Slice="Slice",Sin="Sin",Sinh="Sinh",Sign="Sign",Sigmoid="Sigmoid",Softplus="Softplus",Sqrt="Sqrt",Sum="Sum",SpaceToBatchND="SpaceToBatchND",SplitV="SplitV",Softmax="Softmax",SparseFillEmptyRows="SparseFillEmptyRows",SparseReshape="SparseReshape",SparseSegmentMean="SparseSegmentMean",SparseSegmentSum="SparseSegmentSum",SparseToDense="SparseToDense",SquaredDifference="SquaredDifference",Square="Square",StridedSlice="StridedSlice",StringNGrams="StringNGrams",StringSplit="StringSplit",StringToHashBucketFast="StringToHashBucketFast",Sub="Sub",Tan="Tan",Tanh="Tanh",Tile="Tile",TopK="TopK",Transform="Transform",Transpose="Transpose",Unique="Unique",Unpack="Unpack",UnsortedSegmentSum="UnsortedSegmentSum",ZerosLike="ZerosLike",Step="Step",FromPixels="FromPixels",RotateWithOffset="RotateWithOffset",_FusedMatMul="_FusedMatMul",FusedConv2D="FusedConv2D",FusedDepthwiseConv2D="FusedDepthwiseConv2D";function warn(...e){env().getBool("IS_TEST")||env().getBool("PROD")||console.warn(...e)}function log2(...e){env().getBool("IS_TEST")||env().getBool("PROD")||console.log(...e)}var kernelRegistry=getGlobal("kernelRegistry",(()=>new Map)),gradRegistry=getGlobal("gradRegistry",(()=>new Map));function getKernel(e,t){const n=makeKey(e,t);return kernelRegistry.get(n)}function getGradient(e){return gradRegistry.get(e)}function getKernelsForBackend(e){const t=kernelRegistry.entries(),n=[];for(;;){const{done:a,value:r}=t.next();if(a)break;const[s,o]=r,[i]=s.split("_");i===e&&n.push(o)}return n}function registerKernel(e){const{kernelName:t,backendName:n}=e,a=makeKey(t,n);kernelRegistry.has(a)&&warn(`The kernel '${t}' for backend '${n}' is already registered`),kernelRegistry.set(a,e)}function registerGradient(e){const{kernelName:t}=e;gradRegistry.has(t)&&env().getBool("DEBUG")&&warn(`Overriding the gradient for '${t}'`),gradRegistry.set(t,e)}function unregisterKernel(e,t){const n=makeKey(e,t);if(!kernelRegistry.has(n))throw new Error(`The kernel '${e}' for backend '${t}' is not registered`);kernelRegistry.delete(n)}function unregisterGradient(e){if(!gradRegistry.has(e))throw new Error(`The gradient '${e}' for backend is not registered`);gradRegistry.delete(e)}function copyRegisteredKernels(e,t){getKernelsForBackend(e).forEach((e=>{registerKernel(Object.assign({},e,{backendName:t}))}))}function makeKey(e,t){return`${t}_${e}`}var util_exports={};__export2(util_exports,{arraysEqual:()=>arraysEqual,assert:()=>assert,assertNonNegativeIntegerDimensions:()=>assertNonNegativeIntegerDimensions,assertNonNull:()=>assertNonNull,assertShapesMatch:()=>assertShapesMatch,bytesFromStringArray:()=>bytesFromStringArray,bytesPerElement:()=>bytesPerElement,checkConversionForErrors:()=>checkConversionForErrors,clamp:()=>clamp,computeStrides:()=>computeStrides,createScalarValue:()=>createScalarValue,createShuffledIndices:()=>createShuffledIndices,decodeString:()=>decodeString,distSquared:()=>distSquared,encodeString:()=>encodeString,fetch:()=>fetch3,fingerPrint64:()=>fingerPrint64,flatten:()=>flatten,getArrayFromDType:()=>getArrayFromDType,getTypedArrayFromDType:()=>getTypedArrayFromDType,hasEncodingLoss:()=>hasEncodingLoss,hexToLong:()=>hexToLong,indexToLoc:()=>indexToLoc,inferDtype:()=>inferDtype,inferFromImplicitShape:()=>inferFromImplicitShape,isBoolean:()=>isBoolean,isFunction:()=>isFunction,isInt:()=>isInt,isNumber:()=>isNumber,isPromise:()=>isPromise,isScalarShape:()=>isScalarShape,isString:()=>isString,isTypedArray:()=>isTypedArray,isValidDtype:()=>isValidDtype,locToIndex:()=>locToIndex,makeOnesTypedArray:()=>makeOnesTypedArray,makeZerosNestedTypedArray:()=>makeZerosNestedTypedArray,makeZerosTypedArray:()=>makeZerosTypedArray,nearestDivisor:()=>nearestDivisor,nearestLargerEven:()=>nearestLargerEven,now:()=>now2,parseAxisParam:()=>parseAxisParam,randUniform:()=>randUniform,repeatedTry:()=>repeatedTry,rightPad:()=>rightPad,shuffle:()=>shuffle,shuffleCombo:()=>shuffleCombo,sizeFromShape:()=>sizeFromShape,sizeToSquarishShape:()=>sizeToSquarishShape,squeezeShape:()=>squeezeShape,sum:()=>sum,swap:()=>swap,tanh:()=>tanh,toNestedArray:()=>toNestedArray,toTypedArray:()=>toTypedArray});var LongExports=__toModule(require_long()),Long=LongExports.default||LongExports;function hexToLong(e){return Long.fromString(e,!0,16)}var k0=hexToLong("c3a5c85c97cb3127"),k1=hexToLong("b492b66fbe98f273"),k2=hexToLong("9ae16a3b2f90404f");function shiftMix(e){return e.xor(e.shru(47))}function fetch2(e,t,n){const a=e.slice(t,t+n);return Long.fromBytes(Array.from(a),!0,!0)}function fetch64(e,t){return fetch2(e,t,8)}function fetch32(e,t){return fetch2(e,t,4)}function rotate64(e,t){return 0===t?e:e.shru(t).or(e.shl(64-t))}function hashLen16(e,t,n=hexToLong("9ddfea08eb382d69")){let a=e.xor(t).mul(n);a=a.xor(a.shru(47));let r=t.xor(a).mul(n);return r=r.xor(r.shru(47)),r=r.mul(n),r}function weakHashLen32WithSeeds(e,t,n,a,r,s){r=r.add(e),s=rotate64(s.add(r).add(a),21);const o=r;return r=(r=r.add(t)).add(n),s=s.add(rotate64(r,44)),[r.add(a),s.add(o)]}function weakHashLen32WithSeedsStr(e,t,n,a){return weakHashLen32WithSeeds(fetch64(e,t),fetch64(e,t+8),fetch64(e,t+16),fetch64(e,t+24),n,a)}function hashLen0to16(e,t=e.length){if(t>=8){const n=k2.add(2*t),a=fetch64(e,0).add(k2),r=fetch64(e,t-8);return hashLen16(rotate64(r,37).mul(n).add(a),rotate64(a,25).add(r).mul(n),n)}if(t>=4){const n=k2.add(2*t);return hashLen16(fetch32(e,0).shl(3).add(t),fetch32(e,t-4),n)}if(t>0){const n=e[0]+(e[t>>1]<<8),a=t+(e[t-1]<<2);return shiftMix(k2.mul(n).xor(k0.mul(a))).mul(k2)}return k2}function hashLen17to32(e,t=e.length){const n=k2.add(2*t),a=fetch64(e,0).mul(k1),r=fetch64(e,8),s=fetch64(e,t-8).mul(n),o=fetch64(e,t-16).mul(k2);return hashLen16(rotate64(a.add(r),43).add(rotate64(s,30)).add(o),a.add(rotate64(r.add(k2),18)).add(s),n)}function hashLen33to64(e,t=e.length){const n=k2.add(2*t),a=fetch64(e,0).mul(k2),r=fetch64(e,8),s=fetch64(e,t-8).mul(n),o=fetch64(e,t-16).mul(k2),i=rotate64(a.add(r),43).add(rotate64(s,30)).add(o),l=hashLen16(i,a.add(rotate64(r.add(k2),18)).add(s),n),u=fetch64(e,16).mul(n),c=fetch64(e,24),d=i.add(fetch64(e,t-32)).mul(n),p=l.add(fetch64(e,t-24)).mul(n);return hashLen16(rotate64(u.add(c),43).add(rotate64(d,30)).add(p),u.add(rotate64(c.add(a),18)).add(d),n)}function fingerPrint64(e,t=e.length){const n=Long.fromNumber(81,!0);if(t<=32)return t<=16?hashLen0to16(e,t):hashLen17to32(e,t);if(t<=64)return hashLen33to64(e,t);let a=n,r=n.mul(k1).add(113),s=shiftMix(r.mul(k2).add(113)).mul(k2),o=[Long.UZERO,Long.UZERO],i=[Long.UZERO,Long.UZERO];a=a.mul(k2).add(fetch64(e,0));let l=0;const u=64*(t-1>>6),c=u+(t-1&63)-63;do{a=rotate64(a.add(r).add(o[0]).add(fetch64(e,l+8)),37).mul(k1),r=rotate64(r.add(o[1]).add(fetch64(e,l+48)),42).mul(k1),a=a.xor(i[1]),r=r.add(o[0]).add(fetch64(e,l+40)),s=rotate64(s.add(i[0]),33).mul(k1),o=weakHashLen32WithSeedsStr(e,l,o[1].mul(k1),a.add(i[0])),i=weakHashLen32WithSeedsStr(e,l+32,s.add(i[1]),r.add(fetch64(e,l+16))),[s,a]=[a,s],l+=64}while(l!==u);const d=k1.add(s.and(255).shl(1));return l=c,i[0]=i[0].add(t-1&63),o[0]=o[0].add(i[0]),i[0]=i[0].add(o[0]),a=rotate64(a.add(r).add(o[0]).add(fetch64(e,l+8)),37).mul(d),r=rotate64(r.add(o[1]).add(fetch64(e,l+48)),42).mul(d),a=a.xor(i[1].mul(9)),r=r.add(o[0].mul(9).add(fetch64(e,l+40))),s=rotate64(s.add(i[0]),33).mul(d),o=weakHashLen32WithSeedsStr(e,l,o[1].mul(d),a.add(i[0])),i=weakHashLen32WithSeedsStr(e,l+32,s.add(i[1]),r.add(fetch64(e,l+16))),[s,a]=[a,s],hashLen16(hashLen16(o[0],i[0],d).add(shiftMix(r).mul(k0)).add(s),hashLen16(o[1],i[1],d).add(a),d)}function createScalarValue(e,t){return"string"===t?encodeString(e):toTypedArray([e],t)}function noConversionNeeded(e,t){return e instanceof Float32Array&&"float32"===t||e instanceof Int32Array&&"int32"===t||e instanceof Uint8Array&&"bool"===t}function toTypedArray(e,t){if("string"===t)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=flatten(e)),env().getBool("DEBUG")&&checkConversionForErrors(e,t),noConversionNeeded(e,t))return e;if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t){const t=new Uint8Array(e.length);for(let n=0;n<t.length;++n)0!==Math.round(e[n])&&(t[n]=1);return t}throw new Error(`Unknown data type ${t}`)}function now2(){return env().platform.now()}function fetch3(e,t){return env().platform.fetch(e,t)}function encodeString(e,t="utf-8"){return t=t||"utf-8",env().platform.encode(e,t)}function decodeString(e,t="utf-8"){return t=t||"utf-8",env().platform.decode(e,t)}var Profiler=class{constructor(e,t){this.backendTimer=e,this.logger=t,null==t&&(this.logger=new Logger)}profileKernel(e,t,n){let a;const r=()=>{a=n()};let s;const o=now2();if(this.backendTimer.timerAvailable())s=this.backendTimer.time(r);else{r();for(const e of a)e.dataSync();s=Promise.resolve({kernelMs:now2()-o})}if(env().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let t=0;t<a.length;t++){const n=a[t];n.data().then((t=>{checkComputationForErrors(t,n.dtype,e)}))}return{kernelName:e,outputs:a,inputs:t,timeMs:s.then((e=>e.kernelMs)),extraInfo:s.then((e=>null!=e.getExtraProfileInfo?e.getExtraProfileInfo():""))}}logKernelProfile(e){const{kernelName:t,outputs:n,timeMs:a,inputs:r,extraInfo:s}=e;n.forEach((e=>{Promise.all([e.data(),a,s]).then((n=>{this.logger.logKernelProfile(t,e,n[0],n[1],r,n[2])}))}))}};function checkComputationForErrors(e,t,n){if("float32"!==t)return!1;for(let t=0;t<e.length;t++){const a=e[t];if(isNaN(a)||!isFinite(a))return console.warn(`Found ${a} in the result of '${n}'`),!0}return!1}var Logger=class{logKernelProfile(e,t,n,a,r,s){const o="number"==typeof a?rightPad(`${a}ms`,9):a.error,i=rightPad(e,25),l=t.rank,u=t.size,c=rightPad(t.shape.toString(),14);let d="";for(const e in r){const n=r[e];if(null!=n){const a=n.shape||t.shape,r=a.length;d+=`${e}: ${r}D ${r>0?a:""} `}}console.log(`%c${i}\t%c${o}\t%c${l}D ${c}\t%c${u}\t%c${d}\t%c${s}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}};function getFilteredNodesXToY(e,t,n){const a={},r={};for(let e=0;e<t.length;e++)a[t[e].id]=!0;for(let n=0;n<e.length;n++){const s=e[n],o=s.inputs;for(const e in o){const n=o[e];let i=!1;for(let e=0;e<t.length;e++)if(a[n.id]){s.outputs.forEach((e=>a[e.id]=!0)),i=!0,r[s.id]=!0;break}if(i)break}}const s={};s[n.id]=!0;const o={};for(let t=e.length-1;t>=0;t--){const n=e[t],a=n.inputs;for(let e=0;e<n.outputs.length;e++)if(s[n.outputs[e].id]){for(const e in a)s[a[e].id]=!0,o[n.id]=!0;break}}const i=[];for(let t=0;t<e.length;t++){const n=e[t];if(r[n.id]&&o[n.id]){const e={};for(const t in n.inputs){const r=n.inputs[t];a[r.id]&&(e[t]=r)}const t=Object.assign({},n);t.inputs=e,t.outputs=n.outputs,i.push(t)}}return i}function backpropagateGradients(e,t,n,a){for(let r=t.length-1;r>=0;r--){const s=t[r],o=[];if(s.outputs.forEach((t=>{const n=e[t.id];null!=n?o.push(n):o.push(null)})),null==s.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${s.kernelName}.`);const i=s.gradient(o);for(const t in s.inputs){if(!(t in i))throw new Error(`Cannot backprop through input ${t}. Available gradients found: ${Object.keys(i)}.`);const r=n((()=>i[t]()));if("float32"!==r.dtype)throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input ${t} must have 'float32' dtype, but has '${r.dtype}'`);const o=s.inputs[t];if(!arraysEqual(r.shape,o.shape))throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input '${t}' has shape '${r.shape}', which does not match the shape of the input '${o.shape}'`);if(null==e[o.id])e[o.id]=r;else{const t=e[o.id];e[o.id]=a(t,r),t.dispose()}}}}var FORMAT_LIMIT_NUM_VALS=20,FORMAT_NUM_FIRST_LAST_VALS=3,FORMAT_NUM_SIG_DIGITS=7;function tensorToString(e,t,n,a){const r=computeStrides(t),s=computeMaxSizePerColumn(e,t,n,r),o=t.length,i=subTensorToString(e,t,n,r,s),l=["Tensor"];return a&&(l.push(`  dtype: ${n}`),l.push(`  rank: ${o}`),l.push(`  shape: [${t}]`),l.push("  values:")),l.push(i.map((e=>"    "+e)).join("\n")),l.join("\n")}function computeMaxSizePerColumn(e,t,n,a){const r=sizeFromShape(t),s=a[a.length-1],o=new Array(s).fill(0),i=t.length,l="complex64"===n?createComplexTuples(e):e;if(i>1)for(let e=0;e<r/s;e++){const t=e*s;for(let e=0;e<s;e++)o[e]=Math.max(o[e],valToString(l[t+e],0,n).length)}return o}function valToString(e,t,n){let a;return a=Array.isArray(e)?`${parseFloat(e[0].toFixed(FORMAT_NUM_SIG_DIGITS))} + ${parseFloat(e[1].toFixed(FORMAT_NUM_SIG_DIGITS))}j`:isString(e)?`'${e}'`:"bool"===n?boolNumToString(e):parseFloat(e.toFixed(FORMAT_NUM_SIG_DIGITS)).toString(),rightPad(a,t)}function boolNumToString(e){return 0===e?"false":"true"}function subTensorToString(e,t,n,a,r,s=!0){const o="complex64"===n?2:1,i=t[0],l=t.length;if(0===l){if("complex64"===n){return[valToString(createComplexTuples(e)[0],0,n)]}return"bool"===n?[boolNumToString(e[0])]:[e[0].toString()]}if(1===l){if(i>FORMAT_LIMIT_NUM_VALS){const t=FORMAT_NUM_FIRST_LAST_VALS*o;let a=Array.from(e.slice(0,t)),s=Array.from(e.slice((i-FORMAT_NUM_FIRST_LAST_VALS)*o,i*o));return"complex64"===n&&(a=createComplexTuples(a),s=createComplexTuples(s)),["["+a.map(((e,t)=>valToString(e,r[t],n))).join(", ")+", ..., "+s.map(((e,t)=>valToString(e,r[i-FORMAT_NUM_FIRST_LAST_VALS+t],n))).join(", ")+"]"]}return["["+("complex64"===n?createComplexTuples(e):Array.from(e)).map(((e,t)=>valToString(e,r[t],n))).join(", ")+"]"]}const u=t.slice(1),c=a.slice(1),d=a[0]*o,p=[];if(i>FORMAT_LIMIT_NUM_VALS){for(let t=0;t<FORMAT_NUM_FIRST_LAST_VALS;t++){const a=t*d,s=a+d;p.push(...subTensorToString(e.slice(a,s),u,n,c,r,!1))}p.push("...");for(let t=i-FORMAT_NUM_FIRST_LAST_VALS;t<i;t++){const a=t*d,s=a+d;p.push(...subTensorToString(e.slice(a,s),u,n,c,r,t===i-1))}}else for(let t=0;t<i;t++){const a=t*d,s=a+d;p.push(...subTensorToString(e.slice(a,s),u,n,c,r,t===i-1))}const h=2===l?",":"";p[0]="["+p[0]+h;for(let e=1;e<p.length-1;e++)p[e]=" "+p[e]+h;let m=",\n";for(let e=2;e<l;e++)m+="\n";return p[p.length-1]=" "+p[p.length-1]+"]"+(s?"":m),p}function createComplexTuples(e){const t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}var TensorBuffer=class{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=sizeFromShape(e),null!=n){const e=n.length;assert(e===this.size,(()=>`Length of values '${e}' does not match the size inferred by the shape '${this.size}'.`))}if("complex64"===t)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||getArrayFromDType(t,this.size),this.strides=computeStrides(e)}set(e,...t){0===t.length&&(t=[0]),assert(t.length===this.rank,(()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`));const n=this.locToIndex(t);this.values[n]=e}get(...e){0===e.length&&(e=[0]);let t=0;for(const n of e){if(n<0||n>=this.shape[t]){const t=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(t)}t++}let n=e[e.length-1];for(let t=0;t<e.length-1;++t)n+=this.strides[t]*e[t];return this.values[n]}locToIndex(e){if(0===this.rank)return 0;if(1===this.rank)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(0===this.rank)return[];if(1===this.rank)return[e];const t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return trackerFn().makeTensor(this.values,this.shape,this.dtype)}},trackerFn=null,opHandler=null,deprecationWarningFn=null;function setTensorTracker(e){trackerFn=e}function setOpHandler(e){opHandler=e}function setDeprecationWarningFn(e){deprecationWarningFn=e}var Tensor=class{constructor(e,t,n,a){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=sizeFromShape(e),this.strides=computeStrides(e),this.dataId=n,this.id=a,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return opHandler.buffer(this.shape,this.dtype,e)}bufferSync(){return opHandler.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return toNestedArray(this.shape,e,"complex64"===this.dtype)}arraySync(){return toNestedArray(this.shape,this.dataSync(),"complex64"===this.dtype)}async data(){this.throwIfDisposed();const e=trackerFn().read(this.dataId);if("string"===this.dtype){const t=await e;try{return t.map((e=>decodeString(e)))}catch(e){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataSync(){this.throwIfDisposed();const e=trackerFn().readSync(this.dataId);if("string"===this.dtype)try{return e.map((e=>decodeString(e)))}catch(e){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await trackerFn().read(this.dataId);return"string"===this.dtype?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(trackerFn().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return opHandler.print(this,e)}clone(){return this.throwIfDisposed(),opHandler.clone(this)}toString(e=!1){return tensorToString(this.dataSync(),this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),opHandler.cast(this,e)}variable(e=!0,t,n){return this.throwIfDisposed(),trackerFn().makeVariable(this,e,t,n)}};function getGlobalTensorClass(){return getGlobal("Tensor",(()=>Tensor))}Object.defineProperty(Tensor,Symbol.hasInstance,{value:e=>!!e&&null!=e.data&&null!=e.dataSync&&null!=e.throwIfDisposed}),getGlobalTensorClass();var Variable=class extends Tensor{constructor(e,t,n,a){super(e.shape,e.dtype,e.dataId,a),this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!arraysEqual(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);trackerFn().disposeTensor(this),this.dataId=e.dataId,trackerFn().incRef(this,null)}dispose(){trackerFn().disposeVariable(this),this.isDisposedInternal=!0}};Object.defineProperty(Variable,Symbol.hasInstance,{value:e=>e instanceof Tensor&&null!=e.assign&&e.assign instanceof Function});var Rank,UpcastInt32AndMap,UpcastBoolAndMap,UpcastFloat32AndMap,UpcastComplex64AndMap,tensor_util_exports={};__export2(tensor_util_exports,{assertTypesMatch:()=>assertTypesMatch,getTensorsInContainer:()=>getTensorsInContainer,isTensorInList:()=>isTensorInList,makeTypesMatch:()=>makeTypesMatch}),function(e){e.R0="R0",e.R1="R1",e.R2="R2",e.R3="R3",e.R4="R4",e.R5="R5",e.R6="R6"}(Rank||(Rank={})),function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"}(UpcastInt32AndMap||(UpcastInt32AndMap={})),function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"}(UpcastBoolAndMap||(UpcastBoolAndMap={})),function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"}(UpcastFloat32AndMap||(UpcastFloat32AndMap={})),function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"}(UpcastComplex64AndMap||(UpcastComplex64AndMap={}));var upcastTypeMap={float32:UpcastFloat32AndMap,int32:UpcastInt32AndMap,bool:UpcastBoolAndMap,complex64:UpcastComplex64AndMap};function upcastType(e,t){if("string"===e||"string"===t){if("string"===e&&"string"===t)return"string";throw new Error(`Can not upcast ${e} with ${t}`)}return upcastTypeMap[e][t]}function sumOutType(e){return upcastType(e,"int32")}function makeTypesMatch(e,t){if(e.dtype===t.dtype)return[e,t];const n=upcastType(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function assertTypesMatch(e,t){assert(e.dtype===t.dtype,(()=>`The dtypes of the first(${e.dtype}) and second(${t.dtype}) input must match`))}function isTensorInList(e,t){return t.some((t=>t.id===e.id))}function getTensorsInContainer(e){const t=[];return walkTensorContainer(e,t,new Set),t}function walkTensorContainer(e,t,n){if(null==e)return;if(e instanceof Tensor)return void t.push(e);if(!isIterable(e))return;const a=e;for(const e in a){const r=a[e];n.has(r)||(n.add(r),walkTensorContainer(r,t,n))}}function isIterable(e){return Array.isArray(e)||"object"==typeof e}function isRegisteredKernelInvocation(e){return null!=e.kernelName}var EngineState=class{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map((e=>e.name))))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}},_Engine=class{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new EngineState}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then((()=>{}));if(null!=this.backendInstance)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t];if(await this.initializeBackend(n).success)return void await this.setBackend(n)}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry)){if(!(e in this.registryFactory))return null;{const{asyncInit:t}=this.initializeBackend(e);if(t)return null}}return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,n=1){return e in this.registryFactory?(warn(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:n},!0)}async setBackend(e){if(null==this.registryFactory[e])throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,null==this.registry[e]){this.backendInstance=null;const{success:t,asyncInit:n}=this.initializeBackend(e);if(!(n?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new Profiler(this.backendInstance),!0}setupRegisteredKernels(){getKernelsForBackend(this.backendName).forEach((e=>{null!=e.setupFunc&&e.setupFunc(this.backendInstance)}))}disposeRegisteredKernels(e){getKernelsForBackend(e).forEach((t=>{null!=t.disposeFunc&&t.disposeFunc(this.registry[e])}))}initializeBackend(e){const t=this.registryFactory[e];if(null==t)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const n=t.factory();if(!n||n instanceof KernelBackend||"function"!=typeof n.then)return this.registry[e]=n,{success:!0,asyncInit:!1};{const t=++this.pendingBackendInitId,a=n.then((n=>!(t<this.pendingBackendInitId)&&(this.registry[e]=n,this.pendingBackendInit=null,!0))).catch((n=>(t<this.pendingBackendInitId||(this.pendingBackendInit=null,warn(`Initialization of backend ${e} failed`),warn(n.stack||n.message)),!1)));return this.pendingBackendInit=a,{success:a,asyncInit:!0}}}catch(t){return warn(`Initialization of backend ${e} failed`),warn(t.stack||t.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort(((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority))}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t],{success:a,asyncInit:r}=this.initializeBackend(n);if(r||a)return{name:n,asyncInit:r}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const n=this.state.tensorInfo.get(t),a=n.backend,r=this.readSync(t),s=a.refCount(t);a.disposeData(t,!0),n.backend=e,e.move(t,r,n.shape,n.dtype,s),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let n,a=null;if(null==t){if("function"!=typeof e)throw new Error("Please provide a function to tidy()");t=e}else{if("string"!=typeof e&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof t)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");a=e}return this.scopedRun((()=>this.startScope(a)),(()=>this.endScope(n)),(()=>(n=t(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n)))}scopedRun(e,t,n){e();try{const e=n();return t(),e}catch(e){throw t(),e}}nextTensorId(){return _Engine.nextTensorId++}nextVariableId(){return _Engine.nextVariableId++}clone(e){const t=ENGINE.runKernel(Identity,{x:e}),n={x:e};return this.addTapeNode(this.state.activeScope.name,n,[t],(e=>({x:()=>{const t={x:e},n={dtype:"float32"};return ENGINE.runKernel(Cast,t,n)}})),[],{}),t}runKernel(e,t,n){null==this.backendName&&this.backend;if(!(null!=getKernel(e,this.backendName)))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,n){const a=this.backend.numDataIds();let r=0;n.forEach((e=>{r+="complex64"===e.dtype?3:1}));const s=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],o=a-t-r-s;if(o>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${o} data ids) after running '${e}'`)}runKernelFunc(e){let t,n=[];const a=this.isTapeOn(),r=this.state.numBytes,s=this.state.numTensors;let o,i;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0),null==this.backendName&&this.backend;const l=isRegisteredKernelInvocation(e)?e.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(isRegisteredKernelInvocation(e)){const{kernelName:t,inputs:r,attrs:s}=e;null==this.backendName&&this.backend;const l=getKernel(t,this.backendName);assert(null!=l,(()=>`Cannot find registered kernel '${t}' for backend '${this.backendName}'`)),o=()=>{const e=this.backend.numDataIds();i=l.kernelFunc({inputs:r,attrs:s,backend:this.backend});const o=Array.isArray(i)?i:[i];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(t,e,o);const u=o.map((e=>{if(null!=e.rank)return e;const{dataId:t,shape:n,dtype:a}=e;return this.makeTensorFromDataId(t,n,a)}));if(a){const e=this.getTensorsForGradient(t,r,u);n=this.saveTensorsForBackwardMode(e)}return u}}else{const{forwardFunc:t}=e,r=e=>{a&&(n=e.map((e=>this.keep(this.clone(e)))))};o=()=>{const e=this.backend.numDataIds();i=this.tidy((()=>t(this.backend,r)));const n=Array.isArray(i)?i:[i];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(l,e,n),n}}const{inputs:u,attrs:c}=e,d=isRegisteredKernelInvocation(e)?null:e.backwardsFunc;let p;return this.scopedRun((()=>this.state.kernelDepth++),(()=>this.state.kernelDepth--),(()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(p=this.profiler.profileKernel(l,u,(()=>o())),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(p),t=p.outputs):t=o()})),a&&this.addTapeNode(l,u,t,d,n,c),this.state.profiling&&this.state.activeProfile.kernels.push({name:l,bytesAdded:this.state.numBytes-r,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-s,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(u).map((e=>null!=u[e]?u[e].shape:null)),outputShapes:t.map((e=>e.shape)),kernelTimeMs:p.timeMs,extraInfo:p.extraInfo}),Array.isArray(i)?t:t[0]}saveTensorsForBackwardMode(e){return e.map((e=>this.keep(this.clone(e))))}getTensorsForGradient(e,t,n){const a=getGradient(e);if(null!=a){const e=a.inputsToSave||[],r=a.outputsToSave||[];let s;a.saveAllInputs?(assert(Array.isArray(t),(()=>"saveAllInputs is true, expected inputs to be an array.")),s=Object.keys(t).map((e=>t[e]))):s=e.map((e=>t[e]));const o=n.filter(((e,t)=>r[t]));return s.concat(o)}return[]}makeTensor(e,t,n,a){if(null==e)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",a=a||this.backend;let r=e;"string"===n&&isString(e[0])&&(r=e.map((e=>encodeString(e))));const s=a.write(r,t,n),o=new Tensor(t,n,s,this.nextTensorId());if(this.trackTensor(o,a),"string"===n){const e=this.state.tensorInfo.get(s),t=bytesFromStringArray(r);this.state.numBytes+=t-e.bytes,e.bytes=t}return o}makeTensorFromDataId(e,t,n,a){const r=new Tensor(t,n=n||"float32",e,this.nextTensorId());return this.trackTensor(r,a),r}makeVariable(e,t=!0,n,a){n=n||this.nextVariableId().toString(),null!=a&&a!==e.dtype&&(e=e.cast(a));const r=new Variable(e,t,n,this.nextTensorId());if(null!=this.state.registeredVariables[r.name])throw new Error(`Variable with name ${r.name} was already registered`);return this.state.registeredVariables[r.name]=r,this.incRef(r,this.backend),r}trackTensor(e,t){this.state.numTensors++,"string"===e.dtype&&this.state.numStringTensors++;let n=0;"complex64"!==e.dtype&&"string"!==e.dtype&&(n=e.size*bytesPerElement(e.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:n})),e instanceof Variable||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,"string"===e.dtype&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),"complex64"!==e.dtype&&"string"!==e.dtype){const t=e.size*bytesPerElement(e.dtype);this.state.numBytes-=t}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),null!=this.state.registeredVariables[e.name]&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,null==e.reasons&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map((e=>e.totalBytesSnapshot))),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-n;for(const e of this.state.activeProfile.kernels)e.kernelTimeMs=await e.kernelTimeMs,e.extraInfo=await e.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(e,t,n,a,r,s){const o={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:n,saved:r},i=getGradient(e);null!=i&&(a=i.gradFunc),null!=a&&(o.gradient=e=>(e=e.map(((e,t)=>{if(null==e){const e=n[t],a=makeZerosTypedArray(e.size,e.dtype);return this.makeTensor(a,e.shape,e.dtype)}return e})),a(e.length>1?e:e[0],r,s))),this.state.activeTape.push(o)}keep(e){return e.kept=!0,e}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=getTensorsInContainer(e),n=new Set(t.map((e=>e.id)));for(let e=0;e<this.state.activeScope.track.length;e++){const t=this.state.activeScope.track[e];t.kept||n.has(t.id)||t.dispose()}const a=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach((e=>{e.kept||e.scopeId!==a.id||this.track(e)}))}gradients(e,t,n,a=!1){if(assert(t.length>0,(()=>"gradients() received an empty list of xs.")),null!=n&&"float32"!==n.dtype)throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);const r=this.scopedRun((()=>this.startTape()),(()=>this.endTape()),(()=>this.tidy("forward",e)));assert(r instanceof Tensor,(()=>"The result y returned by f() must be a tensor."));const s=getFilteredNodesXToY(this.state.activeTape,t,r);if(!a&&0===s.length&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",(()=>{const e={};e[r.id]=null==n?ones(r.shape):n,backpropagateGradients(e,s,(e=>this.tidy(e)),add);const a=t.map((t=>e[t.id]));return 0===this.state.gradientDepth&&(this.state.activeTape.forEach((e=>{for(const t of e.saved)t.dispose()})),this.state.activeTape=null),{value:r,grads:a}}))}customGrad(e){return assert(isFunction(e),(()=>"The f passed in customGrad(f) must be a function.")),(...t)=>{let n;assert(t.every((e=>e instanceof Tensor)),(()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors"));const a={};t.forEach(((e,t)=>{a[t]=e}));return this.runKernelFunc({forwardFunc:(a,r)=>(n=e(...t,r),assert(n.value instanceof Tensor,(()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor")),assert(isFunction(n.gradFunc),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.")),n.value),backwardsFunc:(e,a)=>{const r=n.gradFunc(e,a),s=Array.isArray(r)?r:[r];assert(s.length===t.length,(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).")),assert(s.every((e=>e instanceof Tensor)),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."));const o={};return s.forEach(((e,t)=>{o[t]=()=>e})),o},inputs:a})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}async time(e){const t=now2(),n=await this.backend.time(e);return n.wallMs=now2()-t,n}track(e){return null!=this.state.activeScope&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new EngineState;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}},Engine=_Engine;function ones(e){const t=makeOnesTypedArray(sizeFromShape(e),"float32");return ENGINE.makeTensor(t,e,"float32")}function getOrMakeEngine(){const e=getGlobalNamespace();if(null==e._tfengine){const t=new Environment(e);e._tfengine=new Engine(t)}return setEnvironmentGlobal(e._tfengine.ENV),setTensorTracker((()=>e._tfengine)),e._tfengine}Engine.nextTensorId=0,Engine.nextVariableId=0;var ENGINE=getOrMakeEngine();function add(e,t){const n={a:e,b:t};return ENGINE.runKernel(Add,n)}var isMobileMockValue,device_util_exports={};function _isNavigatorDefined(){return"undefined"!=typeof navigator&&null!=navigator}function mockIsMobile(e){isMobileMockValue=e}function isMobile(e){if(void 0!==isMobileMockValue)return isMobileMockValue;if(e||_isNavigatorDefined()){if(e||(e=navigator),"ReactNative"===e.product)return!0;const t=e.userAgent||e.vendor||("undefined"!=typeof window?window.opera:"");if(!t){const t=e;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function isBrowser(){return"undefined"!=typeof window&&null!=window.document||"undefined"!=typeof WorkerGlobalScope}__export2(device_util_exports,{isBrowser:()=>isBrowser,isMobile:()=>isMobile,mockIsMobile:()=>mockIsMobile});var ENV2=env();function inferShape(e,t){let n=e;if(isTypedArray(e))return"string"===t?[]:[e.length];if(!Array.isArray(e))return[];const a=[];for(;Array.isArray(n)||isTypedArray(n)&&"string"!==t;)a.push(n.length),n=n[0];return Array.isArray(e)&&env().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&deepAssertShapeConsistency(e,a,[]),a}function deepAssertShapeConsistency(e,t,n){if(n=n||[],!Array.isArray(e)&&!isTypedArray(e))return void assert(0===t.length,(()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`));assert(t.length>0,(()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${e.length} elements`)),assert(e.length===t[0],(()=>`Element arr[${n.join("][")}] should have ${t[0]} elements, but has ${e.length} elements`));const a=t.slice(1);for(let t=0;t<e.length;++t)deepAssertShapeConsistency(e[t],a,n.concat(t))}function assertDtype(e,t,n,a){if("string_or_numeric"!==e){if(null==e)throw new Error("Expected dtype cannot be null.");if("numeric"!==e&&e!==t||"numeric"===e&&"string"===t)throw new Error(`Argument '${n}' passed to '${a}' must be ${e} tensor, but got ${t} tensor`)}}function convertToTensor(e,t,n,a="numeric"){if(e instanceof Tensor)return assertDtype(a,e.dtype,t,n),e;let r=inferDtype(e);if("string"!==r&&["bool","int32","float32"].indexOf(a)>=0&&(r=a),assertDtype(a,r,t,n),null==e||!isTypedArray(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e){const a=null==e?"null":e.constructor.name;throw new Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${a}'`)}const s=inferShape(e,r);isTypedArray(e)||Array.isArray(e)||(e=[e]);const o="string"!==r?toTypedArray(e,r):flatten(e,[],!0);return ENGINE.makeTensor(o,s,r)}function convertToTensorArray(e,t,n,a="numeric"){if(!Array.isArray(e))throw new Error(`Argument ${t} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return e.map(((e,r)=>convertToTensor(e,`${t}[${r}]`,n,a)))}ENV2.registerFlag("DEBUG",(()=>!1),(e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")})),ENV2.registerFlag("IS_BROWSER",(()=>isBrowser())),ENV2.registerFlag("IS_NODE",(()=>"undefined"!=typeof process&&void 0!==process.versions&&void 0!==process.versions.node)),ENV2.registerFlag("IS_CHROME",(()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor))),ENV2.registerFlag("PROD",(()=>!1)),ENV2.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",(()=>ENV2.getBool("DEBUG"))),ENV2.registerFlag("DEPRECATION_WARNINGS_ENABLED",(()=>!0)),ENV2.registerFlag("IS_TEST",(()=>!1)),ENV2.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",(()=>!0)),ENV2.registerFlag("WRAP_TO_IMAGEBITMAP",(()=>!1));var OP_SCOPE_SUFFIX="__op";function op(e){const t=Object.keys(e);if(1!==t.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let n=t[0];const a=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+=OP_SCOPE_SUFFIX;const r=(...e)=>{ENGINE.startScope(n);try{const t=a(...e);return isPromise(t)&&console.error("Cannot return a Promise inside of tidy."),ENGINE.endScope(t),t}catch(e){throw ENGINE.endScope(null),e}};return Object.defineProperty(r,"name",{value:n,configurable:!0}),r}function complex_(e,t){const n=convertToTensor(e,"real","complex"),a=convertToTensor(t,"imag","complex");assertShapesMatch(n.shape,a.shape,`real and imag shapes, ${n.shape} and ${a.shape}, must match in call to tf.complex().`);const r={real:n,imag:a};return ENGINE.runKernel(Complex,r)}var complex=op({complex_:complex_});function makeTensor(e,t,n,a){if(null==a&&(a=inferDtype(e)),"complex64"===a)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!isTypedArray(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=t){assertNonNegativeIntegerDimensions(t);const e=sizeFromShape(t),a=sizeFromShape(n);assert(e===a,(()=>`Based on the provided shape, [${t}], the tensor should have ${e} values but has ${a}`));for(let e=0;e<n.length;++e){const a=n[e],r=e!==n.length-1||a!==sizeFromShape(t.slice(e));assert(n[e]===t[e]||!r,(()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `))}}return isTypedArray(e)||Array.isArray(e)||(e=[e]),t=t||n,e="string"!==a?toTypedArray(e,a):flatten(e,[],!0),ENGINE.makeTensor(e,t,a)}function tensor(e,t,n){return makeTensor(e,t,inferShape(e,n),n)}var DTYPE_VALUE_SIZE_MAP={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8},NUM_BYTES_STRING_LENGTH=4;async function encodeWeights(e,t){const n=[],a=[],r=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);for(let s=0;s<r.length;++s){const o=r[s],i=Array.isArray(e)?e[s].tensor:e[o];if("float32"!==i.dtype&&"int32"!==i.dtype&&"bool"!==i.dtype&&"string"!==i.dtype&&"complex64"!==i.dtype)throw new Error(`Unsupported dtype in weight '${o}': ${i.dtype}`);const l={name:o,shape:i.shape,dtype:i.dtype};if("string"===i.dtype){const e=new Promise((async e=>{const t=await i.bytes(),n=t.reduce(((e,t)=>e+t.length),0)+NUM_BYTES_STRING_LENGTH*t.length,a=new Uint8Array(n);let r=0;for(let e=0;e<t.length;e++){const n=t[e],s=new Uint8Array(new Uint32Array([n.length]).buffer);a.set(s,r),r+=NUM_BYTES_STRING_LENGTH,a.set(n,r),r+=n.length}e(a)}));a.push(e)}else a.push(i.data());null!=t&&(l.group=t),n.push(l)}return{data:concatenateTypedArrays(await Promise.all(a)),specs:n}}function decodeWeights(e,t){const n={};let a,r=0;for(const s of t){const t=s.name,o=s.dtype,i=s.shape,l=sizeFromShape(i);let u;if("quantization"in s){const n=s.quantization;if("uint8"===n.dtype||"uint16"===n.dtype){if(!("min"in n)||!("scale"in n))throw new Error(`Weight ${s.name} with quantization ${n.dtype} doesn't have corresponding metadata min and scale.`)}else{if("float16"!==n.dtype)throw new Error(`Weight ${s.name} has unknown quantization dtype ${n.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);if("float32"!==o)throw new Error(`Weight ${s.name} is quantized with ${n.dtype} which only supports weights of type float32 not ${o}.`)}const i=DTYPE_VALUE_SIZE_MAP[n.dtype],c=e.slice(r,r+l*i),d="uint8"===n.dtype?new Uint8Array(c):new Uint16Array(c);if("float32"===o)if("uint8"===n.dtype||"uint16"===n.dtype){u=new Float32Array(d.length);for(let e=0;e<d.length;e++){const t=d[e];u[e]=t*n.scale+n.min}}else{if("float16"!==n.dtype)throw new Error(`Unsupported quantization type ${n.dtype} for weight type float32.`);void 0===a&&(a=getFloat16Decoder()),u=a(d)}else{if("int32"!==o)throw new Error(`Unsupported dtype in weight '${t}': ${o}`);if("uint8"!==n.dtype&&"uint16"!==n.dtype)throw new Error(`Unsupported quantization type ${n.dtype} for weight type int32.`);u=new Int32Array(d.length);for(let e=0;e<d.length;e++){const t=d[e];u[e]=Math.round(t*n.scale+n.min)}}r+=l*i}else if("string"===o){const t=sizeFromShape(s.shape);u=[];for(let n=0;n<t;n++){const t=new Uint32Array(e.slice(r,r+NUM_BYTES_STRING_LENGTH))[0];r+=NUM_BYTES_STRING_LENGTH;const n=new Uint8Array(e.slice(r,r+t));u.push(n),r+=t}}else{const a=DTYPE_VALUE_SIZE_MAP[o],s=e.slice(r,r+l*a);if("float32"===o)u=new Float32Array(s);else if("int32"===o)u=new Int32Array(s);else if("bool"===o)u=new Uint8Array(s);else{if("complex64"!==o)throw new Error(`Unsupported dtype in weight '${t}': ${o}`);{u=new Float32Array(s);const e=new Float32Array(u.length/2),a=new Float32Array(u.length/2);for(let t=0;t<e.length;t++)e[t]=u[2*t],a[t]=u[2*t+1];const r=tensor(e,i,"float32"),o=tensor(a,i,"float32");n[t]=complex(r,o),r.dispose(),o.dispose()}}r+=l*a}"complex64"!==o&&(n[t]=tensor(u,i,o))}return n}function concatenateTypedArrays(e){if(null===e)throw new Error(`Invalid input value: ${JSON.stringify(e)}`);let t=0;const n=[];e.forEach((e=>{if(t+=e.byteLength,n.push(e.byteLength===e.buffer.byteLength?e:new e.constructor(e)),!(e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${e.constructor.name}`)}));const a=new Uint8Array(t);let r=0;return n.forEach((e=>{a.set(new Uint8Array(e.buffer),r),r+=e.byteLength})),a.buffer}var useNodeBuffer="undefined"!=typeof Buffer&&("undefined"==typeof Blob||"undefined"==typeof atob||"undefined"==typeof btoa);function stringByteLength(e){return useNodeBuffer?Buffer.byteLength(e):new Blob([e]).size}function arrayBufferToBase64String(e){if(useNodeBuffer)return Buffer.from(e).toString("base64");const t=new Uint8Array(e);let n="";for(let e=0,a=t.length;e<a;e++)n+=String.fromCharCode(t[e]);return btoa(n)}function base64StringToArrayBuffer(e){if(useNodeBuffer){const t=Buffer.from(e,"base64");return t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength)}const t=atob(e),n=new Uint8Array(t.length);for(let e=0;e<t.length;++e)n.set([t.charCodeAt(e)],e);return n.buffer}function concatenateArrayBuffers(e){if(1===e.length)return e[0];let t=0;e.forEach((e=>{t+=e.byteLength}));const n=new Uint8Array(t);let a=0;return e.forEach((e=>{n.set(new Uint8Array(e),a),a+=e.byteLength})),n.buffer}function basename(e){for(e=e.trim();e.endsWith("/");)e=e.slice(0,e.length-1);const t=e.split("/");return t[t.length-1]}function getModelJSONForModelArtifacts(e,t){const n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};return null!=e.signature&&(n.signature=e.signature),null!=e.userDefinedMetadata&&(n.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(n.modelInitializer=e.modelInitializer),null!=e.trainingConfig&&(n.trainingConfig=e.trainingConfig),n}async function getModelArtifactsForJSON(e,t){const n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(null!=e.trainingConfig&&(n.trainingConfig=e.trainingConfig),null!=e.weightsManifest){const[a,r]=await t(e.weightsManifest);n.weightSpecs=a,n.weightData=r}return null!=e.signature&&(n.signature=e.signature),null!=e.userDefinedMetadata&&(n.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(n.modelInitializer=e.modelInitializer),n}function getModelArtifactsInfoForJSON(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==e.modelTopology?0:stringByteLength(JSON.stringify(e.modelTopology)),weightSpecsBytes:null==e.weightSpecs?0:stringByteLength(JSON.stringify(e.weightSpecs)),weightDataBytes:null==e.weightData?0:e.weightData.byteLength}}function computeFloat16MantisaTable(){const e=e=>{let t=e<<13,n=0;for(;0==(8388608&t);)n-=8388608,t<<=1;return t&=-8388609,n+=947912704,t|n},t=new Uint32Array(2048);t[0]=0;for(let n=1;n<1024;n++)t[n]=e(n);for(let e=1024;e<2048;e++)t[e]=939524096+(e-1024<<13);return t}function computeFloat16ExponentTable(){const e=new Uint32Array(64);e[0]=0,e[31]=1199570944,e[32]=2147483648,e[63]=3347054592;for(let t=1;t<31;t++)e[t]=t<<23;for(let t=33;t<63;t++)e[t]=2147483648+(t-32<<23);return e}function computeFloat16OffsetTable(){const e=new Uint32Array(64);for(let t=0;t<64;t++)e[t]=1024;return e[0]=e[32]=0,e}function getFloat16Decoder(){const e=computeFloat16MantisaTable(),t=computeFloat16ExponentTable(),n=computeFloat16OffsetTable();return a=>{const r=new ArrayBuffer(4*a.length),s=new Uint32Array(r);for(let r=0;r<a.length;r++){const o=a[r],i=e[n[o>>10]+(1023&o)]+t[o>>10];s[r]=i}return new Float32Array(r)}}var IORouterRegistry=class{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==IORouterRegistry.instance&&(IORouterRegistry.instance=new IORouterRegistry),IORouterRegistry.instance}static registerSaveRouter(e){IORouterRegistry.getInstance().saveRouters.push(e)}static registerLoadRouter(e){IORouterRegistry.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return IORouterRegistry.getHandlers(e,"save")}static getLoadHandlers(e,t){return IORouterRegistry.getHandlers(e,"load",t)}static getHandlers(e,t,n){const a=[];return("load"===t?IORouterRegistry.getInstance().loadRouters:IORouterRegistry.getInstance().saveRouters).forEach((t=>{const r=t(e,n);null!==r&&a.push(r)})),a}},registerSaveRouter=e=>IORouterRegistry.registerSaveRouter(e),registerLoadRouter=e=>IORouterRegistry.registerLoadRouter(e),getSaveHandlers=e=>IORouterRegistry.getSaveHandlers(e),getLoadHandlers=(e,t)=>IORouterRegistry.getLoadHandlers(e,t),DATABASE_NAME="tensorflowjs",DATABASE_VERSION=1,MODEL_STORE_NAME="models_store",INFO_STORE_NAME="model_info_store";function getIndexedDBFactory(){if(!env().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const e="undefined"==typeof window?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(null==t)throw new Error("The current browser does not appear to support IndexedDB.");return t}function setUpDatabase(e){const t=e.result;t.createObjectStore(MODEL_STORE_NAME,{keyPath:"modelPath"}),t.createObjectStore(INFO_STORE_NAME,{keyPath:"modelPath"})}var BrowserIndexedDB=class{constructor(e){if(this.indexedDB=getIndexedDBFactory(),null==e||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise(((e,n)=>{const a=this.indexedDB.open(DATABASE_NAME,DATABASE_VERSION);a.onupgradeneeded=()=>setUpDatabase(a),a.onsuccess=()=>{const r=a.result;if(null==t){const t=r.transaction(MODEL_STORE_NAME,"readonly"),a=t.objectStore(MODEL_STORE_NAME).get(this.modelPath);a.onsuccess=()=>{if(null==a.result)return r.close(),n(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));e(a.result.modelArtifacts)},a.onerror=e=>(r.close(),n(a.error)),t.oncomplete=()=>r.close()}else{const a=getModelArtifactsInfoForJSON(t),s=r.transaction(INFO_STORE_NAME,"readwrite");let o=s.objectStore(INFO_STORE_NAME);const i=o.put({modelPath:this.modelPath,modelArtifactsInfo:a});let l;i.onsuccess=()=>{l=r.transaction(MODEL_STORE_NAME,"readwrite");const i=l.objectStore(MODEL_STORE_NAME).put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:a});i.onsuccess=()=>e({modelArtifactsInfo:a}),i.onerror=e=>{o=s.objectStore(INFO_STORE_NAME);const t=o.delete(this.modelPath);t.onsuccess=()=>(r.close(),n(i.error)),t.onerror=e=>(r.close(),n(i.error))}},i.onerror=e=>(r.close(),n(i.error)),s.oncomplete=()=>{null==l?r.close():l.oncomplete=()=>r.close()}}},a.onerror=e=>n(a.error)}))}};BrowserIndexedDB.URL_SCHEME="indexeddb://";var indexedDBRouter=e=>env().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(BrowserIndexedDB.URL_SCHEME)?browserIndexedDB(e.slice(BrowserIndexedDB.URL_SCHEME.length)):null;function browserIndexedDB(e){return new BrowserIndexedDB(e)}function maybeStripScheme(e){return e.startsWith(BrowserIndexedDB.URL_SCHEME)?e.slice(BrowserIndexedDB.URL_SCHEME.length):e}IORouterRegistry.registerSaveRouter(indexedDBRouter),IORouterRegistry.registerLoadRouter(indexedDBRouter);var BrowserIndexedDBManager=class{constructor(){this.indexedDB=getIndexedDBFactory()}async listModels(){return new Promise(((e,t)=>{const n=this.indexedDB.open(DATABASE_NAME,DATABASE_VERSION);n.onupgradeneeded=()=>setUpDatabase(n),n.onsuccess=()=>{const a=n.result,r=a.transaction(INFO_STORE_NAME,"readonly"),s=r.objectStore(INFO_STORE_NAME).getAll();s.onsuccess=()=>{const t={};for(const e of s.result)t[e.modelPath]=e.modelArtifactsInfo;e(t)},s.onerror=e=>(a.close(),t(s.error)),r.oncomplete=()=>a.close()},n.onerror=e=>t(n.error)}))}async removeModel(e){return e=maybeStripScheme(e),new Promise(((t,n)=>{const a=this.indexedDB.open(DATABASE_NAME,DATABASE_VERSION);a.onupgradeneeded=()=>setUpDatabase(a),a.onsuccess=()=>{const r=a.result,s=r.transaction(INFO_STORE_NAME,"readwrite"),o=s.objectStore(INFO_STORE_NAME),i=o.get(e);let l;i.onsuccess=()=>{if(null==i.result)return r.close(),n(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const a=o.delete(e),s=()=>{l=r.transaction(MODEL_STORE_NAME,"readwrite");const a=l.objectStore(MODEL_STORE_NAME).delete(e);a.onsuccess=()=>t(i.result.modelArtifactsInfo),a.onerror=e=>n(i.error)};a.onsuccess=s,a.onerror=e=>(s(),r.close(),n(i.error))}},i.onerror=e=>(r.close(),n(i.error)),s.oncomplete=()=>{null==l?r.close():l.oncomplete=()=>r.close()}},a.onerror=e=>n(a.error)}))}},PATH_SEPARATOR="/",PATH_PREFIX="tensorflowjs_models",INFO_SUFFIX="info",MODEL_TOPOLOGY_SUFFIX="model_topology",WEIGHT_SPECS_SUFFIX="weight_specs",WEIGHT_DATA_SUFFIX="weight_data",MODEL_METADATA_SUFFIX="model_metadata";function getModelKeys(e){return{info:[PATH_PREFIX,e,INFO_SUFFIX].join(PATH_SEPARATOR),topology:[PATH_PREFIX,e,MODEL_TOPOLOGY_SUFFIX].join(PATH_SEPARATOR),weightSpecs:[PATH_PREFIX,e,WEIGHT_SPECS_SUFFIX].join(PATH_SEPARATOR),weightData:[PATH_PREFIX,e,WEIGHT_DATA_SUFFIX].join(PATH_SEPARATOR),modelMetadata:[PATH_PREFIX,e,MODEL_METADATA_SUFFIX].join(PATH_SEPARATOR)}}function removeItems(e){for(const t of Object.values(e))window.localStorage.removeItem(t)}function getModelPathFromKey(e){const t=e.split(PATH_SEPARATOR);if(t.length<3)throw new Error(`Invalid key format: ${e}`);return t.slice(1,t.length-1).join(PATH_SEPARATOR)}function maybeStripScheme2(e){return e.startsWith(BrowserLocalStorage.URL_SCHEME)?e.slice(BrowserLocalStorage.URL_SCHEME.length):e}var BrowserLocalStorage=class{constructor(e){if(!env().getBool("IS_BROWSER")||"undefined"==typeof window||void 0===window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==e||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=getModelKeys(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const t=JSON.stringify(e.modelTopology),n=JSON.stringify(e.weightSpecs),a=getModelArtifactsInfoForJSON(e);try{this.LS.setItem(this.keys.info,JSON.stringify(a)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,arrayBufferToBase64String(e.weightData));const r={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:null!=e.signature?e.signature:void 0,userDefinedMetadata:null!=e.userDefinedMetadata?e.userDefinedMetadata:void 0,modelInitializer:null!=e.modelInitializer?e.modelInitializer:void 0,trainingConfig:null!=e.trainingConfig?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(r)),{modelArtifactsInfo:a}}catch(e){throw removeItems(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${a.modelTopologyBytes}, weightSpecsBytes=${a.weightSpecsBytes}, weightDataBytes=${a.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(null==e)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if("JSON"!==e.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(null==n)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=n;const a=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==a)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=a;const r=this.LS.getItem(this.keys.modelMetadata);if(null!=r){const e=JSON.parse(r);t.format=e.format,t.generatedBy=e.generatedBy,t.convertedBy=e.convertedBy,null!=e.signature&&(t.signature=e.signature),null!=e.userDefinedMetadata&&(t.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(t.modelInitializer=e.modelInitializer),null!=e.trainingConfig&&(t.trainingConfig=e.trainingConfig)}const s=this.LS.getItem(this.keys.weightData);if(null==s)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=base64StringToArrayBuffer(s),t}};BrowserLocalStorage.URL_SCHEME="localstorage://";var localStorageRouter=e=>env().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(BrowserLocalStorage.URL_SCHEME)?browserLocalStorage(e.slice(BrowserLocalStorage.URL_SCHEME.length)):null;function browserLocalStorage(e){return new BrowserLocalStorage(e)}IORouterRegistry.registerSaveRouter(localStorageRouter),IORouterRegistry.registerLoadRouter(localStorageRouter);var BrowserLocalStorageManager=class{constructor(){assert(env().getBool("IS_BROWSER"),(()=>"Current environment is not a web browser")),assert("undefined"==typeof window||void 0!==window.localStorage,(()=>"Current browser does not appear to support localStorage")),this.LS=window.localStorage}async listModels(){const e={},t=PATH_PREFIX+PATH_SEPARATOR,n=PATH_SEPARATOR+INFO_SUFFIX;for(let a=0;a<this.LS.length;++a){const r=this.LS.key(a);if(r.startsWith(t)&&r.endsWith(n)){e[getModelPathFromKey(r)]=JSON.parse(this.LS.getItem(r))}}return e}async removeModel(e){const t=getModelKeys(e=maybeStripScheme2(e));if(null==this.LS.getItem(t.info))throw new Error(`Cannot find model at path '${e}'`);const n=JSON.parse(this.LS.getItem(t.info));return removeItems(t),n}},URL_SCHEME_SUFFIX="://",ModelStoreManagerRegistry=class{constructor(){this.managers={}}static getInstance(){return null==ModelStoreManagerRegistry.instance&&(ModelStoreManagerRegistry.instance=new ModelStoreManagerRegistry),ModelStoreManagerRegistry.instance}static registerManager(e,t){assert(null!=e,(()=>"scheme must not be undefined or null.")),e.endsWith(URL_SCHEME_SUFFIX)&&(e=e.slice(0,e.indexOf(URL_SCHEME_SUFFIX))),assert(e.length>0,(()=>"scheme must not be an empty string."));const n=ModelStoreManagerRegistry.getInstance();assert(null==n.managers[e],(()=>`A model store manager is already registered for scheme '${e}'.`)),n.managers[e]=t}static getManager(e){const t=this.getInstance().managers[e];if(null==t)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(this.getInstance().managers)}};function parseURL(e){if(-1===e.indexOf(URL_SCHEME_SUFFIX))throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${ModelStoreManagerRegistry.getSchemes().join(",")}`);return{scheme:e.split(URL_SCHEME_SUFFIX)[0],path:e.split(URL_SCHEME_SUFFIX)[1]}}async function cloneModelInternal(e,t,n=!1){assert(e!==t,(()=>`Old path and new path are the same: '${e}'`));const a=IORouterRegistry.getLoadHandlers(e);assert(a.length>0,(()=>`Copying failed because no load handler is found for source URL ${e}.`)),assert(a.length<2,(()=>`Copying failed because more than one (${a.length}) load handlers for source URL ${e}.`));const r=a[0],s=IORouterRegistry.getSaveHandlers(t);assert(s.length>0,(()=>`Copying failed because no save handler is found for destination URL ${t}.`)),assert(s.length<2,(()=>`Copying failed because more than one (${a.length}) save handlers for destination URL ${t}.`));const o=s[0],i=parseURL(e).scheme,l=parseURL(e).path,u=i===parseURL(e).scheme,c=await r.load();n&&u&&await ModelStoreManagerRegistry.getManager(i).removeModel(l);const d=await o.save(c);return n&&!u&&await ModelStoreManagerRegistry.getManager(i).removeModel(l),d.modelArtifactsInfo}async function listModels(){const e=ModelStoreManagerRegistry.getSchemes(),t={};for(const n of e){const e=await ModelStoreManagerRegistry.getManager(n).listModels();for(const a in e){t[n+URL_SCHEME_SUFFIX+a]=e[a]}}return t}async function removeModel(e){const t=parseURL(e);return ModelStoreManagerRegistry.getManager(t.scheme).removeModel(t.path)}async function copyModel(e,t){return cloneModelInternal(e,t,!1)}async function moveModel(e,t){return cloneModelInternal(e,t,!0)}var PlatformBrowser=class{fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}};if(env().get("IS_BROWSER")){env().setPlatform("browser",new PlatformBrowser);try{ModelStoreManagerRegistry.registerManager(BrowserLocalStorage.URL_SCHEME,new BrowserLocalStorageManager)}catch(e){}try{ModelStoreManagerRegistry.registerManager(BrowserIndexedDB.URL_SCHEME,new BrowserIndexedDBManager)}catch(e){}}var systemFetch,getNodeFetch={importFetch:()=>require_node_fetch()},PlatformNode=class{constructor(){this.util=require_util(),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return null!=env().global.fetch?env().global.fetch(e,t):(null==systemFetch&&(systemFetch=getNodeFetch.importFetch()),systemFetch(e,t))}now(){const e=process.hrtime();return 1e3*e[0]+e[1]/1e6}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return 0===e.length?"":new this.util.TextDecoder(t).decode(e)}};function buffer(e,t="float32",n){return t=t||"float32",assertNonNegativeIntegerDimensions(e),new TensorBuffer(e,t,n)}function cast_(e,t){const n=convertToTensor(e,"x","cast");if(!isValidDtype(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if("string"===t&&"string"!==n.dtype||"string"!==t&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");const a={x:n},r={dtype:t};return ENGINE.runKernel(Cast,a,r)}env().get("IS_NODE")&&env().setPlatform("node",new PlatformNode);var cast=op({cast_:cast_});function clone_(e){const t={x:convertToTensor(e,"x","clone","string_or_numeric")};return ENGINE.runKernel(Identity,t)}var clone=op({clone_:clone_});function print2(e,t=!1){console.log(e.toString(t))}getOrMakeEngine();var opHandler2={buffer:buffer,cast:cast,clone:clone,print:print2};setOpHandler(opHandler2);var io_exports={};__export2(io_exports,{browserFiles:()=>browserFiles,browserHTTPRequest:()=>browserHTTPRequest,concatenateArrayBuffers:()=>concatenateArrayBuffers,copyModel:()=>copyModel,decodeWeights:()=>decodeWeights,encodeWeights:()=>encodeWeights,fromMemory:()=>fromMemory,getLoadHandlers:()=>getLoadHandlers,getModelArtifactsForJSON:()=>getModelArtifactsForJSON,getModelArtifactsInfoForJSON:()=>getModelArtifactsInfoForJSON,getSaveHandlers:()=>getSaveHandlers,http:()=>http,isHTTPScheme:()=>isHTTPScheme,listModels:()=>listModels,loadWeights:()=>loadWeights,moveModel:()=>moveModel,registerLoadRouter:()=>registerLoadRouter,registerSaveRouter:()=>registerSaveRouter,removeModel:()=>removeModel,weightsLoaderFactory:()=>weightsLoaderFactory,withSaveHandler:()=>withSaveHandler});var DEFAULT_FILE_NAME_PREFIX="model",DEFAULT_JSON_EXTENSION_NAME=".json",DEFAULT_WEIGHT_DATA_EXTENSION_NAME=".weights.bin";function defer(e){return new Promise((e=>setTimeout(e))).then(e)}var _BrowserDownloads=class{constructor(e){if(!env().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(_BrowserDownloads.URL_SCHEME)&&(e=e.slice(_BrowserDownloads.URL_SCHEME.length)),null!=e&&0!==e.length||(e=DEFAULT_FILE_NAME_PREFIX),this.modelJsonFileName=e+DEFAULT_JSON_EXTENSION_NAME,this.weightDataFileName=e+DEFAULT_WEIGHT_DATA_EXTENSION_NAME}async save(e){if("undefined"==typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");const t=window.URL.createObjectURL(new Blob([e.weightData],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const n=getModelJSONForModelArtifacts(e,[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}]),a=window.URL.createObjectURL(new Blob([JSON.stringify(n)],{type:"application/json"})),r=null==this.modelJsonAnchor?document.createElement("a"):this.modelJsonAnchor;if(r.download=this.modelJsonFileName,r.href=a,await defer((()=>r.dispatchEvent(new MouseEvent("click")))),null!=e.weightData){const e=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor;e.download=this.weightDataFileName,e.href=t,await defer((()=>e.dispatchEvent(new MouseEvent("click"))))}return{modelArtifactsInfo:getModelArtifactsInfoForJSON(e)}}}},BrowserDownloads=_BrowserDownloads;BrowserDownloads.URL_SCHEME="downloads://";var BrowserFiles=class{constructor(e){if(null==e||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise(((e,t)=>{const n=new FileReader;n.onload=n=>{const a=JSON.parse(n.target.result),r=a.modelTopology;if(null==r)return void t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));if(null==a.weightsManifest)return void t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));if(0===this.weightsFiles.length)return void e({modelTopology:r});const s=getModelArtifactsForJSON(a,(e=>this.loadWeights(e)));e(s)},n.onerror=e=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),n.readAsText(this.jsonFile)}))}loadWeights(e){const t=[],n=[];for(const a of e)t.push(...a.weights),n.push(...a.paths);const a=this.checkManifestAndWeightFiles(e),r=n.map((e=>this.loadWeightsFile(e,a[e])));return Promise.all(r).then((e=>[t,concatenateArrayBuffers(e)]))}loadWeightsFile(e,t){return new Promise(((n,a)=>{const r=new FileReader;r.onload=e=>{const t=e.target.result;n(t)},r.onerror=t=>a(`Failed to weights data from file of path '${e}'.`),r.readAsArrayBuffer(t)}))}checkManifestAndWeightFiles(e){const t=[],n=this.weightsFiles.map((e=>basename(e.name))),a={};for(const r of e)r.paths.forEach((e=>{const r=basename(e);if(-1!==t.indexOf(r))throw new Error(`Duplicate file basename found in weights manifest: '${r}'`);if(t.push(r),-1===n.indexOf(r))throw new Error(`Weight file with basename '${r}' is not provided.`);a[e]=this.weightsFiles[n.indexOf(r)]}));if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return a}},browserDownloadsRouter=e=>env().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(BrowserDownloads.URL_SCHEME)?browserDownloads(e.slice(BrowserDownloads.URL_SCHEME.length)):null;function browserDownloads(e="model"){return new BrowserDownloads(e)}function browserFiles(e){return new BrowserFiles(e)}function monitorPromisesProgress(e,t,n,a){var r,s,o;assert(null!=(r=e)&&Array.isArray(r)&&r.length>0,(()=>"promises must be a none empty array")),o=a=null==a?1:a,assert((s=n=null==n?0:n)>=0&&s<=1,(()=>`Progress fraction must be in range [0, 1], but got startFraction ${s}`)),assert(o>=0&&o<=1,(()=>`Progress fraction must be in range [0, 1], but got endFraction ${o}`)),assert(o>=s,(()=>`startFraction must be no more than endFraction, but got startFraction ${s} and endFraction ${o}`));let i=0;return Promise.all(e.map((r=>(r.then((r=>{const s=n+ ++i/e.length*(a-n);return t(s),r})),r))))}async function loadWeightsAsArrayBuffer(e,t){null==t&&(t={});const n=null==t.fetchFunc?env().platform.fetch:t.fetchFunc,a=e.map((e=>n(e,t.requestInit,{isBinary:!0}))),r=(null==t.onProgress?await Promise.all(a):await monitorPromisesProgress(a,t.onProgress,0,.5)).map((e=>e.arrayBuffer()));return null==t.onProgress?await Promise.all(r):await monitorPromisesProgress(r,t.onProgress,.5,1)}async function loadWeights(e,t="",n,a){return weightsLoaderFactory((e=>loadWeightsAsArrayBuffer(e,{requestInit:a})))(e,t,n)}function weightsLoaderFactory(e){return async(t,n="",a)=>{const r=t.map((()=>!1)),s={},o=null!=a?a.map((()=>!1)):[],i=[];if(t.forEach(((e,t)=>{let n=0;e.weights.forEach((e=>{const l="quantization"in e?e.quantization.dtype:e.dtype,u=DTYPE_VALUE_SIZE_MAP[l]*sizeFromShape(e.shape),c=()=>{r[t]=!0,null==s[t]&&(s[t]=[]),s[t].push({manifestEntry:e,groupOffset:n,sizeBytes:u})};null!=a?a.forEach(((t,n)=>{t===e.name&&(c(),o[n]=!0)})):c(),i.push(e.name),n+=u}))})),!o.every((e=>e))){const e=a.filter(((e,t)=>!o[t]));throw new Error(`Could not find weights in manifest with names: ${e.join(", ")}. \nManifest JSON has weights with names: ${i.join(", ")}.`)}const l=r.reduce(((e,t,n)=>(t&&e.push(n),e)),[]),u=[];l.forEach((e=>{t[e].paths.forEach((e=>{const t=n+(n.endsWith("/")?"":"/")+e;u.push(t)}))}));const c=await e(u),d={};let p=0;return l.forEach((e=>{const n=t[e].paths.length;let a=0;for(let e=0;e<n;e++)a+=c[p+e].byteLength;const r=new ArrayBuffer(a),o=new Uint8Array(r);let i=0;for(let e=0;e<n;e++){const t=new Uint8Array(c[p+e]);o.set(t,i),i+=t.byteLength}s[e].forEach((e=>{const t=decodeWeights(r.slice(e.groupOffset,e.groupOffset+e.sizeBytes),[e.manifestEntry]);for(const e in t)d[e]=t[e]})),p+=n})),d}}IORouterRegistry.registerSaveRouter(browserDownloadsRouter);var OCTET_STREAM_MIME_TYPE="application/octet-stream",JSON_TYPE="application/json",HTTPRequest=class{constructor(e,t){if(this.DEFAULT_METHOD="POST",null==t&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.onProgress=t.onProgress,this.weightUrlConverter=t.weightUrlConverter,null!=t.fetchFunc?(assert("function"==typeof t.fetchFunc,(()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)")),this.fetch=t.fetchFunc):this.fetch=env().platform.fetch,assert(null!=e&&e.length>0,(()=>"URL path for http must not be null, undefined or empty.")),Array.isArray(e)&&assert(2===e.length,(()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`)),this.path=e,null!=t.requestInit&&null!=t.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{}}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const n=getModelJSONForModelArtifacts(e,[{paths:["./model.weights.bin"],weights:e.weightSpecs}]);t.body.append("model.json",new Blob([JSON.stringify(n)],{type:JSON_TYPE}),"model.json"),null!=e.weightData&&t.body.append("model.weights.bin",new Blob([e.weightData],{type:OCTET_STREAM_MIME_TYPE}),"model.weights.bin");const a=await this.fetch(this.path,t);if(a.ok)return{modelArtifactsInfo:getModelArtifactsInfoForJSON(e),responses:[a]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${a.status}.`)}async load(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch(e){let t=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?t+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":t+=" Please make sure the server is serving valid JSON for this request.",new Error(t)}const n=t.modelTopology,a=t.weightsManifest;if(null==n&&null==a)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return getModelArtifactsForJSON(t,(e=>this.loadWeights(e)))}async loadWeights(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[n,a]=parseUrl(t),r=this.weightPathPrefix||n,s=[];for(const t of e)s.push(...t.weights);const o=[],i=[];for(const t of e)for(const e of t.paths)null!=this.weightUrlConverter?i.push(this.weightUrlConverter(e)):o.push(r+e+a);this.weightUrlConverter&&o.push(...await Promise.all(i));return[s,concatenateArrayBuffers(await loadWeightsAsArrayBuffer(o,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress}))]}};function parseUrl(e){const t=e.lastIndexOf("/"),n=e.lastIndexOf("?");return[e.substring(0,t)+"/",n>t?e.substring(n):""]}function isHTTPScheme(e){return null!=e.match(HTTPRequest.URL_SCHEME_REGEX)}HTTPRequest.URL_SCHEME_REGEX=/^https?:\/\//;var httpRouter=(e,t)=>{if("undefined"==typeof fetch&&(null==t||null==t.fetchFunc))return null;{let n=!0;if(n=Array.isArray(e)?e.every((e=>isHTTPScheme(e))):isHTTPScheme(e),n)return http(e,t)}return null};function http(e,t){return new HTTPRequest(e,t)}function browserHTTPRequest(e,t){return http(e,t)}IORouterRegistry.registerSaveRouter(httpRouter),IORouterRegistry.registerLoadRouter(httpRouter);var PassthroughLoader=class{constructor(e){this.modelArtifacts=e}async load(){return this.modelArtifacts}},PassthroughSaver=class{constructor(e){this.saveHandler=e}async save(e){return this.saveHandler(e)}};function fromMemory(e,t,n,a){if(1===arguments.length){return null!=e.modelTopology||null!=e.weightSpecs?new PassthroughLoader(e):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new PassthroughLoader({modelTopology:e}))}return console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new PassthroughLoader({modelTopology:e,weightSpecs:t,weightData:n,trainingConfig:a})}function withSaveHandler(e){return new PassthroughSaver(e)}var math_exports={};function matMul_(e,t,n=!1,a=!1){let r=convertToTensor(e,"a","matMul"),s=convertToTensor(t,"b","matMul");[r,s]=makeTypesMatch(r,s);const o={a:r,b:s},i={transposeA:n,transposeB:a};return ENGINE.runKernel(BatchMatMul,o,i)}__export2(math_exports,{confusionMatrix:()=>confusionMatrix});var matMul=op({matMul_:matMul_});function oneHot_(e,t,n=1,a=0){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);const r={indices:convertToTensor(e,"indices","oneHot","int32")},s={depth:t,onValue:n,offValue:a};return ENGINE.runKernel(OneHot,r,s)}var oneHot=op({oneHot_:oneHot_});function transpose_(e,t){const n=convertToTensor(e,"x","transpose");if(null==t&&(t=n.shape.map(((e,t)=>t)).reverse()),assert(n.rank===t.length,(()=>`Error in transpose: rank of input ${n.rank} must match length of perm ${t}.`)),t.forEach((e=>{assert(e>=0&&e<n.rank,(()=>`All entries in 'perm' must be between 0 and ${n.rank-1} but got ${t}`))})),n.rank<=1)return n.clone();const a={x:n},r={perm:t};return ENGINE.runKernel(Transpose,a,r)}var transpose=op({transpose_:transpose_});function confusionMatrix_(e,t,n){const a=convertToTensor(e,"labels","confusionMatrix"),r=convertToTensor(t,"predictions","confusionMatrix");assert(null==n||n>0&&Number.isInteger(n),(()=>`If provided, numClasses must be a positive integer, but got ${n}`)),assert(1===a.rank,(()=>`Expected the rank of labels to be 1, but got ${a.rank}`)),assert(1===r.rank,(()=>`Expected the rank of predictions to be 1, but got ${r.rank}`)),assert(a.shape[0]===r.shape[0],(()=>`Mismatch in the number of examples: ${a.shape[0]} vs. ${r.shape[0]}. Labels and predictions should have the same number of elements.`)),assert(n>0&&Number.isInteger(n),(()=>`numClasses is required to be a positive integer, but got ${n}`));const s=oneHot(cast(a,"int32"),n),o=oneHot(cast(r,"int32"),n),i=transpose(s),l=matMul(i,o);return cast(l,"int32")}var confusionMatrix=op({confusionMatrix_:confusionMatrix_}),broadcast_util_exports={};function getBroadcastDims(e,t){const n=e.length,a=[];for(let r=0;r<n;r++){const s=n-1-r,o=e[s]||1;(t[t.length-1-r]||1)>1&&1===o&&a.unshift(s)}return a}function getReductionAxes(e,t){const n=[];for(let a=0;a<t.length;a++){const r=e[e.length-a-1],s=t.length-a-1,o=t[s];(null==r||1===r&&o>1)&&n.unshift(s)}return n}function assertAndGetBroadcastShape(e,t){const n=[],a=Math.max(e.length,t.length);for(let r=0;r<a;r++){let a=e[e.length-r-1];null==a&&(a=1);let s=t[t.length-r-1];if(null==s&&(s=1),1===a)n.unshift(s);else if(1===s)n.unshift(a);else{if(a!==s){throw Error(`Operands could not be broadcast together with shapes ${e} and ${t}.`)}n.unshift(a)}}return n}__export2(broadcast_util_exports,{assertAndGetBroadcastShape:()=>assertAndGetBroadcastShape,getBroadcastDims:()=>getBroadcastDims,getReductionAxes:()=>getReductionAxes});var fromPixels2DContext,browser_exports={};function tensor3d(e,t,n){if(assertNonNull(e),null!=t&&3!==t.length)throw new Error("tensor3d() requires shape to have three numbers");const a=inferShape(e,n);if(3!==a.length&&1!==a.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===a.length&&null==t)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return makeTensor(e,t,a,n)}function fromPixels_(e,t=3){if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==e)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,a=!1,r=!1,s=!1,o=!1,i=!1;if(e.data instanceof Uint8Array)n=!0;else if("undefined"!=typeof ImageData&&e instanceof ImageData)a=!0;else if("undefined"!=typeof HTMLVideoElement&&e instanceof HTMLVideoElement)r=!0;else if("undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement)s=!0;else if(null!=e.getContext)o=!0;else{if(!("undefined"!=typeof ImageBitmap&&e instanceof ImageBitmap))throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${e.constructor.name}`);i=!0}if(r){const t=2;if(r&&e.readyState<t)throw new Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.")}if(null!=getKernel(FromPixels,ENGINE.backendName)){const n={pixels:e},a={numChannels:t};return ENGINE.runKernel(FromPixels,n,a)}const[l,u]=r?[e.videoWidth,e.videoHeight]:[e.width,e.height];let c,d;if(o)c=e.getContext("2d").getImageData(0,0,l,u).data;else if(a||n)c=e.data;else if(s||r||i){if(null==fromPixels2DContext)if("undefined"==typeof document){if("undefined"==typeof OffscreenCanvas||"undefined"==typeof OffscreenCanvasRenderingContext2D)throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");fromPixels2DContext=new OffscreenCanvas(1,1).getContext("2d")}else fromPixels2DContext=document.createElement("canvas").getContext("2d");fromPixels2DContext.canvas.width=l,fromPixels2DContext.canvas.height=u,fromPixels2DContext.drawImage(e,0,0,l,u),c=fromPixels2DContext.getImageData(0,0,l,u).data}if(4===t)d=new Int32Array(c);else{const e=l*u;d=new Int32Array(e*t);for(let n=0;n<e;n++)for(let e=0;e<t;++e)d[n*t+e]=c[4*n+e]}return tensor3d(d,[u,l,t],"int32")}function isPixelData(e){return null!=e&&e.data instanceof Uint8Array}function isImageBitmapFullySupported(){return"undefined"!=typeof window&&"undefined"!=typeof ImageBitmap&&window.hasOwnProperty("createImageBitmap")}function isNonEmptyPixels(e){return null!=e&&0!==e.width&&0!==e.height}function canWrapPixelsToImageBitmap(e){return isImageBitmapFullySupported()&&!(e instanceof ImageBitmap)&&isNonEmptyPixels(e)&&!isPixelData(e)}async function fromPixelsAsync(e,t=3){let n=null;if(env().getBool("WRAP_TO_IMAGEBITMAP")&&canWrapPixelsToImageBitmap(e)){let t;try{t=await createImageBitmap(e,{premultiplyAlpha:"none"})}catch(e){t=null}n=null!=t&&t.width===e.width&&t.height===e.height?t:e}else n=e;return fromPixels_(n,t)}async function toPixels(e,t){let n=convertToTensor(e,"img","toPixels");if(!(e instanceof Tensor)){const e=n;n=cast(e,"int32"),e.dispose()}if(2!==n.rank&&3!==n.rank)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${n.rank}.`);const[a,r]=n.shape.slice(0,2),s=2===n.rank?1:n.shape[2];if(s>4||2===s)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${s}`);if("float32"!==n.dtype&&"int32"!==n.dtype)throw new Error(`Unsupported type for toPixels: ${n.dtype}. Please use float32 or int32 tensors.`);const o=await n.data(),i="float32"===n.dtype?255:1,l=new Uint8ClampedArray(r*a*4);for(let e=0;e<a*r;++e){const t=[0,0,0,255];for(let a=0;a<s;a++){const r=o[e*s+a];if("float32"===n.dtype){if(r<0||r>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${r}.`)}else if("int32"===n.dtype&&(r<0||r>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${r}.`);1===s?(t[0]=r*i,t[1]=r*i,t[2]=r*i):t[a]=r*i}const a=4*e;l[a+0]=Math.round(t[0]),l[a+1]=Math.round(t[1]),l[a+2]=Math.round(t[2]),l[a+3]=Math.round(t[3])}if(null!=t){t.width=r,t.height=a;const e=t.getContext("2d"),n=new ImageData(l,r,a);e.putImageData(n,0,0)}return n!==e&&n.dispose(),l}__export2(browser_exports,{fromPixels:()=>fromPixels,fromPixelsAsync:()=>fromPixelsAsync,toPixels:()=>toPixels});var fromPixels=op({fromPixels_:fromPixels_}),gather_nd_util_exports={};function prepareAndValidate(e,t){const n=e.shape.length,a=t.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(a<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${a}.`);if("int32"!==t.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[a-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[a-1]} vs. ${n}`);if(0===sizeFromShape(e.shape))throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);const r=t.shape,s=r[r.length-1];let o=1;for(let e=0;e<r.length-1;++e)o*=r[e];const i=e.shape,l=r.slice();l.pop();let u=1;for(let e=s;e<n;++e)u*=i[e],l.push(i[e]);const c=[...computeStrides(e.shape).map((e=>e/u)),1].slice(0,s);return[l,o,u,c]}__export2(gather_nd_util_exports,{prepareAndValidate:()=>prepareAndValidate});var scatter_nd_util_exports={};function validateUpdateShape(e,t,n){const a=t.rank>1?t.shape[t.rank-1]:1,r=t.rank>1?t.rank-1:1,s=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${a}, and batchDim: ${r}.`;if(n.rank<r)throw new Error(s+` update.rank < ${r}. `);if(e.length<a+(n.rank-r))throw new Error(s+` Output shape length < ${a+(n.rank-r)}`);if(n.rank!==r+e.length-a)throw new Error(s+" update.rank != "+(r+e.length-a));for(let e=0;e<r;++e)if(n.shape[e]!==t.shape[e])throw new Error(s+` updates.shape[${e}] (${n.shape[e]}) != indices.shape[${e}] (${t.shape[e]}).`);for(let t=0;t<n.rank-r;++t)if(n.shape[t+r]!==e[t+a])throw new Error(s+` updates.shape[${t+r}] (${n.shape[t+r]}) != shape[${t+r}] (${e[t+r]})`)}function validateInput(e,t,n){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if("int32"!==t.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(0===n.length){if(0===t.size)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(0===e.size)throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`)}validateUpdateShape(n,t,e)}function calculateShapes(e,t,n){const a=t.shape.length,r=a>1?t.shape[a-1]:1,s=n.length;let o=1;for(let e=r;e<s;++e)o*=n[e];const i=r<1?1:r;return{sliceRank:r,numUpdates:sizeFromShape(t.shape)/i,sliceSize:o,strides:[...computeStrides(n.slice(0,r)),1],outputSize:sizeFromShape(n)}}__export2(scatter_nd_util_exports,{calculateShapes:()=>calculateShapes,validateInput:()=>validateInput,validateUpdateShape:()=>validateUpdateShape});var slice_util_exports={};__export2(slice_util_exports,{assertParamsValid:()=>assertParamsValid,computeFlatOffset:()=>computeFlatOffset,computeOutShape:()=>computeOutShape,getNormalizedAxes:()=>getNormalizedAxes,isSliceContinous:()=>isSliceContinous,maskToAxes:()=>maskToAxes,parseSliceParams:()=>parseSliceParams,sliceInfo:()=>sliceInfo,startForAxis:()=>startForAxis,startIndicesWithElidedDims:()=>startIndicesWithElidedDims,stopForAxis:()=>stopForAxis,stopIndicesWithElidedDims:()=>stopIndicesWithElidedDims,stridesForAxis:()=>stridesForAxis,stridesWithElidedDims:()=>stridesWithElidedDims});var NEW_AXIS=-2,SHRINK_AXIS=-1;function assertParamsValid(e,t,n){const a=e.shape.length;assert(a===t.length,(()=>`Error in slice${a}D: Length of begin ${t} must match the rank of the array (${a}).`)),assert(a===n.length,(()=>`Error in slice${a}D: Length of size ${n} must match the rank of the array (${a}).`));for(let r=0;r<a;++r)assert(t[r]+n[r]<=e.shape[r],(()=>`Error in slice${a}D: begin[${r}] + size[${r}] (${t[r]+n[r]}) would overflow input.shape[${r}] (${e.shape[r]})`))}function maskToAxes(e){const t=[];let n=0;for(;e>0;)1&e&&t.push(n),e/=2,n++;return t}function computeOutShape(e,t,n){const a=[];for(let r=0;r<e.length;r++)a[r]=Math.ceil((t[r]-e[r])/n[r]);return a}function stridesWithElidedDims(e,t,n,a){const r=[...e];for(let e=r.length;e<a.length;e++)r.push(1);for(let e=0;e<n;e++)0===e?r[t]=1:(r.splice(t,0,1),r.pop());return r}function unnormalizeAxis(e,t,n){return n<=e?n:n-(t-1)}function getElidedAxes(e,t){const n=[];for(let a=0;a<e;a++)n.push(t+a);return n}function getNormalizedAxes(e,t,n,a,r,s,o,i,l){const u=e.length;let c=new Array(u),d=new Array(u),p=new Array(u);if(t.length&&n>0){const l=t[0],u=n+1;c=startIndicesWithElidedDims(o,l,u,a,e),d=stopIndicesWithElidedDims(i,l,u,r,e),p=stridesWithElidedDims(s,l,u,e)}else for(let t=0;t<u;t++)c[t]=startForAxis(o,a,s,e,t,l),d[t]=stopForAxis(i,r,s,e,t,l),p[t]=stridesForAxis(s,t,l);return{begin:c,end:d,strides:p}}function startIndicesWithElidedDims(e,t,n,a,r){const s=[...r],o=getElidedAxes(n,t);for(let r=0;r<s.length;r++)if(o.indexOf(r)>-1)s[r]=0;else{const o=unnormalizeAxis(t,n,r);let i=a[o];e&1<<o&&(i=0),s[r]=i}return s}function stopIndicesWithElidedDims(e,t,n,a,r){const s=[...r],o=getElidedAxes(n,t);for(let r=0;r<s.length;r++)if(o.indexOf(r)>-1)s[r]=Number.MAX_SAFE_INTEGER;else{const o=unnormalizeAxis(t,n,r);let i=a[o];e&1<<o&&(i=Number.MAX_SAFE_INTEGER),s[r]=i}for(let e=0;e<s.length;e++){const t=r[e];s[e]<0&&(s[e]+=t),s[e]=clamp(0,s[e],r[e])}return s}function stridesForAxis(e,t,n){let a=e[t];return(n&1<<t||null==a)&&(a=1),a}function startForAxis(e,t,n,a,r,s){let o=t[r];const i=n[r]||1;(e&1<<r||s&1<<r||null==o)&&(o=i>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const l=a[r];return o<0&&(o+=l),o=clamp(0,o,l-1),o}function stopForAxis(e,t,n,a,r,s){let o=t[r];const i=n[r]||1;(e&1<<r||s&1<<r||null==o)&&(o=i>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const l=a[r];return o<0&&(o+=l),o=i>0?clamp(0,o,l):clamp(-1,o,l-1),o}function isSliceContinous(e,t,n){let a=n.length;for(let e=0;e<n.length;e++)if(n[e]>1){a=e;break}for(let r=a+1;r<n.length;r++)if(t[r]>0||n[r]!==e[r])return!1;return!0}function computeFlatOffset(e,t){let n=e.length>0?e[e.length-1]:1;for(let a=0;a<e.length-1;a++)n+=e[a]*t[a];return n}function parseSliceParams(e,t,n){let a;const r=e.shape.length;let s;return a="number"==typeof t?[t,...new Array(r-1).fill(0)]:t.length<r?t.concat(new Array(r-t.length).fill(0)):t.slice(),a.forEach((e=>{assert(-1!==e,(()=>"slice() does not support negative begin indexing."))})),s=null==n?new Array(r).fill(-1):"number"==typeof n?[n,...new Array(r-1).fill(-1)]:n.length<r?n.concat(new Array(r-n.length).fill(-1)):n,s=s.map(((t,n)=>t>=0?t:(assert(-1===t,(()=>`Negative size values should be exactly -1 but got ${t} for the slice() size at index ${n}.`)),e.shape[n]-a[n]))),[a,s]}function sliceInfo(e,t,n,a,r,s,o,i,l){let u;if(null==a?(u=new Array(t.length),u.fill(1)):u=a,null!=o&&0!=(o&o-1))throw new Error("Multiple ellipses in slice is not allowed.");let c=!1;const d={dims:u.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:n.slice(),strides:u.slice(),beginMask:r,endMask:s,ellipsisMask:o,newAxisMask:i,shrinkAxisMask:l};for(let e=0;e<d.dims;e++)c&&0!=(1<<e&i)&&d.numAddAxisAfterEllipsis++,1<<e&o&&(c=!0);c||(d.ellipsisMask|=1<<d.dims,d.dims++);const p={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};buildDenseSpec(d,p);let h=!0,m=!0,f=!0;const g=[],x=[];for(let t=0;t<e.length;++t){if(0===p.strides[t])throw Error(`strides[${t}] must be non-zero`);const n=!!(p.shrinkAxisMask&1<<t),a=e[t];if(-1===a){g.push(n?1:-1);continue}const r=[p.beginMask&1<<t,p.endMask&1<<t],s=[p.strides[t]>0?0:-1,p.strides[t]>0?a:a-1];if(n&&p.strides[t]<=0)throw Error("only stride 1 allowed on non-range indexing.");f=f&&1===p.strides[t];const o=!!(p.beginMask&1<<t&&p.endMask&1<<t);if(p.beginValid&&p.endValid){if(n){const e=p.begin[t]<0?a+p.begin[t]:p.begin[t];if(p.begin[t]=e,p.end[t]=p.begin[t]+1,e<0||e>=a)throw Error(`slice index ${p.begin[t]} of dimension ${t} out of bounds.`)}else p.begin[t]=canonical(p.begin[t],0,p.strides[t],a,r,s),p.end[t]=canonical(p.end[t],1,p.strides[t],a,r,s);const e=1===p.strides[t]&&0===p.begin[t]&&p.end[t]===a;h=h&&e,m=m&&(0===t&&1===p.strides[t]||e)}else h=h&&1===p.strides[t]&&o,m=m&&(0===t&&1===p.strides[t]||o);let i,l=!1;if(p.beginValid&&p.endValid?(i=p.end[t]-p.begin[t],l=!0):n?(i=1,l=!0):o&&a>=0&&(i=p.strides[t]<0?-a:a,l=!0),l){let e;e=0===i||i<0!=p.strides[t]<0?0:Math.trunc(i/p.strides[t])+(i%p.strides[t]!=0?1:0),g.push(e)}else g.push(-1)}for(let e=0;e<p.finalShapeGatherIndices.length;++e){const t=p.finalShapeGatherIndices[e];t>=0?x.push(g[t]):t===NEW_AXIS&&x.push(1)}return{finalShapeSparse:x.filter(((e,t)=>p.finalShapeGatherIndices[t]!==NEW_AXIS)),finalShape:x,isIdentity:h,sliceDim0:m,isSimpleSlice:f,begin:p.begin,end:p.end,strides:p.strides}}function buildDenseSpec(e,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let n=0;t.beginValid=null!=e.begin,t.endValid=null!=e.end,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let a=0;a<e.dims;a++)if(1<<a&e.ellipsisMask){const r=Math.min(t.dims-(e.dims-a)+1+e.numAddAxisAfterEllipsis,t.dims);for(;n<r;n++)t.begin[n]=0,t.end[n]=0,t.strides[n]=1,t.beginMask|=1<<n,t.endMask|=1<<n,t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[n]=a}else if(1<<a&e.newAxisMask)t.finalShapeGatherIndices.push(NEW_AXIS),t.finalShapeGatherIndicesSparse.push(-1);else{if(n===t.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${t.dims} dims, ${t.begin.length}.`);null!=e.begin&&(t.begin[n]=e.begin[a]),null!=e.end&&(t.end[n]=e.end[a]),t.strides[n]=e.strides[a],e.beginMask&1<<a&&(t.beginMask|=1<<n),e.endMask&1<<a&&(t.endMask|=1<<n),e.shrinkAxisMask&1<<a?(t.finalShapeGatherIndices.push(SHRINK_AXIS),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<n):(t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(a)),t.inputShapeGatherIndicesSparse[n]=a,n++}}function canonical(e,t,n,a,r,s){if(r[t])return n>0?s[t]:s[t+1&1];{const t=e<0?a+e:e;return t<s[0]?s[0]:t>s[1]?s[1]:t}}var serialization_exports={};__export2(serialization_exports,{Serializable:()=>Serializable,SerializationMap:()=>SerializationMap,registerClass:()=>registerClass});var Serializable=class{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}},SerializationMap=class{constructor(){this.classNameMap={}}static getMap(){return null==SerializationMap.instance&&(SerializationMap.instance=new SerializationMap),SerializationMap.instance}static register(e){SerializationMap.getMap().classNameMap[e.className]=[e,e.fromConfig]}};function registerClass(e){assert(null!=e.className,(()=>"Class being registered does not have the static className property defined.")),assert("string"==typeof e.className,(()=>"className is required to be a string, but got type "+typeof e.className)),assert(e.className.length>0,(()=>"Class being registered has an empty-string as its className, which is disallowed.")),SerializationMap.register(e)}var test_util_exports={};__export2(test_util_exports,{TEST_EPSILON_FLOAT16:()=>TEST_EPSILON_FLOAT16,encodeStrings:()=>encodeStrings,expectArrayBuffersEqual:()=>expectArrayBuffersEqual,expectArraysClose:()=>expectArraysClose,expectArraysEqual:()=>expectArraysEqual,expectNumbersClose:()=>expectNumbersClose,expectPromiseToFail:()=>expectPromiseToFail,expectValuesInRange:()=>expectValuesInRange,testEpsilon:()=>testEpsilon});var TEST_EPSILON_FLOAT32=.001,TEST_EPSILON_FLOAT16=.1;function expectArraysClose(e,t,n){return null==n&&(n=testEpsilon()),expectArraysPredicate(e,t,((e,t)=>areClose(e,t,n)))}function testEpsilon(){return 32===ENGINE.backend.floatPrecision()?TEST_EPSILON_FLOAT32:TEST_EPSILON_FLOAT16}function expectArraysPredicate(e,t,n){let a=!0;if((isTypedArray(e)||isTypedArray(t))&&(a=!1),isTypedArray(e)&&isTypedArray(t)&&(a=!0),a){const n=e.constructor.name,a=t.constructor.name;if(n!==a)throw new Error(`Arrays are of different type. Actual: ${n}. Expected: ${a}`)}if(Array.isArray(e)&&Array.isArray(t)){const n=inferShape(e),a=inferShape(t);if(!arraysEqual(n,a))throw new Error(`Arrays have different shapes. Actual: [${n}]. Expected: [${a}]`)}const r=isTypedArray(e)?e:flatten(e),s=isTypedArray(t)?t:flatten(t);if(r.length!==s.length)throw new Error(`Arrays have different lengths actual: ${r.length} vs expected: ${s.length}.\nActual:   ${r}.\nExpected: ${s}.`);for(let e=0;e<s.length;++e){const t=r[e],a=s[e];if(!n(t,a))throw new Error(`Arrays differ: actual[${e}] = ${t}, expected[${e}] = ${a}.\nActual:   ${r}.\nExpected: ${s}.`)}}function expectPromiseToFail(e,t){e().then((()=>t.fail()),(()=>t()))}function expectArraysEqual(e,t){const n="string"==typeof t||"number"==typeof t||"boolean"==typeof t?[t]:t;return isString(e)||isString(e[0])||isString(t)||isString(t[0])?expectArraysPredicate(e,n,((e,t)=>e==t)):expectArraysPredicate(e,t,((e,t)=>areClose(e,t,0)))}function expectNumbersClose(e,t,n){if(null==n&&(n=testEpsilon()),!areClose(e,t,n))throw new Error(`Numbers differ: actual === ${e}, expected === ${t}`)}function areClose(e,t,n){return!isFinite(e)&&!isFinite(t)||!(isNaN(e)||isNaN(t)||Math.abs(e-t)>n)}function expectValuesInRange(e,t,n){for(let a=0;a<e.length;a++)if(e[a]<t||e[a]>n)throw new Error(`Value out of range:${e[a]} low: ${t}, high: ${n}`)}function expectArrayBuffersEqual(e,t){expect(new Float32Array(e)).toEqual(new Float32Array(t))}function encodeStrings(e){for(let t=0;t<e.length;t++){const n=e[t];Array.isArray(n)?encodeStrings(n):e[t]=encodeString(n)}return e}function enableProdMode(){env().set("PROD",!0)}function enableDebugMode(){env().set("DEBUG",!0)}function disableDeprecationWarnings(){env().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function deprecationWarn(e){env().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(e+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function disposeVariables(){ENGINE.disposeVariables()}function engine(){return ENGINE}function memory(){return ENGINE.memory()}function profile(e){return ENGINE.profile(e)}function tidy(e,t){return ENGINE.tidy(e,t)}function dispose(e){getTensorsInContainer(e).forEach((e=>e.dispose()))}function keep(e){return ENGINE.keep(e)}function time(e){return ENGINE.time(e)}function setBackend(e){return ENGINE.setBackend(e)}function ready(){return ENGINE.ready()}function getBackend(){return ENGINE.backendName}function removeBackend(e){ENGINE.removeBackend(e)}function findBackend(e){return ENGINE.findBackend(e)}function findBackendFactory(e){return ENGINE.findBackendFactory(e)}function registerBackend(e,t,n=1){return ENGINE.registerBackend(e,t,n)}function backend(){return ENGINE.backend}function setPlatform(e,t){env().setPlatform(e,t)}function add_(e,t){let n=convertToTensor(e,"a","add"),a=convertToTensor(t,"b","add");[n,a]=makeTypesMatch(n,a);const r={a:n,b:a};return ENGINE.runKernel(Add,r)}setDeprecationWarningFn(deprecationWarn);var add2=op({add_:add_});function floorDiv_(e,t){let n=convertToTensor(e,"a","floorDiv"),a=convertToTensor(t,"b","floorDiv");[n,a]=makeTypesMatch(n,a);const r={a:n,b:a};return ENGINE.runKernel(FloorDiv,r)}var floorDiv=op({floorDiv_:floorDiv_});function div_(e,t){let n=convertToTensor(e,"a","div"),a=convertToTensor(t,"b","div");if([n,a]=makeTypesMatch(n,a),"int32"===n.dtype&&"int32"===a.dtype)return floorDiv(n,a);const r={a:n,b:a};return ENGINE.runKernel(RealDiv,r,{})}var div=op({div_:div_});function mul_(e,t){let n=convertToTensor(e,"a","mul"),a=convertToTensor(t,"b","mul");[n,a]=makeTypesMatch(n,a);const r={a:n,b:a};return ENGINE.runKernel(Multiply,r)}var mul=op({mul_:mul_});function abs_(e){const t=convertToTensor(e,"x","abs");if("complex64"===t.dtype){const e={x:t};return ENGINE.runKernel(ComplexAbs,e)}{const e={x:t};return ENGINE.runKernel(Abs,e)}}var abs=op({abs_:abs_});function acos_(e){const t={x:convertToTensor(e,"x","acos")};return ENGINE.runKernel(Acos,t)}var acos=op({acos_:acos_});function acosh_(e){const t={x:convertToTensor(e,"x","acosh")};return ENGINE.runKernel(Acosh,t)}var acosh=op({acosh_:acosh_});function addN_(e){assert(Array.isArray(e),(()=>"The argument passed to tf.addN() must be a list of tensors")),assert(e.length>=1,(()=>`Must pass at least one tensor to tf.addN(), but got ${e.length}`));const t=e.map(((e,t)=>convertToTensor(e,`tensors${t}`,"addN"))),n=t[0];t.forEach((e=>{if(e.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")})),t.forEach((e=>{if(!arraysEqual(e.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")}));const a=t;return ENGINE.runKernel(AddN,a)}var addN=op({addN_:addN_});function all_(e,t=null,n=!1){const a={x:convertToTensor(e,"x","all","bool")},r={axis:t,keepDims:n};return ENGINE.runKernel(All,a,r)}var all=op({all_:all_});function any_(e,t=null,n=!1){const a={x:convertToTensor(e,"x","any","bool")},r={axis:t,keepDims:n};return ENGINE.runKernel(Any,a,r)}var any=op({any_:any_});function argMax_(e,t=0){const n={x:convertToTensor(e,"x","argMax")},a={axis:t};return ENGINE.runKernel(ArgMax,n,a)}var argMax=op({argMax_:argMax_});function argMin_(e,t=0){const n={x:convertToTensor(e,"x","argMin")},a={axis:t};return ENGINE.runKernel(ArgMin,n,a)}var argMin=op({argMin_:argMin_});function asin_(e){const t={x:convertToTensor(e,"x","asin")};return ENGINE.runKernel(Asin,t)}var asin=op({asin_:asin_});function asinh_(e){const t={x:convertToTensor(e,"x","asinh")};return ENGINE.runKernel(Asinh,t)}var asinh=op({asinh_:asinh_});function atan_(e){const t={x:convertToTensor(e,"x","atan")};return ENGINE.runKernel(Atan,t)}var atan=op({atan_:atan_});function atan2_(e,t){let n=convertToTensor(e,"a","atan2"),a=convertToTensor(t,"b","atan2");[n,a]=makeTypesMatch(n,a);const r={a:n,b:a};return ENGINE.runKernel(Atan2,r)}var atan2=op({atan2_:atan2_});function atanh_(e){const t={x:convertToTensor(e,"x","atanh")};return ENGINE.runKernel(Atanh,t)}var atanh=op({atanh_:atanh_});function computeDilation2DInfo(e,t,n,a,r="NHWC",s){return computeConv2DInfo(e,[...t,e[3]],n,s,a,null,null,convertConv2DDataFormat(r))}function computePool2DInfo(e,t,n,a,r,s,o="channelsLast"){const[i,l]=parseTupleParam(t);let u;if("channelsLast"===o)u=[i,l,e[3],e[3]];else{if("channelsFirst"!==o)throw new Error(`Unknown dataFormat ${o}`);u=[i,l,e[1],e[1]]}return computeConv2DInfo(e,u,n,a,r,s,!1,o)}function computePool3DInfo(e,t,n,a,r,s,o="NDHWC"){const[i,l,u]=parse3TupleParam(t);let c,d;if("NDHWC"===o)d="channelsLast",c=[i,l,u,e[4],e[4]];else{if("NCDHW"!==o)throw new Error(`Unknown dataFormat ${o}`);d="channelsFirst",c=[i,l,u,e[1],e[1]]}return computeConv3DInfo(e,c,n,a,r,!1,d,s)}function computeConv2DInfo(e,t,n,a,r,s,o=!1,i="channelsLast"){let[l,u,c,d]=[-1,-1,-1,-1];if("channelsLast"===i)[l,u,c,d]=e;else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);[l,d,u,c]=e}const[p,h,,m]=t,[f,g]=parseTupleParam(n),[x,y]=parseTupleParam(a),A=getEffectiveFilterSize(p,x),b=getEffectiveFilterSize(h,y),{padInfo:v,outHeight:k,outWidth:S}=getPadAndOutInfo(r,u,c,f,g,A,b,s,i),w=o?m*d:m;let C;return"channelsFirst"===i?C=[l,w,k,S]:"channelsLast"===i&&(C=[l,k,S,w]),{batchSize:l,dataFormat:i,inHeight:u,inWidth:c,inChannels:d,outHeight:k,outWidth:S,outChannels:w,padInfo:v,strideHeight:f,strideWidth:g,filterHeight:p,filterWidth:h,effectiveFilterHeight:A,effectiveFilterWidth:b,dilationHeight:x,dilationWidth:y,inShape:e,outShape:C,filterShape:t}}function computeConv3DInfo(e,t,n,a,r,s=!1,o="channelsLast",i){let[l,u,c,d,p]=[-1,-1,-1,-1,-1];if("channelsLast"===o)[l,u,c,d,p]=e;else{if("channelsFirst"!==o)throw new Error(`Unknown dataFormat ${o}`);[l,p,u,c,d]=e}const[h,m,f,,g]=t,[x,y,A]=parse3TupleParam(n),[b,v,k]=parse3TupleParam(a),S=getEffectiveFilterSize(h,b),w=getEffectiveFilterSize(m,v),C=getEffectiveFilterSize(f,k),{padInfo:I,outDepth:T,outHeight:N,outWidth:_}=get3DPadAndOutInfo(r,u,c,d,x,y,A,S,w,C,i),E=s?g*p:g;let P;return"channelsFirst"===o?P=[l,E,T,N,_]:"channelsLast"===o&&(P=[l,T,N,_,E]),{batchSize:l,dataFormat:o,inDepth:u,inHeight:c,inWidth:d,inChannels:p,outDepth:T,outHeight:N,outWidth:_,outChannels:E,padInfo:I,strideDepth:x,strideHeight:y,strideWidth:A,filterDepth:h,filterHeight:m,filterWidth:f,effectiveFilterDepth:S,effectiveFilterHeight:w,effectiveFilterWidth:C,dilationDepth:b,dilationHeight:v,dilationWidth:k,inShape:e,outShape:P,filterShape:t}}function computeOutputShape2D(e,t,n,a,r){null==a&&(a=computeDefaultPad(e,t,n));const s=e[0],o=e[1];return[round((s-t+2*a)/n+1,r),round((o-t+2*a)/n+1,r)]}function computeOutputShape4D(e,t,n,a,r,s){null==r&&(r=computeDefaultPad(e,t,a));const o=e[0],i=e[1],l=e[2];return[round((o-t+2*r)/a+1,s),round((i-t+2*r)/a+1,s),round((l-t+2*r)/a+1,s),n]}function computeDefaultPad(e,t,n,a=1){const r=getEffectiveFilterSize(t,a);return Math.floor((e[0]*(n-1)-n+r)/2)}function parseTupleParam(e){return"number"==typeof e?[e,e,e]:2===e.length?[e[0],e[1],1]:e}function parse3TupleParam(e){return"number"==typeof e?[e,e,e]:e}function getEffectiveFilterSize(e,t){return t<=1?e:e+(e-1)*(t-1)}function getPadAndOutInfo(e,t,n,a,r,s,o,i,l){let u,c,d;if("number"==typeof e){u={top:e,bottom:e,left:e,right:e,type:0===e?"VALID":"NUMBER"};const r=computeOutputShape2D([t,n],s,a,e,i);c=r[0],d=r[1]}else if("same"===e){c=Math.ceil(t/a),d=Math.ceil(n/r);const e=Math.max(0,(c-1)*a+s-t),i=Math.max(0,(d-1)*r+o-n),l=Math.floor(e/2),p=e-l,h=Math.floor(i/2);u={top:l,bottom:p,left:h,right:i-h,type:"SAME"}}else if("valid"===e)u={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((t-s+1)/a),d=Math.ceil((n-o+1)/r);else{if("object"!=typeof e)throw Error(`Unknown padding parameter: ${e}`);{const p="channelsLast"===l?e[1][0]:e[2][0],h="channelsLast"===l?e[1][1]:e[2][1],m="channelsLast"===l?e[2][0]:e[3][0],f="channelsLast"===l?e[2][1]:e[3][1];u={top:p,bottom:h,left:m,right:f,type:0===p&&0===h&&0===m&&0===f?"VALID":"EXPLICIT"},c=round((t-s+p+h)/a+1,i),d=round((n-o+m+f)/r+1,i)}}return{padInfo:u,outHeight:c,outWidth:d}}function get3DPadAndOutInfo(e,t,n,a,r,s,o,i,l,u,c){let d,p,h,m;if("number"==typeof e){d={top:e,bottom:e,left:e,right:e,front:e,back:e,type:0===e?"VALID":"NUMBER"};const s=computeOutputShape4D([t,n,a,1],i,1,r,e,c);p=s[0],h=s[1],m=s[2]}else if("same"===e){p=Math.ceil(t/r),h=Math.ceil(n/s),m=Math.ceil(a/o);const e=(p-1)*r+i-t,c=(h-1)*s+l-n,f=(m-1)*o+u-a,g=Math.floor(e/2),x=e-g,y=Math.floor(c/2),A=c-y,b=Math.floor(f/2);d={top:y,bottom:A,left:b,right:f-b,front:g,back:x,type:"SAME"}}else{if("valid"!==e)throw Error(`Unknown padding parameter: ${e}`);d={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},p=Math.ceil((t-i+1)/r),h=Math.ceil((n-l+1)/s),m=Math.ceil((a-u+1)/o)}return{padInfo:d,outDepth:p,outHeight:h,outWidth:m}}function round(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error(`Unknown roundingMode ${t}`)}}function tupleValuesAreOne(e){const[t,n,a]=parseTupleParam(e);return 1===t&&1===n&&1===a}function eitherStridesOrDilationsAreOne(e,t){return tupleValuesAreOne(e)||tupleValuesAreOne(t)}function convertConv2DDataFormat(e){if("NHWC"===e)return"channelsLast";if("NCHW"===e)return"channelsFirst";throw new Error(`Unknown dataFormat ${e}`)}function reshape_(e,t){const n={x:convertToTensor(e,"x","reshape","string_or_numeric")},a={shape:t};return ENGINE.runKernel(Reshape,n,a)}var reshape=op({reshape_:reshape_});function avgPool_(e,t,n,a,r){const s=convertToTensor(e,"x","avgPool","float32");assert(eitherStridesOrDilationsAreOne(n,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`));let o=s,i=!1;3===s.rank&&(i=!0,o=reshape(s,[1,s.shape[0],s.shape[1],s.shape[2]])),assert(4===o.rank,(()=>`Error in avgPool: x must be rank 4 but got rank ${o.rank}.`)),null!=r&&assert(isInt(a),(()=>`Error in avgPool: pad must be an integer when using, dimRoundingMode ${r} but got pad ${a}.`));const l={x:o},u={filterSize:t,strides:n,pad:a,dimRoundingMode:r};let c=ENGINE.runKernel(AvgPool,l,u);return c=cast(c,s.dtype),i?reshape(c,[c.shape[1],c.shape[2],c.shape[3]]):c}var avgPool=op({avgPool_:avgPool_});function avgPool3d_(e,t,n,a,r,s="NDHWC"){const o=convertToTensor(e,"x","avgPool3d","float32");let i=o,l=!1;4===o.rank&&(l=!0,i=reshape(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),assert(5===i.rank,(()=>`Error in avgPool3d: x must be rank 5 but got rank ${i.rank}.`)),assert("NDHWC"===s,(()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`)),null!=r&&assert(isInt(a),(()=>`Error in avgPool3d: pad must be an integer when using, dimRoundingMode ${r} but got pad ${a}.`));const u={x:i},c={filterSize:t,strides:n,pad:a,dimRoundingMode:r,dataFormat:s};let d=ENGINE.runKernel(AvgPool3D,u,c);return d=cast(d,i.dtype),l?reshape(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}var avgPool3d=op({avgPool3d_:avgPool3d_});function concat_(e,t=0){assert(e.length>=1,(()=>"Pass at least one tensor to concat"));const n=convertToTensorArray(e,"tensors","concat","string_or_numeric");if("complex64"===n[0].dtype&&n.forEach((e=>{if("complex64"!==e.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${e.dtype}. `)})),1===n.length)return clone(n[0]);const a=n,r={axis:t};return ENGINE.runKernel(Concat,a,r)}var concat=op({concat_:concat_});function sigmoid_(e){const t={x:convertToTensor(e,"x","sigmoid","float32")};return ENGINE.runKernel(Sigmoid,t)}var sigmoid=op({sigmoid_:sigmoid_});function slice_(e,t,n){const a=convertToTensor(e,"x","slice","string_or_numeric");if(0===a.rank)throw new Error("Slicing scalar is not possible");const r={x:a},s={begin:t,size:n};return ENGINE.runKernel(Slice,r,s)}var slice=op({slice_:slice_});function tanh_(e){const t={x:convertToTensor(e,"x","tanh","float32")};return ENGINE.runKernel(Tanh,t)}var tanh2=op({tanh_:tanh_});function basicLSTMCell_(e,t,n,a,r,s){const o=convertToTensor(e,"forgetBias","basicLSTMCell"),i=convertToTensor(t,"lstmKernel","basicLSTMCell"),l=convertToTensor(n,"lstmBias","basicLSTMCell"),u=convertToTensor(a,"data","basicLSTMCell"),c=convertToTensor(r,"c","basicLSTMCell"),d=convertToTensor(s,"h","basicLSTMCell"),p=concat([u,d],1),h=matMul(p,i),m=add2(h,l),f=m.shape[0],g=m.shape[1]/4,x=[f,g],y=slice(m,[0,0],x),A=slice(m,[0,g],x),b=slice(m,[0,2*g],x),v=slice(m,[0,3*g],x),k=add2(mul(sigmoid(y),tanh2(A)),mul(c,sigmoid(add2(o,b))));return[k,mul(tanh2(k),sigmoid(v))]}var basicLSTMCell=op({basicLSTMCell_:basicLSTMCell_});function batchToSpaceND_(e,t,n){const a=convertToTensor(e,"x","batchToSpaceND"),r=t.reduce(((e,t)=>e*t));assert(a.rank>=1+t.length,(()=>`input rank is ${a.rank} but should be > than blockShape.length ${t.length}`)),assert(n.length===t.length,(()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${t.length}`)),assert(a.shape[0]%r==0,(()=>`input tensor batch is ${a.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${r}`));const s={x:a},o={blockShape:t,crops:n};return ENGINE.runKernel(BatchToSpaceND,s,o)}var batchToSpaceND=op({batchToSpaceND_:batchToSpaceND_});function xAs4D(e){let t;return t=0===e.rank||1===e.rank?reshape(e,[1,1,1,e.size]):2===e.rank?reshape(e,[1,1,e.shape[0],e.shape[1]]):3===e.rank?reshape(e,[1,e.shape[0],e.shape[1],e.shape[2]]):e,t}function batchNorm_(e,t,n,a,r,s){null==s&&(s=.001);const o=convertToTensor(e,"x","batchNorm"),i=convertToTensor(t,"mean","batchNorm"),l=convertToTensor(n,"variance","batchNorm");let u,c;null!=r&&(u=convertToTensor(r,"scale","batchNorm")),null!=a&&(c=convertToTensor(a,"offset","batchNorm")),assert(i.rank===l.rank,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),assert(null==c||i.rank===c.rank,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),assert(null==u||i.rank===u.rank,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));const d={x:xAs4D(o),scale:u,offset:c,mean:i,variance:l},p={varianceEpsilon:s},h=ENGINE.runKernel(FusedBatchNorm,d,p);return reshape(h,o.shape)}var batchNorm=op({batchNorm_:batchNorm_});function batchNorm2d_(e,t,n,a,r,s){const o=convertToTensor(e,"x","batchNorm"),i=convertToTensor(t,"mean","batchNorm"),l=convertToTensor(n,"variance","batchNorm");let u,c;return null!=r&&(u=convertToTensor(r,"scale","batchNorm")),null!=a&&(c=convertToTensor(a,"offset","batchNorm")),assert(2===o.rank,(()=>`Error in batchNorm2D: x must be rank 2 but got rank ${o.rank}.`)),assert(2===i.rank||1===i.rank,(()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${i.rank}.`)),assert(2===l.rank||1===l.rank,(()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`)),null!=u&&assert(2===u.rank||1===u.rank,(()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${u.rank}.`)),null!=c&&assert(2===c.rank||1===c.rank,(()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`)),batchNorm(o,i,l,c,u,s)}var batchNorm2d=op({batchNorm2d_:batchNorm2d_});function batchNorm3d_(e,t,n,a,r,s){const o=convertToTensor(e,"x","batchNorm"),i=convertToTensor(t,"mean","batchNorm"),l=convertToTensor(n,"variance","batchNorm");let u,c;return null!=r&&(u=convertToTensor(r,"scale","batchNorm")),null!=a&&(c=convertToTensor(a,"offset","batchNorm")),assert(3===o.rank,(()=>`Error in batchNorm3D: x must be rank 3 but got rank ${o.rank}.`)),assert(3===i.rank||1===i.rank,(()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${i.rank}.`)),assert(3===l.rank||1===l.rank,(()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`)),null!=u&&assert(3===u.rank||1===u.rank,(()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${u.rank}.`)),null!=c&&assert(3===c.rank||1===c.rank,(()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`)),batchNorm(o,i,l,c,u,s)}var batchNorm3d=op({batchNorm3d_:batchNorm3d_});function batchNorm4d_(e,t,n,a,r,s){const o=convertToTensor(e,"x","batchNorm"),i=convertToTensor(t,"mean","batchNorm"),l=convertToTensor(n,"variance","batchNorm");let u,c;return null!=r&&(u=convertToTensor(r,"scale","batchNorm")),null!=a&&(c=convertToTensor(a,"offset","batchNorm")),assert(4===o.rank,(()=>`Error in batchNorm4D: x must be rank 4 but got rank ${o.rank}.`)),assert(4===i.rank||1===i.rank,(()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${i.rank}.`)),assert(4===l.rank||1===l.rank,(()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`)),null!=u&&assert(4===u.rank||1===u.rank,(()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${u.rank}.`)),null!=c&&assert(4===c.rank||1===c.rank,(()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`)),batchNorm(o,i,l,c,u,s)}var batchNorm4d=op({batchNorm4d_:batchNorm4d_});function bincount_(e,t,n){const a=convertToTensor(e,"x","bincount"),r=convertToTensor(t,"weights","bincount");assert("int32"===a.dtype,(()=>`Error in bincount: input dtype must be int32, but got ${a.dtype}`)),assert(n>=0,(()=>`size must be non-negative, but got ${n}.`)),assert(r.size===a.size||0===r.size,(()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${a.shape}, weights shape: ${r.shape}.`));const s={x:a,weights:r},o={size:n};return ENGINE.runKernel(Bincount,s,o)}var bincount=op({bincount_:bincount_});function broadcastArgs_(e,t){const n=convertToTensor(e,"s0","broadcastArgs","int32"),a=convertToTensor(t,"s1","broadcastArgs","int32");if(1!==n.rank)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${n.rank}`);if(1!==a.rank)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${a.rank}`);const r={s0:n,s1:a};return ENGINE.runKernel(BroadcastArgs,r)}var broadcastArgs=op({broadcastArgs_:broadcastArgs_});function broadcastTo_(e,t){let n=convertToTensor(e,"broadcastTo","x");const a=n.shape;if(t.some((e=>!(e>0)||e%1!=0)))throw new Error(`broadcastTo(): Invalid broadcast shape [${t}].`);if(t.length<n.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${n.rank}.`);if(t.length>n.rank){const e=n.shape.slice();for(;e.length<t.length;)e.unshift(1);n=reshape(n,e)}const r=n.shape,s=Array.from(t);for(let e=t.length-1;e>=0;e--)if(r[e]===t[e])s[e]=1;else if(1!==n.shape[e])throw new Error(`broadcastTo(): [${a}] cannot be broadcast to [${t}].`);if(0===s.map(((e,t)=>e>1?t:-1)).filter((e=>e>=0)).length)return clone(n);const o={x:n},i={reps:s};return ENGINE.runKernel(Tile,o,i)}var broadcastTo=op({broadcastTo_:broadcastTo_});function ceil_(e){const t={x:convertToTensor(e,"x","ceil","float32")};return ENGINE.runKernel(Ceil,t)}var ceil=op({ceil_:ceil_});function clipByValue_(e,t,n){const a=convertToTensor(e,"x","clipByValue");assert(t<=n,(()=>`Error in clip: min (${t}) must be less than or equal to max (${n}).`));const r={x:a},s={clipValueMin:t,clipValueMax:n};return ENGINE.runKernel(ClipByValue,r,s)}var clipByValue=op({clipByValue_:clipByValue_});function concat1d_(e){return concat(e,0)}var concat1d=op({concat1d_:concat1d_});function concat2d_(e,t){return concat(e,t)}var concat2d=op({concat2d_:concat2d_});function concat3d_(e,t){return concat(e,t)}var concat3d=op({concat3d_:concat3d_});function concat4d_(e,t){return concat(e,t)}var concat4d=op({concat4d_:concat4d_});function conv2d_(e,t,n,a,r="NHWC",s=[1,1],o){const i=convertToTensor(e,"x","conv2d","float32"),l=convertToTensor(t,"filter","conv2d","float32");let u=i,c=!1;3===i.rank&&(c=!0,u=reshape(i,[1,i.shape[0],i.shape[1],i.shape[2]])),assert(4===u.rank,(()=>`Error in conv2d: input must be rank 4, but got rank ${u.rank}.`)),assert(4===l.rank,(()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`)),null!=o&&assert(isInt(a),(()=>`Error in conv2d: pad must be an integer when using, dimRoundingMode ${o} but got pad ${a}.`));const d="NHWC"===r?u.shape[3]:u.shape[1];assert(d===l.shape[2],(()=>`Error in conv2d: depth of input (${d}) must match input depth for filter ${l.shape[2]}.`)),assert(eitherStridesOrDilationsAreOne(n,s),(()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`));const p={x:u,filter:l},h={strides:n,pad:a,dataFormat:r,dilations:s,dimRoundingMode:o},m=ENGINE.runKernel(Conv2D,p,h);return c?reshape(m,[m.shape[1],m.shape[2],m.shape[3]]):m}var conv2d=op({conv2d_:conv2d_});function conv1d_(e,t,n,a,r="NWC",s=1,o){const i=convertToTensor(e,"x","conv1d"),l=convertToTensor(t,"filter","conv1d");let u=i,c=!1;2===i.rank&&(c=!0,u=reshape(i,[1,i.shape[0],i.shape[1]])),assert(3===u.rank,(()=>`Error in conv1d: input must be rank 3, but got rank ${u.rank}.`)),assert(3===l.rank,(()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`)),null!=o&&assert(isInt(a),(()=>`Error in conv1d: pad must be an integer when using, dimRoundingMode ${o} but got pad ${a}.`)),assert(u.shape[2]===l.shape[1],(()=>`Error in conv1d: depth of input (${u.shape[2]}) must match input depth for filter ${l.shape[1]}.`)),assert(eitherStridesOrDilationsAreOne(n,s),(()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${s}'`)),assert("NWC"===r,(()=>`Error in conv1d: got dataFormat of ${r} but only NWC is currently supported.`));const d=reshape(l,[1,l.shape[0],l.shape[1],l.shape[2]]),p=reshape(u,[u.shape[0],1,u.shape[1],u.shape[2]]),h=conv2d(p,d,[1,n],a,"NHWC",[1,s],o);return reshape(h,c?[h.shape[2],h.shape[3]]:[h.shape[0],h.shape[2],h.shape[3]])}var conv1d=op({conv1d_:conv1d_});function conv2DBackpropInput_(e,t,n,a,r,s="NHWC",o){assert(e.length===t.rank,(()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`));let i=e,l=t,u=!1;3===t.rank&&(u=!0,l=reshape(t,[1,t.shape[0],t.shape[1],t.shape[2]]),i=[1,e[0],e[1],e[2]]),assert(4===i.length,(()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${i.length}.`)),assert(4===l.rank,(()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`)),assert(4===n.rank,(()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`));const c="NHWC"===s?i[3]:i[1],d="NHWC"===s?l.shape[3]:l.shape[1];assert(c===n.shape[2],(()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${n.shape[2]}.`)),assert(d===n.shape[3],(()=>`Error in conv2dDerInput: depth of output (${d}) must match output depth for filter ${n.shape[3]}.`)),null!=o&&assert(isInt(r),(()=>`Error in conv2dDerInput: pad must be an integer when using, dimRoundingMode ${o} but got pad ${r}.`));const p={dy:l,filter:n},h={strides:a,pad:r,dataFormat:s,dimRoundingMode:o,inputShape:i},m=ENGINE.runKernel(Conv2DBackpropInput,p,h);return u?reshape(m,[m.shape[1],m.shape[2],m.shape[3]]):m}var conv2DBackpropInput=op({conv2DBackpropInput_:conv2DBackpropInput_});function conv2dTranspose_(e,t,n,a,r,s){const o=convertToTensor(e,"x","conv2dTranspose"),i=convertToTensor(t,"filter","conv2dTranspose");return conv2DBackpropInput(n,o,i,a,r,"NHWC",s)}var conv2dTranspose=op({conv2dTranspose_:conv2dTranspose_});function conv3d_(e,t,n,a,r="NDHWC",s=[1,1,1]){const o=convertToTensor(e,"x","conv3d"),i=convertToTensor(t,"filter","conv3d");let l=o,u=!1;4===o.rank&&(u=!0,l=reshape(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),assert(5===l.rank,(()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`)),assert(5===i.rank,(()=>`Error in conv3d: filter must be rank 5, but got rank ${i.rank}.`)),assert(l.shape[4]===i.shape[3],(()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${i.shape[3]}.`)),assert(eitherStridesOrDilationsAreOne(n,s),(()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`)),assert("NDHWC"===r,(()=>`Error in conv3d: got dataFormat of ${r} but only NDHWC is currently supported.`));const c={x:l,filter:i},d={strides:n,pad:a,dataFormat:r,dilations:s},p=ENGINE.runKernel(Conv3D,c,d);return u?reshape(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}var conv3d=op({conv3d_:conv3d_});function conv3DBackpropInput_(e,t,n,a,r){assert(e.length===t.rank,(()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`));let s=e,o=t,i=!1;4===t.rank&&(i=!0,o=reshape(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),s=[1,e[0],e[1],e[2],e[3]]);const l=s[4],u=o.shape[4];assert(5===s.length,(()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${s.length}.`)),assert(5===o.rank,(()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${o.rank}`)),assert(5===n.rank,(()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`)),assert(l===n.shape[3],(()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${n.shape[3]}.`)),assert(u===n.shape[4],(()=>`Error in conv3dDerInput: depth of output (${u}) must match output depth for filter ${n.shape[4]}.`));const c={dy:o,filter:n},d={pad:r,strides:a,inputShape:s},p=ENGINE.runKernel(Conv3DBackpropInputV2,c,d);return i?reshape(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}var conv3DBackpropInput=op({conv3DBackpropInput_:conv3DBackpropInput_});function conv3dTranspose_(e,t,n,a,r){const s=convertToTensor(e,"x","conv3dTranspose"),o=convertToTensor(t,"filter","conv3dTranspose");return conv3DBackpropInput(n,s,o,a,r)}var conv3dTranspose=op({conv3dTranspose_:conv3dTranspose_});function cos_(e){const t={x:convertToTensor(e,"x","cos","float32")};return ENGINE.runKernel(Cos,t)}var cos=op({cos_:cos_});function cosh_(e){const t={x:convertToTensor(e,"x","cosh","float32")};return ENGINE.runKernel(Cosh,t)}var cosh=op({cosh_:cosh_});function cumsum_(e,t=0,n=!1,a=!1){const r={x:convertToTensor(e,"x","cumsum")},s={axis:t,exclusive:n,reverse:a};return ENGINE.runKernel(Cumsum,r,s)}var cumsum=op({cumsum_:cumsum_});function denseBincount_(e,t,n,a=!1){const r=convertToTensor(e,"x","denseBincount"),s=convertToTensor(t,"weights","denseBincount");assert("int32"===r.dtype,(()=>`Error in denseBincount: input dtype must be int32, but got ${r.dtype}`)),assert(r.rank<=2,(()=>`Error in denseBincount: input must be at most rank 2, but got rank ${r.rank}.`)),assert(n>=0,(()=>`size must be non-negative, but got ${n}.`)),assert(s.size===r.size||0===s.size,(()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${r.shape}, weights shape: ${s.shape}.`));const o={x:r,weights:s},i={size:n,binaryOutput:a};return ENGINE.runKernel(DenseBincount,o,i)}var denseBincount=op({denseBincount_:denseBincount_});function depthToSpace_(e,t,n="NHWC"){const a=convertToTensor(e,"x","depthToSpace","float32"),r="NHWC"===n?a.shape[1]:a.shape[2],s="NHWC"===n?a.shape[2]:a.shape[3],o="NHWC"===n?a.shape[3]:a.shape[1];assert(t>1,(()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`)),assert(r*t>=0,(()=>`Negative dimension size caused by overflow when multiplying\n    ${r} and ${t}  for depthToSpace with input shape\n    ${a.shape}`)),assert(s*t>=0,(()=>`Negative dimension size caused by overflow when multiplying\n    ${s} and ${t} for depthToSpace with input shape\n        ${a.shape}`)),assert(o%(t*t)==0,(()=>`Dimension size must be evenly divisible by ${t*t} but is ${o} for depthToSpace with input shape ${a.shape}`));const i={x:a},l={blockSize:t,dataFormat:n};return ENGINE.runKernel(DepthToSpace,i,l)}var depthToSpace=op({depthToSpace_:depthToSpace_});function depthwiseConv2d_(e,t,n,a,r="NHWC",s=[1,1],o){const i=convertToTensor(e,"x","depthwiseConv2d","float32"),l=convertToTensor(t,"filter","depthwiseConv2d","float32");let u=i,c=!1;3===i.rank&&(c=!0,u=reshape(i,[1,i.shape[0],i.shape[1],i.shape[2]])),assert(4===u.rank,(()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${u.rank}.`)),assert(4===l.rank,(()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`)),assert(u.shape[3]===l.shape[2],(()=>`Error in depthwiseConv2d: number of input channels (${u.shape[3]}) must match the inChannels dimension in filter ${l.shape[2]}.`)),null!=o&&assert(isInt(a),(()=>`Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ${o} but got pad ${a}.`));const d={x:u,filter:l},p={strides:n,pad:a,dataFormat:r,dilations:s,dimRoundingMode:o},h=ENGINE.runKernel(DepthwiseConv2dNative,d,p);return c?reshape(h,[h.shape[1],h.shape[2],h.shape[3]]):h}var depthwiseConv2d=op({depthwiseConv2d_:depthwiseConv2d_});function diag_(e){const t={x:convertToTensor(e,"x","diag")};return ENGINE.runKernel(Diag,t)}var diag=op({diag_:diag_});function dilation2d_(e,t,n,a,r=[1,1],s="NHWC"){const o=convertToTensor(e,"x","dilation2d"),i=convertToTensor(t,"filter","dilation2d");assert(3===o.rank||4===o.rank,(()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${o.rank}.`)),assert(3===i.rank,(()=>`Error in dilation2d: filter must be rank 3, but got rank ${i.rank}.`)),assert("NHWC"===s,(()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${s}`));let l=o,u=!1;3===o.rank&&(l=reshape(o,[1,o.shape[0],o.shape[1],o.shape[2]]),u=!0);const c={x:l,filter:i},d={strides:n,pad:a,dilations:r},p=ENGINE.runKernel(Dilation2D,c,d);return u?reshape(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var dilation2d=op({dilation2d_:dilation2d_});function equal_(e,t){let n=convertToTensor(e,"a","equal","string_or_numeric"),a=convertToTensor(t,"b","equal","string_or_numeric");[n,a]=makeTypesMatch(n,a),assertAndGetBroadcastShape(n.shape,a.shape);const r={a:n,b:a};return ENGINE.runKernel(Equal,r)}var equal=op({equal_:equal_});function where_(e,t,n){const a=convertToTensor(t,"a","where"),r=convertToTensor(n,"b","where"),s=convertToTensor(e,"condition","where","bool"),o=assertAndGetBroadcastShape(assertAndGetBroadcastShape(s.shape,a.shape),r.shape),i={condition:broadcastTo(s,o),t:broadcastTo(a,o),e:broadcastTo(r,o)};return ENGINE.runKernel(Select,i)}var where=op({where_:where_});function zerosLike_(e){const t={x:convertToTensor(e,"x","zerosLike")};return ENGINE.runKernel(ZerosLike,t)}var zerosLike=op({zerosLike_:zerosLike_});function divNoNan_(e,t){let n=convertToTensor(e,"a","div"),a=convertToTensor(t,"b","div");[n,a]=makeTypesMatch(n,a);const r=div(n,a),s=zerosLike(r),o=equal(a,s);return where(o,s,r)}var divNoNan=op({divNoNan_:divNoNan_});function dot_(e,t){const n=convertToTensor(e,"t1","dot"),a=convertToTensor(t,"t2","dot");assert(!(1!==n.rank&&2!==n.rank||1!==a.rank&&2!==a.rank),(()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${a.rank}.`));const r=1===n.rank?n.size:n.shape[1],s=1===a.rank?a.size:a.shape[0];if(assert(r===s,(()=>`Error in dot: inner dimensions of inputs must match, but got ${r} and ${s}.`)),1===n.rank&&1===a.rank){const e=reshape(n,[1,-1]),t=reshape(a,[-1,1]),r=matMul(e,t);return reshape(r,[])}if(1===n.rank&&2===a.rank){const e=reshape(n,[1,-1]),t=reshape(a,[a.shape[0],a.shape[1]]),r=matMul(e,t);return reshape(r,[r.size])}if(2===n.rank&&1===a.rank){const e=reshape(a,[-1,1]),t=matMul(n,e);return reshape(t,[t.size])}{const e=reshape(a,[a.shape[0],a.shape[1]]);return matMul(n,e)}}var dot=op({dot_:dot_});function einsum_(e,...t){const n=t.map(((e,t)=>convertToTensor(e,`tensors${t}`,"einsum"))),a={equation:e};return ENGINE.runKernel(Einsum,n,a)}var einsum=op({einsum_:einsum_});function elu_(e){const t={x:convertToTensor(e,"x","elu","float32")};return ENGINE.runKernel(Elu,t)}var elu=op({elu_:elu_});function erf_(e){let t=convertToTensor(e,"x","erf");assert("int32"===t.dtype||"float32"===t.dtype,(()=>"Input dtype must be `int32` or `float32`.")),"int32"===t.dtype&&(t=cast(t,"float32"));const n={x:t};return ENGINE.runKernel(Erf,n)}var erf=op({erf_:erf_});function exp_(e){const t={x:convertToTensor(e,"x","exp")};return ENGINE.runKernel(Exp,t)}var exp=op({exp_:exp_});function expandDims_(e,t=0){const n=convertToTensor(e,"x","expandDims","string_or_numeric");assert(t<=n.rank,(()=>"Axis must be <= rank of the tensor"));const a={input:n},r={dim:t};return ENGINE.runKernel(ExpandDims,a,r)}var expandDims=op({expandDims_:expandDims_});function expm1_(e){const t={x:convertToTensor(e,"x","expm1")};return ENGINE.runKernel(Expm1,t)}var expm1=op({expm1_:expm1_});function tile_(e,t){const n=convertToTensor(e,"x","tile","string_or_numeric");assert(n.rank===t.length,(()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${t}.`));const a={x:n},r={reps:t};return ENGINE.runKernel(Tile,a,r)}var tile=op({tile_:tile_});function eye_(e,t,n,a="float32"){null==t&&(t=e);const r=buffer([e,t],a),s=e<=t?e:t;for(let e=0;e<s;++e)r.set(1,e,e);const o=reshape(r.toTensor(),[e,t]);if(null==n)return o;if(1===n.length)return tile(expandDims(o,0),[n[0],1,1]);if(2===n.length)return tile(expandDims(expandDims(o,0),0),[n[0],n[1],1,1]);if(3===n.length)return tile(expandDims(expandDims(expandDims(o,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}var eye=op({eye_:eye_});function fill(e,t,n){const a={shape:e,value:t,dtype:n};return ENGINE.runKernel(Fill,{},a)}function floor_(e){const t={x:convertToTensor(e,"x","floor","float32")};return ENGINE.runKernel(Floor,t)}var floor=op({floor_:floor_});function gather_(e,t,n=0,a=0){const r={x:convertToTensor(e,"x","gather"),indices:convertToTensor(t,"indices","gather","int32")},s={axis:n,batchDims:a};return ENGINE.runKernel(GatherV2,r,s)}var gather=op({gather_:gather_});function greater_(e,t){let n=convertToTensor(e,"a","greater","string_or_numeric"),a=convertToTensor(t,"b","greater","string_or_numeric");[n,a]=makeTypesMatch(n,a),assertAndGetBroadcastShape(n.shape,a.shape);const r={a:n,b:a};return ENGINE.runKernel(Greater,r)}var greater=op({greater_:greater_});function greaterEqual_(e,t){let n=convertToTensor(e,"a","greaterEqual","string_or_numeric"),a=convertToTensor(t,"b","greaterEqual","string_or_numeric");[n,a]=makeTypesMatch(n,a),assertAndGetBroadcastShape(n.shape,a.shape);const r={a:n,b:a};return ENGINE.runKernel(GreaterEqual,r)}var greaterEqual=op({greaterEqual_:greaterEqual_});function imag_(e){const t={input:convertToTensor(e,"input","imag")};return ENGINE.runKernel(Imag,t)}var imag=op({imag_:imag_});function isFinite_(e){const t={x:convertToTensor(e,"x","isFinite")};return ENGINE.runKernel(IsFinite,t)}var isFinite2=op({isFinite_:isFinite_});function isInf_(e){const t={x:convertToTensor(e,"x","isInf")};return ENGINE.runKernel(IsInf,t)}var isInf=op({isInf_:isInf_});function isNaN_(e){const t={x:convertToTensor(e,"x","isNaN")};return ENGINE.runKernel(IsNan,t)}var isNaN2=op({isNaN_:isNaN_});function leakyRelu_(e,t=.2){const n={x:convertToTensor(e,"x","leakyRelu")},a={alpha:t};return ENGINE.runKernel(LeakyRelu,n,a)}var leakyRelu=op({leakyRelu_:leakyRelu_});function less_(e,t){let n=convertToTensor(e,"a","less","string_or_numeric"),a=convertToTensor(t,"b","less","string_or_numeric");[n,a]=makeTypesMatch(n,a),assertAndGetBroadcastShape(n.shape,a.shape);const r={a:n,b:a};return ENGINE.runKernel(Less,r)}var less=op({less_:less_});function lessEqual_(e,t){let n=convertToTensor(e,"a","lessEqual","string_or_numeric"),a=convertToTensor(t,"b","lessEqual","string_or_numeric");[n,a]=makeTypesMatch(n,a),assertAndGetBroadcastShape(n.shape,a.shape);const r={a:n,b:a};return ENGINE.runKernel(LessEqual,r)}var lessEqual=op({lessEqual_:lessEqual_});function linspace(e,t,n){if(n<=0)throw new Error("The number of values should be positive.");const a={start:e,stop:t,num:n};return ENGINE.runKernel(LinSpace,{},a)}function localResponseNormalization_(e,t=5,n=1,a=1,r=.5){const s=convertToTensor(e,"x","localResponseNormalization");assert(4===s.rank||3===s.rank,(()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${s.rank}.`)),assert(isInt(t),(()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`));let o=s,i=!1;3===s.rank&&(i=!0,o=reshape(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const l={x:o},u={depthRadius:t,bias:n,alpha:a,beta:r},c=ENGINE.runKernel(LRN,l,u);return i?reshape(c,[c.shape[1],c.shape[2],c.shape[3]]):c}var localResponseNormalization=op({localResponseNormalization_:localResponseNormalization_});function log_(e){const t={x:convertToTensor(e,"x","log","float32")};return ENGINE.runKernel(Log,t)}var log4=op({log_:log_});function log1p_(e){const t={x:convertToTensor(e,"x","log1p")};return ENGINE.runKernel(Log1p,t)}var log1p=op({log1p_:log1p_});function grad(e){return assert(isFunction(e),(()=>"The f passed in grad(f) must be a function")),(t,n)=>{const a=convertToTensor(t,"x","tf.grad","string_or_numeric"),r=null!=n?convertToTensor(n,"dy","tf.grad"):null;return ENGINE.tidy((()=>{const{value:t,grads:n}=ENGINE.gradients((()=>e(a)),[a],r);return null!=r&&assertShapesMatch(t.shape,r.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),checkGrads(n),n[0]}))}}function grads(e){return assert(isFunction(e),(()=>"The f passed in grads(f) must be a function")),(t,n)=>{assert(Array.isArray(t),(()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s"));const a=convertToTensorArray(t,"args","tf.grads","string_or_numeric"),r=null!=n?convertToTensor(n,"dy","tf.grads"):null;return ENGINE.tidy((()=>{const{value:t,grads:n}=ENGINE.gradients((()=>e(...a)),a,r);return null!=r&&assertShapesMatch(t.shape,r.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),checkGrads(n),n}))}}function valueAndGrad(e){return assert(isFunction(e),(()=>"The f passed in valueAndGrad(f) must be a function")),(t,n)=>{assert(t instanceof Tensor,(()=>"The x passed in valueAndGrad(f)(x) must be a tensor")),assert(null==n||n instanceof Tensor,(()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor"));const{grads:a,value:r}=ENGINE.gradients((()=>e(t)),[t],n);return checkGrads(a),{grad:a[0],value:r}}}function valueAndGrads(e){return assert(isFunction(e),(()=>"The f passed in valueAndGrads(f) must be a function")),(t,n)=>{assert(Array.isArray(t)&&t.every((e=>e instanceof Tensor)),(()=>"The args passed in valueAndGrads(f)(args) must be array of tensors")),assert(null==n||n instanceof Tensor,(()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor"));const a=ENGINE.gradients((()=>e(...t)),t,n);return null!=n&&assertShapesMatch(a.value.shape,n.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),checkGrads(a.grads),a}}function variableGrads(e,t){assert(isFunction(e),(()=>"The f passed in variableGrads(f) must be a function")),assert(null==t||Array.isArray(t)&&t.every((e=>e instanceof Variable)),(()=>"The varList passed in variableGrads(f, varList) must be an array of variables"));const n=null!=t;if(!n){t=[];for(const e in ENGINE.registeredVariables)t.push(ENGINE.registeredVariables[e])}const a=n?t.filter((e=>!e.trainable)):null,r=t.length;assert((t=t.filter((e=>e.trainable))).length>0,(()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${r} variables is trainable.`));const{value:s,grads:o}=ENGINE.gradients(e,t,null,!0);assert(o.some((e=>null!=e)),(()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().")),assert(0===s.rank,(()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${s.rank} tensor`));const i={};return t.forEach(((e,t)=>{null!=o[t]&&(i[e.name]=o[t])})),null!=a&&a.forEach((e=>i[e.name]=null)),{value:s,grads:i}}function customGrad(e){return ENGINE.customGrad(e)}function checkGrads(e){if(e.filter((e=>null==e)).length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that\n    the f you passed encloses all operations that lead from x to y.")}function neg_(e){const t={x:convertToTensor(e,"x","neg")};return ENGINE.runKernel(Neg,t)}var neg=op({neg_:neg_});function softplus_(e){const t={x:convertToTensor(e,"x","softplus")};return ENGINE.runKernel(Softplus,t)}var softplus=op({softplus_:softplus_});function logSigmoid_(e){const t=convertToTensor(e,"x","logSigmoid");return customGrad((e=>({value:neg(softplus(neg(e))),gradFunc:t=>mul(t,sigmoid(neg(e)))})))(t)}var logSigmoid=op({logSigmoid_:logSigmoid_});function max_(e,t=null,n=!1){const a={x:convertToTensor(e,"x","max")},r={reductionIndices:t,keepDims:n};return ENGINE.runKernel(Max,a,r)}var max=op({max_:max_});function sub_(e,t){let n=convertToTensor(e,"a","sub"),a=convertToTensor(t,"b","sub");[n,a]=makeTypesMatch(n,a);const r={a:n,b:a};return ENGINE.runKernel(Sub,r)}var sub=op({sub_:sub_});function sum_(e,t=null,n=!1){let a=convertToTensor(e,"x","sum");"bool"===a.dtype&&(a=cast(a,"int32"));const r={x:a},s={axis:t,keepDims:n};return ENGINE.runKernel(Sum,r,s)}var sum2=op({sum_:sum_});function logSoftmax_(e,t=-1){const n=convertToTensor(e,"logits","logSoftmax");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${t}`);return customGrad(((e,n)=>{const a=max(e,t,!0),r=sub(e,a),s=sub(cast(r,"float32"),log4(sum2(exp(r),t,!0)));n([s]);return{value:s,gradFunc:(e,n)=>{const[a]=n,r=exp(a);return sub(e,mul(sum2(e,t,!0),r))}}}))(n)}var logSoftmax=op({logSoftmax_:logSoftmax_});function axesAreInnerMostDims(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function combineLocations(e,t,n){const a=e.length+t.length,r=[];let s=0,o=0;for(let i=0;i<a;i++)-1===n.indexOf(i)?r.push(e[s++]):r.push(t[o++]);return r}function computeOutAndReduceShapes(e,t){const n=[],a=e.length;for(let r=0;r<a;r++)-1===t.indexOf(r)&&n.push(e[r]);return[n,t.map((t=>e[t]))]}function expandShapeToKeepDim(e,t){return combineLocations(e,t.map((e=>1)),t)}function assertAxesAreInnerMostDims(e,t,n){assert(axesAreInnerMostDims(t,n),(()=>`${e} supports only inner-most axes for now. Got axes ${t} and rank-${n} input.`))}function getAxesPermutation(e,t){if(axesAreInnerMostDims(e,t))return null;const n=[];for(let a=0;a<t;++a)-1===e.indexOf(a)&&n.push(a);return e.forEach((e=>n.push(e))),n}function getUndoAxesPermutation(e){return e.map(((e,t)=>[t,e])).sort(((e,t)=>e[1]-t[1])).map((e=>e[0]))}function getInnerMostAxes(e,t){const n=[];for(let a=t-e;a<t;++a)n.push(a);return n}function logSumExp_(e,t=null,n=!1){const a=convertToTensor(e,"x","logSumExp"),r=parseAxisParam(t,a.shape),s=max(a,r,!0),o=sub(a,s),i=exp(o),l=sum2(i,r),u=log4(l),c=add2(reshape(s,u.shape),u);if(n){const e=expandShapeToKeepDim(c.shape,r);return reshape(c,e)}return c}var logSumExp=op({logSumExp_:logSumExp_});function logicalAnd_(e,t){const n=convertToTensor(e,"a","logicalAnd","bool"),a=convertToTensor(t,"b","logicalAnd","bool");assertAndGetBroadcastShape(n.shape,a.shape);const r={a:n,b:a};return ENGINE.runKernel(LogicalAnd,r)}var logicalAnd=op({logicalAnd_:logicalAnd_});function logicalNot_(e){const t={x:convertToTensor(e,"x","logicalNot","bool")};return ENGINE.runKernel(LogicalNot,t)}var logicalNot=op({logicalNot_:logicalNot_});function logicalOr_(e,t){const n=convertToTensor(e,"a","logicalOr","bool"),a=convertToTensor(t,"b","logicalOr","bool");assertAndGetBroadcastShape(n.shape,a.shape);const r={a:n,b:a};return ENGINE.runKernel(LogicalOr,r)}var logicalOr=op({logicalOr_:logicalOr_});function logicalXor_(e,t){const n=convertToTensor(e,"a","logicalXor","bool"),a=convertToTensor(t,"b","logicalXor","bool");return assertAndGetBroadcastShape(n.shape,a.shape),logicalAnd(logicalOr(e,t),logicalNot(logicalAnd(e,t)))}var logicalXor=op({logicalXor_:logicalXor_});function maxPool_(e,t,n,a,r){const s=convertToTensor(e,"x","maxPool");let o=s,i=!1;3===s.rank&&(i=!0,o=reshape(s,[1,s.shape[0],s.shape[1],s.shape[2]])),assert(4===o.rank,(()=>`Error in maxPool: input must be rank 4 but got rank ${o.rank}.`)),assert(eitherStridesOrDilationsAreOne(n,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`)),null!=r&&assert(isInt(a),(()=>`Error in maxPool: pad must be an integer when using, dimRoundingMode ${r} but got pad ${a}.`));const l={x:o},u={filterSize:t,strides:n,pad:a,dimRoundingMode:r},c=ENGINE.runKernel(MaxPool,l,u);return i?reshape(c,[c.shape[1],c.shape[2],c.shape[3]]):c}var maxPool=op({maxPool_:maxPool_});function maxPool3d_(e,t=[1,1,1],n,a,r,s="NDHWC"){const o=convertToTensor(e,"x","maxPool3d");let i=o,l=!1;4===o.rank&&(l=!0,i=reshape(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),assert(5===i.rank,(()=>`Error in maxPool3d: x must be rank 5 but got rank ${i.rank}.`)),assert("NDHWC"===s,(()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`)),null!=r&&assert(isInt(a),(()=>`Error in maxPool3d: pad must be an integer when using, dimRoundingMode ${r} but got pad ${a}.`));const u={x:i},c={filterSize:t,strides:n,pad:a,dimRoundingMode:r,dataFormat:s},d=ENGINE.runKernel(MaxPool3D,u,c);return l?reshape(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}var maxPool3d=op({maxPool3d_:maxPool3d_});function maxPoolWithArgmax_(e,t,n,a,r=!1){const s={x:convertToTensor(e,"x","maxPoolWithArgmax")},o={filterSize:t,strides:n,pad:a,includeBatchInIndex:r},i=ENGINE.runKernel(MaxPoolWithArgmax,s,o);return{result:i[0],indexes:i[1]}}var maxPoolWithArgmax=op({maxPoolWithArgmax_:maxPoolWithArgmax_});function maximum_(e,t){let n=convertToTensor(e,"a","maximum"),a=convertToTensor(t,"b","maximum");[n,a]=makeTypesMatch(n,a),"bool"===n.dtype&&(n=cast(n,"int32"),a=cast(a,"int32")),assertAndGetBroadcastShape(n.shape,a.shape);const r={a:n,b:a};return ENGINE.runKernel(Maximum,r)}var maximum=op({maximum_:maximum_});function mean_(e,t=null,n=!1){const a={x:convertToTensor(e,"x","mean")},r={axis:t,keepDims:n};return ENGINE.runKernel(Mean,a,r)}var mean=op({mean_:mean_});function zeros(e,t="float32"){if("complex64"===t){const t=zeros(e,"float32"),n=zeros(e,"float32");return complex(t,n)}const n=makeZerosTypedArray(sizeFromShape(e),t);return ENGINE.makeTensor(n,e,t)}function ones2(e,t="float32"){if("complex64"===t){const t=ones2(e,"float32"),n=zeros(e,"float32");return complex(t,n)}const n=makeOnesTypedArray(sizeFromShape(e),t);return ENGINE.makeTensor(n,e,t)}function meshgrid(e,t,{indexing:n="xy"}={}){if("xy"!==n&&"ij"!==n)throw new TypeError(`${n} is not a valid third argument to meshgrid`);if(void 0===e)return[];let a=convertToTensor(e,"x","meshgrid",e instanceof Tensor?e.dtype:"float32");if(void 0===t)return[a];let r=convertToTensor(t,"y","meshgrid",t instanceof Tensor?t.dtype:"float32");const s=sizeFromShape(a.shape),o=sizeFromShape(r.shape);return"xy"===n?(a=reshape(a,[1,-1]),r=reshape(r,[-1,1]),[matMul(ones2([o,1],a.dtype),a),matMul(r,ones2([1,s],r.dtype))]):(a=reshape(a,[-1,1]),r=reshape(r,[1,-1]),[matMul(a,ones2([1,o],a.dtype)),matMul(ones2([s,1],r.dtype),r)])}function min_(e,t=null,n=!1){const a={x:convertToTensor(e,"x","min")},r={axis:t,keepDims:n};return ENGINE.runKernel(Min,a,r)}var min=op({min_:min_});function minimum_(e,t){let n=convertToTensor(e,"a","minimum"),a=convertToTensor(t,"b","minimum");[n,a]=makeTypesMatch(n,a),"bool"===n.dtype&&(n=cast(n,"int32"),a=cast(a,"int32")),assertAndGetBroadcastShape(n.shape,a.shape);const r={a:n,b:a};return ENGINE.runKernel(Minimum,r)}var minimum=op({minimum_:minimum_});function mirrorPad_(e,t,n){assert("reflect"===n||"symmetric"===n,(()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`));const a=convertToTensor(e,"x","mirrorPad");if(0===a.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");assert(t.length===a.rank,(()=>`Padding doesn't match input. Must be ${a.rank}. Got ${t.length}.`));const r="reflect"===n?1:0;for(let e=0;e<a.rank;e++)assert(2===t[e].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),assert(t[e][0]>=0&&t[e][0]<=a.shape[e]-r&&t[e][1]>=0&&t[e][1]<=a.shape[e]-r,(()=>`Padding in dimension ${e} cannot be greater than or equal to ${a.shape[e]-r} or less than 0 for input of shape ${a.shape}`));const s={paddings:t,mode:n},o={x:a};return ENGINE.runKernel(MirrorPad,o,s)}var mirrorPad=op({mirrorPad_:mirrorPad_});function mod_(e,t){let n=convertToTensor(e,"a","mod"),a=convertToTensor(t,"b","mod");[n,a]=makeTypesMatch(n,a);const r={a:n,b:a};return ENGINE.runKernel(Mod,r)}var mod=op({mod_:mod_});function square_(e){const t=convertToTensor(e,"x","square");return ENGINE.runKernel("Square",{x:t},{})}var square=op({square_:square_});function moments_(e,t=null,n=!1){const a=parseAxisParam(t,(e=convertToTensor(e,"x","moments")).shape),r=mean(e,a,n);let s=r.shape;n||(s=expandShapeToKeepDim(r.shape,a));const o=square(sub(cast(e,"float32"),reshape(r,s)));return{mean:r,variance:mean(o,a,n)}}var moments=op({moments_:moments_});function multiRNNCell_(e,t,n,a){const r=convertToTensor(t,"data","multiRNNCell"),s=convertToTensorArray(n,"c","multiRNNCell"),o=convertToTensorArray(a,"h","multiRNNCell");let i=r;const l=[];for(let t=0;t<e.length;t++){const n=e[t](i,s[t],o[t]);l.push(n[0]),l.push(n[1]),i=n[1]}const u=[],c=[];for(let e=0;e<l.length;e+=2)u.push(l[e]),c.push(l[e+1]);return[u,c]}var multiRNNCell=op({multiRNNCell_:multiRNNCell_});function multinomial_(e,t,n,a=!1){const r=convertToTensor(e,"logits","multinomial"),s=r.size,o=r.rank;if(s<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${s}.`);if(o>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${o}`);n=n||Math.random();const i={logits:1===o?reshape(r,[1,-1]):r},l={numSamples:t,seed:n,normalized:a},u=ENGINE.runKernel(Multinomial,i,l);return 1===o?reshape(u,[u.size]):u}var multinomial=op({multinomial_:multinomial_});function notEqual_(e,t){let n=convertToTensor(e,"a","notEqual","string_or_numeric"),a=convertToTensor(t,"b","notEqual","string_or_numeric");[n,a]=makeTypesMatch(n,a),assertAndGetBroadcastShape(n.shape,a.shape);const r={a:n,b:a};return ENGINE.runKernel(NotEqual,r)}var notEqual=op({notEqual_:notEqual_});function onesLike_(e){const t={x:convertToTensor(e,"x","onesLike")};return ENGINE.runKernel(OnesLike,t)}var onesLike=op({onesLike_:onesLike_});function outerProduct_(e,t){const n=convertToTensor(e,"v1","outerProduct"),a=convertToTensor(t,"v2","outerProduct");assert(1===n.rank&&1===a.rank,(()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${a.rank}.`));const r=reshape(n,[-1,1]),s=reshape(a,[1,-1]);return matMul(r,s)}var outerProduct=op({outerProduct_:outerProduct_});function pad_(e,t,n=0){const a=convertToTensor(e,"x","pad");if(0===a.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const r={paddings:t,constantValue:n},s={x:a};return ENGINE.runKernel(PadV2,s,r)}var pad=op({pad_:pad_});function pad1d_(e,t,n=0){return assert(2===t.length,(()=>"Invalid number of paddings. Must be length of 2.")),pad(e,[t],n)}var pad1d=op({pad1d_:pad1d_});function pad2d_(e,t,n=0){return assert(2===t.length&&2===t[0].length&&2===t[1].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),pad(e,t,n)}var pad2d=op({pad2d_:pad2d_});function pad3d_(e,t,n=0){return assert(3===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),pad(e,t,n)}var pad3d=op({pad3d_:pad3d_});function pad4d_(e,t,n=0){return assert(4===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length&&2===t[3].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),pad(e,t,n)}var pad4d=op({pad4d_:pad4d_});function spaceToBatchND_(e,t,n){const a=convertToTensor(e,"x","spaceToBatchND");assert(a.rank>=1+t.length,(()=>`input rank ${a.rank} should be > than [blockShape] ${t.length}`)),assert(n.length===t.length,(()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${t.length}`)),assert(a.shape.reduce(((e,a,r)=>r>0&&r<=t.length?e&&(a+n[r-1][0]+n[r-1][1])%t[r-1]==0:e),!0),(()=>`input spatial dimensions ${a.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${t.toString()}`));const r={x:a},s={blockShape:t,paddings:n};return ENGINE.runKernel(SpaceToBatchND,r,s)}var spaceToBatchND=op({spaceToBatchND_:spaceToBatchND_});function pool_(e,t,n,a,r,s){null==r&&(r=[1,1]),null==s&&(s=1),0===a&&(a="valid");const o=convertToTensor(e,"x","maxPool");let i=o,l=!1;3===o.rank&&(l=!0,i=reshape(o,[1,o.shape[0],o.shape[1],o.shape[2]])),assert(eitherStridesOrDilationsAreOne(s,r),(()=>`Error in pool: Either strides or dilations must be 1. Got strides ${s} and dilations '${r}'`));const u=computePool2DInfo(i.shape,t,s,r,a),c=[u.dilationHeight,u.dilationWidth];let d;d="same"===a?withSpaceToBatchBasePaddings([u.filterHeight,u.filterWidth],c):[[0,0],[0,0]];const p=1===c[0]&&1===c[1],[h,m]=requiredSpaceToBatchPaddings([u.inHeight,u.inWidth],c,d),f=p?a:"valid",g=p?i:spaceToBatchND(i,c,h),x=("avg"===n?()=>avgPool(g,t,s,f):()=>maxPool(g,t,s,f))(),y=p?x:batchToSpaceND(x,c,m);return l?reshape(y,[y.shape[1],y.shape[2],y.shape[3]]):y}function requiredSpaceToBatchPaddings(e,t,n){const a=n.map((e=>e[0])),r=n.map((e=>e[1])),s=e.concat(a,r),o=t.map(((e,t)=>(e-s[t]%e)%e)),i=r.map(((e,t)=>e+o[t]));return[t.map(((e,t)=>[a[t],i[t]])),t.map(((e,t)=>[0,o[t]]))]}function withSpaceToBatchBasePaddings(e,t){const n=e.map(((e,n)=>e+(e-1)*(t[n]-1))).map((e=>e-1)),a=n.map((e=>Math.floor(e/2))),r=n.map(((e,t)=>e-a[t]));return n.map(((e,t)=>[a[t],r[t]]))}var pool=op({pool_:pool_});function pow_(e,t){let n=convertToTensor(e,"base","pow"),a=convertToTensor(t,"exp","pow");[n,a]=makeTypesMatch(n,a);const r={a:n,b:a};return ENGINE.runKernel(Pow,r)}var pow=op({pow_:pow_});function prelu_(e,t){const n={x:convertToTensor(e,"x","prelu"),alpha:convertToTensor(t,"alpha","prelu")};return ENGINE.runKernel(Prelu,n)}var prelu=op({prelu_:prelu_});function prod_(e,t=null,n=!1){let a=convertToTensor(e,"x","prod");"bool"===a.dtype&&(a=cast(a,"int32"));const r={x:a},s={axis:t,keepDims:n};return ENGINE.runKernel(Prod,r,s)}var prod=op({prod_:prod_});function rand_(e,t,n){const a=sizeFromShape(e);let r=null;if(null==n||"float32"===n)r=new Float32Array(a);else if("int32"===n)r=new Int32Array(a);else{if("bool"!==n)throw new Error(`Unknown data type ${n}`);r=new Uint8Array(a)}for(let e=0;e<a;e++)r[e]=t();return ENGINE.makeTensor(r,e,n)}var rand=op({rand_:rand_}),seedrandom=__toModule(require_seedrandom2()),MPRandGauss=class{constructor(e,t,n,a,r){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=a,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const s=r||Math.random();this.random=seedrandom.alea(s.toString())}nextValue(){if(!isNaN(this.nextVal)){const e=this.nextVal;return this.nextVal=NaN,e}let e,t,n=!1;for(;!n;){let a,r,s;do{a=2*this.random()-1,r=2*this.random()-1,s=a*a+r*r}while(s>=1||0===s);const o=Math.sqrt(-2*Math.log(s)/s);e=this.mean+this.stdDev*a*o,t=this.mean+this.stdDev*r*o,this.truncated&&!this.isValidTruncated(e)||(n=!0)}return this.truncated&&!this.isValidTruncated(t)||(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return null==this.dtype||"float32"===this.dtype?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}},RandGamma=class{constructor(e,t,n,a){this.alpha=e,this.beta=1/t,this.dtype=n;const r=a||Math.random();this.randu=seedrandom.alea(r.toString()),this.randn=new MPRandGauss(0,1,n,!1,this.randu()),this.d=e<1?e+2/3:e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,n,a,r,s;for(;;){do{a=this.randn.nextValue(),s=1+this.c*a}while(s<=0);if(s*=s*s,e=a*a,t=1-.331*e*e,n=.5*e+this.d*(1-s+Math.log(s)),r=this.randu(),r<t||Math.log(r)<n)break}return s=1/this.beta*this.d*s,this.alpha<1&&(s*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(s)}convertValue(e){return"float32"===this.dtype?e:Math.round(e)}},UniformRandom=class{constructor(e=0,t=1,n,a){if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=e,this.range=t-e,this.dtype=n,null==a&&(a=Math.random()),"number"==typeof a&&(a=a.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=seedrandom.alea(a)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}};function randomGamma_(e,t,n=1,a="float32",r){if(null==n&&(n=1),null==a&&(a="float32"),"float32"!==a&&"int32"!==a)throw new Error(`Unsupported data type ${a}`);const s=new RandGamma(t,n,a,r),o=buffer(e,a);for(let e=0;e<o.values.length;e++)o.values[e]=s.nextValue();return o.toTensor()}var randomGamma=op({randomGamma_:randomGamma_});function randomNormal_(e,t=0,n=1,a,r){if(null!=a&&"bool"===a)throw new Error(`Unsupported data type ${a}`);const s=new MPRandGauss(t,n,a,!1,r),o=buffer(e,a);for(let e=0;e<o.values.length;e++)o.values[e]=s.nextValue();return o.toTensor()}var randomNormal=op({randomNormal_:randomNormal_});function randomUniform_(e,t=0,n=1,a="float32",r){const s=buffer(e,a),o=new UniformRandom(t,n,null,r);for(let e=0;e<s.values.length;e++)s.values[e]=o.nextValue();return s.toTensor()}var randomUniform=op({randomUniform_:randomUniform_});function range(e,t,n=1,a="float32"){if(0===n)throw new Error("Cannot have a step of zero");const r={start:e,stop:t,step:n,dtype:a};return ENGINE.runKernel(Range,{},r)}function real_(e){const t={input:convertToTensor(e,"input","real")};return ENGINE.runKernel(Real,t)}var real=op({real_:real_});function reciprocal_(e){const t={x:convertToTensor(e,"x","reciprocal")};return ENGINE.runKernel(Reciprocal,t)}var reciprocal=op({reciprocal_:reciprocal_});function relu_(e){const t={x:convertToTensor(e,"x","relu")};return ENGINE.runKernel(Relu,t)}var relu=op({relu_:relu_});function relu6_(e){const t={x:convertToTensor(e,"x","relu6")};return ENGINE.runKernel(Relu6,t)}var relu6=op({relu6_:relu6_});function reverse_(e,t){const n={x:convertToTensor(e,"x","reverse")},a={dims:t};return ENGINE.runKernel(Reverse,n,a)}var reverse=op({reverse_:reverse_});function reverse1d_(e){const t=convertToTensor(e,"x","reverse");return assert(1===t.rank,(()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`)),reverse(t,0)}var reverse1d=op({reverse1d_:reverse1d_});function reverse2d_(e,t){const n=convertToTensor(e,"x","reverse");return assert(2===n.rank,(()=>`Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`)),reverse(n,t)}var reverse2d=op({reverse2d_:reverse2d_});function reverse3d_(e,t){const n=convertToTensor(e,"x","reverse");return assert(3===n.rank,(()=>`Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`)),reverse(n,t)}var reverse3d=op({reverse3d_:reverse3d_});function reverse4d_(e,t){const n=convertToTensor(e,"x","reverse");return assert(4===n.rank,(()=>`Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`)),reverse(n,t)}var reverse4d=op({reverse4d_:reverse4d_});function round_(e){const t={x:convertToTensor(e,"x","round")};return ENGINE.runKernel(Round,t)}var round2=op({round_:round_});function rsqrt_(e){const t={x:convertToTensor(e,"x","rsqrt","float32")};return ENGINE.runKernel(Rsqrt,t)}var rsqrt=op({rsqrt_:rsqrt_});function scalar(e,t){if((isTypedArray(e)&&"string"!==t||Array.isArray(e))&&"complex64"!==t)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===t&&isTypedArray(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return makeTensor(e,[],[],t)}function selu_(e){const t={x:convertToTensor(e,"x","selu")};return ENGINE.runKernel(Selu,t)}var selu=op({selu_:selu_});function separableConv2d_(e,t,n,a,r,s=[1,1],o="NHWC"){const i=convertToTensor(e,"x","separableConv2d"),l=convertToTensor(t,"depthwiseFilter","separableConv2d"),u=convertToTensor(n,"pointwiseFilter","separableConv2d");let c=i,d=!1;if(3===i.rank&&(d=!0,c=reshape(i,[1,i.shape[0],i.shape[1],i.shape[2]])),"NCHW"===o)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");assert(4===c.rank,(()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`)),assert(4===l.rank,(()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`)),assert(4===u.rank,(()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`)),assert(1===u.shape[0],(()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`)),assert(1===u.shape[1],(()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`));const p=l.shape[2],h=l.shape[3];assert(u.shape[2]===p*h,(()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${p*h}, but got ${u.shape[2]}.`));const m=depthwiseConv2d(c,l,a,r,o,s),f=conv2d(m,u,1,"valid",o);return d?reshape(f,[f.shape[1],f.shape[2],f.shape[3]]):f}var separableConv2d=op({separableConv2d_:separableConv2d_});async function setdiff1dAsync_(e,t){const n=convertToTensor(e,"x","setdiff1d"),a=convertToTensor(t,"y","setdiff1d");assert(n.dtype===a.dtype,(()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${a.dtype}).`)),assert(1===n.rank,(()=>`x should be 1D tensor, but got x (${n.shape}).`)),assert(1===a.rank,(()=>`y should be 1D tensor, but got y (${a.shape}).`));const r=await n.data(),s=await a.data(),o=new Set(s);let i=0;for(let e=0;e<r.length;e++)o.has(r[e])||i++;const l=new TensorBuffer([i],n.dtype),u=new TensorBuffer([i],"int32");for(let e=0,t=0;e<r.length;e++)o.has(r[e])||(l.values[t]=r[e],u.values[t]=e,t++);return[l.toTensor(),u.toTensor()]}var setdiff1dAsync=setdiff1dAsync_;function sign_(e){const t={x:convertToTensor(e,"x","sign")};return ENGINE.runKernel(Sign,t)}var sign=op({sign_:sign_});function sin_(e){const t={x:convertToTensor(e,"x","sin","float32")};return ENGINE.runKernel(Sin,t)}var sin=op({sin_:sin_});function sinh_(e){const t={x:convertToTensor(e,"x","sinh")};return ENGINE.runKernel(Sinh,t)}var sinh=op({sinh_:sinh_});function slice1d_(e,t,n){const a=convertToTensor(e,"x","slice1d");return assert(1===a.rank,(()=>`slice1d expects a rank-1 tensor, but got a rank-${a.rank} tensor`)),slice(a,[t],[n])}var slice1d=op({slice1d_:slice1d_});function slice2d_(e,t,n){const a=convertToTensor(e,"x","slice2d");return assert(2===a.rank,(()=>`slice2d expects a rank-2 tensor, but got a rank-${a.rank} tensor`)),slice(a,t,n)}var slice2d=op({slice2d_:slice2d_});function slice3d_(e,t,n){const a=convertToTensor(e,"x","slice3d");return assert(3===a.rank,(()=>`slice3d expects a rank-3 tensor, but got a rank-${a.rank} tensor`)),slice(a,t,n)}var slice3d=op({slice3d_:slice3d_});function slice4d_(e,t,n){const a=convertToTensor(e,"x","slice4d");return assert(4===a.rank,(()=>`slice4d expects a rank-4 tensor, but got a rank-${a.rank} tensor`)),slice(a,t,n)}var slice4d=op({slice4d_:slice4d_});function softmax_(e,t=-1){const n=convertToTensor(e,"logits","softmax","float32");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${t}`);const a={logits:n},r={dim:t};return ENGINE.runKernel(Softmax,a,r)}var softmax=op({softmax_:softmax_});function fft_(e){assert("complex64"===e.dtype,(()=>`The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`));const t={input:e};return ENGINE.runKernel(FFT,t)}var fft=op({fft_:fft_});function ifft_(e){assert("complex64"===e.dtype,(()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`));const t={input:e};return ENGINE.runKernel(IFFT,t)}var ifft=op({ifft_:ifft_});function irfft_(e){const t=e.shape[e.shape.length-1],n=e.size/t;let a;if(t<=2){const r=reshape(e,[n,t]);a=ifft(r)}else{const r=[n,2*(t-1)],s=reshape(real(e),[n,t]),o=reshape(imag(e),[n,t]),i=reverse(slice(s,[0,1],[n,t-2]),1),l=mul(reverse(slice(o,[0,1],[n,t-2]),1),scalar(-1)),u=concat([s,i],1),c=concat([o,l],1),d=reshape(complex(u,c),[r[0],r[1]]);a=ifft(d)}if(a=real(a),3===e.rank&&0!==e.shape[0]){const t=a,n=e.shape[0];a=reshape(a,[n,a.shape[0]/n,a.shape[1]]),t.dispose()}return a}var irfft=op({irfft_:irfft_});function split_(e,t,n=0){const a={x:convertToTensor(e,"x","split")},r={numOrSizeSplits:t,axis:n};return ENGINE.runKernel(SplitV,a,r)}var split=op({split_:split_});function rfft_(e,t){assert("float32"===e.dtype,(()=>`The dtype for rfft() must be real value but got ${e.dtype}`));let n=e.shape[e.shape.length-1];const a=e.size/n;let r;if(null!=t&&t<n){const a=e.shape.map((e=>0)),s=e.shape.map((e=>e));s[e.shape.length-1]=t,r=slice(e,a,s),n=t}else if(null!=t&&t>n){const a=e.shape.map((e=>e));a[e.shape.length-1]=t-n,r=concat([e,zeros(a)],e.shape.length-1),n=t}else r=e;const s=zerosLike(r),o=reshape(complex(r,s),[a,n]),i=fft(o),l=Math.floor(n/2)+1,u=real(i),c=imag(i),d=split(u,[l,n-l],u.shape.length-1),p=split(c,[l,n-l],c.shape.length-1),h=r.shape.slice();return h[r.shape.length-1]=l,reshape(complex(d[0],p[0]),h)}var rfft=op({rfft_:rfft_});function sqrt_(e){const t={x:convertToTensor(e,"x","sqrt","float32")};return ENGINE.runKernel(Sqrt,t)}var sqrt=op({sqrt_:sqrt_});function squaredDifference_(e,t){let n=convertToTensor(e,"a","squaredDifference"),a=convertToTensor(t,"b","squaredDifference");[n,a]=makeTypesMatch(n,a),assertAndGetBroadcastShape(n.shape,a.shape);const r={a:n,b:a};return ENGINE.runKernel(SquaredDifference,r,{})}var squaredDifference=op({squaredDifference_:squaredDifference_});function squeeze_(e,t){const n=convertToTensor(e,"x","squeeze");return reshape(n,squeezeShape(n.shape,t).newShape)}var squeeze=op({squeeze_:squeeze_});function stack_(e,t=0){const n=convertToTensorArray(e,"tensors","stack","string_or_numeric");assert(n.length>=1,(()=>"Pass at least one tensor to tf.stack")),n.length>0&&assert(t<=n[0].rank,(()=>"Axis must be <= rank of the tensor"));const a=n,r={axis:t};return ENGINE.runKernel(Pack,a,r)}var stack=op({stack_:stack_});function step_(e,t=0){const n={x:convertToTensor(e,"x","step")},a={alpha:t};return ENGINE.runKernel(Step,n,a)}var step=op({step_:step_});function stridedSlice_(e,t,n,a,r=0,s=0,o=0,i=0,l=0){const u={x:convertToTensor(e,"x","stridedSlice","string_or_numeric")},c={begin:t,end:n,strides:a,beginMask:r,endMask:s,ellipsisMask:o,newAxisMask:i,shrinkAxisMask:l};return ENGINE.runKernel(StridedSlice,u,c)}var stridedSlice=op({stridedSlice_:stridedSlice_});function tan_(e){const t={x:convertToTensor(e,"x","tan","float32")};return ENGINE.runKernel(Tan,t)}var tan=op({tan_:tan_});function tensor1d(e,t){assertNonNull(e);const n=inferShape(e,t);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return makeTensor(e,null,n,t)}function tensor2d(e,t,n){if(assertNonNull(e),null!=t&&2!==t.length)throw new Error("tensor2d() requires shape to have two numbers");const a=inferShape(e,n);if(2!==a.length&&1!==a.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===a.length&&null==t)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return makeTensor(e,t,a,n)}function tensor4d(e,t,n){if(assertNonNull(e),null!=t&&4!==t.length)throw new Error("tensor4d() requires shape to have four numbers");const a=inferShape(e,n);if(4!==a.length&&1!==a.length)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===a.length&&null==t)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return makeTensor(e,t,a,n)}function tensor5d(e,t,n){if(assertNonNull(e),null!=t&&5!==t.length)throw new Error("tensor5d() requires shape to have five numbers");const a=inferShape(e,n);if(5!==a.length&&1!==a.length)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(1===a.length&&null==t)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return makeTensor(e,t,a,n)}function tensor6d(e,t,n){if(assertNonNull(e),null!=t&&6!==t.length)throw new Error("tensor6d() requires shape to have six numbers");const a=inferShape(e,n);if(6!==a.length&&1!==a.length)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(1===a.length&&null==t)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return makeTensor(e,t=t||a,a,n)}function topk_(e,t=1,n=!0){const a=convertToTensor(e,"x","topk");if(0===a.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const r=a.shape[a.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>r)throw new Error(`'k' passed to topk() must be <= the last dimension (${r}) but got ${t}`);const s={x:a},o={k:t,sorted:n},[i,l]=ENGINE.runKernel(TopK,s,o);return{values:i,indices:l}}var topk=op({topk_:topk_});function truncatedNormal_(e,t=0,n=1,a,r){if(null!=a&&"bool"===a)throw new Error("Unsupported data type $ { dtype }");const s=new MPRandGauss(t,n,a,!0,r),o=buffer(e,a);for(let e=0;e<o.values.length;e++)o.values[e]=s.nextValue();return o.toTensor()}var truncatedNormal=op({truncatedNormal_:truncatedNormal_});function unique_(e,t=0){const n=convertToTensor(e,"x","unique","string_or_numeric");assert(n.rank>0,(()=>"The input tensor must be at least 1D"));const a={x:n},r={axis:t},[s,o]=ENGINE.runKernel(Unique,a,r);return{values:s,indices:o}}var unique=op({unique_:unique_});function unsortedSegmentSum_(e,t,n){const a=convertToTensor(e,"x","unsortedSegmentSum"),r=convertToTensor(t,"segmentIds","unsortedSegmentSum","int32");assert(isInt(n),(()=>"numSegments must be of dtype int"));const s={x:a,segmentIds:r},o={numSegments:n};return ENGINE.runKernel(UnsortedSegmentSum,s,o)}var unsortedSegmentSum=op({unsortedSegmentSum_:unsortedSegmentSum_});function unstack_(e,t=0){const n=convertToTensor(e,"x","unstack","string_or_numeric");assert(t>=-n.shape.length&&t<n.shape.length,(()=>`Axis = ${t} is not in [-${n.shape.length}, ${n.shape.length})`));const a={value:n},r={axis:t};return ENGINE.runKernel(Unpack,a,r)}var unstack=op({unstack_:unstack_});function variable(e,t=!0,n,a){return ENGINE.makeVariable(e,t,n,a)}function whereImpl(e,t){const n=[];for(let e=0;e<t.length;e++)t[e]&&n.push(e);const a=buffer(e,"int32"),r=buffer([n.length,e.length],"int32");for(let t=0;t<n.length;t++){const s=a.indexToLoc(n[t]),o=t*e.length;r.values.set(s,o)}return r.toTensor()}async function whereAsync_(e){const t=convertToTensor(e,"condition","whereAsync","bool"),n=await t.data(),a=whereImpl(t.shape,n);return e!==t&&t.dispose(),a}var whereAsync=whereAsync_;async function booleanMaskAsync_(e,t,n){const a=convertToTensor(e,"tensor","boolMask"),r=convertToTensor(t,"mask","boolMask","bool"),s=null==n?0:n,o=r.rank,i=a.shape;assert(o>0,(()=>"mask cannot be scalar")),assertShapesMatch(i.slice(s,s+o),r.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let e=s;e<s+o;e++)l*=i[e];const u=i.slice(0,s).concat([l],i.slice(s+o)),c=reshape(a,u),d=reshape(r,[-1]),p=await whereAsync(d),h=squeeze(p,[1]),m=gather(c,h,s);return e!==a&&a.dispose(),t!==r&&r.dispose(),h.dispose(),c.dispose(),d.dispose(),p.dispose(),m}var booleanMaskAsync=booleanMaskAsync_;function norm_(e,t="euclidean",n=null,a=!1){const r=normImpl(e=convertToTensor(e,"x","norm"),t,n);let s=r.shape;if(a){const t=parseAxisParam(n,e.shape);s=expandShapeToKeepDim(r.shape,t)}return reshape(r,s)}function normImpl(e,t,n=null){if(0===e.rank)return abs(e);if(1!==e.rank&&null===n)return normImpl(reshape(e,[-1]),t,n);if(1===e.rank||"number"==typeof n||Array.isArray(n)&&1===n.length){if(1===t)return sum2(abs(e),n);if(t===1/0)return max(abs(e),n);if(t===-1/0)return min(abs(e),n);if("euclidean"===t||2===t)return sqrt(sum2(pow(abs(e),scalar(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(n)&&2===n.length){if(1===t)return max(sum2(abs(e),n[0]),n[1]-1);if(t===1/0)return max(sum2(abs(e),n[1]),n[0]);if(t===-1/0)return min(sum2(abs(e),n[1]),n[0]);if("fro"===t||"euclidean"===t)return sqrt(sum2(square(e),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}var norm=op({norm_:norm_});function movingAverage_(e,t,n,a,r=!0){const s=convertToTensor(e,"v","movingAverage"),o=convertToTensor(t,"x","movingAverage"),i=convertToTensor(n,"decay","movingAverage");assertTypesMatch(s,o),assert(arraysEqual(s.shape,o.shape),(()=>"Shape mismatch in v and x"));const l=scalar(1),u=sub(l,i);let c=mul(sub(o,s),u);if(r){assert(null!=a,(()=>"When using zeroDebias: true, step is required."));const e=convertToTensor(a,"step","movingAverage");c=div(c,sub(l,pow(i,e)))}return add2(s,c)}var movingAverage=op({movingAverage_:movingAverage_});function scatterND_(e,t,n){const a=convertToTensor(e,"indices","scatterND","int32"),r=convertToTensor(t,"updates","scatterND");validateInput(r,a,n);const s={indices:a,updates:r},o={shape:n};return ENGINE.runKernel(ScatterNd,s,o)}var scatterND=op({scatterND_:scatterND_});function validateInput2(e,t,n,a){if("int32"!==e.dtype)throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${e.shape}.`);const r=e.rank>0?e.shape[0]:1,s=e.rank>1?e.shape[1]:1;if(n.length!==s)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${s}.`);const o=t.size;if(0!==t.rank&&(1!==t.rank||o!==r))throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${r}]`);if(t.dtype!==a.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}function sparseToDense_(e,t,n,a=0){const r=convertToTensor(e,"sparseIndices","sparseToDense","int32"),s=convertToTensor(t,"sparseValues","sparseToDense"),o=convertToTensor(a,"defaultValue","sparseToDense",s.dtype);validateInput2(r,s,n,o);const i={sparseIndices:r,sparseValues:s,defaultValue:o},l={outputShape:n};return ENGINE.runKernel(SparseToDense,i,l)}var sparseToDense=op({sparseToDense_:sparseToDense_});function gatherND_(e,t){const n=convertToTensor(t,"indices","gatherND","int32"),a={params:convertToTensor(e,"x","gatherND","string_or_numeric"),indices:n};return ENGINE.runKernel(GatherNd,a)}var gatherND=op({gatherND_:gatherND_});function getNoiseShape(e,t){if(null==t)return e.shape.slice();if(arraysEqual(e.shape,t))return t;if(e.shape.length===t.length){const n=[];for(let a=0;a<e.shape.length;a++)null==t[a]&&null!=e.shape[a]?n.push(e.shape[a]):n.push(t[a]);return n}return t}function dropout_(e,t,n,a){const r=convertToTensor(e,"x","dropout");if(assert("float32"===r.dtype,(()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${r.dtype} tensor instead.`)),assert(t>=0&&t<1,(()=>`rate must be a float in the range [0, 1), but got ${t}.`)),0===t)return e instanceof Tensor?r.clone():r;const s=getNoiseShape(r,n),o=1-t,i=div(floor(add2(randomUniform(s,0,1,"float32",a),o)),o);return mul(r,i)}var dropout=op({dropout_:dropout_});function enclosingPowerOfTwo(e){return Math.floor(Math.pow(2,Math.ceil(Math.log(e)/Math.log(2))))}function cosineWindow(e,t,n){const a=1-e%2,r=new Float32Array(e);for(let s=0;s<e;++s){const o=2*Math.PI*s/(e+a-1);r[s]=t-n*Math.cos(o)}return tensor1d(r,"float32")}async function inTopKAsync_(e,t,n=1){const a=convertToTensor(e,"predictions","inTopK"),r=convertToTensor(t,"targets","inTopK");assert(a.rank>1,(()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${a.rank}`)),assert(a.rank-1===r.rank,(()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${a.rank} and targets rank ${r.rank}`)),assertShapesMatch(a.shape.slice(0,a.shape.length-1),r.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const s=a.shape[a.shape.length-1];assert(n>0&&n<=s,(()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${s}), but got ${n}`));const o=await a.data(),i=await r.data(),[l,u]=[o.length/s,s],c=getTypedArrayFromDType("bool",l);for(let e=0;e<l;e++){const t=e*u,a=o.subarray(t,t+u),r=[];for(let e=0;e<a.length;e++)r.push({value:a[e],index:e});r.sort(((e,t)=>t.value-e.value)),c[e]=0;for(let t=0;t<n;t++)if(r[t].index===i[e]){c[e]=1;break}}return e!==a&&a.dispose(),t!==r&&r.dispose(),tensor(c,r.shape,"bool")}var inTopKAsync=inTopKAsync_,fused_ops_exports={};function conv2DBackpropFilter_(e,t,n,a,r,s="NHWC",o){let i=e;3===e.rank&&(i=reshape(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;3===l.rank&&(l=reshape(t,[1,t.shape[0],t.shape[1],t.shape[2]])),assert(4===i.rank,(()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${i.shape}.`)),assert(4===l.rank,(()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`)),assert(4===n.length,(()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`));const u="NHWC"===s?i.shape[3]:i.shape[1],c="NHWC"===s?l.shape[3]:l.shape[1];assert(u===n[2],(()=>`Error in conv2dDerFilter: depth of input ${u}) must match input depth in filter (${n[2]}.`)),assert(c===n[3],(()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${n[3]}).`)),null!=o&&assert(isInt(r),(()=>`Error in conv2dDerFilter: pad must be an integer when using, dimRoundingMode ${o} but got pad ${r}.`));const d={x:i,dy:l},p={strides:a,pad:r,dataFormat:s,dimRoundingMode:o,filterShape:n};return ENGINE.runKernel(Conv2DBackpropFilter,d,p)}__export2(fused_ops_exports,{conv2d:()=>conv2d2,depthwiseConv2d:()=>depthwiseConv2d2,matMul:()=>matMul2});var conv2DBackpropFilter=op({conv2DBackpropFilter_:conv2DBackpropFilter_});function getFusedDyActivation(e,t,n){if(null==n||"linear"===n)return e;if("relu"===n)return mul(e,step(t));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function getFusedBiasGradient(e,t){let n=t;const a=getReductionAxes(e.shape,t.shape);return a.length>0&&(n=sum2(n,a)),reshape(n,e.shape)}function applyActivation(e,t,n,a){if("linear"===t)return e;if("relu"===t)return relu(e);if("elu"===t)return elu(e);if("relu6"===t)return relu6(e);if("prelu"===t)return prelu(e,n);if("leakyrelu"===t)return leakyRelu(e,a);if("sigmoid"===t)return sigmoid(e);throw new Error(`Unknown fused activation ${t}.`)}var shouldFuse=(e,t)=>!(e>0)||"linear"===t;function fusedConv2d_({x:e,filter:t,strides:n,pad:a,dataFormat:r="NHWC",dilations:s=[1,1],dimRoundingMode:o,bias:i,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(l=l||"linear",!1===shouldFuse(ENGINE.state.gradientDepth,l)){let d=conv2d(e,t,n,a,r,s,o);return null!=i&&(d=add2(d,i)),applyActivation(d,l,u,c)}const d=convertToTensor(e,"x","conv2d","float32"),p=convertToTensor(t,"filter","conv2d","float32");let h=d,m=!1;3===d.rank&&(m=!0,h=reshape(d,[1,d.shape[0],d.shape[1],d.shape[2]])),assert(4===h.rank,(()=>`Error in fused conv2d: input must be rank 4, but got rank ${h.rank}.`)),assert(4===p.rank,(()=>`Error in fused conv2d: filter must be rank 4, but got rank ${p.rank}.`)),null!=o&&assert(isInt(a),(()=>`Error in fused conv2d: pad must be an integer when using, dimRoundingMode ${o} but got pad ${a}.`)),assert(h.shape[3]===p.shape[2],(()=>`Error in conv2d: depth of input (${h.shape[3]}) must match input depth for filter ${p.shape[2]}.`)),assert(eitherStridesOrDilationsAreOne(n,s),(()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`)),assert("NHWC"===r,(()=>`Error in conv2d: got dataFormat of ${r} but only NHWC is currently supported.`));const f=computeConv2DInfo(h.shape,p.shape,n,s,a,o);let g,x;null!=i&&(g=convertToTensor(i,"bias","fused conv2d"),[g]=makeTypesMatch(g,d),assertAndGetBroadcastShape(f.outShape,g.shape)),null!=u&&(x=convertToTensor(u,"prelu weights","fused conv2d"));const y=(e,t)=>{const[r,o,i,u]=t,c=getFusedDyActivation(e,i,l);assert(tupleValuesAreOne(s),(()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`));const d=[conv2DBackpropInput(o.shape,c,r,n,a),conv2DBackpropFilter(o,c,r.shape,n,a)];if(null!=u){const e=getFusedBiasGradient(u,c);d.push(e)}return d},A={x:h,filter:p,bias:g,preluActivationWeights:x},b={strides:n,pad:a,dataFormat:r,dilations:s,dimRoundingMode:o,activation:l,leakyreluAlpha:c};if(null==i){return customGrad(((e,t,n)=>{let a=ENGINE.runKernel(FusedConv2D,A,b);return n([t,e,a]),m&&(a=reshape(a,[a.shape[1],a.shape[2],a.shape[3]])),{value:a,gradFunc:y}}))(h,p)}return customGrad(((e,t,n,a)=>{let r=ENGINE.runKernel(FusedConv2D,A,b);return a([t,e,r,n]),m&&(r=reshape(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:y}}))(h,p,g)}var conv2d2=op({fusedConv2d_:fusedConv2d_});function depthwiseConv2dNativeBackpropFilter_(e,t,n,a,r,s=[1,1],o){let i=e;3===e.rank&&(i=reshape(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;3===l.rank&&(l=reshape(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const u={x:i,dy:l},c={strides:a,pad:r,dimRoundingMode:o,dilations:s,filterShape:n};return ENGINE.runKernel(DepthwiseConv2dNativeBackpropFilter,u,c)}var depthwiseConv2dNativeBackpropFilter=op({depthwiseConv2dNativeBackpropFilter_:depthwiseConv2dNativeBackpropFilter_});function depthwiseConv2dNativeBackpropInput_(e,t,n,a,r,s=[1,1],o){let i=t,l=!1;3===t.rank&&(l=!0,i=reshape(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const u={dy:i,filter:n},c={strides:a,pad:r,dimRoundingMode:o,dilations:s,inputShape:e},d=ENGINE.runKernel(DepthwiseConv2dNativeBackpropInput,u,c);return l?reshape(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var depthwiseConv2dNativeBackpropInput=op({depthwiseConv2dNativeBackpropInput_:depthwiseConv2dNativeBackpropInput_});function fusedDepthwiseConv2d_({x:e,filter:t,strides:n,pad:a,dataFormat:r="NHWC",dilations:s=[1,1],dimRoundingMode:o,bias:i,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(!1===shouldFuse(ENGINE.state.gradientDepth,l)){let d=depthwiseConv2d(e,t,n,a,r,s,o);return null!=i&&(d=add2(d,i)),applyActivation(d,l,u,c)}const d=convertToTensor(e,"x","depthwiseConv2d","float32"),p=convertToTensor(t,"filter","depthwiseConv2d","float32");let h=d,m=!1;3===d.rank&&(m=!0,h=reshape(d,[1,d.shape[0],d.shape[1],d.shape[2]])),assert(4===h.rank,(()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${h.rank}.`)),assert(4===p.rank,(()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${p.rank}.`)),assert(h.shape[3]===p.shape[2],(()=>`Error in fused depthwiseConv2d: number of input channels (${h.shape[3]}) must match the inChannels dimension in filter ${p.shape[2]}.`)),null==s&&(s=[1,1]),assert(eitherStridesOrDilationsAreOne(n,s),(()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`)),null!=o&&assert(isInt(a),(()=>`Error in fused depthwiseConv2d: pad must be an integer when using dimRoundingMode ${o} but got pad ${a}.`));const f=computeConv2DInfo(h.shape,p.shape,n,s,a,o,!0);let g,x;null!=i&&(g=convertToTensor(i,"bias","fused conv2d"),[g]=makeTypesMatch(g,d),assertAndGetBroadcastShape(f.outShape,g.shape)),null!=u&&(x=convertToTensor(u,"prelu weights","fused depthwiseConv2d"));const y=(e,t)=>{assert(tupleValuesAreOne(s),(()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${s}'`));const[r,i,u,c]=t,d=getFusedDyActivation(e,u,l),p=depthwiseConv2dNativeBackpropInput(i.shape,d,r,n,a,s,o),h=depthwiseConv2dNativeBackpropFilter(i,d,r.shape,n,a,s,o);if(null!=c){return[p,h,getFusedBiasGradient(g,d)]}return[p,h]},A={x:h,filter:p,bias:g,preluActivationWeights:x},b={strides:n,pad:a,dataFormat:r,dilations:s,dimRoundingMode:o,activation:l,leakyreluAlpha:c};if(null==i){return customGrad(((e,t,n)=>{let a=ENGINE.runKernel(FusedDepthwiseConv2D,A,b);return n([t,e,a]),m&&(a=reshape(a,[a.shape[1],a.shape[2],a.shape[3]])),{value:a,gradFunc:y}}))(h,p)}return customGrad(((e,t,n,a)=>{let r=ENGINE.runKernel(FusedDepthwiseConv2D,A,b);return a([t,e,r,n]),m&&(r=reshape(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:y}}))(h,p,g)}var depthwiseConv2d2=op({fusedDepthwiseConv2d_:fusedDepthwiseConv2d_});function fusedMatMul_({a:e,b:t,transposeA:n=!1,transposeB:a=!1,bias:r,activation:s="linear",preluActivationWeights:o,leakyreluAlpha:i}){if(!1===shouldFuse(ENGINE.state.gradientDepth,s)){let l=matMul(e,t,n,a);return null!=r&&(l=add2(l,r)),applyActivation(l,s,o,i)}let l=convertToTensor(e,"a","fused matMul"),u=convertToTensor(t,"b","fused matMul");[l,u]=makeTypesMatch(l,u);const c=n?l.shape[l.rank-2]:l.shape[l.rank-1],d=a?u.shape[u.rank-1]:u.shape[u.rank-2],p=n?l.shape[l.rank-1]:l.shape[l.rank-2],h=a?u.shape[u.rank-2]:u.shape[u.rank-1],m=l.shape.slice(0,-2),f=u.shape.slice(0,-2),g=sizeFromShape(m),x=sizeFromShape(f);assert(c===d,(()=>`Error in fused matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${l.shape} and ${u.shape} and transposeA=${n} and transposeB=${a} must match.`));const y=assertAndGetBroadcastShape(l.shape.slice(0,-2),u.shape.slice(0,-2)).concat([p,h]),A=reshape(l,n?[g,c,p]:[g,p,c]),b=reshape(u,a?[x,h,d]:[x,d,h]);let v,k;null!=r&&(v=convertToTensor(r,"bias","fused matMul"),[v]=makeTypesMatch(v,l),assertAndGetBroadcastShape(y,v.shape)),null!=o&&(k=convertToTensor(o,"prelu weights","fused matMul"));const S=(e,t)=>{const[o,i,l,u]=t,c=getFusedDyActivation(reshape(e,l.shape),l,s);let d,p;if(n||a?!n&&a?(d=matMul(c,i,!1,!1),p=matMul(c,o,!0,!1)):n&&!a?(d=matMul(i,c,!1,!0),p=matMul(o,c,!1,!1)):(d=matMul(i,c,!0,!0),p=matMul(c,o,!0,!0)):(d=matMul(c,i,!1,!0),p=matMul(o,c,!0,!1)),null!=r){return[d,p,getFusedBiasGradient(u,c)]}return[d,p]},w={a:A,b:b,bias:v,preluActivationWeights:k},C={transposeA:n,transposeB:a,activation:s,leakyreluAlpha:i};if(null==r){return customGrad(((e,t,n)=>{const a=ENGINE.runKernel(_FusedMatMul,w,C);return n([e,t,a]),{value:reshape(a,y),gradFunc:S}}))(A,b)}return customGrad(((e,t,n,a)=>{const r=ENGINE.runKernel(_FusedMatMul,w,C);return a([e,t,r,n]),{value:reshape(r,y),gradFunc:S}}))(A,b,v)}var matMul2=op({fusedMatMul_:fusedMatMul_});function hammingWindow_(e){return cosineWindow(e,.54,.46)}var hammingWindow=op({hammingWindow_:hammingWindow_});function hannWindow_(e){return cosineWindow(e,.5,.5)}var hannWindow=op({hannWindow_:hannWindow_});function frame_(e,t,n,a=!1,r=0){let s=0;const o=[];for(;s+t<=e.size;)o.push(slice(e,s,t)),s+=n;if(a)for(;s<e.size;){const a=s+t-e.size,i=concat([slice(e,s,t-a),fill([a],r)]);o.push(i),s+=n}return 0===o.length?tensor2d([],[0,t]):reshape(concat(o),[o.length,t])}var frame=op({frame_:frame_});function stft_(e,t,n,a,r=hannWindow){null==a&&(a=enclosingPowerOfTwo(t));const s=frame(e,t,n),o=mul(s,r(t));return rfft(o,a)}var stft=op({stft_:stft_});function cropAndResize_(e,t,n,a,r="bilinear",s=0){const o=convertToTensor(e,"image","cropAndResize"),i=convertToTensor(t,"boxes","cropAndResize","float32"),l=convertToTensor(n,"boxInd","cropAndResize","int32"),u=i.shape[0];assert(4===o.rank,(()=>`Error in cropAndResize: image must be rank 4,but got rank ${o.rank}.`)),assert(2===i.rank&&4===i.shape[1],(()=>`Error in cropAndResize: boxes must be have size [${u},4] but had shape ${i.shape}.`)),assert(1===l.rank&&l.shape[0]===u,(()=>`Error in cropAndResize: boxInd must be have size [${u}] but had shape ${i.shape}.`)),assert(2===a.length,(()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${a.length}.`)),assert(a[0]>=1&&a[1]>=1,(()=>`cropSize must be atleast [1,1], but was ${a}`)),assert("bilinear"===r||"nearest"===r,(()=>`method must be bilinear or nearest, but was ${r}`));const c={image:o,boxes:i,boxInd:l},d={method:r,extrapolationValue:s,cropSize:a};return ENGINE.runKernel(CropAndResize,c,d)}var cropAndResize=op({cropAndResize_:cropAndResize_});function flipLeftRight_(e){const t=convertToTensor(e,"image","flipLeftRight","float32");assert(4===t.rank,(()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`));const n={image:t};return ENGINE.runKernel(FlipLeftRight,n,{})}var flipLeftRight=op({flipLeftRight_:flipLeftRight_});function grayscaleToRGB_(e){const t=convertToTensor(e,"image","grayscaleToRGB"),n=t.rank-1,a=t.shape[n];assert(t.rank>=2,(()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`)),assert(1===a,(()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${a}.`));const r=new Array(t.rank);return r.fill(1,0,n),r[n]=3,tile(t,r)}var grayscaleToRGB=op({grayscaleToRGB_:grayscaleToRGB_});function rotateWithOffset_(e,t,n=0,a=.5){const r=convertToTensor(e,"image","rotateWithOffset","float32");assert(4===r.rank,(()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${r.rank}.`));const s={image:r},o={radians:t,fillValue:n,center:a};return ENGINE.runKernel(RotateWithOffset,s,o)}var rotateWithOffset=op({rotateWithOffset_:rotateWithOffset_});function nonMaxSuppSanityCheck(e,t,n,a,r,s){null==a&&(a=.5),null==r&&(r=Number.NEGATIVE_INFINITY),null==s&&(s=0);const o=e.shape[0];return n=Math.min(n,o),assert(0<=a&&a<=1,(()=>`iouThreshold must be in [0, 1], but was '${a}'`)),assert(2===e.rank,(()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`)),assert(4===e.shape[1],(()=>`boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`)),assert(1===t.rank,(()=>"scores must be a 1D tensor")),assert(t.shape[0]===o,(()=>`scores has incompatible shape with boxes. Expected ${o}, but was ${t.shape[0]}`)),assert(0<=s&&s<=1,(()=>`softNmsSigma must be in [0, 1], but was '${s}'`)),{maxOutputSize:n,iouThreshold:a,scoreThreshold:r,softNmsSigma:s}}function nonMaxSuppression_(e,t,n,a=.5,r=Number.NEGATIVE_INFINITY){const s=convertToTensor(e,"boxes","nonMaxSuppression","float32"),o=convertToTensor(t,"scores","nonMaxSuppression","float32"),i=nonMaxSuppSanityCheck(s,o,n,a,r),l={maxOutputSize:n=i.maxOutputSize,iouThreshold:a=i.iouThreshold,scoreThreshold:r=i.scoreThreshold};return ENGINE.runKernel(NonMaxSuppressionV3,{boxes:s,scores:o},l)}var nonMaxSuppression=op({nonMaxSuppression_:nonMaxSuppression_});function binaryInsert(e,t,n){const a=binarySearch(e,t,n),r=a<0?-(a+1):a;e.splice(r,0,t)}function binarySearch(e,t,n){return binarySearch_(e,t,n||defaultComparator)}function defaultComparator(e,t){return e>t?1:e<t?-1:0}function binarySearch_(e,t,n){let a=0,r=e.length,s=0,o=!1;for(;a<r;){s=a+(r-a>>>1);const i=n(t,e[s]);i>0?a=s+1:(r=s,o=!i)}return o?a:-a-1}function nonMaxSuppressionV3Impl(e,t,n,a,r){return nonMaxSuppressionImpl_(e,t,n,a,r,0)}function nonMaxSuppressionV4Impl(e,t,n,a,r,s){return nonMaxSuppressionImpl_(e,t,n,a,r,0,!1,s,!0)}function nonMaxSuppressionV5Impl(e,t,n,a,r,s){return nonMaxSuppressionImpl_(e,t,n,a,r,s,!0)}function nonMaxSuppressionImpl_(e,t,n,a,r,s,o=!1,i=!1,l=!1){const u=[];for(let e=0;e<t.length;e++)t[e]>r&&u.push({score:t[e],boxIndex:e,suppressBeginIndex:0});u.sort(ascendingComparator);const c=s>0?-.5/s:0,d=[],p=[];for(;d.length<n&&u.length>0;){const t=u.pop(),{score:n,boxIndex:s,suppressBeginIndex:o}=t;if(n<r)break;let i=!1;for(let n=d.length-1;n>=o;--n){const o=intersectionOverUnion(e,s,d[n]);if(o>=a){i=!0;break}if(t.score=t.score*suppressWeight(a,c,o),t.score<=r)break}t.suppressBeginIndex=d.length,i||(t.score===n?(d.push(s),p.push(t.score)):t.score>r&&binaryInsert(u,t,ascendingComparator))}const h=d.length,m=n-h;i&&m>0&&(d.push(...new Array(m).fill(0)),p.push(...new Array(m).fill(0)));const f={selectedIndices:d};return o&&(f.selectedScores=p),l&&(f.validOutputs=h),f}function intersectionOverUnion(e,t,n){const a=e.subarray(4*t,4*t+4),r=e.subarray(4*n,4*n+4),s=Math.min(a[0],a[2]),o=Math.min(a[1],a[3]),i=Math.max(a[0],a[2]),l=Math.max(a[1],a[3]),u=Math.min(r[0],r[2]),c=Math.min(r[1],r[3]),d=Math.max(r[0],r[2]),p=Math.max(r[1],r[3]),h=(i-s)*(l-o),m=(d-u)*(p-c);if(h<=0||m<=0)return 0;const f=Math.max(s,u),g=Math.max(o,c),x=Math.min(i,d),y=Math.min(l,p),A=Math.max(x-f,0)*Math.max(y-g,0);return A/(h+m-A)}function suppressWeight(e,t,n){const a=Math.exp(t*n*n);return n<=e?a:0}function ascendingComparator(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}async function nonMaxSuppressionAsync_(e,t,n,a=.5,r=Number.NEGATIVE_INFINITY){const s=convertToTensor(e,"boxes","nonMaxSuppressionAsync"),o=convertToTensor(t,"scores","nonMaxSuppressionAsync"),i=nonMaxSuppSanityCheck(s,o,n,a,r);n=i.maxOutputSize,a=i.iouThreshold,r=i.scoreThreshold;const l=await Promise.all([s.data(),o.data()]),u=l[0],c=l[1],{selectedIndices:d}=nonMaxSuppressionV3Impl(u,c,n,a,r);return s!==e&&s.dispose(),o!==t&&o.dispose(),tensor1d(d,"int32")}var nonMaxSuppressionAsync=nonMaxSuppressionAsync_;function nonMaxSuppressionWithScore_(e,t,n,a=.5,r=Number.NEGATIVE_INFINITY,s=0){const o=convertToTensor(e,"boxes","nonMaxSuppression"),i=convertToTensor(t,"scores","nonMaxSuppression"),l=nonMaxSuppSanityCheck(o,i,n,a,r,s),u={boxes:o,scores:i},c={maxOutputSize:n=l.maxOutputSize,iouThreshold:a=l.iouThreshold,scoreThreshold:r=l.scoreThreshold,softNmsSigma:s=l.softNmsSigma},d=ENGINE.runKernel(NonMaxSuppressionV5,u,c);return{selectedIndices:d[0],selectedScores:d[1]}}var nonMaxSuppressionWithScore=op({nonMaxSuppressionWithScore_:nonMaxSuppressionWithScore_});async function nonMaxSuppressionWithScoreAsync_(e,t,n,a=.5,r=Number.NEGATIVE_INFINITY,s=0){const o=convertToTensor(e,"boxes","nonMaxSuppressionAsync"),i=convertToTensor(t,"scores","nonMaxSuppressionAsync"),l=nonMaxSuppSanityCheck(o,i,n,a,r,s);n=l.maxOutputSize,a=l.iouThreshold,r=l.scoreThreshold,s=l.softNmsSigma;const u=await Promise.all([o.data(),i.data()]),c=u[0],d=u[1],{selectedIndices:p,selectedScores:h}=nonMaxSuppressionV5Impl(c,d,n,a,r,s);return o!==e&&o.dispose(),i!==t&&i.dispose(),{selectedIndices:tensor1d(p,"int32"),selectedScores:tensor1d(h)}}var nonMaxSuppressionWithScoreAsync=nonMaxSuppressionWithScoreAsync_;function nonMaxSuppressionPadded_(e,t,n,a=.5,r=Number.NEGATIVE_INFINITY,s=!1){const o=convertToTensor(e,"boxes","nonMaxSuppression"),i=convertToTensor(t,"scores","nonMaxSuppression"),l=nonMaxSuppSanityCheck(o,i,n,a,r,null),u={boxes:o,scores:i},c={maxOutputSize:l.maxOutputSize,iouThreshold:l.iouThreshold,scoreThreshold:l.scoreThreshold,padToMaxOutputSize:s},d=ENGINE.runKernel(NonMaxSuppressionV4,u,c);return{selectedIndices:d[0],validOutputs:d[1]}}var nonMaxSuppressionPadded=op({nonMaxSuppressionPadded_:nonMaxSuppressionPadded_});async function nonMaxSuppressionPaddedAsync_(e,t,n,a=.5,r=Number.NEGATIVE_INFINITY,s=!1){const o=convertToTensor(e,"boxes","nonMaxSuppressionAsync"),i=convertToTensor(t,"scores","nonMaxSuppressionAsync"),l=nonMaxSuppSanityCheck(o,i,n,a,r,null),u=l.maxOutputSize,c=l.iouThreshold,d=l.scoreThreshold,[p,h]=await Promise.all([o.data(),i.data()]),{selectedIndices:m,validOutputs:f}=nonMaxSuppressionV4Impl(p,h,u,c,d,s);return o!==e&&o.dispose(),i!==t&&i.dispose(),{selectedIndices:tensor1d(m,"int32"),validOutputs:scalar(f,"int32")}}var nonMaxSuppressionPaddedAsync=nonMaxSuppressionPaddedAsync_;function resizeBilinear_(e,t,n=!1,a=!1){const r=convertToTensor(e,"images","resizeBilinear");assert(3===r.rank||4===r.rank,(()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${r.rank}.`)),assert(2===t.length,(()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`)),assert(!1===a||!1===n,(()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false."));let s=r,o=!1;3===r.rank&&(o=!0,s=reshape(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const[]=t,i={images:s},l={alignCorners:n,halfPixelCenters:a,size:t},u=ENGINE.runKernel(ResizeBilinear,i,l);return o?reshape(u,[u.shape[1],u.shape[2],u.shape[3]]):u}var resizeBilinear=op({resizeBilinear_:resizeBilinear_});function resizeNearestNeighbor_(e,t,n=!1,a=!1){const r=convertToTensor(e,"images","resizeNearestNeighbor");assert(3===r.rank||4===r.rank,(()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${r.rank}.`)),assert(2===t.length,(()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`)),assert("float32"===r.dtype||"int32"===r.dtype,(()=>"`images` must have `int32` or `float32` as dtype")),assert(!1===a||!1===n,(()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false."));let s=r,o=!1;3===r.rank&&(o=!0,s=reshape(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const[]=t,i={images:s},l={alignCorners:n,halfPixelCenters:a,size:t},u=ENGINE.runKernel(ResizeNearestNeighbor,i,l);return o?reshape(u,[u.shape[1],u.shape[2],u.shape[3]]):u}var resizeNearestNeighbor=op({resizeNearestNeighbor_:resizeNearestNeighbor_});function threshold_(e,t="binary",n=!1,a=.5){const r=convertToTensor(e,"image","threshold"),s=r.shape[0]*r.shape[1];let o,i,l,u,c=mul(tensor1d([a]),255);if(assert(3===r.rank,(()=>`Error in threshold: image must be rank 3,but got rank ${r.rank}.`)),assert(3===r.shape[2]||1===r.shape[2],(()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${r.shape[2]}.`)),assert("int32"===r.dtype||"float32"===r.dtype,(()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${r.dtype}.`)),assert("otsu"===t||"binary"===t,(()=>`Method must be binary or otsu, but was ${t}`)),3===r.shape[2]){[o,i,l]=split(r,[1,1,1],-1);const e=mul(o,.2989),t=mul(i,.587),n=mul(l,.114);u=add2(add2(e,t),n)}else u=e;if("otsu"===t){c=otsu(bincount(cast(round2(u),"int32"),tensor([]),256),s)}const d=n?lessEqual(u,c):greater(u,c);return cast(mul(d,255),"int32")}function otsu(e,t){let n,a,r,s,o,i,l=tensor1d([-1]),u=tensor1d([0]),c=tensor1d([0]);for(let d=0;d<e.size-1;d++){n=slice(e,0,d+1),a=slice(e,d+1),o=div(sum2(n),t),i=div(sum2(a),t);const p=sum2(mul(n,range(0,n.size)));r=div(p,sum2(n));const h=fill(a.shape,n.size),m=add2(range(0,a.size),h),f=mul(a,m);s=div(sum2(f),sum2(a));const g=sub(r,s),x=sub(r,s),y=mul(o,i);c=mul(mul(y,g),x);const A=greater(c,u);u=where(A,c,u),l=where(A,tensor1d([d]),l)}return l}var threshold=op({threshold_:threshold_});function transform_(e,t,n="nearest",a="constant",r=0,s){const o=convertToTensor(e,"image","transform","float32"),i=convertToTensor(t,"transforms","transform","float32");assert(4===o.rank,(()=>`Error in transform: image must be rank 4,but got rank ${o.rank}.`)),assert(2===i.rank&&(i.shape[0]===o.shape[0]||1===i.shape[0])&&8===i.shape[1],(()=>"Error in transform: Input transform should be batch x 8 or 1 x 8")),assert(null==s||2===s.length,(()=>`Error in transform: outputShape must be [height, width] or null, but got ${s}.`));const l={image:o,transforms:i},u={interpolation:n,fillMode:a,fillValue:r,outputShape:s};return ENGINE.runKernel(Transform,l,u)}var transform=op({transform_:transform_});function bandPart_(e,t,n){assert(t%1==0,(()=>`bandPart(): numLower must be an integer, got ${t}.`)),assert(n%1==0,(()=>`bandPart(): numUpper must be an integer, got ${n}.`));const a=convertToTensor(e,"a","bandPart");assert(a.rank>=2,(()=>`bandPart(): Rank must be at least 2, got ${a.rank}.`));const r=a.shape,[s,o]=a.shape.slice(-2);if(!(t<=s))throw new Error(`bandPart(): numLower (${t}) must not be greater than the number of rows (${s}).`);if(!(n<=o))throw new Error(`bandPart(): numUpper (${n}) must not be greater than the number of columns (${o}).`);t<0&&(t=s),n<0&&(n=o);const i=reshape(range(0,s,1,"int32"),[-1,1]),l=range(0,o,1,"int32"),u=sub(i,l),c=logicalAnd(lessEqual(u,scalar(+t,"int32")),greaterEqual(u,scalar(-n,"int32"))),d=zeros([s,o],a.dtype);return reshape(stack(unstack(reshape(a,[-1,s,o])).map((e=>where(c,e,d)))),r)}var bandPart=op({bandPart_:bandPart_});function gramSchmidt_(e){let t;if(Array.isArray(e)){t=!1,assert(null!=e&&e.length>0,(()=>"Gram-Schmidt process: input must not be null, undefined, or empty"));const n=e[0].shape[0];for(let t=1;t<e.length;++t)assert(e[t].shape[0]===n,(()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${e[t].shape[0]} vs. ${n})`))}else t=!0,e=split(e,e.shape[0],0).map((e=>squeeze(e,[0])));assert(e.length<=e[0].shape[0],(()=>`Gram-Schmidt: Number of vectors (${e.length}) exceeds number of dimensions (${e[0].shape[0]}).`));const n=[],a=e;for(let t=0;t<e.length;++t)n.push(ENGINE.tidy((()=>{let e=a[t];if(t>0)for(let a=0;a<t;++a){const t=mul(sum2(mul(n[a],e)),n[a]);e=sub(e,t)}return div(e,norm(e,"euclidean"))})));return t?stack(n,0):n}var gramSchmidt=op({gramSchmidt_:gramSchmidt_});function qr_(e,t=!1){if(assert(e.rank>=2,(()=>`qr() requires input tensor to have a rank >= 2, but got rank ${e.rank}`)),2===e.rank)return qr2d(e,t);{const n=e.shape.slice(0,e.shape.length-2).reduce(((e,t)=>e*t)),a=unstack(reshape(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),r=[],s=[];a.forEach((e=>{const[n,a]=qr2d(e,t);r.push(n),s.push(a)}));return[reshape(stack(r,0),e.shape),reshape(stack(s,0),e.shape)]}}function qr2d(e,t=!1){return ENGINE.tidy((()=>{assert(2===e.shape.length,(()=>`qr2d() requires a 2D Tensor, but got a ${e.shape.length}D Tensor.`));const n=e.shape[0],a=e.shape[1];let r=eye(n),s=clone(e);const o=tensor2d([[1]],[1,1]);let i=clone(o);const l=n>=a?a:n;for(let e=0;e<l;++e){const t=s,l=i,u=r;[i,s,r]=ENGINE.tidy((()=>{const t=slice(s,[e,e],[n-e,1]),l=norm(t),u=slice(s,[e,e],[1,1]),c=where(greater(u,0),tensor2d([[-1]]),tensor2d([[1]])),d=sub(u,mul(c,l)),p=div(t,d);i=1===p.shape[0]?clone(o):concat([o,slice(p,[1,0],[p.shape[0]-1,p.shape[1]])],0);const h=neg(div(matMul(c,d),l)),m=slice(s,[e,0],[n-e,a]),f=mul(h,i),g=transpose(i);if(0===e)s=sub(m,matMul(f,matMul(g,m)));else{const t=sub(m,matMul(f,matMul(g,m)));s=concat([slice(s,[0,0],[e,a]),t],0)}const x=transpose(f),y=slice(r,[0,e],[n,r.shape[1]-e]);if(0===e)r=sub(y,matMul(matMul(y,i),x));else{const t=sub(y,matMul(matMul(y,i),x));r=concat([slice(r,[0,0],[n,e]),t],1)}return[i,s,r]})),dispose([t,l,u])}return!t&&n>a&&(r=slice(r,[0,0],[n,a]),s=slice(s,[0,0],[a,a])),[r,s]}))}var Reduction,qr=op({qr_:qr_});function computeWeightedLoss_(e,t,n=Reduction.SUM_BY_NONZERO_WEIGHTS){const a=convertToTensor(e,"losses","computeWeightedLoss");let r=null;null!=t&&(r=convertToTensor(t,"weights","computeWeightedLoss"));const s=null==r?a:mul(a,r);if(n===Reduction.NONE)return s;if(n===Reduction.SUM)return sum2(s);if(n===Reduction.MEAN){if(null==r)return mean(s);{const e=a.size/r.size,t=div(sum2(s),sum2(r));return e>1?div(t,scalar(e)):t}}if(n===Reduction.SUM_BY_NONZERO_WEIGHTS){if(null==r)return div(sum2(s),scalar(a.size));{const e=mul(r,ones2(a.shape)),t=cast(sum2(notEqual(e,scalar(0))),"float32");return div(sum2(s),t)}}throw Error(`Unknown reduction: ${n}`)}!function(e){e[e.NONE=0]="NONE",e[e.MEAN=1]="MEAN",e[e.SUM=2]="SUM",e[e.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(Reduction||(Reduction={}));var computeWeightedLoss=op({computeWeightedLoss_:computeWeightedLoss_});function absoluteDifference_(e,t,n,a=Reduction.SUM_BY_NONZERO_WEIGHTS){const r=convertToTensor(e,"labels","absoluteDifference"),s=convertToTensor(t,"predictions","absoluteDifference");let o=null;null!=n&&(o=convertToTensor(n,"weights","absoluteDifference")),assertShapesMatch(r.shape,s.shape,"Error in absoluteDifference: ");const i=abs(sub(r,s));return computeWeightedLoss(i,o,a)}var absoluteDifference=op({absoluteDifference_:absoluteDifference_});function cosineDistance_(e,t,n,a,r=Reduction.SUM_BY_NONZERO_WEIGHTS){const s=convertToTensor(e,"labels","cosineDistance"),o=convertToTensor(t,"predictions","cosineDistance");let i=null;null!=a&&(i=convertToTensor(a,"weights","cosineDistance")),assertShapesMatch(s.shape,o.shape,"Error in cosineDistance: ");const l=scalar(1),u=sub(l,sum2(mul(s,o),n,!0));return computeWeightedLoss(u,i,r)}var cosineDistance=op({cosineDistance_:cosineDistance_});function hingeLoss_(e,t,n,a=Reduction.SUM_BY_NONZERO_WEIGHTS){let r=convertToTensor(e,"labels","hingeLoss");const s=convertToTensor(t,"predictions","hingeLoss");let o=null;null!=n&&(o=convertToTensor(n,"weights","hingeLoss")),assertShapesMatch(r.shape,s.shape,"Error in hingeLoss: ");const i=scalar(1);r=sub(mul(scalar(2),r),i);const l=relu(sub(i,mul(r,s)));return computeWeightedLoss(l,o,a)}var hingeLoss=op({hingeLoss_:hingeLoss_});function huberLoss_(e,t,n,a=1,r=Reduction.SUM_BY_NONZERO_WEIGHTS){const s=convertToTensor(e,"labels","huberLoss"),o=convertToTensor(t,"predictions","huberLoss");let i=null;null!=n&&(i=convertToTensor(n,"weights","huberLoss")),assertShapesMatch(s.shape,o.shape,"Error in huberLoss: ");const l=scalar(a),u=abs(sub(o,s)),c=minimum(u,l),d=sub(u,c),p=add2(mul(scalar(.5),square(c)),mul(l,d));return computeWeightedLoss(p,i,r)}var huberLoss=op({huberLoss_:huberLoss_});function logLoss_(e,t,n,a=1e-7,r=Reduction.SUM_BY_NONZERO_WEIGHTS){const s=convertToTensor(e,"labels","logLoss"),o=convertToTensor(t,"predictions","logLoss");let i=null;null!=n&&(i=convertToTensor(n,"weights","logLoss")),assertShapesMatch(s.shape,o.shape,"Error in logLoss: ");const l=scalar(1),u=scalar(a),c=neg(mul(s,log4(add2(o,u)))),d=mul(sub(l,s),log4(add2(sub(l,o),u))),p=sub(c,d);return computeWeightedLoss(p,i,r)}var logLoss=op({logLoss_:logLoss_});function meanSquaredError_(e,t,n,a=Reduction.SUM_BY_NONZERO_WEIGHTS){const r=convertToTensor(e,"labels","meanSquaredError"),s=convertToTensor(t,"predictions","meanSquaredError");let o=null;null!=n&&(o=convertToTensor(n,"weights","meanSquaredError")),assertShapesMatch(r.shape,s.shape,"Error in meanSquaredError: ");const i=squaredDifference(r,s);return computeWeightedLoss(i,o,a)}var meanSquaredError=op({meanSquaredError_:meanSquaredError_});function sigmoidCrossEntropyWithLogits_(e,t){const n=convertToTensor(e,"labels","sigmoidCrossEntropyWithLogits"),a=convertToTensor(t,"logits","sigmoidCrossEntropyWithLogits");assertShapesMatch(n.shape,a.shape,"Error in sigmoidCrossEntropyWithLogits: ");const r=relu(a),s=mul(a,n),o=log1p(exp(neg(abs(a))));return add2(sub(r,s),o)}function sigmoidCrossEntropy_(e,t,n,a=0,r=Reduction.SUM_BY_NONZERO_WEIGHTS){let s=convertToTensor(e,"multiClassLabels","sigmoidCrossEntropy");const o=convertToTensor(t,"logits","sigmoidCrossEntropy");let i=null;if(null!=n&&(i=convertToTensor(n,"weights","sigmoidCrossEntropy")),assertShapesMatch(s.shape,o.shape,"Error in sigmoidCrossEntropy: "),a>0){const e=scalar(a),t=scalar(1),n=scalar(.5);s=add2(mul(s,sub(t,e)),mul(n,e))}const l=sigmoidCrossEntropyWithLogits_(s,o);return computeWeightedLoss(l,i,r)}var sigmoidCrossEntropy=op({sigmoidCrossEntropy_:sigmoidCrossEntropy_});function softmaxCrossEntropyWithLogits_(e,t,n=-1){if(-1===n&&(n=t.rank-1),n!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${n}`);return customGrad(((e,t,a)=>{const r=logSumExp(t,[n],!0),s=sub(cast(t,"float32"),r);a([e,s]);const o=neg(mul(s,e));return{value:sum2(o,[n]),gradFunc:(e,t)=>{const[a,r]=t,s=expandShapeToKeepDim(e.shape,[n]);return[mul(reshape(e,s),sub(cast(a,"float32"),exp(r))),mul(reshape(e,s),sub(exp(r),cast(a,"float32")))]}}}))(e,t)}function softmaxCrossEntropy_(e,t,n,a=0,r=Reduction.SUM_BY_NONZERO_WEIGHTS){let s=convertToTensor(e,"onehotLabels","softmaxCrossEntropy");const o=convertToTensor(t,"logits","softmaxCrossEntropy");let i=null;if(null!=n&&(i=convertToTensor(n,"weights","softmaxCrossEntropy")),assertShapesMatch(s.shape,o.shape,"Error in softmaxCrossEntropy: "),a>0){const e=scalar(a),t=scalar(1),n=scalar(s.shape[1]);s=add2(mul(s,sub(t,e)),div(e,n))}const l=softmaxCrossEntropyWithLogits_(s,o);return computeWeightedLoss(l,i,r)}var softmaxCrossEntropy=op({softmaxCrossEntropy_:softmaxCrossEntropy_});function sparseFillEmptyRows_(e,t,n,a){const r=convertToTensor(e,"indices","sparseFillEmptyRows"),s=convertToTensor(t,"values","sparseFillEmptyRows"),o=convertToTensor(n,"denseShape","sparseFillEmptyRows"),i=convertToTensor(a,"defaultValue","sparseFillEmptyRows",s.dtype);if(2!==r.rank)throw new Error(`Indices should be Tensor2D but received shape\n        ${r.shape}`);if(1!==s.rank)throw new Error(`Values should be Tensor1D but received shape ${s.shape}`);if(1!==o.rank)throw new Error(`Dense shape should be Tensor1D but received shape ${o.shape}`);if(0!==i.rank)throw new Error(`Default value should be a scalar but received shape ${i.shape}`);const l={indices:r,values:s,denseShape:o,defaultValue:i},u=ENGINE.runKernel(SparseFillEmptyRows,l);return{outputIndices:u[0],outputValues:u[1],emptyRowIndicator:u[2],reverseIndexMap:u[3]}}var sparseFillEmptyRows=op({sparseFillEmptyRows_:sparseFillEmptyRows_});function sparseReshape_(e,t,n){const a=convertToTensor(e,"inputIndices","sparseReshape"),r=convertToTensor(t,"inputShape","sparseReshape"),s=convertToTensor(n,"newShape","sparseReshape");if(2!==a.rank)throw new Error(`Input indices should be Tensor2D but received shape\n        ${a.shape}`);if(1!==r.rank)throw new Error(`Input shape should be Tensor1D but received shape ${r.shape}`);if(1!==s.rank)throw new Error(`New shape should be Tensor1D but received shape ${s.shape}`);const o={inputIndices:a,inputShape:r,newShape:s},i=ENGINE.runKernel(SparseReshape,o);return{outputIndices:i[0],outputShape:i[1]}}var sparseReshape=op({sparseReshape_:sparseReshape_});function sparseSegmentMean_(e,t,n){const a=convertToTensor(e,"data","sparseSegmentMean"),r=convertToTensor(t,"indices","sparseSegmentMean"),s=convertToTensor(n,"segmentIds","sparseSegmentMean");if(a.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.rank)throw new Error(`Indices should be Tensor1D but received shape\n          ${r.shape}`);if(1!==s.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n          ${s.shape}`);const o={data:a,indices:r,segmentIds:s};return ENGINE.runKernel(SparseSegmentMean,o)}var sparseSegmentMean=op({sparseSegmentMean_:sparseSegmentMean_});function sparseSegmentSum_(e,t,n){const a=convertToTensor(e,"data","sparseSegmentSum"),r=convertToTensor(t,"indices","sparseSegmentSum"),s=convertToTensor(n,"segmentIds","sparseSegmentSum");if(a.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.rank)throw new Error(`Indices should be Tensor1D but received shape\n         ${r.shape}`);if(1!==s.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n         ${s.shape}`);const o={data:a,indices:r,segmentIds:s};return ENGINE.runKernel(SparseSegmentSum,o)}var sparseSegmentSum=op({sparseSegmentSum_:sparseSegmentSum_});function stringNGrams_(e,t,n,a,r,s,o,i){const l=convertToTensor(e,"data","stringNGrams","string");if("string"!==l.dtype)throw new Error("Data must be of datatype string");if(1!==l.shape.length)throw new Error(`Data must be a vector, saw: ${l.shape}`);const u=convertToTensor(t,"dataSplits","stringNGrams");if("int32"!==u.dtype)throw new Error("Data splits must be of datatype int32");const c={separator:n,nGramWidths:a,leftPad:r,rightPad:s,padWidth:o,preserveShortSequences:i},d={data:l,dataSplits:u},p=ENGINE.runKernel(StringNGrams,d,c);return{nGrams:p[0],nGramsSplits:p[1]}}var stringNGrams=op({stringNGrams_:stringNGrams_});function stringSplit_(e,t,n=!0){const a=convertToTensor(e,"input","stringSplit","string"),r=convertToTensor(t,"delimiter","stringSplit","string");if(1!==a.rank)throw new Error(`Input should be Tensor1D but received shape ${a.shape}`);if(0!==r.rank)throw new Error(`Delimiter should be a scalar but received shape ${r.shape}`);const s={skipEmpty:n},o={input:a,delimiter:r},i=ENGINE.runKernel(StringSplit,o,s);return{indices:i[0],values:i[1],shape:i[2]}}var stringSplit=op({stringSplit_:stringSplit_});function stringToHashBucketFast_(e,t){const n=convertToTensor(e,"input","stringToHashBucketFast","string"),a={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");const r={input:n};return ENGINE.runKernel(StringToHashBucketFast,r,a)}var stringToHashBucketFast=op({stringToHashBucketFast_:stringToHashBucketFast_}),spectral={fft:fft,ifft:ifft,rfft:rfft,irfft:irfft},signal={hammingWindow:hammingWindow,hannWindow:hannWindow,frame:frame,stft:stft},image={flipLeftRight:flipLeftRight,grayscaleToRGB:grayscaleToRGB,resizeNearestNeighbor:resizeNearestNeighbor,resizeBilinear:resizeBilinear,rotateWithOffset:rotateWithOffset,cropAndResize:cropAndResize,nonMaxSuppression:nonMaxSuppression,nonMaxSuppressionAsync:nonMaxSuppressionAsync,nonMaxSuppressionWithScore:nonMaxSuppressionWithScore,nonMaxSuppressionWithScoreAsync:nonMaxSuppressionWithScoreAsync,nonMaxSuppressionPadded:nonMaxSuppressionPadded,nonMaxSuppressionPaddedAsync:nonMaxSuppressionPaddedAsync,threshold:threshold,transform:transform},linalg={bandPart:bandPart,gramSchmidt:gramSchmidt,qr:qr},losses={absoluteDifference:absoluteDifference,computeWeightedLoss:computeWeightedLoss,cosineDistance:cosineDistance,hingeLoss:hingeLoss,huberLoss:huberLoss,logLoss:logLoss,meanSquaredError:meanSquaredError,sigmoidCrossEntropy:sigmoidCrossEntropy,softmaxCrossEntropy:softmaxCrossEntropy},sparse={sparseFillEmptyRows:sparseFillEmptyRows,sparseReshape:sparseReshape,sparseSegmentMean:sparseSegmentMean,sparseSegmentSum:sparseSegmentSum},string={stringNGrams:stringNGrams,stringSplit:stringSplit,stringToHashBucketFast:stringToHashBucketFast},Optimizer=class extends Serializable{minimize(e,t=!1,n){const{value:a,grads:r}=this.computeGradients(e,n);if(null!=n){const e=n.map((e=>({name:e.name,tensor:r[e.name]})));this.applyGradients(e)}else this.applyGradients(r);return dispose(r),t?a:(a.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return variableGrads(e,t)}dispose(){null!=this.iterations_&&dispose(this.iterations_)}async saveIterations(){return null==this.iterations_&&(this.iterations_=0),{name:"iter",tensor:scalar(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}};Object.defineProperty(Optimizer,Symbol.hasInstance,{value:e=>null!=e.minimize&&null!=e.computeGradients&&null!=e.applyGradients});var AdadeltaOptimizer=class extends Optimizer{constructor(e,t,n=null){super(),this.learningRate=e,this.rho=t,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==n&&(this.epsilon=ENGINE.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const a=ENGINE.registeredVariables[t];null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:`${t}/accum_grad`,variable:tidy((()=>zerosLike(a).variable(false)))}),null==this.accumulatedUpdates[n]&&(this.accumulatedUpdates[n]={originalName:`${t}/accum_var`,variable:tidy((()=>zerosLike(a).variable(false)))});const r=Array.isArray(e)?e[n].tensor:e[t];if(null==r)return;const s=this.accumulatedGrads[n].variable,o=this.accumulatedUpdates[n].variable;tidy((()=>{const e=add2(mul(s,this.rho),mul(square(r),1-this.rho)),t=mul(div(sqrt(add2(o,this.epsilon)),sqrt(add2(s,this.epsilon))),r),n=add2(mul(o,this.rho),mul(square(t),1-this.rho));s.assign(e),o.assign(n);const i=add2(mul(t,-this.learningRate),a);a.assign(i)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(dispose(this.accumulatedGrads.map((e=>e.variable))),dispose(this.accumulatedUpdates.map((e=>e.variable))))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){const t=(e=await this.extractIterations(e)).length/2;this.accumulatedGrads=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(false)}))),this.accumulatedUpdates=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}};AdadeltaOptimizer.className="Adadelta",registerClass(AdadeltaOptimizer);var AdagradOptimizer=class extends Optimizer{constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const a=ENGINE.registeredVariables[t];if(null==this.accumulatedGrads[n]){const e=!1;this.accumulatedGrads[n]={originalName:`${t}/accumulator`,variable:tidy((()=>fill(a.shape,this.initialAccumulatorValue).variable(e)))}}const r=Array.isArray(e)?e[n].tensor:e[t];if(null==r)return;const s=this.accumulatedGrads[n].variable;tidy((()=>{const e=add2(s,square(r));s.assign(e);const t=add2(mul(div(r,sqrt(add2(e,ENGINE.backend.epsilon()))),-this.learningRate),a);a.assign(t)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&dispose(this.accumulatedGrads.map((e=>e.variable)))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);this.accumulatedGrads=e.map((e=>({originalName:e.name,variable:e.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}};AdagradOptimizer.className="Adagrad",registerClass(AdagradOptimizer);var AdamOptimizer=class extends Optimizer{constructor(e,t,n,a=null){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=a,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],tidy((()=>{this.accBeta1=scalar(t).variable(),this.accBeta2=scalar(n).variable()})),null==a&&(this.epsilon=ENGINE.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);tidy((()=>{const n=sub(1,this.accBeta1),a=sub(1,this.accBeta2);t.forEach(((t,r)=>{const s=ENGINE.registeredVariables[t];null==this.accumulatedFirstMoment[r]&&(this.accumulatedFirstMoment[r]={originalName:`${t}/m`,variable:tidy((()=>zerosLike(s).variable(false)))}),null==this.accumulatedSecondMoment[r]&&(this.accumulatedSecondMoment[r]={originalName:`${t}/v`,variable:tidy((()=>zerosLike(s).variable(false)))});const o=Array.isArray(e)?e[r].tensor:e[t];if(null==o)return;const i=this.accumulatedFirstMoment[r].variable,l=this.accumulatedSecondMoment[r].variable,u=add2(mul(i,this.beta1),mul(o,1-this.beta1)),c=add2(mul(l,this.beta2),mul(square(o),1-this.beta2)),d=div(u,n),p=div(c,a);i.assign(u),l.assign(c);const h=add2(mul(div(d,add2(sqrt(p),this.epsilon)),-this.learningRate),s);s.assign(h)})),this.accBeta1.assign(mul(this.accBeta1,this.beta1)),this.accBeta2.assign(mul(this.accBeta2,this.beta2))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&dispose(this.accumulatedFirstMoment.map((e=>e.variable))),null!=this.accumulatedSecondMoment&&dispose(this.accumulatedSecondMoment.map((e=>e.variable)))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e),tidy((()=>{this.accBeta1.assign(pow(this.beta1,this.iterations_+1)),this.accBeta2.assign(pow(this.beta2,this.iterations_+1))}));const t=e.length/2;this.accumulatedFirstMoment=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(false)}))),this.accumulatedSecondMoment=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}};AdamOptimizer.className="Adam",registerClass(AdamOptimizer);var AdamaxOptimizer=class extends Optimizer{constructor(e,t,n,a=null,r=0){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=a,this.decay=r,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],tidy((()=>{this.iteration=scalar(0).variable(),this.accBeta1=scalar(t).variable()})),null==a&&(this.epsilon=ENGINE.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);tidy((()=>{const n=sub(1,this.accBeta1),a=div(-this.learningRate,add2(mul(this.iteration,this.decay),1));t.forEach(((t,r)=>{const s=ENGINE.registeredVariables[t];null==this.accumulatedFirstMoment[r]&&(this.accumulatedFirstMoment[r]={originalName:`${t}/m`,variable:zerosLike(s).variable(false)}),null==this.accumulatedWeightedInfNorm[r]&&(this.accumulatedWeightedInfNorm[r]={originalName:`${t}/v`,variable:zerosLike(s).variable(false)});const o=Array.isArray(e)?e[r].tensor:e[t];if(null==o)return;const i=this.accumulatedFirstMoment[r].variable,l=this.accumulatedWeightedInfNorm[r].variable,u=add2(mul(i,this.beta1),mul(o,1-this.beta1)),c=mul(l,this.beta2),d=abs(o),p=maximum(c,d);i.assign(u),l.assign(p);const h=add2(mul(div(a,n),div(u,add2(p,this.epsilon))),s);s.assign(h)})),this.iteration.assign(add2(this.iteration,1)),this.accBeta1.assign(mul(this.accBeta1,this.beta1))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&dispose(this.accumulatedFirstMoment.map((e=>e.variable))),null!=this.accumulatedWeightedInfNorm&&dispose(this.accumulatedWeightedInfNorm.map((e=>e.variable)))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}};AdamaxOptimizer.className="Adamax",registerClass(AdamaxOptimizer);var SGDOptimizer=class extends Optimizer{constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const a=Array.isArray(e)?e[n].tensor:e[t];if(null==a)return;const r=ENGINE.registeredVariables[t];tidy((()=>{const e=add2(mul(this.c,a),r);r.assign(e)}))})),this.incrementIterations()}setLearningRate(e){this.learningRate=e,null!=this.c&&this.c.dispose(),this.c=keep(scalar(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(0!==(e=await this.extractIterations(e)).length)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}};SGDOptimizer.className="SGD",registerClass(SGDOptimizer);var MomentumOptimizer=class extends SGDOptimizer{constructor(e,t,n=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=n,this.accumulations=[],this.m=scalar(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const a=ENGINE.registeredVariables[t];if(null==this.accumulations[n]){const e=!1;this.accumulations[n]={originalName:`${t}/momentum`,variable:tidy((()=>zerosLike(a).variable(e)))}}const r=this.accumulations[n].variable,s=Array.isArray(e)?e[n].tensor:e[t];null!=s&&tidy((()=>{let e;const t=add2(mul(this.m,r),s);e=this.useNesterov?add2(mul(this.c,add2(s,mul(t,this.m))),a):add2(mul(this.c,t),a),r.assign(t),a.assign(e)}))})),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&dispose(this.accumulations.map((e=>e.variable)))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);this.accumulations=e.map((e=>({originalName:e.name,variable:e.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}};MomentumOptimizer.className="Momentum",registerClass(MomentumOptimizer);var RMSPropOptimizer=class extends Optimizer{constructor(e,t=.9,n=0,a=null,r=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=n,this.epsilon=a,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=r,null==a&&(this.epsilon=ENGINE.backend.epsilon()),null==e)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const a=ENGINE.registeredVariables[t],r=!1;null==this.accumulatedMeanSquares[n]&&(this.accumulatedMeanSquares[n]={originalName:`${t}/rms`,variable:tidy((()=>zerosLike(a).variable(r)))}),null==this.accumulatedMoments[n]&&(this.accumulatedMoments[n]={originalName:`${t}/momentum`,variable:tidy((()=>zerosLike(a).variable(r)))}),null==this.accumulatedMeanGrads[n]&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:`${t}/mg`,variable:tidy((()=>zerosLike(a).variable(r)))});const s=Array.isArray(e)?e[n].tensor:e[t];if(null==s)return;const o=this.accumulatedMeanSquares[n].variable,i=this.accumulatedMoments[n].variable;tidy((()=>{const e=add2(mul(o,this.decay),mul(square(s),1-this.decay));if(this.centered){const t=this.accumulatedMeanGrads[n].variable,r=add2(mul(t,this.decay),mul(s,1-this.decay)),l=div(mul(s,this.learningRate),sqrt(sub(e,add2(square(r),this.epsilon)))),u=add2(mul(i,this.momentum),l);o.assign(e),t.assign(r),i.assign(u);const c=sub(a,u);a.assign(c)}else{const e=add2(mul(o,this.decay),mul(square(s),1-this.decay)),t=add2(mul(i,this.momentum),div(mul(s,this.learningRate),sqrt(add2(e,this.epsilon))));o.assign(e),i.assign(t);const n=sub(a,t);a.assign(n)}}))})),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&dispose(this.accumulatedMeanSquares.map((e=>e.variable))),null!=this.accumulatedMeanGrads&&this.centered&&dispose(this.accumulatedMeanGrads.map((e=>e.variable))),null!=this.accumulatedMoments&&dispose(this.accumulatedMoments.map((e=>e.variable)))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);const t=this.centered?e.length/3:e.length/2,n=!1;this.accumulatedMeanSquares=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedMoments=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.centered&&(this.accumulatedMeanGrads=e.slice(2*t,3*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}};RMSPropOptimizer.className="RMSProp",registerClass(RMSPropOptimizer);var OptimizerConstructors=class{static sgd(e){return new SGDOptimizer(e)}static momentum(e,t,n=!1){return new MomentumOptimizer(e,t,n)}static rmsprop(e,t=.9,n=0,a=null,r=!1){return new RMSPropOptimizer(e,t,n,a,r)}static adam(e=.001,t=.9,n=.999,a=null){return new AdamOptimizer(e,t,n,a)}static adadelta(e=.001,t=.95,n=null){return new AdadeltaOptimizer(e,t,n)}static adamax(e=.002,t=.9,n=.999,a=null,r=0){return new AdamaxOptimizer(e,t,n,a,r)}static adagrad(e,t=.1){return new AdagradOptimizer(e,t)}},train={sgd:OptimizerConstructors.sgd,momentum:OptimizerConstructors.momentum,adadelta:OptimizerConstructors.adadelta,adagrad:OptimizerConstructors.adagrad,rmsprop:OptimizerConstructors.rmsprop,adamax:OptimizerConstructors.adamax,adam:OptimizerConstructors.adam},delayCallback="undefined"!=typeof requestAnimationFrame?requestAnimationFrame:"undefined"!=typeof setImmediate?setImmediate:e=>e();function nextFrame(){return new Promise((e=>delayCallback((()=>e()))))}var backend_util_exports={};function assertParamsConsistent(e,t){const n=e[0].length;e.forEach(((e,t)=>{assert(e.length===n,(()=>`Error in concat${n}D: rank of tensors[${t}] must be the same as the rank of the rest (${n})`))})),assert(t>=0&&t<n,(()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`));const a=e[0];e.forEach(((e,r)=>{for(let s=0;s<n;s++)assert(s===t||e[s]===a[s],(()=>`Error in concat${n}D: Shape of tensors[${r}] (${e}) does not match the shape of the rest (${a}) along the non-concatenated axis ${r}.`))}))}function computeOutShape2(e,t){const n=e[0].slice();for(let a=1;a<e.length;a++)n[t]+=e[a][t];return n}__export2(backend_util_exports,{ERF_A1:()=>ERF_A1,ERF_A2:()=>ERF_A2,ERF_A3:()=>ERF_A3,ERF_A4:()=>ERF_A4,ERF_A5:()=>ERF_A5,ERF_P:()=>ERF_P,PARALLELIZE_THRESHOLD:()=>PARALLELIZE_THRESHOLD,SELU_SCALE:()=>SELU_SCALE,SELU_SCALEALPHA:()=>SELU_SCALEALPHA,applyActivation:()=>applyActivation,assertAndGetBroadcastShape:()=>assertAndGetBroadcastShape,assertAxesAreInnerMostDims:()=>assertAxesAreInnerMostDims,assertParamsConsistent:()=>assertParamsConsistent,assignToTypedArray:()=>assignToTypedArray,axesAreInnerMostDims:()=>axesAreInnerMostDims,calculateShapes:()=>calculateShapes,checkEinsumDimSizes:()=>checkEinsumDimSizes,combineLocations:()=>combineLocations,complexWithEvenIndex:()=>complexWithEvenIndex,complexWithOddIndex:()=>complexWithOddIndex,computeConv2DInfo:()=>computeConv2DInfo,computeConv3DInfo:()=>computeConv3DInfo,computeDefaultPad:()=>computeDefaultPad,computeDilation2DInfo:()=>computeDilation2DInfo,computeOptimalWindowSize:()=>computeOptimalWindowSize,computeOutAndReduceShapes:()=>computeOutAndReduceShapes,computeOutShape:()=>computeOutShape2,computePool2DInfo:()=>computePool2DInfo,computePool3DInfo:()=>computePool3DInfo,convertConv2DDataFormat:()=>convertConv2DDataFormat,decodeEinsumEquation:()=>decodeEinsumEquation,eitherStridesOrDilationsAreOne:()=>eitherStridesOrDilationsAreOne,expandShapeToKeepDim:()=>expandShapeToKeepDim,exponent:()=>exponent,exponents:()=>exponents,fromStringArrayToUint8:()=>fromStringArrayToUint8,fromUint8ToStringArray:()=>fromUint8ToStringArray,getAxesPermutation:()=>getAxesPermutation,getBroadcastDims:()=>getBroadcastDims,getComplexWithIndex:()=>getComplexWithIndex,getEinsumComputePath:()=>getEinsumComputePath,getEinsumPermutation:()=>getEinsumPermutation,getFusedBiasGradient:()=>getFusedBiasGradient,getFusedDyActivation:()=>getFusedDyActivation,getImageCenter:()=>getImageCenter,getInnerMostAxes:()=>getInnerMostAxes,getPermuted:()=>getPermuted,getReductionAxes:()=>getReductionAxes,getReshaped:()=>getReshaped,getReshapedPermuted:()=>getReshapedPermuted,getSliceBeginCoords:()=>getSliceBeginCoords,getSliceSize:()=>getSliceSize,getUndoAxesPermutation:()=>getUndoAxesPermutation,isIdentityPermutation:()=>isIdentityPermutation,log:()=>log2,mergeRealAndImagArrays:()=>mergeRealAndImagArrays,prepareAndValidate:()=>prepareAndValidate,prepareSplitSize:()=>prepareSplitSize,segment_util:()=>segment_util_exports,shouldFuse:()=>shouldFuse,slice_util:()=>slice_util_exports,splitRealAndImagArrays:()=>splitRealAndImagArrays,tupleValuesAreOne:()=>tupleValuesAreOne,upcastType:()=>upcastType,validateInput:()=>validateInput,validateUpdateShape:()=>validateUpdateShape,warn:()=>warn});var PARALLELIZE_THRESHOLD=30;function computeOptimalWindowSize(e){return e<=PARALLELIZE_THRESHOLD?e:nearestDivisor(e,Math.floor(Math.sqrt(e)))}function getImageCenter(e,t,n){return[n*("number"==typeof e?e:e[0]),t*("number"==typeof e?e:e[1])]}function getReshaped(e,t,n,a=!0){let r=[];if(a)r=r.concat(t.slice(0)),r.push(e[0]/n),r=r.concat(e.slice(1));else{r=r.concat(e[0]);const n=t.length;for(let a=0;a<n;++a)r=r.concat([e[a+1]/t[a],t[a]]);r=r.concat(e.slice(n+1))}return r}function getPermuted(e,t,n=!0){const a=[];if(n){a.push(t);for(let n=t+1;n<e;++n)n<=2*t?(a.push(n),a.push(n-(t+1))):a.push(n)}else{const n=[],r=[];for(let a=1;a<e;++a)a>=2*t+1||a%2==1?r.push(a):n.push(a);a.push(...n),a.push(0),a.push(...r)}return a}function getReshapedPermuted(e,t,n,a=!0){const r=[];a?r.push(e[0]/n):r.push(e[0]*n);for(let n=1;n<e.length;++n)n<=t.length?a?r.push(t[n-1]*e[n]):r.push(e[n]/t[n-1]):r.push(e[n]);return r}function getSliceBeginCoords(e,t){const n=[0];for(let a=0;a<t;++a)n.push(e[a][0]);return n}function getSliceSize(e,t,n){const a=e.slice(0,1);for(let r=0;r<n;++r)a.push(e[r+1]-t[r][0]-t[r][1]);return a}var SELU_SCALEALPHA=1.7580993408473768,SELU_SCALE=1.0507009873554805,ERF_P=.3275911,ERF_A1=.254829592,ERF_A2=-.284496736,ERF_A3=1.421413741,ERF_A4=-1.453152027,ERF_A5=1.061405429;function mergeRealAndImagArrays(e,t){if(e.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${t.length}.`);const n=new Float32Array(2*e.length);for(let a=0;a<n.length;a+=2)n[a]=e[a/2],n[a+1]=t[a/2];return n}function splitRealAndImagArrays(e){const t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let a=0;a<e.length;a+=2)t[a/2]=e[a],n[a/2]=e[a+1];return{real:t,imag:n}}function complexWithEvenIndex(e){const t=Math.ceil(e.length/4),n=new Float32Array(t),a=new Float32Array(t);for(let t=0;t<e.length;t+=4)n[Math.floor(t/4)]=e[t],a[Math.floor(t/4)]=e[t+1];return{real:n,imag:a}}function complexWithOddIndex(e){const t=Math.floor(e.length/4),n=new Float32Array(t),a=new Float32Array(t);for(let t=2;t<e.length;t+=4)n[Math.floor(t/4)]=e[t],a[Math.floor(t/4)]=e[t+1];return{real:n,imag:a}}function getComplexWithIndex(e,t){return{real:e[2*t],imag:e[2*t+1]}}function assignToTypedArray(e,t,n,a){e[2*a]=t,e[2*a+1]=n}function exponents(e,t){const n=new Float32Array(e/2),a=new Float32Array(e/2);for(let r=0;r<Math.ceil(e/2);r++){const s=(t?2:-2)*Math.PI*(r/e);n[r]=Math.cos(s),a[r]=Math.sin(s)}return{real:n,imag:a}}function exponent(e,t,n){const a=(n?2:-2)*Math.PI*(e/t);return{real:Math.cos(a),imag:Math.sin(a)}}var ARROW="->",ARROW_REGEX=/->/g,COMMA=",",ELLIPSIS="...";function decodeEinsumEquation(e,t){const n=((e=e.replace(/\s/g,"")).length-e.replace(ARROW_REGEX,"").length)/ARROW.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error(`Equation must contain exactly one arrow ("${ARROW}").`);const[a,r]=e.split(ARROW);assert(-1===a.indexOf(ELLIPSIS),(()=>`The ellipsis notation ("${ELLIPSIS}") is not supported yet.`));const s=a.split(COMMA),o=s.length;if(t!==o)throw new Error(`Expected ${o} input tensors, received ${t}`);if(o>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const i=[];for(let e=0;e<r.length;++e){const t=r[e];if(!s.some((e=>-1!==e.indexOf(t))))throw new Error(`Output subscripts contain the label ${t} not present in the input subscripts.`);-1===i.indexOf(t)&&i.push(t)}for(let e=0;e<a.length;++e){const t=a[e];-1===i.indexOf(t)&&t!==COMMA&&i.push(t)}const l=new Array(s.length);for(let e=0;e<o;++e){if(new Set(s[e].split("")).size!==s[e].length)throw new Error(`Found duplicate axes in input component ${s[e]}. Support for duplicate axes in input is not implemented yet.`);l[e]=[];for(let t=0;t<s[e].length;++t)l[e].push(i.indexOf(s[e][t]))}const u=i.length,c=[];for(let e=r.length;e<u;++e)c.push(e);return{allDims:i,summedDims:c,idDims:l}}function getEinsumPermutation(e,t){let n=new Array(e);n.fill(-1);for(let e=0;e<t.length;++e)n[t[e]]=e;const a=[];for(let t=0;t<e;++t)-1===n[t]&&a.push(t);return n=n.filter((e=>-1!==e)),{permutationIndices:n,expandDims:a}}function checkEinsumDimSizes(e,t,n){const a=new Array(e);for(let e=0;e<n.length;++e){const r=n[e].shape;for(let n=0;n<t[e].length;++n)void 0===a[t[e][n]]?a[t[e][n]]=r[n]:assert(a[t[e][n]]===r[n],(()=>`Expected dimension ${a[t[e][n]]} at axis ${n} of input shaped ${JSON.stringify(r)}, but got dimension ${r[n]}`))}}function getEinsumComputePath(e,t){const n=e,a=[];let r=0;0===e.length&&n.push(-1),r=e.length+1;for(let e=0;e<r;++e)a.push([]);const s=[];for(let e=0;e<n.length;++e){const r=findTermsWithDim(t,n[e]);for(const t of r)-1===s.indexOf(t)&&(a[e].push(t),s.push(t))}return{path:n,steps:a}}function isIdentityPermutation(e){return e.every(((e,t)=>e===t))}function findTermsWithDim(e,t){const n=[];for(let a=0;a<e.length;++a)0!==e[a].length&&-1===e[a].indexOf(t)&&-1!==t||n.push(a);return n}function prepareSplitSize(e,t,n=0){let a=[];if("number"==typeof t)assert(e.shape[n]%t==0,(()=>"Number of splits must evenly divide the axis.")),a=new Array(t).fill(e.shape[n]/t);else{assert(t.reduce(((e,t)=>(-1===t&&(e+=1),e)),0)<=1,(()=>"There should be only one negative value in split array."));const r=t.indexOf(-1);if(-1!==r){const a=t.reduce(((e,t)=>t>0?e+t:e));t[r]=e.shape[n]-a}assert(e.shape[n]===t.reduce(((e,t)=>e+t)),(()=>"The sum of sizes must match the size of the axis dimension.")),a=t}return a}var segment_util_exports={};function segOpComputeOptimalWindowSize(e,t){let n,a=!1;for(e<=PARALLELIZE_THRESHOLD?(n=e,a=!0):n=nearestDivisor(e,Math.floor(Math.sqrt(e)));!a;)n>t||n===e?a=!0:n=nearestDivisor(e,n+1);return n}function computeOutShape3(e,t,n){const a=[],r=e.length;for(let s=0;s<r;s++)s!==t?a.push(e[s]):a.push(n);return a}function collectGatherOpShapeInfo(e,t,n,a){const r=t.shape.length,s=e.shape.length;if(0!==a&&(a<-r||a>r))throw new Error(`Expect batchDims in the range of [-${r}, ${r}], but got ${a}`);if(a<0&&(a+=r),a>s)throw new Error(`batchDims (${a}) must be less than rank(x) (\n    ${s}).`);if(n<a)throw new Error(`batchDims (${a}) must be less than or equal to axis (${n}).`);for(let n=0;n<a;++n)if(e.shape[n]!==t.shape[n])throw new Error(`x.shape[${n}]: ${e.shape[n]} should be equal to indices.shape[${n}]: ${t.shape[n]}.`);const o=e.shape[n],i=[];let l=1,u=1,c=1;for(let t=0;t<a;++t)i.push(e.shape[t]),l*=e.shape[t];for(let t=a;t<n;t++)i.push(e.shape[t]),u*=e.shape[t];for(let e=a;e<r;e++)i.push(t.shape[e]);for(let t=n+1;t<s;t++)i.push(e.shape[t]),c*=e.shape[t];return{batchSize:l,sliceSize:c,outerSize:u,dimSize:o,outputShape:i}}function fromUint8ToStringArray(e){try{return e.map((e=>decodeString(e)))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function fromStringArrayToUint8(e){return e.map((e=>encodeString(e)))}__export2(segment_util_exports,{collectGatherOpShapeInfo:()=>collectGatherOpShapeInfo,computeOutShape:()=>computeOutShape3,segOpComputeOptimalWindowSize:()=>segOpComputeOptimalWindowSize});var kernel_impls_exports={};__export2(kernel_impls_exports,{nonMaxSuppressionV3Impl:()=>nonMaxSuppressionV3Impl,nonMaxSuppressionV4Impl:()=>nonMaxSuppressionV4Impl,nonMaxSuppressionV5Impl:()=>nonMaxSuppressionV5Impl,whereImpl:()=>whereImpl});var absGradConfig={kernelName:Abs,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>mul(e,step(cast(n,"float32"),-1))}}},acosGradConfig={kernelName:Acos,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=square(cast(n,"float32")),a=sqrt(sub(scalar(1),t));return neg(div(e,a))}}}},acoshGradConfig={kernelName:Acosh,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=sqrt(sub(square(cast(n,"float32")),1));return div(e,t)}}}},addGradConfig={kernelName:Add,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t,r=assertAndGetBroadcastShape(n.shape,a.shape);return{a:()=>{let t=e;const a=getReductionAxes(n.shape,r);return a.length>0&&(t=sum2(t,a)),reshape(t,n.shape)},b:()=>{let t=e;const n=getReductionAxes(a.shape,r);return n.length>0&&(t=sum2(t,n)),reshape(t,a.shape)}}}},addNGradConfig={kernelName:AddN,saveAllInputs:!0,gradFunc:(e,t)=>{const n={};return t.forEach(((t,a)=>{n[a]=()=>e.clone()})),n}},argMaxGradConfig={kernelName:ArgMax,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>zerosLike(n)}}},argMinGradConfig={kernelName:ArgMin,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>zerosLike(n)}}},asinGradConfig={kernelName:Asin,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>div(e,sqrt(sub(scalar(1),square(cast(n,"float32")))))}}},asinhGradConfig={kernelName:Asinh,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=sqrt(add2(scalar(1),square(cast(n,"float32"))));return div(e,t)}}}},atan2GradConfig={kernelName:Atan2,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t,r=assertAndGetBroadcastShape(n.shape,a.shape);return{a:()=>{const t=add2(square(n),square(a));let s=mul(e,div(a,t));const o=getReductionAxes(n.shape,r);return o.length>0&&(s=sum2(s,o)),reshape(s,n.shape)},b:()=>{const t=add2(square(n),square(a));let s=neg(mul(e,div(n,t)));const o=getReductionAxes(a.shape,r);return o.length>0&&(s=sum2(s,o)),reshape(s,a.shape)}}}},atanGradConfig={kernelName:Atan,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>div(e,add2(square(cast(n,"float32")),1))}}},atanhGradConfig={kernelName:Atanh,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>div(e,sub(scalar(1),square(cast(n,"float32"))))}}};function avgPool3dGrad_(e,t,n,a,r,s){const o=convertToTensor(e,"dy","avgPool3dGrad"),i=convertToTensor(t,"input","avgPool3dGrad");let l=o,u=i,c=!1;4===i.rank&&(c=!0,l=reshape(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),u=reshape(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),assert(5===l.rank,(()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`)),assert(5===u.rank,(()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${u.rank}.`)),null!=s&&assert(isInt(r),(()=>`Error in avgPool3dGrad: pad must be an integer when using, dimRoundingMode ${s} but got pad ${r}.`));const d={dy:l,input:u},p={filterSize:n,strides:a,pad:r,dimRoundingMode:s},h=ENGINE.runKernel(AvgPool3DGrad,d,p);return c?reshape(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}var avgPool3dGrad=op({avgPool3dGrad_:avgPool3dGrad_}),avgPool3DGradConfig={kernelName:AvgPool3D,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{filterSize:r,strides:s,pad:o,dimRoundingMode:i}=n;return{x:()=>avgPool3dGrad(e,a,r,s,o,i)}}};function avgPoolGrad_(e,t,n,a,r){const s=convertToTensor(e,"dy","avgPoolGrad"),o=convertToTensor(t,"input","avgPoolGrad");assert(o.rank===s.rank,(()=>`Rank of input (${o.rank}) does not match rank of dy (${s.rank})`));let i=o,l=s,u=!1;3===o.rank&&(u=!0,i=reshape(o,[1,o.shape[0],o.shape[1],o.shape[2]]),l=reshape(s,[1,s.shape[0],s.shape[1],s.shape[2]])),assert(4===l.rank,(()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`)),assert(4===i.rank,(()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${i.rank}.`));const c={dy:l,input:i},d={filterSize:n,strides:a,pad:r},p=ENGINE.runKernel(AvgPoolGrad,c,d);return u?reshape(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var avgPoolGrad=op({avgPoolGrad_:avgPoolGrad_}),avgPoolGradConfig={kernelName:AvgPool,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{filterSize:r,strides:s,pad:o}=n;return{x:()=>avgPoolGrad(e,a,r,s,o)}}},batchMatMulGradConfig={kernelName:BatchMatMul,inputsToSave:["a","b"],gradFunc:(e,t,n)=>{const[a,r]=t,{transposeA:s,transposeB:o}=n;return s||o?!s&&o?{a:()=>matMul(e,r,!1,!1),b:()=>matMul(e,a,!0,!1)}:s&&!o?{a:()=>matMul(r,e,!1,!0),b:()=>matMul(a,e,!1,!1)}:{a:()=>matMul(r,e,!0,!0),b:()=>matMul(e,a,!0,!0)}:{a:()=>matMul(e,r,!1,!0),b:()=>matMul(a,e,!0,!1)}}},batchToSpaceNDGradConfig={kernelName:BatchToSpaceND,gradFunc:(e,t,n)=>{const{blockShape:a,crops:r}=n;return{x:()=>spaceToBatchND(e,a,r)}}},broadcastToGradConfig={kernelName:BroadcastTo,gradFunc:(e,t,n)=>{const a=n,r=a.inputShape,s=a.shape,o=Array.from(s);for(let e=r.length-1;e>=0;e--)if(r[e]===s[e])o[e]=1;else if(1!==r[e])throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${s}].`);const i=[];for(let e=0;e<o.length;e++)o[e]>1&&i.push(e);return{x:()=>sum2(e,i,!0)}}},castGradConfig={kernelName:Cast,gradFunc:e=>({x:()=>e.clone()})},ceilGradConfig={kernelName:Ceil,gradFunc:e=>({x:()=>zerosLike(e)})},clipByValueGradConfig={kernelName:ClipByValue,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{clipValueMin:r,clipValueMax:s}=n;return{x:()=>where(logicalAnd(greaterEqual(a,r),lessEqual(a,s)),e,zerosLike(e))}}},complexAbsGradConfig={kernelName:ComplexAbs,inputsToSave:["x"],gradFunc:absGradConfig.gradFunc},concatGradConfig={kernelName:Concat,saveAllInputs:!0,gradFunc:(e,t,n)=>{const a=t.map((e=>e.shape)),{axis:r}=n,s=parseAxisParam(r,t[0].shape)[0],o=a.map((e=>e[s]));return split(e,o,s).map((e=>()=>e))}},conv2DGradConfig={kernelName:Conv2D,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const[a,r]=t,{dilations:s,strides:o,pad:i,dataFormat:l}=n;return assert(tupleValuesAreOne(s),(()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`)),{x:()=>conv2DBackpropInput(a.shape,e,r,o,i,l),filter:()=>conv2DBackpropFilter(a,e,r.shape,o,i,l)}}},conv2DBackpropInputGradConfig={kernelName:Conv2DBackpropInput,inputsToSave:["dy","filter"],gradFunc:(e,t,n)=>{const[a,r]=t,{strides:s,pad:o,dataFormat:i,dimRoundingMode:l}=n;return{dy:()=>conv2d(e,r,s,o,i,1,l),filter:()=>conv2DBackpropFilter(e,a,r.shape,s,o,i,l)}}};function conv3DBackpropFilter_(e,t,n,a,r){let s=e;4===e.rank&&(s=reshape(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]));let o=t;4===o.rank&&(o=reshape(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),assert(5===s.rank,(()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${s.shape}.`)),assert(5===o.rank,(()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${o.shape}.`)),assert(5===n.length,(()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`)),assert(s.shape[4]===n[3],(()=>`Error in conv3dDerFilter: depth of input ${s.shape[4]}) must match input depth in filter (${n[3]}.`)),assert(o.shape[4]===n[4],(()=>`Error in conv3dDerFilter: depth of dy (${o.shape[4]}) must match output depth for filter (${n[4]}).`));const i={x:s,dy:o},l={strides:a,pad:r,filterShape:n};return ENGINE.runKernel(Conv3DBackpropFilterV2,i,l)}var conv3DBackpropFilter=op({conv3DBackpropFilter_:conv3DBackpropFilter_}),conv3DGradConfig={kernelName:Conv3D,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const{dilations:a,strides:r,pad:s}=n;assert(tupleValuesAreOne(a),(()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`));const[o,i]=t;return{x:()=>conv3DBackpropInput(o.shape,e,i,r,s),filter:()=>conv3DBackpropFilter(o,e,i.shape,r,s)}}},cosGradConfig={kernelName:Cos,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>mul(neg(sin(cast(n,"float32"))),e)}}},coshGradConfig={kernelName:Cosh,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>mul(sinh(cast(n,"float32")),e)}}},cumsumGradConfig={kernelName:Cumsum,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{axis:r,exclusive:s,reverse:o}=n;return{x:()=>{const t=getAxesPermutation([r],a.rank);let n=cumsum(e,r,s,!o);return null!=t&&(n=transpose(n,t)),n}}}},depthwiseConv2dNativeGradConfig={kernelName:DepthwiseConv2dNative,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const{dilations:a,strides:r,pad:s,dimRoundingMode:o}=n,i=null==a?[1,1]:a;assert(tupleValuesAreOne(i),(()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${i}'`));const[l,u]=t;return assert(4===l.rank,(()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`)),assert(4===u.rank,(()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${u.rank}.`)),assert(l.shape[3]===u.shape[2],(()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`)),assert(eitherStridesOrDilationsAreOne(r,i),(()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${r} and dilations '${i}'.`)),null!=o&&assert(isInt(s),(()=>`Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ${o} but got pad ${s}.`)),{x:()=>depthwiseConv2dNativeBackpropInput(l.shape,e,u,r,s,i,o),filter:()=>depthwiseConv2dNativeBackpropFilter(l,e,u.shape,r,s,i,o)}}},dilation2dGradConfig={kernelName:Dilation2D,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const[a,r]=t,s={x:a,filter:r,dy:e},o={x:a,filter:r,dy:e};return{x:()=>ENGINE.runKernel(Dilation2DBackpropInput,s,n),filter:()=>ENGINE.runKernel(Dilation2DBackpropFilter,o,n)}}},eluGradConfig={kernelName:Elu,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t,a={dy:e,y:n};return{x:()=>ENGINE.runKernel(EluGrad,a)}}},erfGradConfig={kernelName:Erf,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t,a=mul(exp(neg(square(n))),2/Math.sqrt(Math.PI));return{x:()=>mul(e,a)}}},expGradConfig={kernelName:Exp,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>mul(e,n)}}},expandDimsGradConfig={kernelName:ExpandDims,inputsToSave:["input"],gradFunc:(e,t)=>{const[n]=t;return{input:()=>reshape(e,n.shape)}}},expm1GradConfig={kernelName:Expm1,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>mul(e,exp(n))}}},floorGradConfig={kernelName:Floor,gradFunc:e=>({x:()=>zerosLike(e)})},floorDivGradConfig={kernelName:FloorDiv,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t,r=assertAndGetBroadcastShape(n.shape,a.shape);return{a:()=>{const t=div(e,cast(a,"float32")),s=getReductionAxes(n.shape,r);return s.length>0?reshape(sum2(t,s),n.shape):t},b:()=>{let t=mul(e,cast(n,"float32"));const s=getReductionAxes(a.shape,r);s.length>0&&(t=reshape(sum2(t,s),a.shape));const o=square(a);return neg(div(t,cast(o,"float32")))}}}},fusedBatchNormGradConfig={kernelName:FusedBatchNorm,inputsToSave:["x","mean","variance","scale"],gradFunc:(e,t,n)=>{const{varianceEpsilon:a}=n,[r,s,o,i]=t,l=null==i?scalar(1):i,u=getReductionAxes(s.shape,r.shape),c=[];if(1===s.rank){for(let e=0;e<r.shape.length-1;++e)c.push(r.shape[e]);c.push(1)}const d=sub(r,s),p=mul(e,l),h=rsqrt(add2(o,scalar(a))),m=mul(mul(mul(h,h),h),scalar(-.5));return{x:()=>1===s.rank?reshape(mul(mul(e,tile(reshape(h,[1,1,1,s.shape[0]]),c)),l),r.shape):reshape(mul(mul(e,h),l),r.shape),mean:()=>{let e=mul(mul(h,scalar(-1)),p);return 1===s.rank&&(e=sum2(e,u)),reshape(e,s.shape)},variance:()=>{let e=mul(mul(m,d),p);return 1===s.rank&&(e=sum2(e,u)),reshape(e,s.shape)},scale:()=>{const t=mul(d,h);let n=mul(e,t);return 1===s.rank&&(n=sum2(n,u)),reshape(n,s.shape)},offset:()=>{let t=e;return 1===s.rank&&(t=sum2(t,u)),reshape(t,s.shape)}}}},gatherGradConfig={kernelName:GatherV2,inputsToSave:["x","indices"],gradFunc:(e,t,n)=>{const[a,r]=t,{axis:s}=n,o=parseAxisParam(s,a.shape)[0];return{x:()=>{const t=a.shape,n=r.size,i=t.slice(0,o),l=i.length,u=t.slice(s,t.length).slice(1),c=u.length,d=arrayRange(0,l),p=arrayRange(l+1,l+1+c),h=arrayConcat([i,[n],u]),m=reshape(e,h),f=reshape(r,[n]),g=arrayConcat([[l],d,p]),x=transpose(m,g);let y=unsortedSegmentSum(x,f,a.shape[o]);const A=getUndoAxesPermutation(g);return y=transpose(y,A),y},indices:()=>r}}};function arrayRange(e,t){const n=[];for(let a=e;a<t;++a)n.push(a);return n}function arrayConcat(e){const t=[];for(let n=0;n<e.length;++n)for(let a=0;a<e[n].length;++a)t.push(e[n][a]);return t}var greaterEqualGradConfig={kernelName:GreaterEqual,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t;return{a:()=>zerosLike(n),b:()=>zerosLike(a)}}},identityGradConfig={kernelName:Identity,gradFunc:e=>({x:()=>cast(e,"float32")})},isFiniteGradConfig={kernelName:IsFinite,gradFunc:e=>({x:()=>zerosLike(e)})},isInfGradConfig={kernelName:IsInf,gradFunc:e=>({x:()=>zerosLike(e)})},isNanGradConfig={kernelName:IsNan,gradFunc:e=>({x:()=>zerosLike(e)})},leakyReluGradConfig={kernelName:LeakyRelu,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{alpha:r}=n,s=greater(a,0);return{x:()=>where(s,e,mul(e,r))}}},log1pGradConfig={kernelName:Log1p,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>div(e,add2(n,1))}}},logGradConfig={kernelName:Log,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>div(e,cast(n,"float32"))}}},logSoftmaxGradConfig={kernelName:LogSoftmax,inputsToSave:[],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[a]=t,{axis:r}=n;return{logits:()=>{const t=exp(a);return sub(e,mul(sum2(e,r,!0),t))}}}};function localResponseNormalizationBackprop_(e,t,n,a=5,r=1,s=1,o=.5){const i={x:e,y:t,dy:n},l={depthRadius:a,bias:r,alpha:s,beta:o};return ENGINE.runKernel(LRNGrad,i,l)}var localResponseNormalizationBackprop=op({localResponseNormalizationBackprop_:localResponseNormalizationBackprop_}),lrnGradConfig={kernelName:LRN,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[a,r]=t,{depthRadius:s,bias:o,alpha:i,beta:l}=n;return{x:()=>localResponseNormalizationBackprop(a,r,e,s,o,i,l)}}};function gradForMinAndMax(e,t,n,a){return t.rank<n.rank&&(t=reshape(t,expandShapeToKeepDim(t.shape,a))),e.rank<n.rank&&(e=reshape(e,expandShapeToKeepDim(e.shape,a))),{x:()=>mul(e,cast(equal(n,t),e.dtype))}}var maxGradConfig={kernelName:Max,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const a=n,{reductionIndices:r}=a,s=t[0],o=gradForMinAndMax(e,t[1],s,parseAxisParam(r,s.shape));return{x:()=>o.x()}}},maximumGradConfig={kernelName:Maximum,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t;return{a:()=>mul(e,cast(greaterEqual(n,a),"float32")),b:()=>mul(e,cast(less(n,a),"float32"))}}};function maxPool3dGrad_(e,t,n,a,r,s,o){const i=convertToTensor(e,"dy","maxPool3dGrad"),l=convertToTensor(t,"input","maxPool3dGrad"),u=convertToTensor(n,"output","maxPool3dGrad");let c=i,d=l,p=u,h=!1;4===l.rank&&(h=!0,c=reshape(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),d=reshape(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),p=reshape(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),assert(5===c.rank,(()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`)),assert(5===d.rank,(()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${d.rank}.`)),assert(5===p.rank,(()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${p.rank}.`)),null!=o&&assert(isInt(s),(()=>`Error in maxPool3dGrad: pad must be an integer when using, dimRoundingMode ${o} but got pad ${s}.`));const m={dy:c,input:d,output:p},f={filterSize:a,strides:r,pad:s,dimRoundingMode:o},g=ENGINE.runKernel(MaxPool3DGrad,m,f);return h?reshape(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}var maxPool3dGrad=op({maxPool3dGrad_:maxPool3dGrad_}),maxPool3DGradConfig={kernelName:MaxPool3D,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[a,r]=t,{filterSize:s,strides:o,pad:i,dimRoundingMode:l}=n;return{x:()=>maxPool3dGrad(e,a,r,s,o,i,l)}}};function maxPoolGrad_(e,t,n,a,r,s,o){const i=convertToTensor(e,"dy","maxPoolGrad"),l=convertToTensor(t,"input","maxPoolGrad"),u=convertToTensor(n,"output","maxPoolGrad");assert(l.rank===i.rank,(()=>`Rank of input (${l.rank}) does not match rank of dy (${i.rank})`)),assert(4===i.rank,(()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${i.rank}.`)),assert(4===l.rank,(()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`)),null!=o&&assert(isInt(s),(()=>`Error in maxPoolGrad: pad must be an integer when using, dimRoundingMode ${o} but got pad ${s}.`));const c={dy:i,input:l,output:u},d={filterSize:a,strides:r,pad:s,dimRoundingMode:o};return ENGINE.runKernel(MaxPoolGrad,c,d)}var maxPoolGrad=op({maxPoolGrad_:maxPoolGrad_}),maxPoolGradConfig={kernelName:MaxPool,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[a,r]=t,{filterSize:s,strides:o,pad:i}=n;return{x:()=>maxPoolGrad(e,a,r,s,o,i)}}},meanGradConfig={kernelName:Mean,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{axis:r}=n,s=parseAxisParam(r,a.shape),o=sizeFromShape(computeOutAndReduceShapes(a.shape,s)[1]);return{x:()=>{const t=a.shape.slice();s.forEach((e=>{t[e]=1}));const n=reshape(e,t);return div(mul(n,ones2(a.shape,"float32")),o)}}}},minGradConfig={kernelName:Min,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const a=n,{axis:r}=a,[s,o]=t,i=gradForMinAndMax(e,o,s,parseAxisParam(r,s.shape));return{x:()=>i.x()}}},minimumGradConfig={kernelName:Minimum,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t;return{a:()=>mul(e,cast(lessEqual(n,a),"float32")),b:()=>mul(e,cast(greater(n,a),"float32"))}}},mirrorPadGradConfig={kernelName:MirrorPad,inputsToSave:["x"],gradFunc:(e,t,n)=>{const a=t[0],{paddings:r}=n,s=r.map((e=>e[0]));return{x:()=>slice(e,s,a.shape)}}},modGradConfig={kernelName:Mod,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t,r=assertAndGetBroadcastShape(n.shape,a.shape);return{a:()=>{const t=getReductionAxes(n.shape,r);return t.length>0?reshape(sum2(e,t),n.shape):e},b:()=>{const t=mul(e,neg(floor(div(n,a)))),s=getReductionAxes(a.shape,r);return s.length>0?reshape(sum2(t,s),a.shape):t}}}},multiplyGradConfig={kernelName:Multiply,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t,r=assertAndGetBroadcastShape(n.shape,a.shape);return{a:()=>{const t=mul(e,cast(a,"float32")),s=getReductionAxes(n.shape,r);return s.length>0?reshape(sum2(t,s),n.shape):t},b:()=>{const t=mul(e,cast(n,"float32")),s=getReductionAxes(a.shape,r);return s.length>0?reshape(sum2(t,s),a.shape):t}}}},negGradConfig={kernelName:Neg,gradFunc:e=>({x:()=>neg(e)})},oneHotGradConfig={kernelName:OneHot,inputsToSave:["indices"],gradFunc:(e,t)=>{const n=t[0];return{indices:()=>zeros(n.shape,"float32")}}},onesLikeGradConfig={kernelName:OnesLike,gradFunc:e=>({x:()=>zerosLike(e)})},packGradConfig={kernelName:Pack,saveAllInputs:!0,gradFunc:(e,t,n)=>{const{axis:a}=n;return unstack(e,a).map((e=>()=>e))}},padV2GradConfig={kernelName:PadV2,inputsToSave:["x"],gradFunc:(e,t,n)=>{const a=t[0],{paddings:r}=n,s=r.map((e=>e[0]));return{x:()=>slice(e,s,a.shape)}}},powGradConfig={kernelName:Pow,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(e,t)=>{const[n,a,r]=t,s=n,o=a,i=assertAndGetBroadcastShape(s.shape,o.shape);return{a:()=>{const t=cast(o,"float32");let n=mul(e,mul(t,pow(s,sub(t,scalar(1)))));const a=getReductionAxes(s.shape,i);return a.length>0&&(n=sum2(n,a)),reshape(n,s.shape)},b:()=>{const t=greater(s,0),n=where(t,log4(s),zerosLike(s));let a=mul(e,mul(r,n));const l=getReductionAxes(o.shape,i);return l.length>0&&(a=sum2(a,l)),reshape(a,o.shape)}}}},preluGradConfig={kernelName:Prelu,inputsToSave:["x","alpha"],gradFunc:(e,t)=>{const[n,a]=t,r=greater(n,0);return{x:()=>where(r,e,mul(e,a)),alpha:()=>{let t=where(r,zerosLike(e),mul(e,n));const s=getReductionAxes(a.shape,e.shape);return s.length>0&&(t=sum2(t,s)),reshape(t,a.shape)}}}},divGradConfig={kernelName:RealDiv,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t,r=assertAndGetBroadcastShape(n.shape,a.shape);return{a:()=>{const t=div(e,cast(a,"float32")),s=getReductionAxes(n.shape,r);return s.length>0?reshape(sum2(t,s),n.shape):t},b:()=>{let t=mul(e,cast(n,"float32"));const s=getReductionAxes(a.shape,r);s.length>0&&(t=reshape(sum2(t,s),a.shape));const o=square(a);return neg(div(t,cast(o,"float32")))}}}},reciprocalGradConfig={kernelName:Reciprocal,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>div(e,neg(square(n)))}}},relu6GradConfig={kernelName:Relu6,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t,a=mul(lessEqual(n,6),step(n));return{x:()=>mul(e,cast(a,"float32"))}}},reluGradConfig={kernelName:Relu,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>mul(e,cast(step(n),"float32"))}}},reshapeGradConfig={kernelName:Reshape,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>reshape(e,n.shape)}}},resizeBilinearGradConfig={kernelName:ResizeBilinear,inputsToSave:["images"],gradFunc:(e,t,n)=>{const[a]=t,r={dy:e,images:a};return{images:()=>ENGINE.runKernel(ResizeBilinearGrad,r,n)}}},resizeNearestNeighborGradConfig={kernelName:ResizeNearestNeighbor,inputsToSave:["images"],gradFunc:(e,t,n)=>{const[a]=t,r={dy:e,images:a};return{images:()=>ENGINE.runKernel(ResizeNearestNeighborGrad,r,n)}}},reverseGradConfig={kernelName:Reverse,gradFunc:(e,t,n)=>{const{dims:a}=n,r=parseAxisParam(a,e.shape);return{x:()=>reverse(e,r)}}},roundGradConfig={kernelName:Round,gradFunc:e=>({x:()=>zerosLike(e)})},rsqrtGradConfig={kernelName:Rsqrt,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>neg(div(e,mul(pow(n,1.5),2)))}}},selectGradConfig={kernelName:Select,inputsToSave:["condition"],gradFunc:(e,t)=>{const[n]=t;return{condition:()=>cast(zerosLike(n),"float32"),t:()=>mul(e,cast(n,e.dtype)),e:()=>mul(e,cast(logicalNot(n),e.dtype))}}},seluGradConfig={kernelName:Selu,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=greater(n,scalar(0)),a=scalar(SELU_SCALEALPHA),r=scalar(SELU_SCALE),s=mul(e,r),o=mul(mul(e,a),exp(cast(n,"float32")));return where(t,s,o)}}}},sigmoidGradConfig={kernelName:Sigmoid,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>mul(e,mul(n,sub(scalar(1),n)))}}},signGradConfig={kernelName:Sign,gradFunc:e=>({x:()=>zerosLike(e)})},sinGradConfig={kernelName:Sin,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>mul(cos(cast(n,"float32")),e)}}},sinhGradConfig={kernelName:Sinh,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>mul(cosh(cast(n,"float32")),e)}}},sliceGradConfig={kernelName:Slice,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{begin:r,size:s}=n,o=a.shape,[i,l]=parseSliceParams(a,r,s),u=[];for(let t=0;t<e.rank;t++)u.push([i[t],o[t]-i[t]-l[t]]);return{x:()=>pad(e,u)}}},softmaxGradConfig={kernelName:Softmax,outputsToSave:[!0],gradFunc:(e,t,n)=>{const[a]=t,{dim:r}=n,s=mul(e,a);return{logits:()=>sub(s,mul(sum2(s,[r],true),a))}}},softplusGradConfig={kernelName:Softplus,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>mul(e,sigmoid(n))}}},spaceToBatchNDGradConfig={kernelName:SpaceToBatchND,gradFunc:(e,t,n)=>{const{blockShape:a,paddings:r}=n;return{x:()=>batchToSpaceND(e,a,r)}}},splitVGradConfig={kernelName:SplitV,gradFunc:(e,t,n)=>{const{axis:a}=n;return{x:()=>concat(e,a)}}},sqrtGradConfig={kernelName:Sqrt,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>div(e,mul(sqrt(cast(n,"float32")),2))}}},squareGradConfig={kernelName:Square,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>mul(e,mul(cast(n,"float32"),2))}}},squaredDifferenceGradConfig={kernelName:SquaredDifference,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t,r=scalar(2);return{a:()=>mul(e,mul(r,sub(n,a))),b:()=>mul(e,mul(r,sub(a,n)))}}},stepGradConfig={kernelName:Step,gradFunc:e=>({x:()=>zerosLike(e)})},subGradConfig={kernelName:Sub,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t,r=assertAndGetBroadcastShape(n.shape,a.shape);return{a:()=>{let t=e;const a=getReductionAxes(n.shape,r);return a.length>0&&(t=sum2(t,a)),reshape(t,n.shape)},b:()=>{let t=e;const n=getReductionAxes(a.shape,r);return n.length>0&&(t=sum2(t,n)),reshape(neg(t),a.shape)}}}},sumGradConfig={kernelName:Sum,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,r=a.shape.slice(),{axis:s}=n;parseAxisParam(s,a.shape).forEach((e=>{r[e]=1}));const o=reshape(e,r),i=mul(o,ones2(a.shape,"float32"));return{x:()=>i}}},tanGradConfig={kernelName:Tan,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>div(e,square(cos(n)))}}},tanhGradConfig={kernelName:Tanh,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>mul(sub(scalar(1),square(n)),e)}}},tileGradConfig={kernelName:Tile,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{reps:r}=n;return{x:()=>{let t=zerosLike(a);if(1===a.rank)for(let n=0;n<r[0];++n)t=add2(t,slice(e,[n*a.shape[0]],[a.shape[0]]));else if(2===a.rank)for(let n=0;n<r[0];++n)for(let s=0;s<r[1];++s)t=add2(t,slice(e,[n*a.shape[0],s*a.shape[1]],[a.shape[0],a.shape[1]]));else if(3===a.rank)for(let n=0;n<r[0];++n)for(let s=0;s<r[1];++s)for(let o=0;o<r[2];++o)t=add2(t,slice(e,[n*a.shape[0],s*a.shape[1],o*a.shape[2]],[a.shape[0],a.shape[1],a.shape[2]]));else{if(4!==a.rank)throw new Error(`Gradient for tile operation is not implemented for rank-${a.rank} tensors yet.`);for(let n=0;n<r[0];++n)for(let s=0;s<r[1];++s)for(let o=0;o<r[2];++o)for(let i=0;i<r[3];++i)t=add2(t,slice(e,[n*a.shape[0],s*a.shape[1],o*a.shape[2],i*a.shape[3]],[a.shape[0],a.shape[1],a.shape[2],a.shape[3]]))}return t}}}},transposeGradConfig={kernelName:Transpose,gradFunc:(e,t,n)=>{const a=n,{perm:r}=a,s=getUndoAxesPermutation(r);return{x:()=>transpose(e,s)}}},unpackGradConfig={kernelName:Unpack,gradFunc:(e,t,n)=>{const a=n,{axis:r}=a;return{value:()=>stack(e,r)}}},unsortedSegmentSumGradConfig={kernelName:UnsortedSegmentSum,inputsToSave:["segmentIds"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>gatherDropNegatives(e,n)}}};function gatherDropNegatives(e,t){const n=maximum(t,zerosLike(t)),a=gather(e,n);let r=greaterEqual(t,scalar(0,"int32"));const s=a.rank-r.rank;for(let e=0;e<s;++e)r=expandDims(r,e+1);r=logicalAnd(r,ones2(a.shape,"bool"));const o=zerosLike(a);return where(r,a,o)}var zerosLikeGradConfig={kernelName:ZerosLike,gradFunc:e=>({x:()=>zerosLike(e)})},gradConfigs=[absGradConfig,acosGradConfig,acoshGradConfig,addGradConfig,addNGradConfig,argMaxGradConfig,argMinGradConfig,asinGradConfig,asinhGradConfig,atan2GradConfig,atanGradConfig,atanhGradConfig,avgPool3DGradConfig,avgPoolGradConfig,batchMatMulGradConfig,batchToSpaceNDGradConfig,broadcastToGradConfig,castGradConfig,ceilGradConfig,clipByValueGradConfig,complexAbsGradConfig,concatGradConfig,conv2DBackpropInputGradConfig,conv2DGradConfig,conv3DGradConfig,cosGradConfig,coshGradConfig,cumsumGradConfig,depthwiseConv2dNativeGradConfig,dilation2dGradConfig,divGradConfig,eluGradConfig,erfGradConfig,expGradConfig,expandDimsGradConfig,expm1GradConfig,floorDivGradConfig,floorGradConfig,fusedBatchNormGradConfig,gatherGradConfig,greaterEqualGradConfig,identityGradConfig,isFiniteGradConfig,isInfGradConfig,isNanGradConfig,leakyReluGradConfig,log1pGradConfig,logGradConfig,logSoftmaxGradConfig,lrnGradConfig,maxGradConfig,maxGradConfig,maximumGradConfig,maxPool3DGradConfig,maxPoolGradConfig,meanGradConfig,minGradConfig,minimumGradConfig,mirrorPadGradConfig,modGradConfig,multiplyGradConfig,negGradConfig,oneHotGradConfig,onesLikeGradConfig,packGradConfig,padV2GradConfig,padV2GradConfig,powGradConfig,preluGradConfig,reciprocalGradConfig,relu6GradConfig,reluGradConfig,reshapeGradConfig,resizeBilinearGradConfig,resizeNearestNeighborGradConfig,reverseGradConfig,roundGradConfig,rsqrtGradConfig,selectGradConfig,seluGradConfig,sigmoidGradConfig,signGradConfig,sinGradConfig,sinhGradConfig,sliceGradConfig,softmaxGradConfig,softplusGradConfig,spaceToBatchNDGradConfig,spaceToBatchNDGradConfig,splitVGradConfig,splitVGradConfig,sqrtGradConfig,squaredDifferenceGradConfig,squareGradConfig,stepGradConfig,subGradConfig,sumGradConfig,tanGradConfig,tanhGradConfig,tileGradConfig,transposeGradConfig,unpackGradConfig,unsortedSegmentSumGradConfig,zerosLikeGradConfig];for(const e of gradConfigs)registerGradient(e);var _epsilon,exports_constraints_exports={};function epsilon(){return null==_epsilon&&(_epsilon=backend().epsilon()),_epsilon}function imageDataFormat(){return"channelsLast"}__export2(exports_constraints_exports,{maxNorm:()=>maxNorm,minMaxNorm:()=>minMaxNorm,nonNeg:()=>nonNeg,unitNorm:()=>unitNorm});var AttributeError=class extends Error{constructor(e){super(e),Object.setPrototypeOf(this,AttributeError.prototype)}},RuntimeError=class extends Error{constructor(e){super(e),Object.setPrototypeOf(this,RuntimeError.prototype)}},ValueError=class extends Error{constructor(e){super(e),Object.setPrototypeOf(this,ValueError.prototype)}},NotImplementedError=class extends Error{constructor(e){super(e),Object.setPrototypeOf(this,NotImplementedError.prototype)}},AssertionError=class extends Error{constructor(e){super(e),Object.setPrototypeOf(this,AssertionError.prototype)}};function pyListRepeat(e,t){if(Array.isArray(e)){let n=[];for(let a=0;a<t;a++)n=n.concat(e);return n}{const n=new Array(t);return n.fill(e),n}}function assert2(e,t){if(!e)throw new AssertionError(t)}function count(e,t){let n=0;for(const a of e)a===t&&n++;return n}function singletonOrArray(e){return 1===e.length?e[0]:e}function toList(e){return Array.isArray(e)?e:[e]}function toSnakeCase(e){const t=e.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==t[0]?t:"private"+t}function toCamelCase(e){return e.length<=1||-1===e.indexOf("_")?e:e.replace(/[_]+(\w|$)/g,((e,t)=>t.toUpperCase()))}var _GLOBAL_CUSTOM_OBJECTS={};function serializeKerasObject(e){if(null==e)return null;const t={};return t.className=e.getClassName(),t.config=e.getConfig(),t}function convertNDArrayScalarsInConfig(e){if(null!=e&&"object"==typeof e)if(Array.isArray(e))e.forEach((e=>convertNDArrayScalarsInConfig(e)));else{const t=Object.keys(e);for(const n of t){const t=e[n];null!=t&&"object"==typeof t&&(Array.isArray(t)||"ndarray"!==t.type||"number"!=typeof t.value?convertNDArrayScalarsInConfig(t):e[n]=t.value)}}}function deserializeKerasObject(e,t={},n={},a="object",r=!1){if("string"==typeof e){const r=e;let s;if(r in n)s=n[r];else if(r in _GLOBAL_CUSTOM_OBJECTS)s=_GLOBAL_CUSTOM_OBJECTS[r];else if(s=t[r],null==s)throw new ValueError(`Unknown ${a}: ${e}. This may be due to one of the following reasons:\n1. The ${a} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${a} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return s}{const s=e;if(null==s.className||null==s.config)throw new ValueError(`${a}: Improper config format: ${JSON.stringify(s)}.\n'className' and 'config' must set.`);const o=s.className;let i,l;if(o in n?[i,l]=n[o]:o in _GLOBAL_CUSTOM_OBJECTS?[i,l]=_GLOBAL_CUSTOM_OBJECTS.className:o in t&&([i,l]=t[o]),null==i)throw new ValueError(`Unknown ${a}: ${o}. This may be due to one of the following reasons:\n1. The ${a} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${a} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(null!=l){const e={};for(const t of Object.keys(_GLOBAL_CUSTOM_OBJECTS))e[t]=_GLOBAL_CUSTOM_OBJECTS[t];for(const t of Object.keys(n))e[t]=n[t];s.config.customObjects=e;const t={..._GLOBAL_CUSTOM_OBJECTS};for(const e of Object.keys(n))_GLOBAL_CUSTOM_OBJECTS[e]=n[e];convertNDArrayScalarsInConfig(s.config);const a=l(i,s.config,n,r);return _GLOBAL_CUSTOM_OBJECTS={...t},a}{const e={..._GLOBAL_CUSTOM_OBJECTS};for(const e of Object.keys(n))_GLOBAL_CUSTOM_OBJECTS[e]=n[e];const t=new i(s.config);return _GLOBAL_CUSTOM_OBJECTS={...e},t}}}function numberCompare(e,t){return e<t?-1:e>t?1:0}function reverseNumberCompare(e,t){return-1*numberCompare(e,t)}function unique2(e){if(null==e)return e;const t=[];for(const n of e)-1===t.indexOf(n)&&t.push(n);return t}function isObjectEmpty(e){if(null==e)throw new ValueError(`Invalid value in obj: ${JSON.stringify(e)}`);for(const t in e)if(e.hasOwnProperty(t))return!1;return!0}function checkStringTypeUnionValue(e,t,n){if(null!=n&&e.indexOf(n)<0)throw new ValueError(`${n} is not a valid ${t}.  Valid values are ${e} or null/undefined.`)}function checkArrayTypeAndLength(e,t,n=0,a=1/0){return assert2(n>=0),assert2(a>=n),Array.isArray(e)&&e.length>=n&&e.length<=a&&e.every((e=>typeof e===t))}function assertPositiveInteger(e,t){Array.isArray(e)?(util_exports.assert(e.length>0,(()=>`${t} is unexpectedly an empty array.`)),e.forEach(((e,n)=>assertPositiveInteger(e,`element ${n+1} of ${t}`)))):util_exports.assert(Number.isInteger(e)&&e>0,(()=>`Expected ${t} to be a positive integer, but got ${formatAsFriendlyString(e)}.`))}function formatAsFriendlyString(e){return null===e?"null":Array.isArray(e)?"["+e.map((e=>formatAsFriendlyString(e))).join(",")+"]":"string"==typeof e?`"${e}"`:`${e}`}function debounce(e,t,n){let a,r=null!=n?n():util_exports.now();return(...s)=>{const o=null!=n?n():util_exports.now();return o-r<t||(r=o,a=e(...s)),a}}function mapActivationToFusedKernel(e){return"relu"===e?"relu":"linear"===e?"linear":"elu"===e?"elu":null}function calcL2Norms(e,t){return tidy((()=>sqrt(sum2(mul(e,e),t,!0))))}var Constraint=class extends serialization_exports.Serializable{getConfig(){return{}}},MaxNorm=class extends Constraint{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return tidy((()=>{const t=calcL2Norms(e,this.axis),n=clipByValue(t,0,this.maxValue);return mul(e,div(n,add2(epsilon(),t)))}))}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}};MaxNorm.className="MaxNorm",serialization_exports.registerClass(MaxNorm);var UnitNorm=class extends Constraint{constructor(e){super(),this.defaultAxis=0,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return tidy((()=>div(e,add2(epsilon(),calcL2Norms(e,this.axis)))))}getConfig(){return{axis:this.axis}}};UnitNorm.className="UnitNorm",serialization_exports.registerClass(UnitNorm);var NonNeg=class extends Constraint{apply(e){return relu(e)}};NonNeg.className="NonNeg",serialization_exports.registerClass(NonNeg);var MinMaxNorm=class extends Constraint{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=e.minValue?e.minValue:this.defaultMinValue,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.rate=null!=e.rate?e.rate:this.defaultRate,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return tidy((()=>{const t=calcL2Norms(e,this.axis),n=add2(mul(this.rate,clipByValue(t,this.minValue,this.maxValue)),mul(1-this.rate,t));return mul(e,div(n,add2(epsilon(),t)))}))}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}};MinMaxNorm.className="MinMaxNorm",serialization_exports.registerClass(MinMaxNorm);var CONSTRAINT_IDENTIFIER_REGISTRY_SYMBOL_MAP={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function serializeConstraint(e){return serializeKerasObject(e)}function deserializeConstraint(e,t={}){return deserializeKerasObject(e,serialization_exports.SerializationMap.getMap().classNameMap,t,"constraint")}function getConstraint(e){if(null==e)return null;if("string"==typeof e){return deserializeConstraint({className:e in CONSTRAINT_IDENTIFIER_REGISTRY_SYMBOL_MAP?CONSTRAINT_IDENTIFIER_REGISTRY_SYMBOL_MAP[e]:e,config:{}})}return e instanceof Constraint?e:deserializeConstraint(e)}function maxNorm(e){return new MaxNorm(e)}function unitNorm(e){return new UnitNorm(e)}function nonNeg(){return new NonNeg}function minMaxNorm(e){return new MinMaxNorm(e)}var exports_initializers_exports={};__export2(exports_initializers_exports,{constant:()=>constant,glorotNormal:()=>glorotNormal,glorotUniform:()=>glorotUniform,heNormal:()=>heNormal,heUniform:()=>heUniform,identity:()=>identity,leCunNormal:()=>leCunNormal,leCunUniform:()=>leCunUniform,ones:()=>ones3,orthogonal:()=>orthogonal,randomNormal:()=>randomNormal3,randomUniform:()=>randomUniform2,truncatedNormal:()=>truncatedNormal2,varianceScaling:()=>varianceScaling,zeros:()=>zeros2});var VALID_DATA_FORMAT_VALUES=["channelsFirst","channelsLast"],VALID_INTERPOLATION_FORMAT_VALUES=["nearest","bilinear"],VALID_PADDING_MODE_VALUES=["valid","same","causal"],VALID_POOL_MODE_VALUES=["max","avg"],VALID_BIDIRECTIONAL_MERGE_MODES=["sum","mul","concat","ave"],nameMap=new Map;function checkDataFormat(e){checkStringTypeUnionValue(VALID_DATA_FORMAT_VALUES,"DataFormat",e)}function checkInterpolationFormat(e){checkStringTypeUnionValue(VALID_INTERPOLATION_FORMAT_VALUES,"InterpolationFormat",e)}function checkPaddingMode(e){checkStringTypeUnionValue(VALID_PADDING_MODE_VALUES,"PaddingMode",e)}function checkPoolMode(e){checkStringTypeUnionValue(VALID_POOL_MODE_VALUES,"PoolMode",e)}var _nameScopeStack=[],_nameScopeDivider="/";function nameScope(e,t){_nameScopeStack.push(e);try{const e=t();return _nameScopeStack.pop(),e}catch(e){throw _nameScopeStack.pop(),e}}function currentNameScopePrefix(){return 0===_nameScopeStack.length?"":_nameScopeStack.join(_nameScopeDivider)+_nameScopeDivider}function getScopedTensorName(e){if(!isValidTensorName(e))throw new Error("Not a valid tensor name: '"+e+"'");return currentNameScopePrefix()+e}function getUniqueTensorName(e){if(!isValidTensorName(e))throw new Error("Not a valid tensor name: '"+e+"'");nameMap.has(e)||nameMap.set(e,0);const t=nameMap.get(e);if(nameMap.set(e,nameMap.get(e)+1),t>0){const n=`${e}_${t}`;return nameMap.set(n,1),n}return e}var tensorNameRegex=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function isValidTensorName(e){return!!e.match(tensorNameRegex)}function isInteger(e){return e===parseInt(e.toString(),10)}function arrayProd(e,t,n){null==t&&(t=0),null==n&&(n=e.length);let a=1;for(let r=t;r<n;++r)a*=e[r];return a}function min2(e){if(0===e.length)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let n=0;n<e.length;n++){const a=e[n];a<t&&(t=a)}return t}function max2(e){if(0===e.length)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let n=0;n<e.length;n++){const a=e[n];a>t&&(t=a)}return t}function range2(e,t){if(t<e)throw new ValueError(`end (${t}) < begin (${e}) is forbidden.`);const n=[];for(let a=e;a<t;++a)n.push(a);return n}function cast2(e,t){return cast(e,t)}function expandDims2(e,t=-1){const n=e.shape.slice();return t<0&&(t=n.length+t+1),n.splice(t,0,1),reshape(e,n)}function repeat(e,t){return tidy((()=>{if(2!==e.shape.length)throw new ValueError(`repeat() expects a rank-2 tensor, but received a rank-${e.shape.length} tensor.`);return tile2(expandDims2(e,1),[1,t,1])}))}function flatten2(e){const t=[arrayProd(e.shape)];return reshape(e,t)}function batchFlatten(e){if(e.rank<=1)throw new ValueError(`batchFlatten requires a minimum rank of 2. Got rank: ${e.rank}.`);const t=[e.shape[0],arrayProd(e.shape,1)];return reshape(e,t)}function sliceAlongFirstAxis(e,t,n){return tidy((()=>{switch(e.rank){case 1:return slice1d(e,t,n);case 2:return slice2d(e,[t,0],[n,e.shape[1]]);case 3:return slice3d(e,[t,0,0],[n,e.shape[1],e.shape[2]]);case 4:return slice4d(e,[t,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3]]);case 5:return slice(e,[t,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4]]);case 6:return slice(e,[t,0,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4],e.shape[5]]);default:throw new ValueError(`sliceAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}))}function sliceAlongLastAxis(e,t,n){return tidy((()=>{switch(e.rank){case 1:return slice1d(e,t,n);case 2:return slice2d(e,[0,t],[e.shape[0],n]);case 3:return slice3d(e,[0,0,t],[e.shape[0],e.shape[1],n]);case 4:return slice4d(e,[0,0,0,t],[e.shape[0],e.shape[1],e.shape[2],n]);default:throw new ValueError(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}}))}function sliceAlongAxis(e,t,n,a){return tidy((()=>{switch(e.rank){case 1:return slice1d(e,t,n);case 2:switch(a){case 1:return sliceAlongFirstAxis(e,t,n);case 2:return sliceAlongLastAxis(e,t,n);default:throw new ValueError(`The axis is not within the rank of the tensor ${a}`)}case 3:switch(a){case 1:return sliceAlongFirstAxis(e,t,n);case 2:return slice3d(e,[0,t,0],[e.shape[0],n,e.shape[2]]);case 3:return sliceAlongLastAxis(e,t,n);default:throw new ValueError(`The axis is not within the rank of the tensor ${a}`)}case 4:switch(a){case 1:return sliceAlongFirstAxis(e,t,n);case 2:return slice4d(e,[0,t,0,0],[e.shape[0],n,e.shape[2],e.shape[3]]);case 3:return slice4d(e,[0,0,t,0],[e.shape[0],e.shape[1],n,e.shape[3]]);case 4:return sliceAlongLastAxis(e,t,n);default:throw new ValueError(`The axis is not within the rank of the tensor ${a}`)}default:throw new ValueError(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}}))}function concatenate(e,t=-1){let n;return t<0&&(n=e[0].rank,t=0!==n?n:0),t===e[0].rank&&(t=-1),concat(e,t)}function concatAlongFirstAxis(e,t){switch(e.rank){case 1:return concat1d([e,t]);case 2:return concat2d([e,t],0);case 3:return concat3d([e,t],0);case 4:return concat4d([e,t],0);default:throw new ValueError(`concatAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}function tile2(e,t){if(Array.isArray(t)||(t=[t]),e.rank!==t.length)throw new ValueError(`The length of input n (${t.length}) does not match the number of dimensions in input x (${e.rank})`);return tile(e,t)}function randomNormal2(e,t=0,n=1,a,r){return randomNormal(e,t,n,a,r)}function dot2(e,t,n,a){if(e.rank<2||t.rank<2)throw new NotImplementedError(`dot requires both inputs to be rank >= 2 but got x shape = ${e.shape} and y shape = ${t.shape}`);if(t.rank>=3){if(e.shape.slice(-1)[0]!==t.shape.slice(-2)[0])throw new NotImplementedError(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${e.shape} and  y shape = ${t.shape}`)}if(2===e.rank&&2===t.rank){const r=!1,s=!1;return fused_ops_exports.matMul({a:e,b:t,transposeA:r,transposeB:s,bias:a?reshapeBias(e.rank,a,imageDataFormat()):null,activation:n})}{const r=e.shape.slice(),s=r.pop();e=reshape(e,[-1,s]);const o=t.shape.slice(),i=o.pop(),l=o.pop(),u=[...o,i],c=Array.from({length:t.rank},((e,n)=>0===n?t.rank-2:n<=t.rank-2?n-1:n));t=reshape(transpose(t,c),[l,-1]);const d=[...r,...u],p=!1,h=!1;return reshape(fused_ops_exports.matMul({a:e,b:t,transposeA:p,transposeB:h,bias:a?reshapeBias(e.rank,a,imageDataFormat()):null,activation:n}),d)}}function gather2(e,t,n){return tidy((()=>(t=Array.isArray(t)?tensor1d(t,"int32"):cast(t,"int32"),gather(e,t,n))))}function square2(e){return mul(e,e)}function reshapeBias(e,t,n){const a=t.shape;if(1!==t.rank&&t.rank!==e)throw new ValueError(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${e}`);if(5===e){if("channelsFirst"===n)return 1===a.length?reshape(t,[1,a[0],1,1,1]):reshape(t,[1,a[3],a[0],a[1],a[2]]);if("channelsLast"===n)return 1===a.length?reshape(t,[1,1,1,1,a[0]]):reshape(t,[1].concat(a))}else if(4===e){if("channelsFirst"===n)return 1===a.length?reshape(t,[1,a[0],1,1]):reshape(t,[1,a[2],a[0],a[1]]);if("channelsLast"===n)return 1===a.length?reshape(t,[1,1,1,a[0]]):reshape(t,[1].concat(a))}else if(3===e){if("channelsFirst"===n)return 1===a.length?reshape(t,[1,a[0],1]):reshape(t,[1,a[1],a[0]]);if("channelsLast"===n)return 1===a.length?reshape(t,[1,1,a[0]]):reshape(t,[1].concat(a))}else if(e<3)return t;throw new ValueError(`Unsupported input rank by biasAdd: ${t.rank}`)}function biasAdd(e,t,n){return tidy((()=>(null==n&&(n=imageDataFormat()),checkDataFormat(n),add2(e,reshapeBias(e.rank,t,n)))))}function elu2(e,t=1){if(1!==t)throw new NotImplementedError(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return elu(e)}function softsign(e){return tidy((()=>div(e,add2(abs(e),1))))}function dropout2(e,t,n,a){return tidy((()=>dropout(e,t,n,a)))}function hardSigmoid(e){return tidy((()=>{const t=add2(.5,mul(.2,e));return clipByValue(t,0,1)}))}function inTrainPhase(e,t,n=!1){return n?e():t()}var VALID_FAN_MODE_VALUES=["fanIn","fanOut","fanAvg"],VALID_DISTRIBUTION_VALUES=["normal","uniform","truncatedNormal"];function checkFanMode(e){checkStringTypeUnionValue(VALID_FAN_MODE_VALUES,"FanMode",e)}function checkDistribution(e){checkStringTypeUnionValue(VALID_DISTRIBUTION_VALUES,"Distribution",e)}var Initializer=class extends serialization_exports.Serializable{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}},Zeros=class extends Initializer{apply(e,t){return zeros(e,t)}};Zeros.className="Zeros",serialization_exports.registerClass(Zeros);var Ones=class extends Initializer{apply(e,t){return ones2(e,t)}};Ones.className="Ones",serialization_exports.registerClass(Ones);var Constant=class extends Initializer{constructor(e){if(super(),"object"!=typeof e)throw new ValueError(`Expected argument of type ConstantConfig but got ${e}`);if(void 0===e.value)throw new ValueError(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return tidy((()=>mul(scalar(this.value),ones2(e,t))))}getConfig(){return{value:this.value}}};Constant.className="Constant",serialization_exports.registerClass(Constant);var RandomUniform=class extends Initializer{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return randomUniform(e,this.minval,this.maxval,t)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}};RandomUniform.className="RandomUniform",serialization_exports.registerClass(RandomUniform);var RandomNormal=class extends Initializer{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new NotImplementedError(`randomNormal does not support dType ${t}.`);return randomNormal2(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};RandomNormal.className="RandomNormal",serialization_exports.registerClass(RandomNormal);var TruncatedNormal=class extends Initializer{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new NotImplementedError(`truncatedNormal does not support dType ${t}.`);return truncatedNormal(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};TruncatedNormal.className="TruncatedNormal",serialization_exports.registerClass(TruncatedNormal);var Identity2=class extends Initializer{constructor(e){super(),this.gain=null!=e.gain?e.gain:1}apply(e,t){return tidy((()=>{if(2!==e.length||e[0]!==e[1])throw new ValueError("Identity matrix initializer can only be used for 2D square matrices.");return mul(this.gain,eye(e[0]))}))}getConfig(){return{gain:this.gain}}};function computeFans(e,t="channelsLast"){let n,a;if(checkDataFormat(t),2===e.length)n=e[0],a=e[1];else if(-1!==[3,4,5].indexOf(e.length)){if("channelsFirst"===t){const t=arrayProd(e,2);n=e[1]*t,a=e[0]*t}else if("channelsLast"===t){const t=arrayProd(e,0,e.length-2);n=e[e.length-2]*t,a=e[e.length-1]*t}}else{const t=arrayProd(e);n=Math.sqrt(t),a=Math.sqrt(t)}return[n,a]}Identity2.className="Identity",serialization_exports.registerClass(Identity2);var VarianceScaling=class extends Initializer{constructor(e){if(super(),e.scale<0)throw new ValueError(`scale must be a positive float. Got: ${e.scale}`);this.scale=null==e.scale?1:e.scale,this.mode=null==e.mode?"fanIn":e.mode,checkFanMode(this.mode),this.distribution=null==e.distribution?"normal":e.distribution,checkDistribution(this.distribution),this.seed=e.seed}apply(e,t){const n=computeFans(e),a=n[0],r=n[1];let s=this.scale;if("fanIn"===this.mode?s/=Math.max(1,a):"fanOut"===this.mode?s/=Math.max(1,r):s/=Math.max(1,(a+r)/2),"normal"===this.distribution){const n=Math.sqrt(s);if("float32"!==(t=t||"float32")&&"int32"!==t)throw new NotImplementedError(`${this.getClassName()} does not support dType ${t}.`);return truncatedNormal(e,0,n,t,this.seed)}{const n=Math.sqrt(3*s);return randomUniform(e,-n,n,t)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}};VarianceScaling.className="VarianceScaling",serialization_exports.registerClass(VarianceScaling);var GlorotUniform=class extends VarianceScaling{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return VarianceScaling.className}};GlorotUniform.className="GlorotUniform",serialization_exports.registerClass(GlorotUniform);var GlorotNormal=class extends VarianceScaling{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return VarianceScaling.className}};GlorotNormal.className="GlorotNormal",serialization_exports.registerClass(GlorotNormal);var HeNormal=class extends VarianceScaling{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return VarianceScaling.className}};HeNormal.className="HeNormal",serialization_exports.registerClass(HeNormal);var HeUniform=class extends VarianceScaling{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return VarianceScaling.className}};HeUniform.className="HeUniform",serialization_exports.registerClass(HeUniform);var LeCunNormal=class extends VarianceScaling{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return VarianceScaling.className}};LeCunNormal.className="LeCunNormal",serialization_exports.registerClass(LeCunNormal);var LeCunUniform=class extends VarianceScaling{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return VarianceScaling.className}};LeCunUniform.className="LeCunNormal",serialization_exports.registerClass(LeCunUniform);var Orthogonal=class extends Initializer{constructor(e){if(super(),this.DEFAULT_GAIN=1,this.gain=null==e.gain?this.DEFAULT_GAIN:e.gain,this.seed=e.seed,null!=this.seed)throw new NotImplementedError("Random seed is not implemented for Orthogonal Initializer yet.")}apply(e,t){return tidy((()=>{if(e.length<2)throw new NotImplementedError("Shape must be at least 2D.");e[0]*e[1]>2e3&&console.warn(`Orthogonal initializer is being called on a matrix with more than 2000 (${e[0]*e[1]}) elements: Slowness may result.`);const t=randomNormal2(e[0]>e[1]?[e[1],e[0]]:e,0,1,"float32");let n=linalg.gramSchmidt(t);return e[0]>e[1]&&(n=transpose(n)),mul(this.gain,n)}))}getConfig(){return{gain:this.gain,seed:this.seed}}};Orthogonal.className="Orthogonal",serialization_exports.registerClass(Orthogonal);var INITIALIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function deserializeInitializer(e,t={}){return deserializeKerasObject(e,serialization_exports.SerializationMap.getMap().classNameMap,t,"initializer")}function serializeInitializer(e){return serializeKerasObject(e)}function getInitializer(e){if("string"==typeof e){const t=e in INITIALIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP?INITIALIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP[e]:e;if("GlorotNormal"===t)return new GlorotNormal;if("GlorotUniform"===t)return new GlorotUniform;if("HeNormal"===t)return new HeNormal;if("HeUniform"===t)return new HeUniform;if("LeCunNormal"===t)return new LeCunNormal;if("LeCunUniform"===t)return new LeCunUniform;{const e={};return e.className=t,e.config={},deserializeInitializer(e)}}return e instanceof Initializer?e:deserializeInitializer(e)}function zeros2(){return new Zeros}function ones3(){return new Ones}function constant(e){return new Constant(e)}function randomUniform2(e){return new RandomUniform(e)}function randomNormal3(e){return new RandomNormal(e)}function truncatedNormal2(e){return new TruncatedNormal(e)}function identity(e){return new Identity2(e)}function varianceScaling(e){return new VarianceScaling(e)}function glorotUniform(e){return new GlorotUniform(e)}function glorotNormal(e){return new GlorotNormal(e)}function heNormal(e){return new HeNormal(e)}function heUniform(e){return new HeUniform(e)}function leCunNormal(e){return new LeCunNormal(e)}function leCunUniform(e){return new LeCunUniform(e)}function orthogonal(e){return new Orthogonal(e)}var exports_layers_exports={};__export2(exports_layers_exports,{Layer:()=>Layer,RNN:()=>RNN,RNNCell:()=>RNNCell,activation:()=>activation,add:()=>add3,alphaDropout:()=>alphaDropout,average:()=>average,averagePooling1d:()=>averagePooling1d,averagePooling2d:()=>averagePooling2d,averagePooling3d:()=>averagePooling3d,avgPool1d:()=>avgPool1d,avgPool2d:()=>avgPool2d,avgPool3d:()=>avgPool3d2,avgPooling1d:()=>avgPooling1d,avgPooling2d:()=>avgPooling2d,avgPooling3d:()=>avgPooling3d,batchNormalization:()=>batchNormalization2,bidirectional:()=>bidirectional,concatenate:()=>concatenate2,conv1d:()=>conv1d2,conv2d:()=>conv2d3,conv2dTranspose:()=>conv2dTranspose2,conv3d:()=>conv3d2,conv3dTranspose:()=>conv3dTranspose2,convLstm2d:()=>convLstm2d,convLstm2dCell:()=>convLstm2dCell,cropping2D:()=>cropping2D,dense:()=>dense,depthwiseConv2d:()=>depthwiseConv2d4,dot:()=>dot3,dropout:()=>dropout3,elu:()=>elu3,embedding:()=>embedding,flatten:()=>flatten3,gaussianDropout:()=>gaussianDropout,gaussianNoise:()=>gaussianNoise,globalAveragePooling1d:()=>globalAveragePooling1d,globalAveragePooling2d:()=>globalAveragePooling2d,globalMaxPool1d:()=>globalMaxPool1d,globalMaxPool2d:()=>globalMaxPool2d,globalMaxPooling1d:()=>globalMaxPooling1d,globalMaxPooling2d:()=>globalMaxPooling2d,gru:()=>gru,gruCell:()=>gruCell,input:()=>input,inputLayer:()=>inputLayer,layerNormalization:()=>layerNormalization,leakyReLU:()=>leakyReLU,lstm:()=>lstm,lstmCell:()=>lstmCell,masking:()=>masking,maxPool1d:()=>maxPool1d,maxPool2d:()=>maxPool2d,maxPooling1d:()=>maxPooling1d,maxPooling2d:()=>maxPooling2d,maxPooling3d:()=>maxPooling3d,maximum:()=>maximum2,minimum:()=>minimum2,multiply:()=>multiply,permute:()=>permute,prelu:()=>prelu2,reLU:()=>reLU,repeatVector:()=>repeatVector,reshape:()=>reshape2,rnn:()=>rnn2,separableConv2d:()=>separableConv2d2,simpleRNN:()=>simpleRNN,simpleRNNCell:()=>simpleRNNCell,softmax:()=>softmax2,spatialDropout1d:()=>spatialDropout1d,stackedRNNCells:()=>stackedRNNCells,thresholdedReLU:()=>thresholdedReLU,timeDistributed:()=>timeDistributed,upSampling2d:()=>upSampling2d,zeroPadding2d:()=>zeroPadding2d});var _nextUniqueTensorId=0;function getNextUniqueTensorId(){return _nextUniqueTensorId++}var _uidPrefixes={};function getUid(e=""){return e in _uidPrefixes||(_uidPrefixes[e]=0),_uidPrefixes[e]+=1,e+_uidPrefixes[e].toString()}function isArrayOfShapes(e){return Array.isArray(e)&&Array.isArray(e[0])}function normalizeShapeList(e){return 0===e.length?[]:Array.isArray(e[0])?e:[e]}function getExactlyOneTensor(e){let t;if(Array.isArray(e)){if(1!==e.length)throw new ValueError(`Expected Tensor length to be 1; got ${e.length}`);t=e[0]}else t=e;return t}function getExactlyOneShape(e){if(Array.isArray(e)&&Array.isArray(e[0])){if(1===e.length)return e[0];throw new ValueError(`Expected exactly 1 Shape; got ${e.length}`)}return e}function countParamsInWeights(e){let t=0;for(const n of e)0===n.shape.length?t+=1:t+=n.shape.reduce(((e,t)=>e*t));return t}var DEFAULT_VARIABLE_NAME_PREFIX="Variable",LayerVariable=class{constructor(e,t="float32",n=DEFAULT_VARIABLE_NAME_PREFIX,a=!0,r=null){this.dtype=null==t?"float32":t,this.shape=e.shape,this.id=getNextUniqueTensorId(),n=null==n?DEFAULT_VARIABLE_NAME_PREFIX:n,this.originalName=getScopedTensorName(n),this.name=getUniqueTensorName(this.originalName),this.trainable_=a,this.constraint=r,this.val=variable(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),checkShapesMatch(this.val,e),this.val.id!==e.id&&(this.val.assign(e),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}};function checkShapesMatch(e,t){if(e.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(e.shape)+" vs. "+JSON.stringify(t.shape))}function batchGetValue(e){return e.map((e=>e.read()))}function batchSetValue(e){e.forEach((e=>{e[0].write(e[1])}))}var InputSpec=class{constructor(e){this.dtype=e.dtype,this.shape=e.shape,null!=e.shape?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}},SymbolicTensor=class{constructor(e,t,n,a,r,s,o){this.dtype=e,this.shape=t,this.sourceLayer=n,this.inputs=a,this.callArgs=r,this.outputTensorIndex=o,this.id=getNextUniqueTensorId(),null!=s&&(this.originalName=getScopedTensorName(s),this.name=getUniqueTensorName(this.originalName)),this.rank=t.length}},_nextNodeID=0,Node=class{constructor(e,t){this.callArgs=t,this.id=_nextNodeID++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(const t of e.inboundLayers)null!=t&&t.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){const e=[];for(const t of this.inboundLayers)null!=t?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}},_nextLayerID=0,Layer=class extends serialization_exports.Serializable{constructor(e={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=_nextLayerID++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){const e=this.getClassName();t=toSnakeCase(e)+"_"+getUid(e)}if(this.name=t,this.trainable_=null==e.trainable||e.trainable,null!=e.inputShape||null!=e.batchInputShape){let t;if(null!=e.batchInputShape)t=e.batchInputShape;else if(null!=e.inputShape){let n=null;null!=e.batchSize&&(n=e.batchSize),t=[n].concat(e.inputShape)}this.batchInputShape=t;let n=e.dtype;null==n&&(n=e.inputDType),null==n&&(n="float32"),this.dtype=n}null!=e.weights?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(0===this.inboundNodes.length)throw new RuntimeError(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new ValueError(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return singletonOrArray(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return singletonOrArray(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new AttributeError(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(0===this.inboundNodes.length)throw new AttributeError(`Layer ${this.name} is not connected, no input to return.`);return singletonOrArray(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new AttributeError(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new AttributeError(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return singletonOrArray(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map((e=>e()))}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach((t=>t.trainable=e)),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter((e=>e.trainable)):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter((e=>!e.trainable)).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){if(e=toList(e),null==this.inputSpec||0===this.inputSpec.length)return;const t=toList(this.inputSpec);if(e.length!==t.length)throw new ValueError(`Layer ${this.name} expects ${t.length} inputs, but it received ${e.length} input tensors. Input received: ${e}`);for(let n=0;n<e.length;n++){const a=e[n],r=t[n];if(null==r)continue;const s=a.rank;if(null!=r.ndim&&s!==r.ndim)throw new ValueError(`Input ${n} is incompatible with layer ${this.name}: expected ndim=${r.ndim}, found ndim=${s}`);if(null!=r.maxNDim&&s>r.maxNDim)throw new ValueError(`Input ${n} is incompatible with layer ${this.name}: expected max_ndim=${r.maxNDim}, found ndim=${s}`);if(null!=r.minNDim&&s<r.minNDim)throw new ValueError(`Input ${n} is incompatible with layer ${this.name}: expected min_ndim=${r.minNDim}, found ndim=${s}.`);if(null!=r.dtype&&a.dtype!==r.dtype)throw new ValueError(`Input ${n} is incompatible with layer ${this.name} : expected dtype=${r.dtype}, found dtype=${a.dtype}.`);if(r.axes){const e=a.shape;for(const t in r.axes){const a=Number(t),s=r.axes[t],o=a>=0?e[a]:e[e.length+a];if(null!=s&&-1===[s,null].indexOf(o))throw new ValueError(`Input ${n} is incompatible with layer ${this.name}: expected axis ${a} of input shape to have value ${s} but got shape ${e}.`)}}if(null!=r.shape)for(let e=0;e<r.shape.length;++e){const t=r.shape[e],s=a.shape[e];if(null!=t&&null!=s&&t!==s)throw new ValueError(`Input ${n} is incompatible with layer ${this.name}: expected shape=${r.shape}, found shape=${a.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){null!=this._callHook&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();const n=toList(e);let a=!0;for(const e of n)if(!(e instanceof SymbolicTensor)){a=!1;break}let r=!0;for(const e of n)if(e instanceof SymbolicTensor){r=!1;break}if(a===r)throw new ValueError("Arguments to apply() must be all SymbolicTensors or all Tensors");return nameScope(this.name,(()=>{if(!this.built){this.assertInputCompatibility(e);const t=[];for(const n of toList(e))t.push(n.shape);this.build(singletonOrArray(t)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&r&&(this._refCount=1)}if(this.assertInputCompatibility(e),r){let a=this.call(e,t);const r=toList(a),s=[];for(let e of r)-1!==n.indexOf(e)&&(e=e.clone()),s.push(e);if(a=singletonOrArray(s),null!=this.activityRegularizer)throw new NotImplementedError("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return a}{const n=collectInputShape(e),a=this.computeOutputShape(n);let r;const s=guessOutputDType(e);if(this.warnOnIncompatibleInputShape(Array.isArray(e)?n[0]:n),r=null!=a&&a.length>0&&Array.isArray(a[0])?a.map(((n,a)=>new SymbolicTensor(s,n,this,toList(e),t,this.name,a))):new SymbolicTensor(s,a,this,toList(e),t,this.name),this.addInboundNode(e,r,null,null,n,a,t),this._refCount++,null!=this.activityRegularizer)throw new NotImplementedError("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return r}}))}warnOnIncompatibleInputShape(e){if(null!=this.batchInputShape)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach(((n,a)=>{null!=n&&null!=e[a]&&e[a]!==n&&(t=!0)})),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new AttributeError(`The layer ${this.name} has never been called and thus has no defined output shape.`);const e=[];for(const t of this.inboundNodes){const n=JSON.stringify(t.outputShapes);-1===e.indexOf(n)&&e.push(n)}if(1===e.length){const e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&1===e.length?e[0]:e}throw new AttributeError(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new RuntimeError(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return countParamsInWeights(this.weights)}build(e){this.built=!0}getWeights(e=!1){return batchGetValue(e?this.trainableWeights:this.weights)}setWeights(e){tidy((()=>{const t=this.weights;if(t.length!==e.length)throw new ValueError(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(0===t.length)return;const n=[],a=batchGetValue(t);for(let r=0;r<a.length;++r){const s=a[r],o=t[r],i=e[r];if(!util_exports.arraysEqual(s.shape,i.shape))throw new ValueError(`Layer weight shape ${s.shape} not compatible with provided weight shape ${i.shape}`);n.push([o,i])}batchSetValue(n)}))}addWeight(e,t,n,a,r,s,o,i){if(-1!==this._addedWeightNames.indexOf(e))throw new ValueError(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),null==n&&(n="float32"),this.fastWeightInitDuringBuild&&(a=null!=i?i():getInitializer("zeros"));const l=a.apply(t,n),u=new LayerVariable(l,n,e,s,o);return l.dispose(),null!=r&&this.addLoss((()=>r.apply(u.read()))),null==s&&(s=!0),s?this._trainableWeights.push(u):this._nonTrainableWeights.push(u),u}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){null==e||Array.isArray(e)&&0===e.length||(e=toList(e),void 0!==this._losses&&null!==this._losses&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(null!=t){if(!Array.isArray(t))throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);t.forEach((e=>{if(null!=e)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)}))}return null}return t}addInboundNode(e,t,n,a,r,s,o=null){const i=toList(e);t=toList(t),n=toList(n),a=toList(a),r=normalizeShapeList(r),s=normalizeShapeList(s);const l=[],u=[],c=[];for(const e of i)l.push(e.sourceLayer),u.push(e.nodeIndex),c.push(e.tensorIndex);new Node({outboundLayer:this,inboundLayers:l,nodeIndices:u,tensorIndices:c,inputTensors:i,outputTensors:t,inputMasks:n,outputMasks:a,inputShapes:r,outputShapes:s},o);for(let e=0;e<t.length;e++)t[e].sourceLayer=this,t[e].nodeIndex=this.inboundNodes.length-1,t[e].tensorIndex=e}getConfig(){const e={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(e.batchInputShape=this.batchInputShape),null!=this.dtype&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach((e=>e.dispose())),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(null===this._refCount)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return 0==--this._refCount&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}};function collectInputShape(e){e=toList(e);const t=[];for(const n of e)t.push(n.shape);return singletonOrArray(t)}function guessOutputDType(e){return"float32"}function getSourceInputs(e,t,n){if((null==t||null!=n&&n>0)&&(t=e.sourceLayer,n=e.nodeIndex),0===t.inboundNodes.length)return[e];{const e=t.inboundNodes[n];if(0===e.inboundLayers.length)return e.inputTensors;{const t=[];for(let n=0;n<e.inboundLayers.length;n++){const a=getSourceInputs(e.inputTensors[n],e.inboundLayers[n],e.nodeIndices[n]);for(const e of a)-1===t.indexOf(e)&&t.push(e)}return t}}}var ModelLoggingVerbosity,InputLayer=class extends Layer{constructor(e){if(super({dtype:e.dtype,name:null!=e.name?e.name:getUid("input").toString()}),null==e.batchSize&&(e.batchSize=null),null==e.sparse&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,null!=e.inputShape&&null!=e.batchInputShape)throw new ValueError("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(null==t){if(null==e.inputShape)throw new ValueError("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(null!=e.batchSize)throw new ValueError("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const n=e.dtype||"float32";this.batchInputShape=t,this.dtype=n,this.inputSpec=[{shape:t}];const a=new SymbolicTensor(this.dtype,this.batchInputShape,this,[],{},this.name);a.nodeIndex=0,a.tensorIndex=0,new Node({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[a],outputTensors:[a],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new ValueError(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}};function Input(e){if(null==e.batchShape&&null==e.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=e.batchShape&&null!=e.shape)throw new ValueError("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=e.batchShape;null!=e.shape&&null==t&&(t=[null].concat(e.shape));let n=e.dtype;null==n&&(n="float32");return new InputLayer({batchInputShape:t,name:e.name,dtype:n,sparse:e.sparse}).inboundNodes[0].outputTensors[0]}async function resolveScalarsInLogs(e){if(null==e)return;const t=[],n=[],a=[];for(const r in e){const s=e[r];if("number"!=typeof s){const e=s;t.push(e.data()),n.push(r),a.push(e)}}if(t.length>0){const r=await Promise.all(t);for(let t=0;t<r.length;++t)e[n[t]]=r[t][0];dispose(a)}}function disposeTensorsInLogs(e){if(null!=e)for(const t in e){const n=e[t];"number"!=typeof n&&n.dispose()}}InputLayer.className="InputLayer",serialization_exports.registerClass(InputLayer),function(e){e[e.SILENT=0]="SILENT",e[e.VERBOSE=1]="VERBOSE"}(ModelLoggingVerbosity||(ModelLoggingVerbosity={}));var DEFAULT_YIELD_EVERY_MS=125,BaseCallback=class{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}},CallbackList=class{constructor(e,t=10){null==e&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(const t of this.callbacks)t.setParams(e)}setModel(e){for(const t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onEpochBegin(e,t)}async onEpochEnd(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onEpochEnd(e,t)}async onBatchBegin(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onBatchBegin(e,t)}async onBatchEnd(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onBatchEnd(e,t)}async onTrainBegin(e){null==e&&(e={});for(const t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){null==e&&(e={});for(const t of this.callbacks)await t.onTrainEnd(e)}},BaseLogger=class extends BaseCallback{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){null==t&&(t={});const n=null==t.size?0:t.size;this.seen+=n;for(const e in t){const a=t[e];if("number"==typeof a)this.totals.hasOwnProperty(e)||(this.totals[e]=0),this.totals[e]=this.totals[e]+a*n;else{let t;e in this.totals?t=this.totals[e]:this.totals[e]=0;const r=tidy((()=>add2(this.totals[e],mul(a,n))));this.totals[e]=r,null!=t&&t.dispose()}}}async onEpochEnd(e,t){if(null!=t)for(const e of this.params.metrics)null!=this.totals[e]&&("number"==typeof this.totals[e]?t[e]=this.totals[e]/this.seen:tidy((()=>{const n=mul(div(1,this.seen),this.totals[e]);t[e]=n,this.totals[e].dispose(),keep(t[e])})))}},History=class extends BaseCallback{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){null==t&&(t={}),this.epoch.push(e);for(const e in t)null==this.history[e]&&(this.history[e]=[]),this.history[e].push(t[e])}async syncData(){const e=[],t=[],n=[];for(const a in this.history){const r=this.history[a];for(let s=0;s<r.length;++s)if("number"!=typeof r[s]){const o=r[s];e.push(o.data()),t.push(a),n.push(s)}}const a=await Promise.all(e);for(let e=0;e<a.length;++e){this.history[t[e]][n[e]].dispose(),this.history[t[e]][n[e]]=a[e][0]}}},CustomCallback=class extends BaseCallback{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||nextFrame,this.yieldEvery=t||"auto","auto"===this.yieldEvery&&(this.yieldEvery=DEFAULT_YIELD_EVERY_MS),"never"===this.yieldEvery&&null!=e.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");util_exports.isNumber(this.yieldEvery)&&(this.maybeWait=debounce(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,n){const a=[];null!=this.yield&&(await resolveScalarsInLogs(n),a.push(this.yield(e,t,n))),a.push(this.nextFrameFunc()),await Promise.all(a)}async onEpochBegin(e,t){this.currentEpoch=e,null!=this.epochBegin&&(await resolveScalarsInLogs(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){const n=[];null!=this.epochEnd&&(await resolveScalarsInLogs(t),n.push(this.epochEnd(e,t))),"epoch"===this.yieldEvery&&n.push(this.nextFrameFunc()),await Promise.all(n)}async onBatchBegin(e,t){null!=this.batchBegin&&(await resolveScalarsInLogs(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){const n=[];null!=this.batchEnd&&(await resolveScalarsInLogs(t),n.push(this.batchEnd(e,t))),"batch"===this.yieldEvery?n.push(this.nextFrameFunc()):util_exports.isNumber(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(n)}async onTrainBegin(e){null!=this.trainBegin&&(await resolveScalarsInLogs(e),await this.trainBegin(e))}async onTrainEnd(e){null!=this.trainEnd&&(await resolveScalarsInLogs(e),await this.trainEnd(e))}};function standardizeCallbacks(e,t){if(null==e&&(e={}),e instanceof BaseCallback)return[e];if(Array.isArray(e)&&e[0]instanceof BaseCallback)return e;return toList(e).map((e=>new CustomCallback(e,t)))}var _CallbackConstructorRegistry=class{constructor(){}static registerCallbackConstructor(e,t){util_exports.assert(e>=0&&Number.isInteger(e),(()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`)),_CallbackConstructorRegistry.checkForDuplicate(t),null==_CallbackConstructorRegistry.constructors[e]&&(_CallbackConstructorRegistry.constructors[e]=[]),_CallbackConstructorRegistry.constructors[e].push(t)}static checkForDuplicate(e){for(const t in _CallbackConstructorRegistry.constructors){_CallbackConstructorRegistry.constructors[+t].forEach((t=>{if(t===e)throw new ValueError("Duplicate callback constructor.")}))}}static clear(){_CallbackConstructorRegistry.constructors={}}static createCallbacks(e){const t=[];for(const n in _CallbackConstructorRegistry.constructors){const a=+n;e>=a&&t.push(..._CallbackConstructorRegistry.constructors[a])}return t.map((e=>new e))}},CallbackConstructorRegistry=_CallbackConstructorRegistry;function configureCallbacks(e,t,n,a,r,s,o,i,l){const u=new History,c=[new BaseLogger,...CallbackConstructorRegistry.createCallbacks(t)];null!=e&&c.push(...e),c.push(u);const d=new CallbackList(c);return d.setParams({epochs:n,initialEpoch:a,samples:r,steps:s,batchSize:o,verbose:t,doValidation:i,metrics:l}),{callbackList:d,history:u}}function deserialize(e,t={},n=!1){return deserializeKerasObject(e,serialization_exports.SerializationMap.getMap().classNameMap,t,"layer",n)}function l2Normalize(e,t){return tidy((()=>{"float32"!==e.dtype&&(e=cast(e,"float32"));const n=sum2(square2(e),t,!0),a=fill(n.shape,epsilon()),r=sqrt(maximum(n,a));return div(e,r)}))}function meanSquaredError2(e,t){return tidy((()=>mean(square2(sub(t,e)),-1)))}function meanAbsoluteError(e,t){return tidy((()=>mean(abs(sub(t,e)),-1)))}function meanAbsolutePercentageError(e,t){return tidy((()=>{const n=sub(e,t),a=clipByValue(abs(e),epsilon(),Number.MAX_VALUE),r=abs(div(n,a));return mul(100,mean(r,-1))}))}function meanSquaredLogarithmicError(e,t){return tidy((()=>{const n=clipByValue(t,epsilon(),Number.MAX_VALUE),a=log4(add2(1,n)),r=clipByValue(e,epsilon(),Number.MAX_VALUE),s=log4(add2(1,r));return mean(square2(sub(a,s)),-1)}))}function squaredHinge(e,t){return tidy((()=>{const n=maximum(0,sub(1,mul(e,t)));return mean(square2(n),-1)}))}function hinge(e,t){return tidy((()=>{const n=maximum(0,sub(1,mul(e,t)));return mean(n,-1)}))}function categoricalHinge(e,t){return tidy((()=>{const n=sum2(mul(e,t),-1),a=max(mul(sub(1,e),t),-1);return maximum(0,add2(1,sub(a,n)))}))}function logcosh(e,t){return tidy((()=>{const n=Math.log(2),a=sub(t,e),r=sub(add2(a,softplus(mul(-2,a))),n);return mean(r,-1)}))}function categoricalCrossentropy(e,t,n=!1){return tidy((()=>{if(n)t=softmax(t);else{const e=sum2(t,t.shape.length-1,!0);t=div(t,e)}return t=clipByValue(t,epsilon(),1-epsilon()),neg(sum2(mul(cast(e,"float32"),log4(t)),t.shape.length-1))}))}function sparseCategoricalCrossentropy(e,t,n=!1){return tidy((()=>{const a=cast(floor(flatten2(e)),"int32"),r=(t=clipByValue(t,epsilon(),1-epsilon())).shape;return categoricalCrossentropy(reshape(oneHot(a,r[r.length-1]),r),t,n)}))}function sigmoidCrossEntropyWithLogits(e,t){if(!util_exports.arraysEqual(e.shape,t.shape))throw new ValueError(`logits and labels must have the same shape, but got shapes ${JSON.stringify(e.shape)} and ${JSON.stringify(t.shape)}`);return tidy((()=>{const n=relu(t),a=neg(abs(t));return add2(sub(n,mul(t,e)),log1p(exp(a)))}))}function binaryCrossentropy(e,t){return tidy((()=>{let n;return n=clipByValue(t,epsilon(),1-epsilon()),n=log4(div(n,sub(1,n))),mean(sigmoidCrossEntropyWithLogits(e,n),-1)}))}function kullbackLeiblerDivergence(e,t){return tidy((()=>{const n=clipByValue(e,epsilon(),1),a=clipByValue(t,epsilon(),1);return sum2(mul(e,log4(div(n,a))),-1)}))}function poisson(e,t){return tidy((()=>{const n=log4(add2(epsilon(),t));return mean(sub(t,mul(e,n)),-1)}))}function cosineProximity(e,t){return tidy((()=>{const n=l2Normalize(e,-1),a=l2Normalize(t,-1),r=mul(n,a);return neg(sum2(r,-1))}))}CallbackConstructorRegistry.constructors={};var lossesMap={meanSquaredError:meanSquaredError2,meanAbsoluteError:meanAbsoluteError,meanAbsolutePercentageError:meanAbsolutePercentageError,meanSquaredLogarithmicError:meanSquaredLogarithmicError,squaredHinge:squaredHinge,hinge:hinge,categoricalHinge:categoricalHinge,logcosh:logcosh,categoricalCrossentropy:categoricalCrossentropy,sparseCategoricalCrossentropy:sparseCategoricalCrossentropy,binaryCrossentropy:binaryCrossentropy,kullbackLeiblerDivergence:kullbackLeiblerDivergence,poisson:poisson,cosineProximity:cosineProximity};function get(e){if("string"==typeof e){if(e in lossesMap)return lossesMap[e];let t=`Unknown loss ${e}`;throw e.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${e}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new ValueError(t)}return e}function binaryAccuracy(e,t){return tidy((()=>{const n=mul(.5,onesLike(t)),a=cast2(greater(t,n),e.dtype);return mean(equal(e,a),-1)}))}function categoricalAccuracy(e,t){return tidy((()=>cast2(equal(argMax(e,-1),argMax(t,-1)),"float32")))}function truePositives(e,t){return tidy((()=>cast(sum2(logicalAnd(equal(e,1),equal(t,1))),"float32")))}function falseNegatives(e,t){return tidy((()=>cast(sum2(logicalAnd(equal(e,1),equal(t,0))),"float32")))}function falsePositives(e,t){return tidy((()=>cast(sum2(logicalAnd(equal(e,0),equal(t,1))),"float32")))}function precision(e,t){return tidy((()=>{const n=truePositives(e,t),a=falsePositives(e,t),r=add2(n,a);return cast(where(greater(r,0),div(n,r),0),"float32")}))}function recall(e,t){return tidy((()=>{const n=truePositives(e,t),a=falseNegatives(e,t),r=add2(n,a);return cast(where(greater(r,0),div(n,r),0),"float32")}))}function binaryCrossentropy2(e,t){return binaryCrossentropy(e,t)}function sparseCategoricalAccuracy(e,t){return e.rank===t.rank&&(e=squeeze(e,[e.rank-1])),(t=argMax(t,-1)).dtype!==e.dtype&&(t=cast(t,e.dtype)),cast(equal(e,t),"float32")}var mse=meanSquaredError2,MSE=meanSquaredError2,mae=meanAbsoluteError,MAE=meanAbsoluteError,mape=meanAbsolutePercentageError,MAPE=meanAbsolutePercentageError,categoricalCrossentropy2=categoricalCrossentropy,cosine=cosineProximity,sparseCategoricalCrossentropy2=sparseCategoricalCrossentropy,metricsMap={binaryAccuracy:binaryAccuracy,categoricalAccuracy:categoricalAccuracy,precision:precision,categoricalCrossentropy:categoricalCrossentropy2,sparseCategoricalCrossentropy:sparseCategoricalCrossentropy2,mse:mse,MSE:MSE,mae:mae,MAE:MAE,mape:mape,MAPE:MAPE,cosine:cosine};function get2(e){if("string"==typeof e&&e in metricsMap)return metricsMap[e];if("string"!=typeof e&&null!=e)return e;throw new ValueError(`Unknown metric ${e}`)}function getLossOrMetricName(e){if(assert2(null!==e,`Unknown LossOrMetricFn ${e}`),"string"==typeof e)return e;{let t;for(const n of Object.keys(lossesMap))if(lossesMap[n]===e){t=n;break}if(void 0!==t)return t;for(const n of Object.keys(metricsMap))if(metricsMap[n]===e){t=n;break}return void 0!==t?t:e.name}}function getOptimizer(e){const t={Adagrad:()=>train.adagrad(.01),Adadelta:()=>train.adadelta(1,.95,epsilon()),Adam:()=>train.adam(.001,.9,.999,epsilon()),Adamax:()=>train.adamax(.002,.9,.999,epsilon(),0),RMSProp:()=>train.rmsprop(.001,.9,0,epsilon()),SGD:()=>train.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,e in t)return t[e]();throw new ValueError(`Unknown Optimizer ${e}`)}var MAX_USER_DEFINED_METADATA_SERIALIZED_LENGTH=1048576;function checkUserDefinedMetadata(e,t,n=!1){if(null==e||"object"!=typeof e||Object.getPrototypeOf(e)!==Object.prototype||!plainObjectCheck(e))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){const n=JSON.stringify(e);n.length>MAX_USER_DEFINED_METADATA_SERIALIZED_LENGTH&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${n.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${MAX_USER_DEFINED_METADATA_SERIALIZED_LENGTH}.`)}}function plainObjectCheck(e){if(null===e)return!0;if("object"==typeof e){if(Object.getPrototypeOf(e)===Object.prototype){const t=Object.keys(e);for(const n of t){if("string"!=typeof n)return!1;if(!plainObjectCheck(e[n]))return!1}return!0}if(Array.isArray(e)){for(const t of e)if(!plainObjectCheck(t))return!1;return!0}return!1}{const t=typeof e;return"string"===t||"number"===t||"boolean"===t}}function printSummary(e,t,n,a=console.log){const r=isModelSequentialLike(e),s=["Layer (type)","Output shape","Param #"];let o;if(r?(t=t||65,n=n||[.45,.85,1]):(t=t||98,n=n||[.33,.55,.67,1]),n[n.length-1]<=1&&(n=n.map((e=>Math.floor(t*e)))),!r){s.push("Receives inputs"),o=[];for(const t in e.nodesByDepth)o.push(...e.nodesByDepth[t])}a("_".repeat(t)),printRow(s,n,a),a("=".repeat(t));const i=e.layers;for(let e=0;e<i.length;++e)r?printLayerSummary(i[e],n,a):printLayerSummaryWithConnections(i[e],n,o,a),a((e===i.length-1?"=":"_").repeat(t));e.checkTrainableWeightsConsistency();const l=countTrainableParams(e),u=countParamsInWeights(e.nonTrainableWeights);a(`Total params: ${l+u}`),a(`Trainable params: ${l}`),a(`Non-trainable params: ${u}`),a("_".repeat(t))}function countTrainableParams(e){let t;return t=null!=e.collectedTrainableWeights?countParamsInWeights(e.collectedTrainableWeights):countParamsInWeights(e.trainableWeights),t}function isModelSequentialLike(e){let t=!0;const n=[],a=[];for(const t in e.nodesByDepth)n.push(e.nodesByDepth[t]);for(const e of n){if(e.length>1||1===e.length&&e[0].inboundLayers.length>1){t=!1;break}a.push(...e)}if(t)for(const n of e.layers){let e=!1;for(const r of n.inboundNodes)if(-1!==a.indexOf(r)){if(e){t=!1;break}e=!0}if(!t)break}return t}function printRow(e,t,n=console.log){let a="";for(let n=0;n<e.length;++n)n>0&&(a=a.slice(0,a.length-1)+" "),a+=e[n],a=a.slice(0,t[n]),a+=" ".repeat(t[n]-a.length);n(a)}function printLayerSummary(e,t,n){let a;try{a=JSON.stringify(e.outputShape)}catch(e){a="multiple"}printRow([`${e.name} (${e.getClassName()})`,a,e.countParams().toString()],t,n)}function printLayerSummaryWithConnections(e,t,n,a){let r;try{r=JSON.stringify(e.outputShape)}catch(e){r="multiple"}const s=[];for(const t of e.inboundNodes)if(!(null!=n&&n.length>0&&-1===n.indexOf(t)))for(let e=0;e<t.inboundLayers.length;++e){const n=t.inboundLayers[e].name,a=t.nodeIndices[e],r=t.tensorIndices[e];s.push(`${n}[${a}][${r}]`)}const o=e.name,i=e.getClassName(),l=0===s.length?"":s[0];printRow([`${o} (${i})`,r,e.countParams().toString(),l],t,a);for(let e=1;e<s.length;++e)printRow(["","","",s[e]],t,a)}function isArrayItemInputOrOutputName(e,t,n){return("inboundNodes"===e||"outputLayers"===e||"inputLayers"===e)&&0===t&&"string"==typeof n}function convertPythonicToTs(e,t){if(null===e)return null;if("string"==typeof e)return toCamelCase(e);if("number"==typeof e||"boolean"==typeof e)return e;if(e instanceof Array){const n=[],a=e.length;for(let r=0;r<a;++r){const a=e[r];isArrayItemInputOrOutputName(t,r,a)?n.push(a):n.push(convertPythonicToTs(a,t))}return n}{const t={};for(const n of Object.keys(e)){const a=e[n];if("name"===n&&"string"==typeof a)t[n]=a;else{const e=toCamelCase(n);t[e]=convertPythonicToTs(a,e)}}return t}}function convertTsToPythonic(e,t){if(null==e)return null;if("string"==typeof e)return toSnakeCase(e);if("number"==typeof e||"boolean"==typeof e)return e;if(e instanceof Array){const n=[],a=e.length;for(let r=0;r<a;++r){const a=e[r];isArrayItemInputOrOutputName(t,r,a)?n.push(a):n.push(convertTsToPythonic(a,t))}return n}{const t={};for(const n of Object.keys(e)){const a=e[n],r=toSnakeCase(n);t[r]="name"!==n&&"className"!==n||"string"!=typeof a?convertTsToPythonic(a,n):a}return t}}var version2="0.0.0";function assertFeedCompatibility(e,t){if(null==e.dtype||e.dtype===t.dtype)return t;try{return cast(t,e.dtype)}catch(n){throw new ValueError(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${e.name}' (${e.dtype}).`)}}var FeedDict=class{constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof FeedDict)for(const t in e.id2Value)this.id2Value[t]=e.id2Value[t],t in e.id2Mask&&(this.id2Mask[t]=e.id2Mask[t]);else{if(null==e)return;for(const t of e)this.add(t.key,t.value)}}add(e,t,n){if(null!=this.id2Value[e.id])throw new ValueError(`Duplicate key: name=${e.name}, id=${e.id}`);return this.id2Value[e.id]=assertFeedCompatibility(e,t),this.name2Id[e.name]=e.id,null!=n&&(this.id2Mask[e.id]=n),this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return null!=this.id2Value[e.id]}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof SymbolicTensor){if(null==this.id2Value[e.id])throw new ValueError(`Nonexistent key: ${e.name}`);return this.id2Value[e.id]}{const t=this.name2Id[e];if(null==t)throw new ValueError(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[t]}}getMask(e){if(e instanceof SymbolicTensor){if(null==this.id2Value[e.id])throw new ValueError(`Nonexistent key: ${e.name}`);return this.id2Mask[e.id]}{const t=this.name2Id[e];if(null==t)throw new ValueError(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[t]}}disposeMasks(){null!=this.id2Mask&&dispose(this.id2Mask)}},cachedSorted={},cachedRecipientCounts={};function execute(e,t,n,a){const r=null!=n&&n.training,s=Array.isArray(e),o=s?e:[e],i=o.map((e=>e.name)),l=[],u=t.names();for(const e of i)-1!==u.indexOf(e)?l.push(t.getValue(e)):l.push(null);null!=a&&(a.maxNumTensors=-1/0,a.minNumTensors=1/0);const c=i.join(",")+"|"+t.names().join(",");let d,p;if(null==cachedSorted[c]){const e=getTopologicalSortAndRecipientCounts(o,t);d=e.sorted,p=e.recipientCounts,cachedSorted[c]=d,cachedRecipientCounts[c]=p}d=cachedSorted[c],p={},r||Object.assign(p,cachedRecipientCounts[c]);const h=new FeedDict(t);for(let e=0;e<d.length;++e){if(null!=a){const e=memory().numTensors;e>a.maxNumTensors&&(a.maxNumTensors=e),e<a.minNumTensors&&(a.minNumTensors=e)}const s=d[e],o=s.sourceLayer;if(o instanceof InputLayer)continue;const u=[],c=[],m=[];let f=!1;for(const e of s.inputs){const n=h.getValue(e),a=h.getMask(e);u.push(n),c.push(a),null!=a&&(f=!0),r||(p[e.name]--,0!==p[e.name]||t.hasKey(e)||-1!==i.indexOf(e.name)||n.isDisposed||!0===e.sourceLayer.stateful||m.push(n))}f&&((n=n||{}).mask=c[0]);const g=toList(o.apply(u,n));let x=null;o.supportsMasking&&(x=o.computeMask(u,c));const y=getNodeOutputs(s),A=Array.isArray(y)?y:[y];for(let e=0;e<A.length;++e){h.hasKey(A[e])||h.add(A[e],g[e],Array.isArray(x)?x[0]:x);const t=i.indexOf(A[e].name);-1!==t&&(l[t]=g[e])}r||dispose(m)}return h.disposeMasks(),s?l:l[0]}function getTopologicalSortAndRecipientCounts(e,t){util_exports.assert(null!=e&&e.length>0,(()=>"Expected at least one fetch, got none"));let n=[],a={};if(1===e.length){const r=getTopologicalSortAndRecipientCountsForOneFetch(e[0],t);n=r.sorted,a=r.recipientMap}else{const r=new Set;for(const s of e){const{sorted:e,recipientMap:o}=getTopologicalSortAndRecipientCountsForOneFetch(s,t);for(const t of e)r.has(t.name)||(n.push(t),r.add(t.name));for(const e in o)null==a[e]&&(a[e]=new Set),o[e].forEach((t=>a[e].add(t)))}}return{sorted:n,recipientCounts:recipientMap2Counts(a)}}function recipientMap2Counts(e){const t={};for(const n in e)t[n]=e[n].size;return t}function getTopologicalSortAndRecipientCountsForOneFetch(e,t){const n=new Set,a=[],r={};for(const e of t.names())n.add(e);const s=[],o=[];for(s.push(e);s.length>0;){const e=s[s.length-1];if(n.has(e.name)){s.pop();continue}const t=o[o.length-1]===s.length-1;if(0===e.inputs.length||t)s.pop(),a.push(e),n.add(e.name),t&&o.pop();else{o.push(s.length-1);for(const t of e.inputs)null==r[t.name]&&(r[t.name]=new Set),r[t.name].add(e.name),n.has(t.name)||s.push(t)}}return{sorted:a,recipientMap:r}}function getNodeOutputs(e){let t;if(1===e.sourceLayer.inboundNodes.length)t=e.sourceLayer.output;else{let n=null;for(let t=0;t<e.sourceLayer.inboundNodes.length;++t)for(const a of e.sourceLayer.inboundNodes[t].outputTensors)if(a.id===e.id){n=t;break}t=e.sourceLayer.getOutputAt(n)}return t}var Container=class extends Layer{constructor(e){if(super({}),this.containerNodes=new Set,this.name=e.name,null==this.name){const e=this.getClassName().toLowerCase();this.name=getUid(e)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],unique2(this.inputs).length!==this.inputs.length)throw new ValueError(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map((e=>e.name))}`);unique2(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map((e=>e.name))}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const e of this.outputs){const t=e.sourceLayer,n=e.nodeIndex,a=e.tensorIndex;this.outputLayers.push(t),this.outputLayersNodeIndices.push(n),this.outputLayersTensorIndices.push(a)}for(const e of this.inputs){const t=e.sourceLayer,n=e.nodeIndex,a=e.tensorIndex;assert2(0===n,"input layer has >1 nodes"),assert2(0===a,"input layer has >1 tensors"),this.inputLayers.push(t),this.inputLayersNodeIndices.push(n),this.inputLayersTensorIndices.push(a)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let t=0;t<this.inputLayers.length;t++){const n=this.inputLayers[t];if(!(n instanceof InputLayer))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${e.inputs}. Input ${t} (0-based) originates from layer type ${n.getClassName()}.`);this.inputNames.push(n.name),this.feedInputShapes.push(n.batchInputShape),this.feedInputNames.push(n.name)}for(const e of this.outputLayers)this.outputNames.push(e.name);this.internalInputShapes=this.inputs.map((e=>e.shape)),this.internalOutputShapes=this.outputs.map((e=>e.shape));const t={},n={},a={},r={},s={},o=[],i=(e,t,n,a,r,l)=>{null!=a&&null!=r&&null!=l||(a=e.sourceLayer,r=e.nodeIndex,l=e.tensorIndex);const u=a.inboundNodes[r];if(-1!==n.indexOf(u))throw new RuntimeError(`The tensor ${e.name} at layer "${a.name}" is part of a cycle.`);if(-1!==t.indexOf(u))return;this.containerNodes.add(Container.nodeKey(a,r)),a.id in s||(s[a.id]=Object.keys(s).length),-1===n.indexOf(u)&&n.push(u);const c=u.inboundLayers.length;for(let e=0;e<c;e++){const a=u.inputTensors[e],r=u.inboundLayers[e],s=u.nodeIndices[e],o=u.tensorIndices[e];i(a,t,n,r,s,o)}for(t.push(u);n.indexOf(u)>=0;)n.splice(n.indexOf(u),1);o.push(u)},l=[],u=[];for(const e of this.outputs)i(e,l,u);const c=o.slice().reverse();for(const e of c){n[e.id]=e,e.id in t||(t[e.id]=0);let s=t[e.id];const o=null==a[e.outboundLayer.id]?0:a[e.outboundLayer.id];s=Math.max(s,o),a[e.outboundLayer.id]=s,r[e.outboundLayer.id]=e.outboundLayer,t[e.id]=s;for(let a=0;a<e.inboundLayers.length;a++){const r=e.inboundLayers[a],o=e.nodeIndices[a],i=r.inboundNodes[o],l=null==t[i.id]?0:t[i.id];t[i.id]=Math.max(s+1,l),n[i.id]=i}}const d={};for(const e in t){const a=t[e];a in d||(d[a]=[]),d[a].push(n[e])}const p={};for(const e in a){const t=a[e];t in p||(p[t]=[]),p[t].push(r[e])}let h=Object.keys(p).map((e=>parseInt(e,10))).sort(reverseNumberCompare);this.layers=[];for(const e of h){const t=p[e];t.sort(((e,t)=>{const n=s[e.id],a=s[t.id];return n<a?-1:n>a?1:0}));for(const e of t)e instanceof Container&&this.internalContainerRefs.push(e),this.layers.push(e)}this.layersByDepth=p,h=Object.keys(d).map((e=>parseInt(e,10))).sort(reverseNumberCompare);const m=this.inputs.slice(),f=[];for(const e of h)for(const t of d[e]){const e=t.outboundLayer;if(null!=e){for(const n of t.inputTensors)if(-1===m.indexOf(n))throw new RuntimeError(`Graph disconnected: cannot obtain value for tensor ${n} at layer "${e.name}". The following previous layers were accessed without issue: ${f}`);for(const e of t.outputTensors)m.push(e);f.push(e.name)}}this.nodesByDepth=d;const g=this.layers.map((e=>e.name));for(const e of g){const t=g.filter((t=>t===e)).length;if(1!==t)throw new RuntimeError(`The name "${e}" is used ${t} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(g))}this.outboundNodes=[],this.inboundNodes=[],new Node({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map((e=>null)),outputMasks:this.outputs.map((e=>null)),inputShapes:this.inputs.map((e=>e.shape)),outputShapes:this.outputs.map((e=>e.shape))}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const e={refCountAfterDispose:null,numDisposedVariables:0};if(0==--this._refCount){for(const t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(const t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach((t=>{t._trainableWeights.forEach((t=>t.trainable=e))})),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new ValueError("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(const t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const e of this.layers)t.push(...e.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e,t=!0){const n={};let a=0;for(const e of this.layers)for(const t of e.weights){if(null!=n[t.originalName])throw new ValueError(`Duplicate weight name: ${t.originalName}`);n[t.originalName]=t,a++}const r=[];for(const a in e){let s=a;if(null==n[a]){const e=a.split("/");s=e.slice(0,-2).concat([e[e.length-1]]).join("/")}if(null!=n[s])r.push([n[s],e[a]]);else if(t)throw new ValueError(`Provided weight data has no target variable: ${a}`);delete n[s]}if(t){const e=[];for(const t in n)e.push(t);if(e.length>0)throw new ValueError(`${e.length} of ${a} weights are not set: ${e}`)}batchSetValue(r)}updatedConfig(){const e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion=`tfjs-layers ${version2}`,t.backend="TensorFlow.js",t}toJSON(e,t=!0){const n=convertTsToPythonic(this.updatedConfig());return t?JSON.stringify(n):n}call(e,t){return tidy((()=>{e=toList(e);const n=new FeedDict;for(let t=0;t<this.inputs.length;++t)n.add(this.inputs[t],e[t]);return execute(this.outputs,n,t)}))}computeMask(e,t){return tidy((()=>{let n;return e=toList(e),n=null==t?pyListRepeat(null,e.length):toList(t),this.runInternalGraph(e,n)[1]}))}computeOutputShape(e){const t=normalizeShapeList(e);if(t.length!==this.inputLayers.length)throw new ValueError(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);const n={};for(let e=0;e<t.length;e++){const a=this.inputLayers[e],r=t[e];n[a.name+"_0_0"]=r}const a=Object.keys(this.nodesByDepth).map((e=>parseInt(e,10))).sort(reverseNumberCompare);if(a.length>1)for(const e of a){const t=this.nodesByDepth[e];for(const e of t){const t=e.outboundLayer;if(-1!==this.inputLayers.map((e=>e.id)).indexOf(t.id))continue;const a=[];for(let t=0;t<e.inboundLayers.length;t++){const r=e.inboundLayers[t],s=e.nodeIndices[t],o=e.tensorIndices[t],i=n[`${r.name}_${s}_${o}`];a.push(i)}const r=normalizeShapeList(t.computeOutputShape(singletonOrArray(a))),s=t.inboundNodes.indexOf(e);for(let e=0;e<r.length;e++){n[`${t.name}_${s}_${e}`]=r[e]}}}const r=[],s=[];for(let e=0;e<this.outputLayers.length;e++){const t=this.outputLayers[e],n=this.outputLayersNodeIndices[e],a=this.outputLayersTensorIndices[e],r=`${t.name}_${n}_${a}`;s.push(r)}for(let e=0;e<s.length;e++){const t=s[e];assert2(t in n),r.push(n[t])}return singletonOrArray(r)}runInternalGraph(e,t){null==t&&(t=pyListRepeat(null,e.length));const n={};for(let a=0;a<this.inputs.length;++a){const r=this.inputs[a],s=e[a],o=t[a];n[r.id]=[s,o]}const a=Object.keys(this.nodesByDepth).map((e=>parseInt(e,10))).sort(reverseNumberCompare);for(const e of a){const t=this.nodesByDepth[e];for(const e of t){const t=e.outboundLayer,a=e.inputTensors,r=e.outputTensors,s=new Array;for(const e of a)e.id in n&&s.push(n[e.id]);if(s.length===a.length){let a,o,i,l,u={};if(null!=e.callArgs&&(u=e.callArgs),1===s.length){const[e,n]=s[0];null==u.mask&&(u.mask=n),i=toList(t.call(e,u)),l=toList(t.computeMask(e,n)),a=[e],o=[n]}else a=s.map((e=>e[0])),o=s.map((e=>e[1])),null==u.mask&&(u.mask=o),i=toList(t.call(a,u)),l=toList(t.computeMask(a,o));if(t.activityRegularizer)throw new NotImplementedError("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let e=0;e<r.length;++e){const t=r[e],a=i[e],s=l[e];n[t.id]=[a,s]}}}}const r=[],s=[],o=[];for(const e of this.outputs){assert2(e.id in n,`Could not compute output ${e.name} : ${e.id}`);const[t,a]=n[e.id];o.push(t.shape),r.push(t),s.push(a)}return[r,s,o]}buildNodeConversionMap(e){const t={};let n;for(const e of this.layers){n=e instanceof Container?1:0;for(let a=0;a<e.inboundNodes.length;a++){const r=Container.nodeKey(e,a);this.containerNodes.has(r)&&(t[r]=n,n+=1)}}return t}getLayer(e,t){if(null!=t){if(this.layers.length<=t)throw new ValueError(`Was asked to retrieve layer at index ${t}, but model only has ${this.layers.length} layer(s).`);return this.layers[t]}if(null==e)throw new ValueError("Provide either a layer name or layer index");for(const t of this.layers)if(t.name===e)return t;throw new ValueError(`No such layer: ${e}`)}calculateLosses(){return tidy((()=>{const e=[];for(const t of this.layers)for(let n=0;n<t.inboundNodes.length;++n){const a=Container.nodeKey(t,n);this.containerNodes.has(a)&&e.push(...t.calculateLosses())}return e}))}getConfig(){const e={name:this.name},t=this.buildNodeConversionMap(this.layers),n=[];for(const e of this.layers){const a=e.getClassName(),r=e.getConfig(),s=[];for(let n=0;n<e.inboundNodes.length;n++){const a=e.inboundNodes[n],r=Container.nodeKey(e,n);let o={};if(this.containerNodes.has(r)){if(a.callArgs)try{JSON.stringify(a.callArgs),o=a.callArgs}catch(t){console.warn(`Layer ${e.name} was passed non-serializable keyword arguments: ${a.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),o={}}if(a.inboundLayers.length>0){const e=[];for(let n=0;n<a.inboundLayers.length;n++){const r=a.inboundLayers[n],s=a.nodeIndices[n],i=a.tensorIndices[n];let l=t[Container.nodeKey(r,s)];null==l&&(l=0),e.push([r.name,l,i,o])}s.push(e)}}}const o={};o.name=e.name,o.className=a,o.config=r,o.inboundNodes=s,n.push(o)}e.layers=n;const a=[];for(let e=0;e<this.inputLayers.length;e++){const n=this.inputLayers[e],r=this.inputLayersNodeIndices[e],s=Container.nodeKey(n,r);if(!this.containerNodes.has(s))continue;let o=t[s];null==o&&(o=0);const i=this.inputLayersTensorIndices[e];a.push([n.name,o,i])}e.inputLayers=a;const r=[];for(let e=0;e<this.outputLayers.length;e++){const n=this.outputLayers[e],a=this.outputLayersNodeIndices[e],s=Container.nodeKey(n,a);if(!this.containerNodes.has(s))continue;let o=t[s];null==o&&(o=0);const i=this.outputLayersTensorIndices[e];r.push([n.name,o,i])}return e.outputLayers=r,e}static fromConfig(e,t,n={},a=!1){const r={},s={};function o(e,t){e.name in s?s[e.name].push(t):s[e.name]=[t]}function i(e,t){const n=[];let a;for(const s of t){const i=s[0],l=s[1],u=s[2];if(a=null==s[3]?{}:s[3],!(i in r))return void o(e,t);const c=r[i];if(c.inboundNodes.length<=l)return void o(e,t);const d=c.inboundNodes[l];n.push(d.outputTensors[u])}n.length>0&&e.apply(singletonOrArray(n),a)}function l(e){const n=e.name,s=deserialize(e,null!=t.customObjects?t.customObjects:{});s.setFastWeightInitDuringBuild(a),r[n]=s;e.inboundNodes.forEach((e=>{if(!(e instanceof Array))throw new ValueError(`Corrupted configuration, expected array for nodeData: ${e}`);o(s,e)}))}const u=t.name,c=t.layers;for(const e of c)l(e);for(;!isObjectEmpty(s);)for(const e of c){const t=r[e.name];if(t.name in s){const e=s[t.name];delete s[t.name];for(const n of e)i(t,n)}}const d=[],p=[],h=t.inputLayers;for(const e of h){const t=e[0],n=e[1],a=e[2];assert2(t in r);const s=r[t].inboundNodes[n].outputTensors;d.push(s[a])}const m=t.outputLayers;for(const e of m){const t=e[0],n=e[1],a=e[2];assert2(t in r);const s=r[t].inboundNodes[n].outputTensors;p.push(s[a])}return new e({inputs:d,outputs:p,name:u})}get stateful(){if(this._stateful)throw new ValueError("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const e of this.layers)if(e.stateful)return!0;return!1}resetStates(){tidy((()=>{this.layers.forEach((e=>{e.stateful&&e.resetStates()}))}))}};function standardizeSampleOrClassWeights(e,t,n){const a=t.length;if(null==e||Array.isArray(e)&&0===e.length)return t.map((e=>null));if(1===a)return Array.isArray(e)&&1===e.length?e:"object"==typeof e&&t[0]in e?[e[t[0]]]:[e];if(Array.isArray(e)){if(e.length!==a)throw new Error(`Provided ${n} is an array of ${e.length} element(s), but the model has ${a} outputs. Make sure a set of weights is provided for each model output.`);return e}if("object"==typeof e&&Object.keys(e).length>0&&"object"==typeof e[Object.keys(e)[0]]){const n=[];return t.forEach((t=>{t in e?n.push(e[t]):n.push(null)})),n}throw new Error(`The model has multiple (${a}) outputs, so ${n} must be either an array with ${a} elements or an object with ${t} keys. Provided ${n} not understood: ${JSON.stringify(e)}`)}function standardizeClassWeights(e,t){return standardizeSampleOrClassWeights(e,t,"classWeight")}async function standardizeWeights(e,t,n,a){if(null!=t||null!=a)throw new Error("Support sampleWeight is not implemented yet");if(null!=n){const t=tidy((()=>{if(1===e.shape.length)return clone(e);if(2===e.shape.length){if(e.shape[1]>1){return argMax(e,1)}if(1===e.shape[1])return reshape(e,[e.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${e.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}throw new Error(`Unexpected rank of target (y) tensor (${e.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)})),a=Array.from(await t.data());dispose(t);const r=[];return a.forEach((e=>{if(null==n[e])throw new Error(`classWeight must contain all classes in the training data. The class ${e} exists in the data but not in classWeight`);r.push(n[e])})),tensor1d(r,"float32")}return null}function computeWeightedLoss2(e,t){return mul(e,t)}var DEFAULT_VALIDATION_BATCH_SIZE=32;function standardizeDataIteratorOutput(e,t){let n,a;const r=t;n=r.xs,a=r.ys,util_exports.assert(null!=n&&null!=a,(()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`));const s=flattenTensorOrArrayOrMap("input",e.inputNames,n),o=flattenTensorOrArrayOrMap("output",e.outputNames,a),i=s[0].shape[0];util_exports.assert(s.length===e.inputs.length,(()=>`LayersModel has ${e.inputs.length} inputs, but the dataset provides ${s.length} inputs.  (Expected input keys: ${JSON.stringify(e.inputNames)})`)),util_exports.assert(o.length===e.outputs.length,(()=>`LayersModel has ${e.outputs.length} outputs, but the dataset provides ${o.length} outputs.  (Expected output keys: ${JSON.stringify(e.outputNames)})`));for(let t=0;t<s.length;t++)util_exports.assert(s[t].shape[0]===i,(()=>`Batch size mismatch: input ${e.inputNames[t]} has ${s[t].shape[0]}; expected  ${i} based on input ${e.inputNames[0]}.`));for(let t=0;t<o.length;t++)util_exports.assert(o[t].shape[0]===i,(()=>`Batch size mismatch: output ${e.outputNames[t]} has ${o[t].shape[0]}; expected  ${i} based on input ${e.inputNames[0]}.`));return{xs:s,ys:o}}function flattenTensorOrArrayOrMap(e,t,n){if(n instanceof Tensor)return[n];if(Array.isArray(n))return util_exports.assert(n.length===t.length,(()=>`Received an array of ${n.length} Tensors, but expected ${t.length} to match the ${e} keys ${t}.`)),n;{const a=[];for(const r of t){if(null==n[r])throw new ValueError(`The feature data generated by the dataset lacks the required ${e} key '${r}'.`);a.push(n[r])}return a}}function standardizeTensorValidationData(e){if(3===e.length)throw new NotImplementedError("Validation with sample weights is not implemented yet.");return{xs:e[0],ys:e[1]}}async function fitDataset(e,t,n){const a=null!=n.batchesPerEpoch;if(util_exports.assert(null!=e.optimizer,(()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig).")),util_exports.assert(null!=n,(()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call.")),util_exports.assert(null!=n.epochs&&n.epochs>0&&Number.isInteger(n.epochs),(()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${n.epochs}`)),util_exports.assert(!a||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),(()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${n.batchesPerEpoch}`)),util_exports.assert(null==n.validationSplit,(()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead.")),e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");e.isTraining=!0;try{const r=null!=n.validationData;let s,o;if(r)if(isDatasetObject(n.validationData))util_exports.assert(null==n.validationBatches||n.validationBatches>0&&Number.isInteger(n.validationBatches),(()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${n.validationBatches}`));else{const e=standardizeTensorValidationData(n.validationData);s=e.xs,o=e.ys}const i=e.makeTrainFunction(),l=e.getDedupedMetricsNames();let u;u=r?l.slice().concat(l.map((e=>"val_"+e))):l.slice();const c=standardizeCallbacks(n.callbacks,n.yieldEvery),d=null==n.verbose?1:n.verbose,{callbackList:p,history:h}=configureCallbacks(c,d,n.epochs,null,null,getStepsPerEpoch(t,n),null,r,u);p.setModel(e),e.history=h,await p.onTrainBegin(),e.stopTraining_=!1;let m=null==n.initialEpoch?0:n.initialEpoch,f=await t.iterator();for(;m<n.epochs;){const u={};await p.onEpochBegin(m);let c=0,d=0;for(a||(f=await t.iterator());!a||c<n.batchesPerEpoch;){const t=await f.next();if(a&&t.done){console.warn(`You provided \`batchesPerEpoch\` as ${n.batchesPerEpoch}, but your dataset iterator ran out of data after ${c} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${n.batchesPerEpoch*n.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(null!=t.value){const{xs:a,ys:r}=standardizeDataIteratorOutput(e,t.value),s={};s.batch=d,s.size=a[0].shape[0],await p.onBatchBegin(d,s);const o=[];if(null!=n.classWeight){const t=standardizeClassWeights(n.classWeight,e.outputNames);for(let e=0;e<t.length;++e)o.push(await standardizeWeights(r[e],null,t[e]))}const u=a.concat(r).concat(o),h=i(u);dispose(u);for(let e=0;e<l.length;++e){const t=l[e],n=h[e];s[t]=n,keep(n)}await p.onBatchEnd(d,s),disposeTensorsInLogs(s),d++,c++}if(a?c>=n.batchesPerEpoch:t.done){if(r){let t;t=isDatasetObject(n.validationData)?toList(await e.evaluateDataset(n.validationData,{batches:n.validationBatches})):toList(e.evaluate(s,o,{batchSize:null==n.validationBatchSize?DEFAULT_VALIDATION_BATCH_SIZE:n.validationBatchSize,verbose:0}));for(let n=0;n<e.metricsNames.length;++n)u[`val_${e.metricsNames[n]}`]=t[n]}break}if(e.stopTraining_)break}if(await p.onEpochEnd(m,u),m++,e.stopTraining_)break}return await p.onTrainEnd(),await e.history.syncData(),e.history}finally{e.isTraining=!1}}function getStepsPerEpoch(e,t){let n=null;return null!=t.batchesPerEpoch?n=t.batchesPerEpoch:Number.isFinite(e.size)&&(n=e.size),n}function isDatasetObject(e){return"function"==typeof e.iterator}function isLazyIteratorObject(e){return"function"==typeof e.next}async function evaluateDataset(e,t,n){const a=null!=(n=n||{}).batches,r=e.testFunction;let s=[];if(n.verbose>0)throw new NotImplementedError("Verbose mode is not implemented yet.");util_exports.assert(!a||n.batches>0&&Number.isInteger(n.batches),(()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(n.batches)}`));const o=isLazyIteratorObject(t)?t:await t.iterator();let i=0,l=0;for(;!a||l<n.batches;){const t=await o.next();if(s=tidy((()=>{if(t.value){const{xs:n,ys:a}=standardizeDataIteratorOutput(e,t.value),o=n.concat(a),u=tidy((()=>r(o)));if(dispose(o),0===l)for(let e=0;e<u.length;++e)s.push(scalar(0));const c=o[0].shape[0];for(let e=0;e<u.length;++e){const t=u[e],n=s[e];s[e]=tidy((()=>add2(s[e],mul(c,t)))),l>0&&dispose(n)}dispose(u),i+=c,++l}return s})),t.done){a&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${n.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let e=0;e<s.length;++e){const t=s[e];s[e]=div(s[e],i),dispose(t)}return singletonOrArray(s)}function checkBatchSize(e){util_exports.assert(e>0&&Number.isInteger(e),(()=>`batchSize is required to be a positive integer, but got ${e}`))}function sliceArrays(e,t,n){return null==e?[null]:Array.isArray(e)?e.map((e=>sliceAlongFirstAxis(e,t,n-t))):sliceAlongFirstAxis(e,t,n-t)}function sliceArraysByIndices(e,t){return tidy((()=>null==e?null:Array.isArray(e)?e.map((e=>sliceArraysByIndices(e,t))):gather2(e,"int32"===t.dtype?t:cast(t,"int32"))))}function makeBatches(e,t){const n=[];let a=0,r=null;for(;a<e;)r=a+t,r>=e&&(r=e),n.push([a,r]),a=r;return n}async function fitLoop(e,t,n,a,r,s,o,i,l,u,c,d,p,h,m){null==r&&(r=32),null==s&&(s=1),null==c&&(c=!0),null==p&&(p=0);let f=!1;if(null!=l&&null!=u&&(f=!0),null!=m&&(f=!0,null==h))throw new ValueError("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const g=e.checkNumSamples(n,r,h,"steps_per_epoch");let x;null!=g&&(x=range2(0,g)),null==o&&(o=1);const{callbackList:y,history:A}=configureCallbacks(i,o,s,p,g,h,r,f,d);y.setModel(e),e.history=A,await y.onTrainBegin(),e.stopTraining_=!1;for(let o=p;o<s;++o){await y.onEpochBegin(o);const s={};if(null!=h)throw new NotImplementedError("stepsPerEpoch mode is not implemented yet.");{if("batch"===c)throw new NotImplementedError("batch shuffling is not implemneted yet");c&&util_exports.shuffle(x);const o=tensor1d(x),i=makeBatches(g,r);for(let c=0;c<i.length;++c){const d={};if(await y.onBatchBegin(c,d),tidy((()=>{const p=i[c][0],h=i[c][1],m=sliceAlongFirstAxis(o,p,h-p);d.batch=c,d.size=h-p;const g=sliceArraysByIndices(n,m),x=t(g);for(let e=0;e<a.length;++e){const t=a[e],n=x[e];d[t]=n,keep(n)}if(c===i.length-1&&f){const t=e.testLoop(l,u,r);for(let e=0;e<a.length;++e){const n=a[e],r=t[e];keep(r),s["val_"+n]=r}}})),await y.onBatchEnd(c,d),disposeTensorsInLogs(d),e.stopTraining_)break}o.dispose()}if(await y.onEpochEnd(o,s),e.stopTraining_)break}return await y.onTrainEnd(),await e.history.syncData(),e.history}async function fitTensors(e,t,n,a={}){if(e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");let r,s,o,i,l,u,c;e.isTraining=!0;try{const d=null==a.batchSize?32:a.batchSize;checkBatchSize(d);const p=!1,h=await e.standardizeUserData(t,n,a.sampleWeight,a.classWeight,p,d);r=h[0],s=h[1],c=h[2];let m,f=!1;if(null!=a.validationData&&a.validationData.length>0){if(f=!0,2!==a.validationData.length)throw 3===a.validationData.length?new NotImplementedError("validationData including sample weights is not supported yet."):new ValueError(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${a.validationData} is invalid.`);o=a.validationData[0],i=a.validationData[1];const t=!0,n=await e.standardizeUserData(o,i,null,null,t,d);l=n[0],u=n[1],m=l.concat(u)}else if(null!=a.validationSplit&&a.validationSplit>0&&a.validationSplit<1){f=!0;const e=Math.floor(r[0].shape[0]*(1-a.validationSplit)),t=r[0].shape[0];l=sliceArrays(r,e,t),r=sliceArrays(r,0,e),u=sliceArrays(s,e,t),s=sliceArrays(s,0,e),m=l.concat(u)}else null!=a.validationSteps&&(f=!0);const g=r.concat(s).concat(c);e.checkTrainableWeightsConsistency();const x=e.makeTrainFunction(),y=e.getDedupedMetricsNames();let A,b;f?(e.makeTestFunction(),A=e.testFunction,b=y.slice().concat(y.map((e=>"val_"+e)))):(A=null,m=[],b=y.slice());const v=standardizeCallbacks(a.callbacks,a.yieldEvery);return await fitLoop(e,x,g,y,d,a.epochs,a.verbose,v,A,m,a.shuffle,b,a.initialEpoch,null,null)}finally{e.isTraining=!1,disposeNewTensors(r,t),disposeNewTensors(s,n),disposeNewTensors(l,o),disposeNewTensors(u,i),null!=c&&dispose(c)}}function ensureTensorsRank2OrHigher(e){const t=[];e instanceof Tensor&&(e=[e]);for(let n=0;n<e.length;++n){const a=e[n];if(1===a.rank)t.push(expandDims2(a,1));else{if(0===a.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(a)}}return t}function disposeNewTensors(e,t){if(null==e)return;const n=[];if(t instanceof Tensor)n.push(t.id);else if(Array.isArray(t))t.forEach((e=>n.push(e.id)));else if(null!=t)for(const e in t){const a=t[e];n.push(a.id)}const a=[];if(e instanceof Tensor)-1===n.indexOf(e.id)&&a.push(e);else if(Array.isArray(e))e.forEach((e=>{-1===n.indexOf(e.id)&&a.push(e)}));else if(null!=e)for(const t in e){const r=e[t];-1===n.indexOf(r.id)&&a.push(r)}a.forEach((e=>{e.isDisposed||e.dispose()}))}function isDataTensor(e){return e instanceof Tensor}function isDataArray(e){return Array.isArray(e)}function isDataDict(e){return!isDataTensor(e)&&!isDataArray(e)}function standardizeInputData(e,t,n,a=!0,r=""){if(null==t||0===t.length){if(null!=e){let t=!1;if(isDataArray(e)&&e.length>0)t=!0;else if(isDataDict(e)){for(const n in e)if(e.hasOwnProperty(n)){t=!0;break}}else t=!0;if(t)throw new ValueError(`Error when checking model ${r} expected no data, but got ${e}`)}return[]}if(null==e)return t.map((e=>null));let s;if(isDataDict(e)){s=[];for(const n of t){if(null==e[n])throw new ValueError(`No data provided for "${n}". Need data for each key in: ${t}`);s.push(e[n])}}else if(isDataArray(e)){if(e.length!==t.length)throw new ValueError(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${e}`);s=e}else{if(t.length>1)throw new ValueError(`The model ${r} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${e.shape}`);s=[e]}if(s=ensureTensorsRank2OrHigher(s),null!=n)for(let e=0;e<t.length;++e){if(null==n[e])continue;const o=s[e];if(o.shape.length!==n[e].length)throw new ValueError(`Error when checking ${r}: expected ${t[e]} to have ${n[e].length} dimension(s). but got array with shape ${o.shape}`);for(let t=0;t<n[e].length;++t){if(0===t&&!a)continue;const s=o.shape[t],i=n[e][t];if(null!=i&&i>=0&&s!==i)throw new ValueError(`${r} expected a batch of elements where each example has shape [${n[e].slice(1,n[e].length)}] (i.e.,tensor shape [*,${n[e].slice(1,n[e].length)}]) but the ${r} received an input with ${o.shape[0]} examples, each with shape [${o.shape.slice(1,o.shape.length)}] (tensor shape [${o.shape}])`)}}return s}function checkArrayLengths(e,t,n){const a=unique2(e.map((e=>e.shape[0])));a.sort();const r=unique2(t.map((e=>e.shape[0])));if(r.sort(),a.length>1)throw new ValueError(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map((e=>e.shape)))}`);if(r.length>1)throw new ValueError(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map((e=>e.shape)))}`);if(a.length>0&&r.length>0&&!util_exports.arraysEqual(a,r))throw new ValueError(`Input Tensors should have the same number of samples as target Tensors. Found ${a[0]} input sample(s) and ${r[0]} target sample(s).`)}function checkLossAndTargetCompatibility(e,t,n){const a=[meanSquaredError2,binaryCrossentropy,categoricalCrossentropy];for(let r=0;r<e.length;++r){const s=e[r],o=t[r],i=n[r];if(null!=o){if(o===categoricalCrossentropy&&1===s.shape[s.shape.length-1])throw new ValueError(`You are passing a target array of shape ${s.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(-1!==a.indexOf(o)){const e=s.shape.slice(1),t=i.slice(1);for(let n=0;n<e.length;++n){const a=e[n],r=t[n];if(null!=r&&a!==r)throw new ValueError(`A target Tensor with shape ${s.shape} was passed for an output of shape ${i}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function checkInputData(e,t,n,a=!0,r=""){let s;if(Array.isArray(e)){if(e.length!==t.length)throw new ValueError(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${e.length} Tensors(s).`);s=e}else{if(t.length>1)throw new ValueError(`The model expects ${t.length} ${r} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(e.shape)}.`);s=[e]}if(null!=n)for(let e=0;e<t.length;++e){if(null==n[e])continue;const o=s[e];if(o.shape.length!==n[e].length)throw new ValueError(`Error when checking ${r}: expected ${t[e]} to have ${n[e].length} dimension(s), but got array with shape ${JSON.stringify(o.shape)}`);for(let s=0;s<n[e].length;++s){if(0===s&&!a)continue;const i=o.shape[s],l=n[e][s];if(null!=l&&l!==i)throw new ValueError(`Error when checking ${r}: expected ${t[e]} to have shape ${JSON.stringify(n[e])} but got array with shape ${JSON.stringify(o.shape)}.`)}}}function collectMetrics(e,t){if(null==e||Array.isArray(e)&&0===e.length)return t.map((e=>[]));let n;if("string"==typeof e||"function"==typeof e)n=[e];else{if(!Array.isArray(e)&&"object"!=typeof e)throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${e}`);n=e}if(Array.isArray(n))return t.map((e=>n));{const e=[];for(const a of t){let t=n.hasOwnProperty(a)?n[a]:[];Array.isArray(t)||(t=[t]),e.push(t)}return e}}var LAYERS_MODEL_FORMAT_NAME="layers-model",LayersModel=class extends Container{constructor(e){super(e),this.isTraining=!1}summary(e,t,n=console.log){if(!this.built)throw new ValueError("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");printSummary(this,e,t,n)}compile(e){if(null==e.loss&&(e.loss=[]),this.loss=e.loss,"string"==typeof e.optimizer)this.optimizer_=getOptimizer(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof Optimizer))throw new ValueError("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(Array.isArray(e.loss)||"string"==typeof e.loss||"function"==typeof e.loss)if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new ValueError(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);const n=e.loss;t=n.map((e=>get(e)))}else{const n=get(e.loss);this.outputs.forEach((e=>{t.push(n)}))}else{e.loss=e.loss;for(const t in e.loss)if(-1===this.outputNames.indexOf(t))throw new ValueError(`Unknown entry in loss dictionary: "${t}". Only expected the following keys: ${this.outputNames}`);for(const n of this.outputNames)null==e.loss[n]&&console.warn(`Output "${n}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${n} during training`),t.push(get(e.loss[n]))}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let e=0;e<this.outputs.length;++e){const t=this.internalOutputShapes[e],n=this.outputNames[e];this.feedOutputNames.push(n),this.feedOutputShapes.push(t),this.feedLossFns.push(this.lossFunctions[e])}const n=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],nameScope("loss",(()=>{for(let e=0;e<this.outputs.length;++e){if(-1!==n.indexOf(e))continue;const t=this.lossFunctions[e];this.outputs.length>1&&(this.metricsTensors.push([t,e]),this.metricsNames.push(this.outputNames[e]+"_loss"))}}));const a=collectMetrics(e.metrics,this.outputNames),r=(e,t,n)=>{this.outputNames.length>1&&(t=this.outputNames[e]+"_"+t),this.metricsNames.push(t),this.metricsTensors.push([n,e])};nameScope("metric",(()=>{for(let e=0;e<this.outputs.length;++e){if(-1!==n.indexOf(e))continue;(t=>{let n,a,s;for(const o of t){if("string"==typeof o&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(o)){const t=this.internalOutputShapes[e];let r;1===t[t.length-1]||this.lossFunctions[e]===binaryCrossentropy?-1!==["accuracy","acc"].indexOf(o)?a=binaryAccuracy:-1!==["crossentropy","ce"].indexOf(o)&&(a=binaryCrossentropy2):this.lossFunctions[e]===sparseCategoricalCrossentropy?-1!==["accuracy","acc"].indexOf(o)?a=sparseCategoricalAccuracy:-1!==["crossentropy","ce"].indexOf(o)&&(a=sparseCategoricalCrossentropy2):-1!==["accuracy","acc"].indexOf(o)?a=categoricalAccuracy:-1!==["crossentropy","ce"].indexOf(o)&&(a=categoricalCrossentropy2),-1!==["accuracy","acc"].indexOf(o)?r="acc":-1!==["crossentropy","ce"].indexOf(o)&&(r="ce"),s=a,n=""+r}else{const e=get2(o);s=e,n=""+getLossOrMetricName(o)}let t;nameScope(n,(()=>{t=s})),r(e,n,t)}})(a[e])}})),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t,n={}){const a=null==n.batchSize?32:n.batchSize;checkBatchSize(a);const r=this.standardizeUserDataXY(e,t,!0,a);try{const s=r[0].concat(r[1]);this.makeTestFunction();const o=this.testFunction;return singletonOrArray(this.testLoop(o,s,a,n.verbose,n.steps))}finally{disposeNewTensors(r[0],e),disposeNewTensors(r[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),evaluateDataset(this,e,t)}checkNumSamples(e,t,n,a="steps"){let r;if(null!=n){if(r=null,null!=t)throw new ValueError(`If ${a} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else{if(null==e)throw new ValueError(`Either the input data should have a defined shape, or ${a} shoud be specified.`);r=Array.isArray(e)?e[0].shape[0]:e.shape[0]}return r}execute(e,t){if(Array.isArray(t)&&0===t.length)throw new ValueError("`outputs` is an empty Array, which is not allowed.");const n=Array.isArray(t),a=n?t:[t],r=this.retrieveSymbolicTensors(a),s=new FeedDict;if(e instanceof Tensor&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new ValueError(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let t=0;t<this.inputs.length;++t)s.add(this.inputs[t],e[t])}else for(const t of this.inputs){const n=e[t.name];if(null==n)throw new ValueError(`No value is provided for the model's input ${t.name}`);s.add(t,n)}const o=execute(r,s);return n?o:o[0]}retrieveSymbolicTensors(e){const t=pyListRepeat(null,e.length);let n=e.length;for(const a of this.layers){const r=Array.isArray(a.output)?a.output:[a.output],s=r.map((e=>e.name));for(let a=0;a<e.length;++a){const o=s.indexOf(e[a]);if(-1!==o&&(t[a]=r[o],n--),0===n)break}if(0===n)break}if(n>0){const n=[];throw t.forEach(((t,a)=>{null==t&&n.push(e[a])})),new ValueError(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(n)}`)}return t}predictLoop(e,t=32,n=!1){return tidy((()=>{const a=this.checkNumSamples(e);if(n)throw new NotImplementedError("Verbose predictLoop() is not implemented yet.");const r=makeBatches(a,t),s=this.outputs.map((e=>[]));for(let t=0;t<r.length;++t){tidy((()=>{const n=r[t][0],a=r[t][1],s=sliceArrays(e,n,a),o=[];if(Array.isArray(s))for(let e=0;e<s.length;++e)o.push({key:this.inputs[e],value:s[e]});else o.push({key:this.inputs[0],value:s});const i=new FeedDict(o);return execute(this.outputs,i)})).forEach(((e,t)=>s[t].push(e)))}return singletonOrArray(s.map((e=>concat(e,0))))}))}predict(e,t={}){const n=ensureTensorsRank2OrHigher(e);checkInputData(n,this.inputNames,this.feedInputShapes,!1);try{const a=null==t.batchSize?32:t.batchSize;return checkBatchSize(a),this.predictLoop(n,a)}finally{disposeNewTensors(n,e)}}predictOnBatch(e){checkInputData(e,this.inputNames,this.feedInputShapes,!0);const t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t,n=!0,a){if(null==this.optimizer_)throw new RuntimeError("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const r=[];for(let e=0;e<this.feedOutputShapes.length;++e){const t=this.feedOutputShapes[e];this.feedLossFns[e]===sparseCategoricalCrossentropy?r.push(t.slice(0,t.length-1).concat([1])):r.push(t)}if(checkArrayLengths(e=standardizeInputData(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=standardizeInputData(t,this.feedOutputNames,r,!1,"target"),null),checkLossAndTargetCompatibility(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=a&&a>0&&e[0].shape[0]%a!=0)throw new ValueError(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${a}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,n,a,r=!0,s){const[o,i]=this.standardizeUserDataXY(e,t,r,s);if(null!=n)throw new Error("sample weight is not supported yet.");let l=null;if(null!=a){const e=standardizeClassWeights(a,this.outputNames);l=[];for(let t=0;t<e.length;++t)l.push(await standardizeWeights(i[t],null,e[t]))}return[o,i,l]}testLoop(e,t,n,a=0,r){return tidy((()=>{const s=this.checkNumSamples(t,n,r,"steps"),o=[];if(a>0)throw new NotImplementedError("Verbose mode is not implemented yet.");if(null!=r)throw new NotImplementedError("steps mode in testLoop() is not implemented yet");{const a=makeBatches(s,n),r=tensor1d(range2(0,s));for(let n=0;n<a.length;++n){const s=a[n][0],i=a[n][1],l=sliceAlongFirstAxis(r,s,i-s),u=sliceArraysByIndices(t,l),c=e(u);if(0===n)for(let e=0;e<c.length;++e)o.push(scalar(0));for(let e=0;e<c.length;++e){const t=c[e];o[e]=add2(o[e],mul(i-s,t))}}for(let e=0;e<o.length;++e)o[e]=div(o[e],s)}return o}))}getDedupedMetricsNames(){const e=this.metricsNames,t=[];for(let n=0;n<e.length;++n){const a=e[n];let r=a;if(count(e,a)>1){r+=`_${count(e.slice(0,n),a)}`}t.push(r)}return t}makeTrainFunction(){return e=>{const t=[],n=e.slice(0,this.inputs.length),a=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),r=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),s=[],o=this.collectedTrainableWeights.map((e=>e.read()));return[this.optimizer_.minimize((()=>{const e=[];for(let t=0;t<this.inputs.length;++t)e.push({key:this.inputs[t],value:n[t]});const o=new FeedDict(e),i=execute(this.outputs,o,{training:!0});let l;for(let e=0;e<this.lossFunctions.length;++e){let n=(0,this.lossFunctions[e])(a[e],i[e]);null!=r[e]&&(n=computeWeightedLoss2(n,r[e]));const s=mean(n);t.push(s),l=0===e?n:add2(l,n)}for(let e=0;e<this.metricsTensors.length;++e){let n;if(this.outputs.length>1&&e<this.outputs.length)n=t[e];else{const t=this.metricsTensors[e][0],r=this.metricsTensors[e][1];n=mean(t(a[r],i[r]))}keep(n),s.push(n)}return l=mean(l),this.calculateLosses().forEach((e=>{l=add2(l,e)})),l}),!0,o)].concat(s)}}makeTestFunction(){this.testFunction=e=>tidy((()=>{const t=[];let n;const a=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),s=[];for(let e=0;e<this.inputs.length;++e)s.push({key:this.inputs[e],value:a[e]});const o=new FeedDict(s),i=execute(this.outputs,o);for(let e=0;e<this.lossFunctions.length;++e){const a=this.lossFunctions[e],s=mean(a(r[e],i[e]));n=0===e?s:add2(n,s),t.push(n)}for(let e=0;e<this.metricsTensors.length;++e){const n=this.metricsTensors[e][0],a=this.metricsTensors[e][1],s=mean(n(r[a],i[a]));t.push(s)}return t}))}async fit(e,t,n={}){return fitTensors(this,e,t,n)}async fitDataset(e,t){return fitDataset(this,e,t)}async trainOnBatch(e,t){const n=await this.standardizeUserData(e,t),a=n[0],r=n[1],s=this.makeTrainFunction()(a.concat(r)),o=[];for(const e of s){const t=await e.data();o.push(t[0])}return dispose(s),singletonOrArray(o)}getNamedWeights(e){const t=[],n=null!=e&&e.trainableOnly,a=n?this.trainableWeights:this.weights,r=this.getWeights(n);for(let e=0;e<a.length;++e)n&&!a[e].trainable||t.push({name:a[e].originalName,tensor:r[e]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(0===e.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){const t=memory().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-memory().numTensors}return e}getLossIdentifiers(){let e;if("string"==typeof this.loss)e=toSnakeCase(this.loss);else if(Array.isArray(this.loss)){for(const e of this.loss)if("string"!=typeof e)throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map((e=>toSnakeCase(e)))}else{const t=Object.keys(this.loss);e={};const n=this.loss;for(const a of t){if("string"!=typeof n[a])throw new Error("Serialization of non-string loss is not supported.");e[a]=toSnakeCase(n[a])}}return e}getMetricIdentifiers(){if("string"==typeof this.metrics||"function"==typeof this.metrics)return[toSnakeCase(getLossOrMetricName(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map((e=>toSnakeCase(getLossOrMetricName(e))));{const e={};for(const t in this.metrics)e[t]=toSnakeCase(getLossOrMetricName(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(null!=e.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=e.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=e.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");const t=deserialize(convertPythonicToTs(e.optimizer_config));let n,a;if("string"==typeof e.loss)n=toCamelCase(e.loss);else if(Array.isArray(e.loss))n=e.loss.map((e=>toCamelCase(e)));else if(null!=e.loss){n={};for(const t in e.loss)n[t]=toCamelCase(e.loss[t])}if(Array.isArray(e.metrics))a=e.metrics.map((e=>toCamelCase(e)));else if(null!=e.metrics){a={};for(const t in e.metrics)a[t]=toCamelCase(e.metrics[t])}this.compile({loss:n,metrics:a,optimizer:t})}async save(e,t){if("string"==typeof e){const t=io_exports.getSaveHandlers(e);if(0===t.length)throw new ValueError(`Cannot find any save handlers for URL '${e}'`);if(t.length>1)throw new ValueError(`Found more than one (${t.length}) save handlers for URL '${e}'`);e=t[0]}if(null==e.save)throw new ValueError("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const n=await io_exports.encodeWeights(this.getNamedWeights(t)),a={modelTopology:this.toJSON(null,!1),format:LAYERS_MODEL_FORMAT_NAME,generatedBy:`TensorFlow.js tfjs-layers v${version2}`,convertedBy:null};if(null!=t&&t.includeOptimizer&&null!=this.optimizer){a.trainingConfig=this.getTrainingConfig();const e="optimizer",{data:t,specs:r}=await io_exports.encodeWeights(await this.optimizer.getWeights(),e);n.specs.push(...r),n.data=io_exports.concatenateArrayBuffers([n.data,t])}if(null!=this.userDefinedMetadata){const e=!0;checkUserDefinedMetadata(this.userDefinedMetadata,this.name,e),a.userDefinedMetadata=this.userDefinedMetadata}return a.weightData=n.data,a.weightSpecs=n.specs,e.save(a)}setUserDefinedMetadata(e){checkUserDefinedMetadata(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}};LayersModel.className="Model",serialization_exports.registerClass(LayersModel);var Functional=class extends LayersModel{};async function modelFromJSON(e,t){"modelTopology"in e||(e={modelTopology:e});let n=e.modelTopology;null!=n.model_config&&(n=n.model_config);const a=deserialize(convertPythonicToTs(n),t);if(null!=e.weightsManifest){const t=await io_exports.loadWeights(e.weightsManifest,e.pathPrefix,a.weights.map((e=>e.originalName))),n={};for(const e of a.weights)n[e.originalName]=t[e.originalName];a.loadWeights(n),dispose(t)}return a}async function loadLayersModelInternal(e,t){if(null==t&&(t={}),"string"==typeof e){const n=io_exports.getLoadHandlers(e,t);if(0===n.length)n.push(io_exports.browserHTTPRequest(e,t));else if(n.length>1)throw new ValueError(`Found more than one (${n.length}) load handlers for URL '${e}'`);e=n[0]}return loadLayersModelFromIOHandler(e,void 0,t)}async function loadLayersModelFromIOHandler(e,t,n){if(null==n&&(n={}),null==e.load)throw new ValueError("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const a=await e.load();let r=a.modelTopology;null!=r.model_config&&(r=r.model_config);const s=null==n.strict||n.strict,o=null!=a.weightData&&null!=a.weightSpecs&&s,i=deserialize(convertPythonicToTs(r),t,o),l=a.trainingConfig;if(null!=l&&i.loadTrainingConfig(l),null!=a.userDefinedMetadata&&i.setUserDefinedMetadata(a.userDefinedMetadata),null!=a.weightData){if(null==a.weightSpecs)throw new ValueError("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");const{modelWeights:e,optimizerWeights:t}=decodeModelAndOptimizerWeights(a.weightData,a.weightSpecs);i.loadWeights(e,s),null!=i.optimizer&&t.length>0&&await i.optimizer.setWeights(t),dispose(e),dispose(t.map((e=>e.tensor)))}return i}function decodeModelAndOptimizerWeights(e,t){const n=io_exports.decodeWeights(e,t),a={},r=[];return t.forEach((e=>{"optimizer"===e.group?r.push({name:e.name,tensor:n[e.name]}):a[e.name]=n[e.name]})),{modelWeights:a,optimizerWeights:r}}Functional.className="Functional",serialization_exports.registerClass(Functional);var _Sequential=class extends LayersModel{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=null!=e.name?e.name:getUid("sequential_"),null!=e.layers)for(const t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some((e=>e<0)))throw new ValueError(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){const t=e instanceof _Sequential||e instanceof LayersModel;let n;if(t){if(n=e,1!==n.outputs.length)throw new ValueError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==n.inputs.length)throw new ValueError("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===e.inboundNodes.length){if(null==e.batchInputShape)throw new ValueError("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const t=Input({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(t)}if(t)this.outputs=n.outputs,this.inputs=n.inputs;else{if(1!==e.inboundNodes.length)throw new ValueError(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(1!==e.inboundNodes[0].outputTensors.length)throw new ValueError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=getSourceInputs(this.outputs[0])}this.inboundNodes=[],new Node({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:pyListRepeat(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map((e=>e.shape)),outputShapes:this.outputs[0].shape})}else{const t=e.apply(this.outputs[0]);if(Array.isArray(t))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[t],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return null==this.model&&this.build(),this.model.call(e,t)}build(e){if(getExactlyOneShape(e),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new LayersModel({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t,n=console.log){this.built||this.build(),super.summary(e,t,n)}setWeights(e){null==this.model&&this.build(),this.model.setWeights(e)}evaluate(e,t,n={}){if(!this.built)throw new RuntimeError("The model needs to be compiled before being used.");return this.model.evaluate(e,t,n)}async evaluateDataset(e,t){if(!this.built)throw new RuntimeError("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,t)}predict(e,t={}){return null==this.model&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return null==this.model&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,t,n={}){if(!this.built)throw new RuntimeError("The model needs to be compiled before being used.");return this.model.fit(e,t,n)}async fitDataset(e,t){if(!this.built)throw new RuntimeError("The model needs to be compiled before being used.");return this.model.fitDataset(e,t)}async trainOnBatch(e,t){return this.model.trainOnBatch(e,t)}static fromConfig(e,t,n={},a=!1){let r,s={};if(t instanceof Array){if(null==t[0].className||"Merge"===t[0].className)throw new ValueError("Legacy serialization format not supported yet.");r=t}else util_exports.assert(null!=t.layers,(()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field.")),r=t.layers,delete t.layers,s=t;const o=new e(s);if(!(o instanceof _Sequential))throw new NotImplementedError(`Sequential.fromConfig called on non-Sequential input: ${o}`);for(const e of r){const t=deserialize(e,void 0,a);a&&t.setFastWeightInitDuringBuild(!0),o.add(t)}return o}set stopTraining(e){if(null==this.model)throw new ValueError("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(null==this.model)throw new ValueError("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const t of this.layers){const n={};n.className=t.getClassName(),n.config=t.getConfig(),e.push(n)}return{name:this.name,layers:e}}},Sequential=_Sequential;function model(e){return new LayersModel(e)}function sequential(e){return new Sequential(e)}function loadLayersModel(e,t){return null==t&&(t={}),loadLayersModelInternal(e,t)}function input(e){return Input(e)}function registerCallbackConstructor(e,t){CallbackConstructorRegistry.registerCallbackConstructor(e,t)}Sequential.className="Sequential",serialization_exports.registerClass(Sequential);var Activation2=class extends serialization_exports.Serializable{getConfig(){return{}}},Elu2=class extends Activation2{apply(e,t=1){return elu2(e,t)}};Elu2.className="elu",serialization_exports.registerClass(Elu2);var Selu2=class extends Activation2{apply(e){return selu(e)}};Selu2.className="selu",serialization_exports.registerClass(Selu2);var Relu2=class extends Activation2{apply(e){return relu(e)}};Relu2.className="relu",serialization_exports.registerClass(Relu2);var Relu62=class extends Activation2{apply(e){return tidy((()=>minimum(6,relu(e))))}};Relu62.className="relu6",serialization_exports.registerClass(Relu62);var Linear=class extends Activation2{apply(e){return e}};Linear.className="linear",serialization_exports.registerClass(Linear);var Sigmoid2=class extends Activation2{apply(e){return sigmoid(e)}};Sigmoid2.className="sigmoid",serialization_exports.registerClass(Sigmoid2);var HardSigmoid=class extends Activation2{apply(e){return hardSigmoid(e)}};HardSigmoid.className="hardSigmoid",serialization_exports.registerClass(HardSigmoid);var Softplus2=class extends Activation2{apply(e){return softplus(e)}};Softplus2.className="softplus",serialization_exports.registerClass(Softplus2);var Softsign=class extends Activation2{apply(e){return softsign(e)}};Softsign.className="softsign",serialization_exports.registerClass(Softsign);var Tanh2=class extends Activation2{apply(e){return tanh2(e)}};Tanh2.className="tanh",serialization_exports.registerClass(Tanh2);var Softmax2=class extends Activation2{apply(e,t=-1){return softmax(e,t)}};Softmax2.className="softmax",serialization_exports.registerClass(Softmax2);var LogSoftmax2=class extends Activation2{apply(e,t=-1){return logSoftmax(e,t)}};LogSoftmax2.className="logSoftmax",serialization_exports.registerClass(LogSoftmax2);var Swish=class extends Activation2{apply(e,t=1){return tidy((()=>mul(sigmoid(mul(e,t)),e)))}};Swish.className="swish",serialization_exports.registerClass(Swish);var Mish=class extends Activation2{apply(e){return tidy((()=>mul(e,tanh2(softplus(e)))))}};function serializeActivation(e){return e.getClassName()}function deserializeActivation(e,t={}){return deserializeKerasObject(e,serialization_exports.SerializationMap.getMap().classNameMap,t,"activation")}function getActivation(e){if(null==e){const e={className:"linear",config:{}};return deserializeActivation(e)}if("string"==typeof e){const t={};return t.className=e,t.config={},deserializeActivation(t)}return e instanceof Activation2?e:deserializeActivation(e)}function assertObjectArgs(e){if(null!=e&&"object"!=typeof e)throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${e}`)}Mish.className="mish",serialization_exports.registerClass(Mish);var Regularizer=class extends serialization_exports.Serializable{},L1L2=class extends Regularizer{constructor(e){super(),assertObjectArgs(e),this.l1=null==e||null==e.l1?.01:e.l1,this.l2=null==e||null==e.l2?.01:e.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(e){return tidy((()=>{let t=zeros([1]);return this.hasL1&&(t=add2(t,sum2(mul(this.l1,abs(e))))),this.hasL2&&(t=add2(t,sum2(mul(this.l2,square2(e))))),reshape(t,[])}))}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}};function l1(e){return assertObjectArgs(e),new L1L2({l1:null!=e?e.l1:null,l2:0})}function l2(e){return assertObjectArgs(e),new L1L2({l2:null!=e?e.l2:null,l1:0})}L1L2.className="L1L2",serialization_exports.registerClass(L1L2);var REGULARIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP={l1l2:"L1L2"};function serializeRegularizer(e){return serializeKerasObject(e)}function deserializeRegularizer(e,t={}){return deserializeKerasObject(e,serialization_exports.SerializationMap.getMap().classNameMap,t,"regularizer")}function getRegularizer(e){if(null==e)return null;if("string"==typeof e){return deserializeRegularizer({className:e in REGULARIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP?REGULARIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP[e]:e,config:{}})}return e instanceof Regularizer?e:deserializeRegularizer(e)}var ReLU=class extends Layer{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,null!=e&&(this.maxValue=e.maxValue)}call(e,t){e=getExactlyOneTensor(e);let n=relu(e);return null!=this.maxValue&&(n=clipByValue(n,0,this.maxValue)),n}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}};ReLU.className="ReLU",serialization_exports.registerClass(ReLU);var LeakyReLU=class extends Layer{constructor(e){super(null==e?{}:e),this.DEFAULT_ALPHA=.3,null==e&&(e={}),this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){const n=getExactlyOneTensor(e);return leakyRelu(n,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};LeakyReLU.className="LeakyReLU",serialization_exports.registerClass(LeakyReLU);var PReLU=class extends Layer{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==e&&(e={}),this.supportsMasking=!0,this.alphaInitializer=getInitializer(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=getRegularizer(e.alphaRegularizer),this.alphaConstraint=getConstraint(e.alphaConstraint),null==e.sharedAxes)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else{if("number"!=typeof e.sharedAxes)throw new ValueError(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`);this.sharedAxes=[e.sharedAxes]}}build(e){const t=(e=getExactlyOneShape(e)).slice(1);if(null!=this.sharedAxes)for(const e of this.sharedAxes)t[e-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const n={};if(null!=this.sharedAxes)for(let t=1;t<e.length;++t)n[t]=e[t];this.inputSpec=[new InputSpec({ndim:e.length,axes:n})],this.built=!0}call(e,t){return e=getExactlyOneTensor(e),prelu(e,this.alpha.read())}getConfig(){const e={alphaInitializer:serializeInitializer(this.alphaInitializer),alphaRegularizer:serializeRegularizer(this.alphaRegularizer),alphaConstraint:serializeConstraint(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}};PReLU.className="PReLU",serialization_exports.registerClass(PReLU);var ELU=class extends Layer{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA=1,null==e&&(e={}),null!=e.alpha&&e.alpha!==this.DEFAULT_ALPHA)throw new NotImplementedError(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){const n=getExactlyOneTensor(e);return elu(n)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};ELU.className="ELU",serialization_exports.registerClass(ELU);var ThresholdedReLU=class extends Layer{constructor(e){super(null==e?{}:e),this.DEFAULT_THETA=1,null==e&&(e={}),this.theta=null==e.theta?this.DEFAULT_THETA:e.theta}call(e,t){const n=getExactlyOneTensor(e);return mul(n,cast(greater(n,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}};ThresholdedReLU.className="ThresholdedReLU",serialization_exports.registerClass(ThresholdedReLU);var Softmax3=class extends Layer{constructor(e){super(null==e?{}:e),this.DEFAULT_AXIS=1,null==e&&(e={}),this.softmax=(new Softmax2).apply,this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis}call(e,t){const n=getExactlyOneTensor(e);return this.softmax(n,this.axis)}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}};function normalizeArray(e,t,n){if("number"==typeof e)return pyListRepeat(e,t);if(e.length!==t)throw new ValueError(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${e.length} elements.`);for(let a=0;a<t;++a){const r=e[a];if(!isInteger(r))throw new ValueError(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(e)} including a non-integer number ${r}`)}return e}function convOutputLength(e,t,n,a,r=1){if(null==e)return e;let s;return s="same"===n?e:e-(t+(t-1)*(r-1))+1,Math.floor((s+a-1)/a)}function deconvLength(e,t,n,a){if(null==e)return null;if("valid"===a)e=e*t+max2([n-t,0]);else{if("same"!==a)throw new ValueError(`Unsupport padding mode: ${a}.`);e*=t}return e}function preprocessConv2DInput(e,t){return tidy((()=>(checkDataFormat(t),"channelsFirst"===t?transpose(e,[0,2,3,1]):e)))}function preprocessConv3DInput(e,t){return tidy((()=>(checkDataFormat(t),"channelsFirst"===t?transpose(e,[0,2,3,4,1]):e)))}function conv1dWithBias(e,t,n,a=1,r="valid",s,o=1){return tidy((()=>{if(null==s&&(s=imageDataFormat()),checkDataFormat(s),3!==e.shape.length)throw new ValueError(`The input of a conv1dWithBias operation should be 3, but is ${e.shape.length} instead.`);if(3!==t.shape.length)throw new ValueError(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(null!=n&&1!==n.shape.length)throw new ValueError(`The bias for a conv1dWithBias operation should be 1, but is ${t.shape.length} instead`);if("channelsFirst"===s&&(e=transpose(e,[0,2,1])),"causal"===r)throw new NotImplementedError("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let i=conv1d(e,t,a,"same"===r?"same":"valid","NWC",o);return null!=n&&(i=biasAdd(i,n)),i}))}function conv2dWithBiasActivation(e,t,n,a=[1,1],r="valid",s,o,i=null){return tidy((()=>{if(null==s&&(s=imageDataFormat()),checkDataFormat(s),3!==e.rank&&4!==e.rank)throw new ValueError(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${e.rank}.`);if(3!==t.rank&&4!==t.rank)throw new ValueError(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${e.rank}.`);let l=preprocessConv2DInput(e,s);if("causal"===r)throw new NotImplementedError("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=fused_ops_exports.conv2d({x:l,filter:t,strides:a,pad:"same"===r?"same":"valid",dilations:o,dataFormat:"NHWC",bias:n,activation:i}),"channelsFirst"===s&&(l=transpose(l,[0,3,1,2])),l}))}function conv3dWithBias(e,t,n,a=[1,1,1],r="valid",s,o){return tidy((()=>{if(null==s&&(s=imageDataFormat()),checkDataFormat(s),4!==e.rank&&5!==e.rank)throw new ValueError(`conv3dWithBias expects input to be of rank 4 or 5, but received ${e.rank}.`);if(4!==t.rank&&5!==t.rank)throw new ValueError(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${e.rank}.`);let i=preprocessConv3DInput(e,s);if("causal"===r)throw new NotImplementedError("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return i=conv3d(i,t,a,"same"===r?"same":"valid","NDHWC",o),null!=n&&(i=biasAdd(i,n)),"channelsFirst"===s&&(i=transpose(i,[0,4,1,2,3])),i}))}Softmax3.className="Softmax",serialization_exports.registerClass(Softmax3);var BaseConv=class extends Layer{constructor(e,t){if(super(t),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",BaseConv.verifyArgs(t),this.rank=e,assertPositiveInteger(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new NotImplementedError(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=normalizeArray(t.kernelSize,e,"kernelSize"),this.strides=normalizeArray(null==t.strides?1:t.strides,e,"strides"),this.padding=null==t.padding?"valid":t.padding,checkPaddingMode(this.padding),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,checkDataFormat(this.dataFormat),this.activation=getActivation(t.activation),this.useBias=null==t.useBias||t.useBias,this.biasInitializer=getInitializer(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=getConstraint(t.biasConstraint),this.biasRegularizer=getRegularizer(t.biasRegularizer),this.activityRegularizer=getRegularizer(t.activityRegularizer),this.dilationRate=normalizeArray(null==t.dilationRate?1:t.dilationRate,e,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new ValueError(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(2===this.rank){if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new ValueError(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(3===this.rank)if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new ValueError(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}static verifyArgs(e){if(assert2("kernelSize"in e,"required key 'kernelSize' not in config"),"number"!=typeof e.kernelSize&&!checkArrayTypeAndLength(e.kernelSize,"number",1,3))throw new ValueError(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){const e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:serializeActivation(this.activation),useBias:this.useBias,biasInitializer:serializeInitializer(this.biasInitializer),biasRegularizer:serializeRegularizer(this.biasRegularizer),activityRegularizer:serializeRegularizer(this.activityRegularizer),biasConstraint:serializeConstraint(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}},Conv=class extends BaseConv{constructor(e,t){super(e,t),this.kernel=null,Conv.verifyArgs(t),this.filters=t.filters,assertPositiveInteger(this.filters,"filters"),this.kernelInitializer=getInitializer(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=getConstraint(t.kernelConstraint),this.kernelRegularizer=getRegularizer(t.kernelRegularizer)}build(e){e=getExactlyOneShape(e);const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new ValueError(`The channel dimension of the input should be defined. Found ${e[t]}`);const n=e[t],a=this.kernelSize.concat([n,this.filters]);this.kernel=this.addWeight("kernel",a,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:n}}],this.built=!0}call(e,t){return tidy((()=>{let t;e=getExactlyOneTensor(e);const n=null==this.bias?null:this.bias.read(),a=mapActivationToFusedKernel(this.activation.getClassName());if(null!=a&&2===this.rank)t=conv2dWithBiasActivation(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate,a);else{if(1===this.rank)t=conv1dWithBias(e,this.kernel.read(),n,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)t=conv2dWithBiasActivation(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new NotImplementedError("convolutions greater than 3D are not implemented yet.");t=conv3dWithBias(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(t=this.activation.apply(t))}return t}))}computeOutputShape(e){e=getExactlyOneShape(e);const t=[],n="channelsLast"===this.dataFormat?e.slice(1,e.length-1):e.slice(2);for(let e=0;e<n.length;++e){const a=convOutputLength(n[e],this.kernelSize[e],this.padding,this.strides[e],"number"==typeof this.dilationRate?this.dilationRate:this.dilationRate[e]);t.push(a)}let a=[e[0]];return"channelsLast"===this.dataFormat?(a=a.concat(t),a.push(this.filters)):(a.push(this.filters),a=a.concat(t)),a}getConfig(){const e={filters:this.filters,kernelInitializer:serializeInitializer(this.kernelInitializer),kernelRegularizer:serializeRegularizer(this.kernelRegularizer),kernelConstraint:serializeConstraint(this.kernelConstraint)},t=super.getConfig();return Object.assign(e,t),e}static verifyArgs(e){if(!("filters"in e)||"number"!=typeof e.filters||e.filters<1)throw new ValueError(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)}},_Conv2D=class extends Conv{constructor(e){super(2,e),_Conv2D.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!checkArrayTypeAndLength(e.kernelSize,"number",1,2))throw new ValueError(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}},Conv2D2=_Conv2D;Conv2D2.className="Conv2D",serialization_exports.registerClass(Conv2D2);var _Conv3D=class extends Conv{constructor(e){super(3,e),_Conv3D.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&(!Array.isArray(e.kernelSize)||1!==e.kernelSize.length&&3!==e.kernelSize.length))throw new ValueError(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}},Conv3D2=_Conv3D;Conv3D2.className="Conv3D",serialization_exports.registerClass(Conv3D2);var Conv2DTranspose=class extends Conv2D2{constructor(e){if(super(e),this.inputSpec=[new InputSpec({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new ValueError(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(4!==(e=getExactlyOneShape(e)).length)throw new ValueError("Input should have rank 4; Received input shape: "+JSON.stringify(e));const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new ValueError("The channel dimension of the inputs should be defined. Found `None`.");const n=e[t],a=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",a,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new InputSpec({ndim:4,axes:{[t]:n}})],this.built=!0}call(e,t){return tidy((()=>{let t=getExactlyOneTensor(e);if(4!==t.shape.length)throw new ValueError(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${t.shape.length}`);const n=t.shape,a=n[0];let r,s;"channelsFirst"===this.dataFormat?(r=2,s=3):(r=1,s=2);const o=n[r],i=n[s],l=this.kernelSize[0],u=this.kernelSize[1],c=this.strides[0],d=this.strides[1],p=[a,deconvLength(o,c,l,this.padding),deconvLength(i,d,u,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(t=transpose(t,[0,2,3,1]));let h=conv2dTranspose(t,this.kernel.read(),p,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(h=transpose(h,[0,3,1,2])),null!=this.bias&&(h=biasAdd(h,this.bias.read(),this.dataFormat)),null!=this.activation&&(h=this.activation.apply(h)),h}))}computeOutputShape(e){const t=(e=getExactlyOneShape(e)).slice();let n,a,r;"channelsFirst"===this.dataFormat?(n=1,a=2,r=3):(n=3,a=1,r=2);const s=this.kernelSize[0],o=this.kernelSize[1],i=this.strides[0],l=this.strides[1];return t[n]=this.filters,t[a]=deconvLength(t[a],i,s,this.padding),t[r]=deconvLength(t[r],l,o,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}};Conv2DTranspose.className="Conv2DTranspose",serialization_exports.registerClass(Conv2DTranspose);var Conv3DTranspose=class extends Conv3D2{constructor(e){if(super(e),this.inputSpec=[new InputSpec({ndim:5})],"same"!==this.padding&&"valid"!==this.padding)throw new ValueError(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(5!==(e=getExactlyOneShape(e)).length)throw new ValueError("Input should have rank 5; Received input shape: "+JSON.stringify(e));const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new ValueError("The channel dimension of the inputs should be defined. Found `None`.");const n=e[t],a=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",a,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new InputSpec({ndim:5,axes:{[t]:n}})],this.built=!0}call(e,t){return tidy((()=>{let t=getExactlyOneTensor(e);if(5!==t.shape.length)throw new ValueError(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${t.shape.length}`);const n=t.shape,a=n[0];let r,s,o;"channelsFirst"===this.dataFormat?(o=2,r=3,s=4):(o=1,r=2,s=3);const i=n[o],l=n[r],u=n[s],c=this.kernelSize[0],d=this.kernelSize[1],p=this.kernelSize[2],h=this.strides[0],m=this.strides[1],f=this.strides[2],g=[a,deconvLength(i,h,c,this.padding),deconvLength(l,m,d,this.padding),deconvLength(u,f,p,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(t=transpose(t,[0,2,3,4,1]));let x=conv3dTranspose(t,this.kernel.read(),g,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(x=transpose(x,[0,4,1,2,3])),null!==this.bias&&(x=biasAdd(x,this.bias.read(),this.dataFormat)),null!==this.activation&&(x=this.activation.apply(x)),x}))}computeOutputShape(e){const t=(e=getExactlyOneShape(e)).slice();let n,a,r,s;"channelsFirst"===this.dataFormat?(n=1,a=2,r=3,s=4):(n=4,a=1,r=2,s=3);const o=this.kernelSize[0],i=this.kernelSize[1],l=this.kernelSize[2],u=this.strides[0],c=this.strides[1],d=this.strides[2];return t[n]=this.filters,t[a]=deconvLength(t[a],u,o,this.padding),t[r]=deconvLength(t[r],c,i,this.padding),t[s]=deconvLength(t[s],d,l,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}};Conv3DTranspose.className="Conv3DTranspose",serialization_exports.registerClass(Conv3DTranspose);var SeparableConv=class extends Conv{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==t.filters)throw new ValueError("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=t.kernelInitializer||null!=t.kernelRegularizer||null!=t.kernelConstraint)throw new ValueError("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=t.padding&&"same"!==t.padding&&"valid"!==t.padding)throw new ValueError(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=null==t.depthMultiplier?1:t.depthMultiplier,this.depthwiseInitializer=getInitializer(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=getRegularizer(t.depthwiseRegularizer),this.depthwiseConstraint=getConstraint(t.depthwiseConstraint),this.pointwiseInitializer=getInitializer(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=getRegularizer(t.pointwiseRegularizer),this.pointwiseConstraint=getConstraint(t.pointwiseConstraint)}build(e){if((e=getExactlyOneShape(e)).length<this.rank+2)throw new ValueError(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t]||e[t]<0)throw new ValueError(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);const n=e[t],a=this.kernelSize.concat([n,this.depthMultiplier]),r=[];for(let e=0;e<this.rank;++e)r.push(1);r.push(n*this.depthMultiplier,this.filters);const s=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",a,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,s,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",r,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,s,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,s,this.biasConstraint):this.bias=null,this.inputSpec=[new InputSpec({ndim:this.rank+2,axes:{[t]:n}})],this.built=!0}call(e,t){return tidy((()=>{let t;if(e=getExactlyOneTensor(e),1===this.rank)throw new NotImplementedError("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(e=transpose(e,[0,2,3,1])),t=separableConv2d(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(t=biasAdd(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),"channelsFirst"===this.dataFormat&&(t=transpose(t,[0,3,1,2])),t}))}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=serializeInitializer(this.depthwiseInitializer),e.pointwiseInitializer=serializeInitializer(this.pointwiseInitializer),e.depthwiseRegularizer=serializeRegularizer(this.depthwiseRegularizer),e.pointwiseRegularizer=serializeRegularizer(this.pointwiseRegularizer),e.depthwiseConstraint=serializeConstraint(this.depthwiseConstraint),e.pointwiseConstraint=serializeConstraint(this.pointwiseConstraint),e}};SeparableConv.className="SeparableConv";var SeparableConv2D=class extends SeparableConv{constructor(e){super(2,e)}};SeparableConv2D.className="SeparableConv2D",serialization_exports.registerClass(SeparableConv2D);var _Conv1D=class extends Conv{constructor(e){super(1,e),_Conv1D.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!checkArrayTypeAndLength(e.kernelSize,"number",1,1))throw new ValueError(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}},Conv1D=_Conv1D;Conv1D.className="Conv1D",serialization_exports.registerClass(Conv1D);var Cropping2D=class extends Layer{constructor(e){super(e),"number"==typeof e.cropping?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:"number"==typeof e.cropping[0]?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=void 0===e.dataFormat?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return tidy((()=>{if(e=getExactlyOneTensor(e),"channelsLast"===this.dataFormat){const t=sliceAlongAxis(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return sliceAlongAxis(t,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{const t=sliceAlongAxis(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return sliceAlongAxis(t,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}}))}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}};Cropping2D.className="Cropping2D",serialization_exports.registerClass(Cropping2D);var UpSampling2D=class extends Layer{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=null==e.size?this.DEFAULT_SIZE:e.size,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,checkDataFormat(this.dataFormat),this.interpolation=null==e.interpolation?"nearest":e.interpolation,checkInterpolationFormat(this.interpolation)}computeOutputShape(e){if("channelsFirst"===this.dataFormat){const t=null==e[2]?null:this.size[0]*e[2],n=null==e[3]?null:this.size[1]*e[3];return[e[0],e[1],t,n]}{const t=null==e[1]?null:this.size[0]*e[1],n=null==e[2]?null:this.size[1]*e[2];return[e[0],t,n,e[3]]}}call(e,t){return tidy((()=>{let t=getExactlyOneTensor(e);const n=t.shape;if("channelsFirst"===this.dataFormat){t=transpose(t,[0,2,3,1]);const e=this.size[0]*n[2],a=this.size[1]*n[3],r="nearest"===this.interpolation?image.resizeNearestNeighbor(t,[e,a]):image.resizeBilinear(t,[e,a]);return transpose(r,[0,3,1,2])}{const e=this.size[0]*n[1],a=this.size[1]*n[2];return"nearest"===this.interpolation?image.resizeNearestNeighbor(t,[e,a]):image.resizeBilinear(t,[e,a])}}))}getConfig(){const e={size:this.size,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}};function depthwiseConv2d3(e,t,n=[1,1],a="valid",r,s){return tidy((()=>{null==r&&(r=imageDataFormat()),checkDataFormat(r);let o=preprocessConv2DInput(e,r);if(4!==e.rank)throw new ValueError(`Input for depthwiseConv2d is required to be 4-D, but is instead ${e.rank}-D`);if(4!==t.rank)throw new ValueError(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return o=depthwiseConv2d(o,t,n,"same"===a?"same":"valid","NHWC",s),"channelsFirst"===r&&(o=transpose(o,[0,3,1,2])),o}))}UpSampling2D.className="UpSampling2D",serialization_exports.registerClass(UpSampling2D);var DepthwiseConv2D=class extends BaseConv{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=null==e.depthMultiplier?1:e.depthMultiplier,this.depthwiseInitializer=getInitializer(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=getConstraint(e.depthwiseConstraint),this.depthwiseRegularizer=getRegularizer(e.depthwiseRegularizer)}build(e){if((e=getExactlyOneShape(e)).length<4)throw new ValueError(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);const t="channelsFirst"===this.dataFormat?1:3;if(null==e[t]||e[t]<0)throw new ValueError(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);const n=e[t],a=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",a,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return tidy((()=>{let t=depthwiseConv2d3(e=getExactlyOneTensor(e),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(t=biasAdd(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),t}))}computeOutputShape(e){e=getExactlyOneShape(e);const t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],a="channelsFirst"===this.dataFormat?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,r=convOutputLength(t,this.kernelSize[0],this.padding,this.strides[0]),s=convOutputLength(n,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[e[0],a,r,s]:[e[0],r,s,a]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=serializeInitializer(this.depthwiseInitializer),e.depthwiseRegularizer=serializeRegularizer(this.depthwiseRegularizer),e.depthwiseConstraint=serializeConstraint(this.depthwiseRegularizer),e}};function standardizeArgs(e,t,n,a){if(Array.isArray(e)){if(null!=t||null!=n)throw new ValueError("When inputs is an array, neither initialState or constants should be provided");null!=a&&(n=e.slice(e.length-a,e.length),e=e.slice(0,e.length-a)),e.length>1&&(t=e.slice(1,e.length)),e=e[0]}function r(e){return null==e||Array.isArray(e)?e:[e]}return{inputs:e,initialState:t=r(t),constants:n=r(n)}}function rnn(e,t,n,a=!1,r,s,o=!1,i=!1){return tidy((()=>{const l=t.shape.length;if(l<3)throw new ValueError(`Input should be at least 3D, but is ${l}D.`);const u=[1,0].concat(range2(2,l));if(t=transpose(t,u),null!=s)throw new NotImplementedError("The rnn() functoin of the deeplearn.js backend does not support constants yet.");o&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=r&&((r=cast(cast(r,"bool"),"float32")).rank===l-1&&(r=expandDims(r,-1)),r=transpose(r,u)),a&&(t=reverse(t,0),null!=r&&(r=reverse(r,0)));const c=[];let d,p=n;const h=t.shape[0],m=unstack(t);let f,g;null!=r&&(f=unstack(r));for(let t=0;t<h;++t){const n=m[t],a=tidy((()=>e(n,p)));if(null==r)d=a[0],p=a[1];else{const e=tidy((()=>{const e=f[t],n=sub(onesLike(e),e);return{output:add2(mul(a[0],e),mul(p[0],n)),newStates:p.map(((t,r)=>add2(mul(a[1][r],e),mul(t,n))))}}));d=e.output,p=e.newStates}i&&c.push(d)}if(i){g=stack(c,1)}return[d,g,p]}))}DepthwiseConv2D.className="DepthwiseConv2D",serialization_exports.registerClass(DepthwiseConv2D);var _RNN=class extends Layer{constructor(e){let t;if(super(e),null==e.cell)throw new ValueError("cell property is missing for the constructor of RNN.");if(t=Array.isArray(e.cell)?new StackedRNNCells({cells:e.cell}):e.cell,null==t.stateSize)throw new ValueError("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=null!=e.returnSequences&&e.returnSequences,this.returnState=null!=e.returnState&&e.returnState,this.goBackwards=null!=e.goBackwards&&e.goBackwards,this._stateful=null!=e.stateful&&e.stateful,this.unroll=null!=e.unroll&&e.unroll,this.supportsMasking=!0,this.inputSpec=[new InputSpec({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(null==this.states_){return range2(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map((e=>null))}return this.states_}setStates(e){this.states_=e}computeOutputShape(e){isArrayOfShapes(e)&&(e=e[0]);let t=this.cell.stateSize;Array.isArray(t)||(t=[t]);const n=t[0];let a;if(a=this.returnSequences?[e[0],e[1],n]:[e[0],n],this.returnState){const n=[];for(const a of t)n.push([e[0],a]);return[a].concat(n)}return a}computeMask(e,t){return tidy((()=>{Array.isArray(t)&&(t=t[0]);const e=this.returnSequences?t:null;if(this.returnState){const t=this.states.map((e=>null));return[e].concat(t)}return e}))}get states(){if(null==this.states_){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let n=0;n<e;++n)t.push(null);return t}return this.states_}set states(e){this.states_=e}build(e){if(null!=this.numConstants)throw new NotImplementedError("Constants support is not implemented in RNN yet.");isArrayOfShapes(e)&&(e=e[0]);const t=this.stateful?e[0]:null,n=e.slice(2);this.inputSpec[0]=new InputSpec({shape:[t,null,...n]});const a=[e[0]].concat(e.slice(2));let r;if(this.cell.build(a),r=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!util_exports.arraysEqual(this.stateSpec.map((e=>e.shape[e.shape.length-1])),r))throw new ValueError(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=r.map((e=>new InputSpec({shape:[null,e]})));this.stateful&&this.resetStates()}resetStates(e,t=!1){tidy((()=>{if(!this.stateful)throw new AttributeError("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape[0];if(null==n)throw new ValueError("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((e=>zeros([n,e]))):this.states_=[zeros([n,this.cell.stateSize])];else if(null==e)dispose(this.states_),null!=this.keptStates&&(dispose(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((e=>zeros([n,e]))):this.states_[0]=zeros([n,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new ValueError(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);!0===t?this.keptStates.push(this.states_.slice()):dispose(this.states_);for(let t=0;t<this.states_.length;++t){const a=e[t],r=Array.isArray(this.cell.stateSize)?this.cell.stateSize[t]:this.cell.stateSize,s=[n,r];if(!util_exports.arraysEqual(a.shape,s))throw new ValueError(`State ${t} is incompatible with layer ${this.name}: expected shape=${s}, received shape=${a.shape}`);this.states_[t]=a}}this.states_=this.states_.map((e=>keep(e.clone())))}))}apply(e,t){let n=null==t?null:t.initialState,a=null==t?null:t.constants;null==t&&(t={});const r=standardizeArgs(e,n,a,this.numConstants);e=r.inputs,n=r.initialState,a=r.constants;let s=[],o=[];if(null!=n){t.initialState=n,s=s.concat(n),this.stateSpec=[];for(const e of n)this.stateSpec.push(new InputSpec({shape:e.shape}));o=o.concat(this.stateSpec)}null!=a&&(t.constants=a,s=s.concat(a),this.numConstants=a.length);if(s[0]instanceof SymbolicTensor){const n=[e].concat(s),a=this.inputSpec.concat(o),r=this.inputSpec;this.inputSpec=a;const i=super.apply(n,t);return this.inputSpec=r,i}return super.apply(e,t)}call(e,t){return tidy((()=>{const n=null==t?null:t.mask,a=null==t?null:t.training;let r=null==t?null:t.initialState;e=getExactlyOneTensor(e),null==r&&(r=this.stateful?this.states_:this.getInitialState(e));const s=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(r.length!==s)throw new ValueError(`RNN Layer has ${s} state(s) but was passed ${r.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const o={training:a},i=rnn(((e,t)=>{const n=this.cell.call([e].concat(t),o);return[n[0],n.slice(1)]}),e,r,this.goBackwards,n,null,this.unroll,this.returnSequences),l=i[0],u=i[1],c=i[2];this.stateful&&this.resetStates(c,a);const d=this.returnSequences?u:l;return this.returnState?[d].concat(c):d}))}getInitialState(e){return tidy((()=>{let t=zeros(e.shape);return t=sum2(t,[1,2]),t=expandDims2(t),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map((e=>e>1?tile2(t,[1,e]):t)):this.cell.stateSize>1?[tile2(t,[1,this.cell.stateSize])]:[t]}))}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(t.numConstants=this.numConstants);const n=this.cell.getConfig();return this.getClassName()===_RNN.className&&(t.cell={className:this.cell.getClassName(),config:n}),{...n,...e,...t}}static fromConfig(e,t,n={}){const a=deserialize(t.cell,n);return new e(Object.assign(t,{cell:a}))}},RNN=_RNN;RNN.className="RNN",serialization_exports.registerClass(RNN);var RNNCell=class extends Layer{},SimpleRNNCell=class extends RNNCell{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,assertPositiveInteger(this.units,"units"),this.activation=getActivation(null==e.activation?this.DEFAULT_ACTIVATION:e.activation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=getInitializer(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=getInitializer(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=getInitializer(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=getRegularizer(e.kernelRegularizer),this.recurrentRegularizer=getRegularizer(e.recurrentRegularizer),this.biasRegularizer=getRegularizer(e.biasRegularizer),this.kernelConstraint=getConstraint(e.kernelConstraint),this.recurrentConstraint=getConstraint(e.recurrentConstraint),this.biasConstraint=getConstraint(e.biasConstraint),this.dropout=min2([1,max2([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=min2([1,max2([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=getExactlyOneShape(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return tidy((()=>{if(2!==e.length)throw new ValueError(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let n=e[1];e=e[0];const a=null!=t.training&&t.training;let r;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=generateDropoutMask({ones:()=>onesLike(e),rate:this.dropout,training:a,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=generateDropoutMask({ones:()=>onesLike(n),rate:this.recurrentDropout,training:a,dropoutFunc:this.dropoutFunc}));const s=this.dropoutMask,o=this.recurrentDropoutMask;r=dot2(null!=s?mul(e,s):e,this.kernel.read()),null!=this.bias&&(r=biasAdd(r,this.bias.read())),null!=o&&(n=mul(n,o));let i=add2(r,dot2(n,this.recurrentKernel.read()));return null!=this.activation&&(i=this.activation.apply(i)),[i,i]}))}getConfig(){return{...super.getConfig(),...{units:this.units,activation:serializeActivation(this.activation),useBias:this.useBias,kernelInitializer:serializeInitializer(this.kernelInitializer),recurrentInitializer:serializeInitializer(this.recurrentInitializer),biasInitializer:serializeInitializer(this.biasInitializer),kernelRegularizer:serializeRegularizer(this.kernelRegularizer),recurrentRegularizer:serializeRegularizer(this.recurrentRegularizer),biasRegularizer:serializeRegularizer(this.biasRegularizer),activityRegularizer:serializeRegularizer(this.activityRegularizer),kernelConstraint:serializeConstraint(this.kernelConstraint),recurrentConstraint:serializeConstraint(this.recurrentConstraint),biasConstraint:serializeConstraint(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout}}}};SimpleRNNCell.className="SimpleRNNCell",serialization_exports.registerClass(SimpleRNNCell);var SimpleRNN=class extends RNN{constructor(e){e.cell=new SimpleRNNCell(e),super(e)}call(e,t){return tidy((()=>{null!=this.cell.dropoutMask&&(dispose(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(dispose(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,a=null==t?null:t.training,r=null==t?null:t.initialState;return super.call(e,{mask:n,training:a,initialState:r})}))}static fromConfig(e,t){return new e(t)}};SimpleRNN.className="SimpleRNN",serialization_exports.registerClass(SimpleRNN);var GRUCell=class extends RNNCell{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new ValueError("GRUCell does not support reset_after parameter set to true.");this.units=e.units,assertPositiveInteger(this.units,"units"),this.activation=getActivation(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=getActivation(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=getInitializer(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=getInitializer(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=getInitializer(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=getRegularizer(e.kernelRegularizer),this.recurrentRegularizer=getRegularizer(e.recurrentRegularizer),this.biasRegularizer=getRegularizer(e.biasRegularizer),this.kernelConstraint=getConstraint(e.kernelConstraint),this.recurrentConstraint=getConstraint(e.recurrentConstraint),this.biasConstraint=getConstraint(e.biasConstraint),this.dropout=min2([1,max2([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=min2([1,max2([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){const t=(e=getExactlyOneShape(e))[e.length-1];this.kernel=this.addWeight("kernel",[t,3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return tidy((()=>{if(2!==e.length)throw new ValueError(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);const n=null!=t.training&&t.training;let a=e[1];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=generateDropoutMask({ones:()=>onesLike(e),rate:this.dropout,training:n,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=generateDropoutMask({ones:()=>onesLike(a),rate:this.recurrentDropout,training:n,count:3,dropoutFunc:this.dropoutFunc}));const r=this.dropoutMask,s=this.recurrentDropoutMask;let o,i,l;0<this.dropout&&this.dropout<1&&(e=mul(e,r[0]));let u=dot2(e,this.kernel.read());this.useBias&&(u=biasAdd(u,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(a=mul(a,s[0]));const c=this.recurrentKernel.read(),[d,p]=split(c,[2*this.units,this.units],c.rank-1),h=dot2(a,d),[m,f,g]=split(u,3,u.rank-1),[x,y]=split(h,2,h.rank-1);o=this.recurrentActivation.apply(add2(m,x)),i=this.recurrentActivation.apply(add2(f,y));const A=dot2(mul(i,a),p);l=this.activation.apply(add2(g,A));const b=add2(mul(o,a),mul(add2(1,neg(o)),l));return[b,b]}))}getConfig(){return{...super.getConfig(),...{units:this.units,activation:serializeActivation(this.activation),recurrentActivation:serializeActivation(this.recurrentActivation),useBias:this.useBias,kernelInitializer:serializeInitializer(this.kernelInitializer),recurrentInitializer:serializeInitializer(this.recurrentInitializer),biasInitializer:serializeInitializer(this.biasInitializer),kernelRegularizer:serializeRegularizer(this.kernelRegularizer),recurrentRegularizer:serializeRegularizer(this.recurrentRegularizer),biasRegularizer:serializeRegularizer(this.biasRegularizer),activityRegularizer:serializeRegularizer(this.activityRegularizer),kernelConstraint:serializeConstraint(this.kernelConstraint),recurrentConstraint:serializeConstraint(this.recurrentConstraint),biasConstraint:serializeConstraint(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1}}}};GRUCell.className="GRUCell",serialization_exports.registerClass(GRUCell);var GRU=class extends RNN{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new GRUCell(e),super(e)}call(e,t){return tidy((()=>{null!=this.cell.dropoutMask&&(dispose(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(dispose(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,a=null==t?null:t.training,r=null==t?null:t.initialState;return super.call(e,{mask:n,training:a,initialState:r})}))}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}};GRU.className="GRU",serialization_exports.registerClass(GRU);var LSTMCell=class extends RNNCell{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,assertPositiveInteger(this.units,"units"),this.activation=getActivation(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=getActivation(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=getInitializer(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=getInitializer(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=getInitializer(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=getRegularizer(e.kernelRegularizer),this.recurrentRegularizer=getRegularizer(e.recurrentRegularizer),this.biasRegularizer=getRegularizer(e.biasRegularizer),this.kernelConstraint=getConstraint(e.kernelConstraint),this.recurrentConstraint=getConstraint(e.recurrentConstraint),this.biasConstraint=getConstraint(e.biasConstraint),this.dropout=min2([1,max2([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=min2([1,max2([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;const n=(e=getExactlyOneShape(e))[e.length-1];let a;if(this.kernel=this.addWeight("kernel",[n,4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){const e=this.biasInitializer,n=this.units;a=new((t=class extends Initializer{apply(t,a){const r=e.apply([n]),s=(new Ones).apply([n]),o=e.apply([2*n]);return concatAlongFirstAxis(concatAlongFirstAxis(r,s),o)}}).className="CustomInit",t)}else a=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,a,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return tidy((()=>{const n=null!=t.training&&t.training;if(3!==e.length)throw new ValueError(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let a=e[1];const r=e[2];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=generateDropoutMask({ones:()=>onesLike(e),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=generateDropoutMask({ones:()=>onesLike(a),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const s=this.dropoutMask,o=this.recurrentDropoutMask;let i,l,u,c;0<this.dropout&&this.dropout<1&&(e=mul(e,s[0]));let d=dot2(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(a=mul(a,o[0])),d=add2(d,dot2(a,this.recurrentKernel.read())),this.useBias&&(d=biasAdd(d,this.bias.read()));const[p,h,m,f]=split(d,4,d.rank-1);i=this.recurrentActivation.apply(p),l=this.recurrentActivation.apply(h),u=add2(mul(l,r),mul(i,this.activation.apply(m))),c=this.recurrentActivation.apply(f);const g=mul(c,this.activation.apply(u));return[g,g,u]}))}getConfig(){return{...super.getConfig(),...{units:this.units,activation:serializeActivation(this.activation),recurrentActivation:serializeActivation(this.recurrentActivation),useBias:this.useBias,kernelInitializer:serializeInitializer(this.kernelInitializer),recurrentInitializer:serializeInitializer(this.recurrentInitializer),biasInitializer:serializeInitializer(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:serializeRegularizer(this.kernelRegularizer),recurrentRegularizer:serializeRegularizer(this.recurrentRegularizer),biasRegularizer:serializeRegularizer(this.biasRegularizer),activityRegularizer:serializeRegularizer(this.activityRegularizer),kernelConstraint:serializeConstraint(this.kernelConstraint),recurrentConstraint:serializeConstraint(this.recurrentConstraint),biasConstraint:serializeConstraint(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation}}}};LSTMCell.className="LSTMCell",serialization_exports.registerClass(LSTMCell);var LSTM=class extends RNN{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new LSTMCell(e),super(e)}call(e,t){return tidy((()=>{null!=this.cell.dropoutMask&&(dispose(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(dispose(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,a=null==t?null:t.training,r=null==t?null:t.initialState;return super.call(e,{mask:n,training:a,initialState:r})}))}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}};LSTM.className="LSTM",serialization_exports.registerClass(LSTM);var StackedRNNCells=class extends RNNCell{constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return tidy((()=>{let n=e.slice(1);const a=[];for(const e of this.cells.slice().reverse())Array.isArray(e.stateSize)?a.push(n.splice(0,e.stateSize.length)):a.push(n.splice(0,1));a.reverse();const r=[];let s;for(let o=0;o<this.cells.length;++o){const i=this.cells[o];n=a[o],s=0===o?[e[0]].concat(n):[s[0]].concat(n),s=i.call(s,t),r.push(s.slice(1))}n=[];for(const e of r.slice().reverse())n.push(...e);return[s[0]].concat(n)}))}build(e){let t;isArrayOfShapes(e)&&(e=e[0]),this.cells.forEach(((n,a)=>{nameScope(`RNNCell_${a}`,(()=>{n.build(e),t=Array.isArray(n.stateSize)?n.stateSize[0]:n.stateSize,e=[e[0],t]}))})),this.built=!0}getConfig(){return{...super.getConfig(),...{cells:this.cells.map((e=>({className:e.getClassName(),config:e.getConfig()})))}}}static fromConfig(e,t,n={}){const a=[];for(const e of t.cells)a.push(deserialize(e,n));return new e({cells:a})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const e of this.cells)t.push(...e.trainableWeights);return t.concat(e)}return e}getWeights(){const e=[];for(const t of this.cells)e.push(...t.weights);return batchGetValue(e)}setWeights(e){const t=[];for(const n of this.cells){const a=n.weights.length,r=e.splice(a);for(let e=0;e<n.weights.length;++e)t.push([n.weights[e],r[e]])}batchSetValue(t)}};function generateDropoutMask(e){const{ones:t,rate:n,training:a=!1,count:r=1,dropoutFunc:s}=e,o=()=>null!=s?s(t(),n):dropout2(t(),n),i=()=>inTrainPhase(o,t,a);if(!r||r<=1)return keep(i().clone());return Array(r).fill(void 0).map(i).map((e=>keep(e.clone())))}StackedRNNCells.className="StackedRNNCells",serialization_exports.registerClass(StackedRNNCells);var ConvRNN2D=class extends RNN{constructor(e){if(e.unroll)throw new NotImplementedError("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new NotImplementedError("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new InputSpec({ndim:5})]}call(e,t){return tidy((()=>{if(null!=this.cell.dropoutMask&&(dispose(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(dispose(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new ValueError("ConvRNN2D cell does not support constants");const n=null==t?null:t.mask,a=null==t?null:t.training,r=null==t?null:t.initialState;return super.call(e,{mask:n,training:a,initialState:r})}))}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return tidy((()=>{const{stateSize:t}=this.cell,n=e.shape,a=this.computeSingleOutputShape(n),r=zeros([a[0],...a.slice(2)]);return Array.isArray(t)?Array(t.length).fill(r):[r]}))}resetStates(e,t=!1){tidy((()=>{if(!this.stateful)throw new AttributeError("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape,a=this.computeSingleOutputShape(n),r=[a[0],...a.slice(2)];if(null==n[0])throw new ValueError("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>zeros(r))):this.states_=[zeros(r)];else if(null==e)dispose(this.states_),null!=this.keptStates&&(dispose(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>zeros(r))):this.states_[0]=zeros(r);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new ValueError(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):dispose(this.states_);for(let t=0;t<this.states_.length;++t){const n=e[t],a=r;if(!util_exports.arraysEqual(n.shape,a))throw new ValueError(`State ${t} is incompatible with layer ${this.name}: expected shape=${a}, received shape=${n.shape}`);this.states_[t]=n}}this.states_=this.states_.map((e=>keep(e.clone())))}))}computeSingleOutputShape(e){const{dataFormat:t,filters:n,kernelSize:a,padding:r,strides:s,dilationRate:o}=this.cell,i="channelsFirst"===t,l=e[i?3:2],u=e[i?4:3],c=convOutputLength(l,a[0],r,s[0],o[0]),d=convOutputLength(u,a[1],r,s[1],o[1]);return[...e.slice(0,2),...i?[n,c,d]:[c,d,n]]}};ConvRNN2D.className="ConvRNN2D";var ConvLSTM2DCell=class extends LSTMCell{constructor(e){const{filters:t,kernelSize:n,strides:a,padding:r,dataFormat:s,dilationRate:o}=e;super({...e,units:t}),this.filters=t,assertPositiveInteger(this.filters,"filters"),this.kernelSize=normalizeArray(n,2,"kernelSize"),this.kernelSize.forEach((e=>assertPositiveInteger(e,"kernelSize"))),this.strides=normalizeArray(a||1,2,"strides"),this.strides.forEach((e=>assertPositiveInteger(e,"strides"))),this.padding=r||"valid",checkPaddingMode(this.padding),this.dataFormat=s||"channelsLast",checkDataFormat(this.dataFormat),this.dilationRate=normalizeArray(o||1,2,"dilationRate"),this.dilationRate.forEach((e=>assertPositiveInteger(e,"dilationRate")))}build(e){var t;e=getExactlyOneShape(e);const n="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[n])throw new ValueError(`The channel dimension of the input should be defined. Found ${e[n]}`);const a=e[n],r=this.kernelSize.concat([a,4*this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const s=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",s,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let e;if(this.unitForgetBias){const n=this.biasInitializer,a=this.filters;e=new((t=class extends Initializer{apply(e,t){return concatenate([n.apply([a]),ones2([a]),n.apply([2*a])])}}).className="CustomInit",t)}else e=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,e,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return tidy((()=>{if(3!==e.length)throw new ValueError(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);const n=t.training||!1,a=e[0],r=e[1],s=e[2];0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=generateDropoutMask({ones:()=>onesLike(a),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const o=this.dropoutMask,i=(e,t,n)=>t&&t[n]?mul(t[n],e):e;let l=i(a,o,0),u=i(a,o,1),c=i(a,o,2),d=i(a,o,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=generateDropoutMask({ones:()=>onesLike(r),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const p=this.recurrentDropoutMask;let h=i(r,p,0),m=i(r,p,1),f=i(r,p,2),g=i(r,p,3);const[x,y,A,b]=split(this.kernel.read(),4,3),[v,k,S,w]=this.useBias?split(this.bias.read(),4):[null,null,null,null];l=this.inputConv(l,x,v,this.padding),u=this.inputConv(u,y,k,this.padding),c=this.inputConv(c,A,S,this.padding),d=this.inputConv(d,b,w,this.padding);const[C,I,T,N]=split(this.recurrentKernel.read(),4,3);h=this.recurrentConv(h,C),m=this.recurrentConv(m,I),f=this.recurrentConv(f,T),g=this.recurrentConv(g,N);const _=this.recurrentActivation.apply(add2(l,h)),E=this.recurrentActivation.apply(add2(u,m)),P=add2(mul(E,s),mul(_,this.activation.apply(add2(c,f)))),R=mul(this.recurrentActivation.apply(add2(d,g)),this.activation.apply(P));return[R,R,P]}))}getConfig(){const{units:e,...t}=super.getConfig();return{...t,...{filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides}}}inputConv(e,t,n,a){const r=conv2d(e,t,this.strides,a||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return n?biasAdd(r,n,this.dataFormat):r}recurrentConv(e,t){return conv2d(e,t,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}};ConvLSTM2DCell.className="ConvLSTM2DCell",serialization_exports.registerClass(ConvLSTM2DCell);var ConvLSTM2D=class extends ConvRNN2D{constructor(e){const t=new ConvLSTM2DCell(e);super({...e,cell:t})}static fromConfig(e,t){return new e(t)}};ConvLSTM2D.className="ConvLSTM2D",serialization_exports.registerClass(ConvLSTM2D);var Dropout=class extends Layer{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(null==this.noiseShape)return this.noiseShape;const t=e.shape,n=[];for(let e=0;e<this.noiseShape.length;++e)n.push(null==this.noiseShape[e]?t[e]:this.noiseShape[e]);return n}call(e,t){return tidy((()=>{this.invokeCallHook(e,t);const n=getExactlyOneTensor(e);if(0<this.rate&&this.rate<1){const e=null!=t.training&&t.training,a=this.getNoiseShape(n);return inTrainPhase((()=>dropout2(n,this.rate,a,this.seed)),(()=>n),e)}return e}))}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}};Dropout.className="Dropout",serialization_exports.registerClass(Dropout);var SpatialDropout1D=class extends Dropout{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const t=e.shape;return[t[0],1,t[2]]}};SpatialDropout1D.className="SpatialDropout1D",serialization_exports.registerClass(SpatialDropout1D);var Dense=class extends Layer{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==e.batchInputShape&&null==e.inputShape&&null!=e.inputDim){let t=null;null!=e.batchSize&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,assertPositiveInteger(this.units,"units"),this.activation=getActivation(e.activation),null!=e.useBias&&(this.useBias=e.useBias),this.kernelInitializer=getInitializer(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=getInitializer(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=getConstraint(e.kernelConstraint),this.biasConstraint=getConstraint(e.biasConstraint),this.kernelRegularizer=getRegularizer(e.kernelRegularizer),this.biasRegularizer=getRegularizer(e.biasRegularizer),this.activityRegularizer=getRegularizer(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){const t=(e=getExactlyOneShape(e))[e.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){const t=(e=getExactlyOneShape(e)).slice();return t[t.length-1]=this.units,t}call(e,t){return tidy((()=>{this.invokeCallHook(e,t);const n=getExactlyOneTensor(e),a=mapActivationToFusedKernel(this.activation.getClassName());let r;return null!=a?r=dot2(n,this.kernel.read(),a,this.bias?this.bias.read():null):(r=dot2(n,this.kernel.read()),null!=this.bias&&(r=biasAdd(r,this.bias.read())),null!=this.activation&&(r=this.activation.apply(r))),r}))}getConfig(){const e={units:this.units,activation:serializeActivation(this.activation),useBias:this.useBias,kernelInitializer:serializeInitializer(this.kernelInitializer),biasInitializer:serializeInitializer(this.biasInitializer),kernelRegularizer:serializeRegularizer(this.kernelRegularizer),biasRegularizer:serializeRegularizer(this.biasRegularizer),activityRegularizer:serializeRegularizer(this.activityRegularizer),kernelConstraint:serializeConstraint(this.kernelConstraint),biasConstraint:serializeConstraint(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}};Dense.className="Dense",serialization_exports.registerClass(Dense);var Flatten=class extends Layer{constructor(e){super(e=e||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=getExactlyOneShape(e);for(const t of e.slice(1))if(null==t)throw new ValueError(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],arrayProd(e,1)]}call(e,t){return tidy((()=>{this.invokeCallHook(e,t);let n=getExactlyOneTensor(e);if("channelsFirst"===this.dataFormat&&n.rank>1){const e=[0];for(let t=2;t<n.rank;++t)e.push(t);e.push(1),n=transpose(n,e)}return batchFlatten(n)}))}getConfig(){const e={};null!=this.dataFormat&&(e.dataFormat=this.dataFormat);const t=super.getConfig();return Object.assign(e,t),e}};Flatten.className="Flatten",serialization_exports.registerClass(Flatten);var Activation5=class extends Layer{constructor(e){super(e),this.supportsMasking=!0,this.activation=getActivation(e.activation)}call(e,t){return tidy((()=>{this.invokeCallHook(e,t);const n=getExactlyOneTensor(e);return this.activation.apply(n)}))}getConfig(){const e={activation:serializeActivation(this.activation)},t=super.getConfig();return Object.assign(e,t),e}};Activation5.className="Activation",serialization_exports.registerClass(Activation5);var RepeatVector=class extends Layer{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return tidy((()=>repeat(e=getExactlyOneTensor(e),this.n)))}getConfig(){const e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}};RepeatVector.className="RepeatVector",serialization_exports.registerClass(RepeatVector);var Reshape2=class extends Layer{constructor(e){super(e),this.targetShape=e.targetShape;for(let e=0;e<this.targetShape.length;++e)this.isUnknown(this.targetShape[e])&&(this.targetShape[e]=null)}isUnknown(e){return e<0||null==e}fixUnknownDimension(e,t){const n="Total size of new array must be unchanged.",a=t.slice();let r=1,s=null;for(let e=0;e<a.length;++e){const t=a[e];if(this.isUnknown(t)){if(null!==s)throw new ValueError("Can only specifiy one unknown dimension.");s=e}else r*=t}const o=arrayProd(e);if(null!==s){if(0===r||o%r!=0)throw new ValueError(n);a[s]=o/r}else if(o!==r)throw new ValueError(n);return a}computeOutputShape(e){let t=!1;for(let n=0;n<e.length;++n)if(this.isUnknown(e[n])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return tidy((()=>{this.invokeCallHook(e,t);const n=getExactlyOneTensor(e),a=n.shape,r=a.slice(0,1).concat(this.fixUnknownDimension(a.slice(1),this.targetShape));return reshape(n,r)}))}getConfig(){const e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}};Reshape2.className="Reshape",serialization_exports.registerClass(Reshape2);var Permute=class extends Layer{constructor(e){if(super(e),null==e.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);const t=range2(1,e.dims.length+1);if(!util_exports.arraysEqual(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new InputSpec({ndim:this.dims.length+1})]}computeOutputShape(e){const t=(e=getExactlyOneShape(e)).slice();return this.dims.forEach(((n,a)=>{t[a+1]=e[n]})),t}call(e,t){return transpose(getExactlyOneTensor(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}};Permute.className="Permute",serialization_exports.registerClass(Permute);var Masking=class extends Layer{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,this.maskValue=null!=e?null==e.maskValue?0:e.maskValue:0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){const n=getExactlyOneTensor(e);return any(notEqual(n,this.maskValue),-1)}call(e,t){return tidy((()=>{this.invokeCallHook(e,t);const n=getExactlyOneTensor(e),a=any(notEqual(n,this.maskValue),-1,!0);return mul(n,cast(a,n.dtype))}))}};Masking.className="Masking",serialization_exports.registerClass(Masking);var Embedding=class extends Layer{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==e.batchInputShape&&null==e.inputShape){let t=null;null!=e.batchSize&&(t=e.batchSize),null==e.inputLength?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(toList(e.inputLength))}this.inputDim=e.inputDim,assertPositiveInteger(this.inputDim,"inputDim"),this.outputDim=e.outputDim,assertPositiveInteger(this.outputDim,"outputDim"),this.embeddingsInitializer=getInitializer(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=getRegularizer(e.embeddingsRegularizer),this.activityRegularizer=getRegularizer(e.activityRegularizer),this.embeddingsConstraint=getConstraint(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return tidy((()=>this.maskZero?(e=getExactlyOneTensor(e),notEqual(e,zerosLike(e))):null))}computeOutputShape(e){if(e=getExactlyOneShape(e),null==this.inputLength)return[...e,this.outputDim];const t=toList(this.inputLength);if(t.length!==e.length-1)throw new ValueError(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let n=0;for(let a=0;a<t.length;++a){const r=t[a],s=e[a+1];if(null!=r&&null!=s&&r!==s)throw new ValueError(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);null==r&&(t[n]=s),n++}}return[e[0],...t,this.outputDim]}call(e,t){return tidy((()=>{this.invokeCallHook(e,t);let n=getExactlyOneTensor(e);"int32"!==n.dtype&&(n=cast2(n,"int32"));const a=gather2(this.embeddings.read(),reshape(n,[n.size]));return reshape(a,getExactlyOneShape(this.computeOutputShape(n.shape)))}))}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:serializeInitializer(this.embeddingsInitializer),embeddingsRegularizer:serializeRegularizer(this.embeddingsRegularizer),activityRegularizer:serializeRegularizer(this.activityRegularizer),embeddingsConstraint:serializeConstraint(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}};Embedding.className="Embedding",serialization_exports.registerClass(Embedding);var Merge=class extends Layer{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new NotImplementedError}computeElementwiseOpOutputShape(e,t){if(null==e||null==t)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(0===t.length)return e;const n=e.slice(0,e.length-t.length);for(let a=0;a<t.length;++a){const r=e[e.length-t.length+a],s=t[a];if(null==r||null==s||r<0||s<0)n.push(null);else if(1===r)n.push(s);else if(1===s)n.push(r);else{if(r!==s)throw new ValueError("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));n.push(r)}}return n}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[getExactlyOneShape(e)]),e.length<2)throw new ValueError(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(const n of e)null!=n&&null!==n[0]&&t.push(n[0]);if(t=unique2(t),t.length>1)throw new ValueError(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let n=null==e[0]?null:e[0].slice(1);for(let t=1;t<e.length;++t){const a=null==e[t]?null:e[t].slice(1);n=this.computeElementwiseOpOutputShape(n,a)}const a=e.map((e=>e.length));-1===e.indexOf(null)&&1===unique2(a).length?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return tidy((()=>{if(this.reshapeRequired){const t=[],n=e.map((e=>e.rank));if(-1===n.indexOf(null)){const a=max2(n);for(let n of e){const e=n.rank;for(let t=0;t<a-e;++t)n=expandDims2(n,1);t.push(n)}return this.mergeFunction(t)}{let n=!1;for(const a of e){const e=a.rank;if(null==e){const e=a.shape,r=e[0],s=e.slice(1).concat([r]);let o=reshape(a,[r].concat(arrayProd(e.slice(1))));o=transpose(o,[1,0]),o=reshape(o,s),t.push(o),n=!0}else if(e>1){const r=range2(1,e).concat([0]);t.push(transpose(a,r)),n=!0}else t.push(a)}let a=this.mergeFunction(t);const r=a.rank;if(n)if(null==r){const e=a.shape,t=e[e.length-1],n=[t].concat(e.slice(0,e.length-1));a=reshape(transpose(reshape(a,[-1,t]),[1,0]),n)}else if(r>1){const e=[r-1].concat(range2(0,r-1));a=transpose(a,e)}return a}}return this.mergeFunction(e)}))}computeOutputShape(e){let t;t=null==e[0]?null:e[0].slice(1);for(let n=1;n<e.length;++n){const a=null==e[n]?null:e[n].slice(1);t=this.computeElementwiseOpOutputShape(t,a)}let n=[];for(const t of e)null!=t&&null!==t[0]&&n.push(t[0]);return n=unique2(n),t=1===n.length?n.concat(t):[null].concat(t),t}computeMask(e,t){return tidy((()=>{if(null==t)return null;if(!Array.isArray(t))throw new ValueError("`mask` should be an Array");if(!Array.isArray(e))throw new ValueError("`inputs` should be an Array");if(t.length!==e.length)throw new ValueError(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every((e=>null==e)))return null;let n=(t=t.map((e=>null==e?e:expandDims(e,0))))[0];for(let e=1;e<t.length-1;++e)n=logicalAnd(n,t[e]);return n}))}},Add2=class extends Merge{constructor(e){super(e)}mergeFunction(e){return tidy((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=add2(t,e[n]);return t}))}};Add2.className="Add",serialization_exports.registerClass(Add2);var Multiply2=class extends Merge{constructor(e){super(e)}mergeFunction(e){return tidy((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=mul(t,e[n]);return t}))}};Multiply2.className="Multiply",serialization_exports.registerClass(Multiply2);var Average=class extends Merge{constructor(e){super(e)}mergeFunction(e){return tidy((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=add2(t,e[n]);return mul(1/e.length,t)}))}};Average.className="Average",serialization_exports.registerClass(Average);var Maximum2=class extends Merge{constructor(e){super(e)}mergeFunction(e){return tidy((()=>{let t=e[0];for(let n=1;n<e.length;++n)t=maximum(t,e[n]);return t}))}};Maximum2.className="Maximum",serialization_exports.registerClass(Maximum2);var Minimum2=class extends Merge{constructor(e){super(e)}mergeFunction(e){return tidy((()=>{let t=e[0];for(let n=1;n<e.length;++n)t=minimum(t,e[n]);return t}))}};Minimum2.className="Minimum",serialization_exports.registerClass(Minimum2);var Concatenate=class extends Merge{constructor(e){super(e),this.DEFAULT_AXIS=-1,null==e&&(e={}),this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!Array.isArray(e)||!Array.isArray(e[0])||1===e.length)throw new ValueError("A `Concatenate` layer should be called on a list of at least 2 inputs");let t=!0;for(const n of e)if(null!=n){t=!1;break}if(t)return;const n=[];for(let t=0;t<e.length;++t){const a=e[t].slice();a.splice(this.axis,1);let r=!1;for(const e of n)if(util_exports.arraysEqual(e,a)){r=!0;break}r||n.push(a)}if(n.length>1)throw new ValueError("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return tidy((()=>concatenate(e,this.axis)))}computeOutputShape(e){if(!Array.isArray(e)||!Array.isArray(e[0]))throw new ValueError("A `Concatenate` layer should be called on a list of inputs.");const t=e,n=t[0].slice(),a=this.axis<0?n.length+this.axis:this.axis;for(const e of t.slice(1)){if(null==n[a]||null==e[a]){n[a]=null;break}n[a]+=e[a]}return n}computeMask(e,t){if(null==t)return null;if(!Array.isArray(t))throw new ValueError("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new ValueError("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new ValueError(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return tidy((()=>{let n=!0;if(t.forEach((e=>{null==e||(n=!1)})),n)return null;const a=[];for(let n=0;n<e.length;++n)null==t[n]?a.push(cast(onesLike(e[n]),"bool")):t[n].rank<e[n].rank?a.push(expandDims(t[n],-1)):a.push(t[n]);const r=concat(a,this.axis);return all(r,-1,!1)}))}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}};function interpretAxis(e,t){for(;e<0;)e+=t;return e}function batchDot(e,t,n){if(e.shape.length>3||t.shape.length>3)throw new NotImplementedError("batchDot is not implemented for tensors of 4D or higher rank yet");if(util_exports.assert(e.shape.length>=2,(()=>`batchDot requires the rank of x to be >= 2, but got ${e.shape.length}`)),util_exports.assert(e.shape.length>=2,(()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`)),"number"==typeof n&&(n=[n,n]),"complex64"===e.dtype||"complex64"===t.dtype)throw new NotImplementedError("batchDot is not implemented for complex64-type Tensors yet.");const a=e.shape.length,r=t.shape.length;null==n&&(n=[a-1,r-2]);const s=n;return tidy((()=>{let n,o;if(a>r){n=a-r;const e=[];for(let t=0;t<n;++t)e.push(1);t=reshape(t,t.shape.concat(e))}else if(r>a){n=r-a;const t=[];for(let e=0;e<n;++e)t.push(1);e=reshape(e,e.shape.concat(t))}else n=0;if(2===e.shape.length&&2===t.shape.length)o=s[0]===s[1]?sum2(mul(e,t),s[0]):sum2(mul(transpose(e,[1,0]),t),s[1]);else{const n=s[0]!==e.shape.length-1,a=s[1]===t.shape.length-1;o=matMul(e,t,n,a)}if(n>0){let e;e=a>r?a+r-3:a-1;const t=[];for(let a=e;a<e+n;++a)t.push(a);o=squeeze(o,t)}return 1===o.shape.length&&(o=expandDims(o,1)),o}))}Concatenate.className="Concatenate",serialization_exports.registerClass(Concatenate);var Dot=class extends Merge{constructor(e){super(e),this.axes=e.axes,this.normalize=null!=e.normalize&&e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){util_exports.assert(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));const t=e[0],n=e[1];if(t.length>3||n.length>3)throw new NotImplementedError("Dot layer does not support tensors of 4D or higher rank yet.");const a=this.interpretAxes(t,n);if(t[a[0]]!==n[a[1]])throw new ValueError(`Dimension incompatibility: ${t[a[0]]} !== ${n[a[1]]}`)}mergeFunction(e){if(2!==e.length)throw new ValueError(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t,n=e[0],a=e[1];return t=Array.isArray(this.axes)?this.axes.map(((t,n)=>interpretAxis(t,e[n].shape.length))):[interpretAxis(this.axes,n.shape.length),interpretAxis(this.axes,a.shape.length)],this.normalize&&(n=l2Normalize(n,t[0]),a=l2Normalize(a,t[1])),batchDot(n,a,t)}interpretAxes(e,t){let n;return n=Array.isArray(this.axes)?this.axes:[interpretAxis(this.axes,e.length),interpretAxis(this.axes,t.length)],n}computeOutputShape(e){util_exports.assert(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));const t=e[0].slice(),n=e[1].slice();if(t.length>3||n.length>3)throw new NotImplementedError("Dot layer does not support tensors of 4D or higher rank yet.");const a=this.interpretAxes(t,n);t.splice(a[0],1),n.splice(a[1],1),n.splice(0,1);const r=t.concat(n);return 1===r.length&&r.push(1),r}computeMask(e,t){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}};Dot.className="Dot",serialization_exports.registerClass(Dot);var GaussianNoise=class extends Layer{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return tidy((()=>{this.invokeCallHook(e,t);const n=getExactlyOneTensor(e);return inTrainPhase((()=>add2(randomNormal2(n.shape,0,this.stddev),n)),(()=>n),t.training||!1)}))}};GaussianNoise.className="GaussianNoise",serialization_exports.registerClass(GaussianNoise);var GaussianDropout=class extends Layer{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return tidy((()=>{this.invokeCallHook(e,t);const n=getExactlyOneTensor(e);if(this.rate>0&&this.rate<1){return inTrainPhase((()=>{const e=Math.sqrt(this.rate/(1-this.rate));return mul(n,randomNormal2(n.shape,1,e))}),(()=>n),t.training||!1)}return n}))}};GaussianDropout.className="GaussianDropout",serialization_exports.registerClass(GaussianDropout);var AlphaDropout=class extends Layer{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||getExactlyOneTensor(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return tidy((()=>{if(this.rate<1&&this.rate>0){const n=this._getNoiseShape(e);return inTrainPhase((()=>{const t=getExactlyOneTensor(e),a=-1.7580993408473766;let r=greaterEqual(randomUniform(n),this.rate);r=cast2(r,"float32");const s=((1-this.rate)*(1+this.rate*a**2))**-.5,o=-s*a*this.rate,i=add2(mul(t,r),mul(add2(r,-1),a));return add2(mul(i,s),o)}),(()=>getExactlyOneTensor(e)),t.training||!1)}return e}))}};function batchNormalization(e,t,n,a,r,s=.001){let o;if(2===e.rank)o=batchNorm2d(e,t,n,a,r,s);else if(3===e.rank)o=batchNorm3d(e,t,n,a,r,s);else{if(4!==e.rank)throw new NotImplementedError(`batchNormalization is not implemented for array of rank ${e.rank} yet`);o=batchNorm4d(e,t,n,a,r,s)}return o}function regularNormalizeBatchInTraining(e,t,n,a,r=.001){return tidy((()=>{const s=moments(e,a),o=s.mean,i=s.variance;return[batchNormalization(e,o,i,n,t,r),o,i]}))}function broadcastNormalizeBatchInTraining(e,t,n,a,r=.001){return tidy((()=>{const s=moments(e,a),o=s.mean,i=s.variance,l=[];for(const t of range2(0,e.rank))-1!==a.indexOf(t)?l.push(1):l.push(e.shape[t]);const u=reshape(o,l),c=reshape(i,l),d=null==t?null:reshape(t,l),p=null==n?null:reshape(n,l);return[batchNormalization(e,u,c,p,d,r),o,i]}))}function normalizeBatchInTraining(e,t,n,a,r=.001){return util_exports.arraysEqual(a.slice().sort(),range2(0,e.rank-1))?regularNormalizeBatchInTraining(e,t,n,a,r):broadcastNormalizeBatchInTraining(e,t,n,a,r)}AlphaDropout.className="AlphaDropout",serialization_exports.registerClass(AlphaDropout);var BatchNormalization=class extends Layer{constructor(e){null==e&&(e={}),super(e),this.supportsMasking=!0,this.axis=null==e.axis?-1:e.axis,this.momentum=null==e.momentum?.99:e.momentum,this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=getInitializer(e.betaInitializer||"zeros"),this.gammaInitializer=getInitializer(e.gammaInitializer||"ones"),this.movingMeanInitializer=getInitializer(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=getInitializer(e.movingVarianceInitializer||"ones"),this.betaConstraint=getConstraint(e.betaConstraint),this.gammaConstraint=getConstraint(e.gammaConstraint),this.betaRegularizer=getRegularizer(e.betaRegularizer),this.gammaRegularizer=getRegularizer(e.gammaRegularizer)}build(e){e=getExactlyOneShape(e);const t=this.axis>=0?this.axis:this.axis+e.length,n=e[t];if(null==n)throw new ValueError(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new InputSpec({ndim:e.length,axes:{[t]:n}})];const a=[n];this.scale&&(this.gamma=this.addWeight("gamma",a,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",a,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",a,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",a,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return tidy((()=>{const n=null!=t.training&&t.training,a=getExactlyOneTensor(e),r=a.shape,s=r.length,o=range2(0,s),i=this.axis>=0?this.axis:this.axis+s;o.splice(i,1);const l=pyListRepeat(1,s);l[i]=r[i];const u=o.slice();u.sort();const c=!util_exports.arraysEqual(u,range2(0,s).slice(0,s-1));if(!n)return(()=>{if(c){const e=reshape(this.movingMean.read(),l),t=reshape(this.movingVariance.read(),l),n=this.center?reshape(this.beta.read(),l):null,r=this.scale?reshape(this.gamma.read(),l):null;return batchNormalization(a,e,t,n,r,this.epsilon)}return batchNormalization(a,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)})();const[d,p,h]=normalizeBatchInTraining(a,this.gamma.read(),this.beta.read(),o,this.epsilon),m=(e,t,n)=>{tidy((()=>{const a=1-n,r=e.read(),s=mul(sub(r,t),a);e.write(sub(r,s))}))};return(()=>{m(this.movingMean,p,this.momentum),m(this.movingVariance,h,this.momentum)})(),d}))}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:serializeInitializer(this.betaInitializer),gammaInitializer:serializeInitializer(this.gammaInitializer),movingMeanInitializer:serializeInitializer(this.movingMeanInitializer),movingVarianceInitializer:serializeInitializer(this.movingVarianceInitializer),betaRegularizer:serializeRegularizer(this.betaRegularizer),gammaRegularizer:serializeRegularizer(this.gammaRegularizer),betaConstraint:serializeConstraint(this.betaConstraint),gammaConstraint:serializeConstraint(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}};BatchNormalization.className="BatchNormalization",serialization_exports.registerClass(BatchNormalization);var LayerNormalization=class extends Layer{constructor(e){if(null==e&&(e={}),super(e),this.axis=null==e.axis?-1:e.axis,"number"==typeof this.axis){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else{if(!Array.isArray(this.axis))throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);for(const e of this.axis)if(!Number.isInteger(e))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=getInitializer(e.betaInitializer||"zeros"),this.gammaInitializer=getInitializer(e.gammaInitializer||"ones"),this.betaRegularizer=getRegularizer(e.betaRegularizer),this.gammaRegularizer=getRegularizer(e.gammaRegularizer),this.supportsMasking=!0}build(e){const t=(e=getExactlyOneShape(e)).length;"number"==typeof this.axis&&(this.axis=[this.axis]);for(let e=0;e<this.axis.length;++e)this.axis[e]<0&&(this.axis[e]+=t);for(const e of this.axis)if(e<0||e>=t)throw new Error(`Invalid axis: ${e}`);if(this.axis.length!==unique2(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const n=this.axis.map((t=>e[t]));this.scale?this.gamma=this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,true):this.gamma=null,this.center?this.beta=this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,true):this.beta=null,this.built=!0}call(e,t){const n=getExactlyOneTensor(e),a=n.shape,r=a.length;return tidy((()=>{let{mean:e,variance:t}=moments(n,this.axis,!0);const s=pyListRepeat(1,r);for(const e of this.axis)s[e]=a[e];const o=e=>null!=e&&e.shape.length!==r?reshape(e,s):e;let i=o(this.gamma.read()),l=o(this.beta.read());const u=[],c=[];for(let e=0;e<r;++e)-1!==this.axis.indexOf(e)?(u.push(a[e]),c.push(1)):(u.push(1),c.push(a[e]));return e=tile(e,u),t=tile(t,u),i=tile(i,c),l=tile(l,c),batchNormalization(n,e,t,l,i,this.epsilon)}))}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:serializeInitializer(this.betaInitializer),gammaInitializer:serializeInitializer(this.gammaInitializer),betaRegularizer:serializeRegularizer(this.betaRegularizer),gammaRegularizer:serializeRegularizer(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}};function spatial2dPadding(e,t,n){return tidy((()=>{if(4!==e.rank)throw new ValueError(`temporalPadding expects input tensor to be 4-D, but received a ${e.rank}-D tensor.`);if(null==t&&(t=[[1,1],[1,1]]),2!==t.length||2!==t[0].length||2!==t[1].length)throw new ValueError("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==n&&(n=imageDataFormat()),"channelsLast"!==n&&"channelsFirst"!==n)throw new ValueError(`Unknown data format: ${n}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let a;return a="channelsFirst"===n?[[0,0],[0,0],t[0],t[1]]:[[0,0],t[0],t[1],[0,0]],pad(e,a)}))}LayerNormalization.className="LayerNormalization",serialization_exports.registerClass(LayerNormalization);var ZeroPadding2D=class extends Layer{constructor(e){if(null==e&&(e={}),super(e),this.dataFormat=null==e.dataFormat?imageDataFormat():e.dataFormat,null==e.padding)this.padding=[[1,1],[1,1]];else if("number"==typeof e.padding)this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,2!==e.padding.length)throw new ValueError(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,n;if("number"==typeof e.padding[0])t=[e.padding[0],e.padding[0]],n=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,2!==e.padding[0].length)throw new ValueError(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],2!==e.padding[1].length)throw new ValueError(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);n=e.padding[1]}this.padding=[t,n]}this.inputSpec=[new InputSpec({ndim:4})]}computeOutputShape(e){let t,n;return e=getExactlyOneShape(e),"channelsFirst"===this.dataFormat?(t=null!=e[2]&&e[2]>=0?e[2]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[3]&&e[3]>=0?e[3]+this.padding[1][0]+this.padding[1][1]:null,[e[0],e[1],t,n]):(t=null!=e[1]&&e[1]>=0?e[1]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[2]&&e[2]>=0?e[2]+this.padding[1][0]+this.padding[1][1]:null,[e[0],t,n,e[3]])}call(e,t){return tidy((()=>spatial2dPadding(getExactlyOneTensor(e),this.padding,this.dataFormat)))}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}};function pool2d(e,t,n,a,r,s){return tidy((()=>{let o;checkDataFormat(r),checkPoolMode(s),checkPaddingMode(a),null==n&&(n=[1,1]),null==a&&(a="valid"),null==r&&(r=imageDataFormat()),null==s&&(s="max"),e=preprocessConv2DInput(e,r);const i="same"===a?"same":"valid";return o="max"===s?maxPool(e,t,n,i):avgPool(e,t,n,i),"channelsFirst"===r&&(o=transpose(o,[0,3,1,2])),o}))}function pool3d(e,t,n,a,r,s){return tidy((()=>{let o;checkDataFormat(r),checkPoolMode(s),checkPaddingMode(a),null==n&&(n=[1,1,1]),null==a&&(a="valid"),null==r&&(r=imageDataFormat()),null==s&&(s="max"),e=preprocessConv3DInput(e,r);const i="same"===a?"same":"valid";return o="max"===s?maxPool3d(e,t,n,i):avgPool3d(e,t,n,i),"channelsFirst"===r&&(o=transpose(o,[0,4,1,2,3])),o}))}ZeroPadding2D.className="ZeroPadding2D",serialization_exports.registerClass(ZeroPadding2D);var Pooling1D=class extends Layer{constructor(e){if(null==e.poolSize&&(e.poolSize=2),super(e),"number"==typeof e.poolSize)this.poolSize=[e.poolSize];else{if(!Array.isArray(e.poolSize)||1!==e.poolSize.length||"number"!=typeof e.poolSize[0])throw new ValueError(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);this.poolSize=e.poolSize}if(assertPositiveInteger(this.poolSize,"poolSize"),null==e.strides)this.strides=this.poolSize;else if("number"==typeof e.strides)this.strides=[e.strides];else{if(!Array.isArray(e.strides)||1!==e.strides.length||"number"!=typeof e.strides[0])throw new ValueError(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);this.strides=e.strides}assertPositiveInteger(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,checkPaddingMode(this.padding),this.inputSpec=[new InputSpec({ndim:3})]}computeOutputShape(e){const t=convOutputLength((e=getExactlyOneShape(e))[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return tidy((()=>{this.invokeCallHook(e,t),e=expandDims2(getExactlyOneTensor(e),2);const n=this.poolingFunction(getExactlyOneTensor(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return squeeze(n,[2])}))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}},MaxPooling1D=class extends Pooling1D{constructor(e){super(e)}poolingFunction(e,t,n,a,r){return checkDataFormat(r),checkPaddingMode(a),pool2d(e,t,n,a,r,"max")}};MaxPooling1D.className="MaxPooling1D",serialization_exports.registerClass(MaxPooling1D);var AveragePooling1D=class extends Pooling1D{constructor(e){super(e)}poolingFunction(e,t,n,a,r){return checkDataFormat(r),checkPaddingMode(a),pool2d(e,t,n,a,r,"avg")}};AveragePooling1D.className="AveragePooling1D",serialization_exports.registerClass(AveragePooling1D);var Pooling2D=class extends Layer{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(2!==e.strides.length)throw new ValueError(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];assertPositiveInteger(this.poolSize,"poolSize"),assertPositiveInteger(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,checkDataFormat(this.dataFormat),checkPaddingMode(this.padding),this.inputSpec=[new InputSpec({ndim:4})]}computeOutputShape(e){e=getExactlyOneShape(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2];return t=convOutputLength(t,this.poolSize[0],this.padding,this.strides[0]),n=convOutputLength(n,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n]:[e[0],t,n,e[3]]}call(e,t){return tidy((()=>(this.invokeCallHook(e,t),this.poolingFunction(getExactlyOneTensor(e),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},MaxPooling2D=class extends Pooling2D{constructor(e){super(e)}poolingFunction(e,t,n,a,r){return checkDataFormat(r),checkPaddingMode(a),pool2d(e,t,n,a,r,"max")}};MaxPooling2D.className="MaxPooling2D",serialization_exports.registerClass(MaxPooling2D);var AveragePooling2D=class extends Pooling2D{constructor(e){super(e)}poolingFunction(e,t,n,a,r){return checkDataFormat(r),checkPaddingMode(a),pool2d(e,t,n,a,r,"avg")}};AveragePooling2D.className="AveragePooling2D",serialization_exports.registerClass(AveragePooling2D);var Pooling3D=class extends Layer{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(3!==e.strides.length)throw new ValueError(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];assertPositiveInteger(this.poolSize,"poolSize"),assertPositiveInteger(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,checkDataFormat(this.dataFormat),checkPaddingMode(this.padding),this.inputSpec=[new InputSpec({ndim:5})]}computeOutputShape(e){e=getExactlyOneShape(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],a="channelsFirst"===this.dataFormat?e[4]:e[3];return t=convOutputLength(t,this.poolSize[0],this.padding,this.strides[0]),n=convOutputLength(n,this.poolSize[1],this.padding,this.strides[1]),a=convOutputLength(a,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n,a]:[e[0],t,n,a,e[4]]}call(e,t){return tidy((()=>(this.invokeCallHook(e,t),this.poolingFunction(getExactlyOneTensor(e),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},MaxPooling3D=class extends Pooling3D{constructor(e){super(e)}poolingFunction(e,t,n,a,r){return checkDataFormat(r),checkPaddingMode(a),pool3d(e,t,n,a,r,"max")}};MaxPooling3D.className="MaxPooling3D",serialization_exports.registerClass(MaxPooling3D);var AveragePooling3D=class extends Pooling3D{constructor(e){super(e)}poolingFunction(e,t,n,a,r){return checkDataFormat(r),checkPaddingMode(a),pool3d(e,t,n,a,r,"avg")}};AveragePooling3D.className="AveragePooling3D",serialization_exports.registerClass(AveragePooling3D);var GlobalPooling1D=class extends Layer{constructor(e){super(e),this.inputSpec=[new InputSpec({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new NotImplementedError}},GlobalAveragePooling1D=class extends GlobalPooling1D{constructor(e){super(e||{})}call(e,t){return tidy((()=>{const t=getExactlyOneTensor(e);return mean(t,1)}))}};GlobalAveragePooling1D.className="GlobalAveragePooling1D",serialization_exports.registerClass(GlobalAveragePooling1D);var GlobalMaxPooling1D=class extends GlobalPooling1D{constructor(e){super(e||{})}call(e,t){return tidy((()=>{const t=getExactlyOneTensor(e);return max(t,1)}))}};GlobalMaxPooling1D.className="GlobalMaxPooling1D",serialization_exports.registerClass(GlobalMaxPooling1D);var GlobalPooling2D=class extends Layer{constructor(e){super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,checkDataFormat(this.dataFormat),this.inputSpec=[new InputSpec({ndim:4})]}computeOutputShape(e){return"channelsLast"===this.dataFormat?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new NotImplementedError}getConfig(){const e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},GlobalAveragePooling2D=class extends GlobalPooling2D{call(e,t){return tidy((()=>{const t=getExactlyOneTensor(e);return"channelsLast"===this.dataFormat?mean(t,[1,2]):mean(t,[2,3])}))}};GlobalAveragePooling2D.className="GlobalAveragePooling2D",serialization_exports.registerClass(GlobalAveragePooling2D);var GlobalMaxPooling2D=class extends GlobalPooling2D{call(e,t){return tidy((()=>{const t=getExactlyOneTensor(e);return"channelsLast"===this.dataFormat?max(t,[1,2]):max(t,[2,3])}))}};GlobalMaxPooling2D.className="GlobalMaxPooling2D",serialization_exports.registerClass(GlobalMaxPooling2D);var Wrapper=class extends Layer{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(e){null!=this.layer&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){const e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t,n={}){const a=deserialize(t.layer,n);delete t.layer;const r={layer:a};return Object.assign(r,t),new e(r)}},TimeDistributed=class extends Wrapper{constructor(e){super(e),this.supportsMasking=!0}build(e){if((e=getExactlyOneShape(e)).length<3)throw new ValueError(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];const t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){const t=[(e=getExactlyOneShape(e))[0]].concat(e.slice(2)),n=this.layer.computeOutputShape(t),a=e[1];return[n[0],a].concat(n.slice(1))}call(e,t){return tidy((()=>rnn(((e,n)=>[getExactlyOneTensor(this.layer.call(e,t)),[]]),e=getExactlyOneTensor(e),[],!1,null,null,!1,!0)[1]))}};function checkBidirectionalMergeMode(e){checkStringTypeUnionValue(VALID_BIDIRECTIONAL_MERGE_MODES,"BidirectionalMergeMode",e)}TimeDistributed.className="TimeDistributed",serialization_exports.registerClass(TimeDistributed);var DEFAULT_BIDIRECTIONAL_MERGE_MODE="concat",Bidirectional=class extends Wrapper{constructor(e){super(e);const t=e.layer.getConfig(),n={};n.className=e.layer.getClassName(),n.config=t,this.forwardLayer=deserialize(n),t.goBackwards=!0!==t.goBackwards;const a={};if(a.className=e.layer.getClassName(),a.config=t,this.backwardLayer=deserialize(a),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===e.mergeMode?DEFAULT_BIDIRECTIONAL_MERGE_MODE:e.mergeMode,checkBidirectionalMergeMode(this.mergeMode),e.weights)throw new NotImplementedError("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,null!=this.forwardLayer&&(this.forwardLayer.trainable=e),null!=this.backwardLayer&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const t=e.length,n=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,n)),this.backwardLayer.setWeights(e.slice(n))}computeOutputShape(e){let t,n,a,r=this.forwardLayer.computeOutputShape(e);return Array.isArray(r)&&Array.isArray(r[0])||(r=[r]),this.returnState?(a=r.slice(1),t=r[0]):t=r[0],"concat"===this.mergeMode?(t[t.length-1]*=2,n=[t]):n=null==this.mergeMode?[t,t.slice()]:[t],this.returnState?null==this.mergeMode?n.concat(a).concat(a.slice()):[t].concat(a).concat(a.slice()):singletonOrArray(n)}apply(e,t){let n=null==t?null:t.initialState,a=null==t?null:t.constants;null==t&&(t={});const r=standardizeArgs(e,n,a,this.numConstants);if(e=r.inputs,n=r.initialState,a=r.constants,Array.isArray(e)&&(n=e.slice(1),e=e[0]),(null==n||0===n.length)&&null==a)return super.apply(e,t);const s=[],o=[];if(null!=n){const e=n.length;if(e%2>0)throw new ValueError("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=n,s.push(...n);const a=n.map((e=>new InputSpec({shape:e.shape})));this.forwardLayer.stateSpec=a.slice(0,e/2),this.backwardLayer.stateSpec=a.slice(e/2),o.push(...a)}if(null!=a)throw new NotImplementedError("Support for constants in Bidirectional layers is not implemented yet.");const i=s[0]instanceof SymbolicTensor;for(const e of s)if(e instanceof SymbolicTensor!==i)throw new ValueError("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(i){const n=[e].concat(s),a=this.inputSpec.concat(o),r=this.inputSpec;this.inputSpec=a;const i=super.apply(n,t);return this.inputSpec=r,i}return super.apply(e,t)}call(e,t){return tidy((()=>{const n=t.initialState;let a,r,s,o;if(null==n)a=this.forwardLayer.call(e,t),r=this.backwardLayer.call(e,t);else{const s=n.slice(0,n.length/2),o=n.slice(n.length/2);a=this.forwardLayer.call(e,Object.assign(t,{initialState:s})),r=this.backwardLayer.call(e,Object.assign(t,{initialState:o}))}return this.returnState&&(Array.isArray(a)&&(s=a.slice(1).concat(r.slice(1))),a=a[0],r=r[0]),this.returnSequences&&(r=reverse(r,1)),"concat"===this.mergeMode?o=concatenate([a,r]):"sum"===this.mergeMode?o=add2(a,r):"ave"===this.mergeMode?o=mul(.5,add2(a,r)):"mul"===this.mergeMode?o=mul(a,r):null==this.mergeMode&&(o=[a,r]),this.returnState?null==this.mergeMode?o.concat(s):[o].concat(s):o}))}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){nameScope(this.forwardLayer.name,(()=>{this.forwardLayer.build(e)})),nameScope(this.backwardLayer.name,(()=>{this.backwardLayer.build(e)})),this.built=!0}computeMask(e,t){let n;if(Array.isArray(t)&&(t=t[0]),n=this.returnSequences?null==this.mergeMode?[t,t]:t:null==this.mergeMode?[null,null]:null,this.returnState){const e=this.forwardLayer.states.map((e=>null));return Array.isArray(n)?n.concat(e).concat(e):[n].concat(e).concat(e)}return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(e),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){const n=deserialize(t.layer);if(delete t.layer,null!=t.numConstants)throw new NotImplementedError("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const a=t;return a.layer=n,new e(a)}};function inputLayer(e){return new InputLayer(e)}function elu3(e){return new ELU(e)}function reLU(e){return new ReLU(e)}function leakyReLU(e){return new LeakyReLU(e)}function prelu2(e){return new PReLU(e)}function softmax2(e){return new Softmax3(e)}function thresholdedReLU(e){return new ThresholdedReLU(e)}function conv1d2(e){return new Conv1D(e)}function conv2d3(e){return new Conv2D2(e)}function conv2dTranspose2(e){return new Conv2DTranspose(e)}function conv3d2(e){return new Conv3D2(e)}function conv3dTranspose2(e){return new Conv3DTranspose(e)}function separableConv2d2(e){return new SeparableConv2D(e)}function cropping2D(e){return new Cropping2D(e)}function upSampling2d(e){return new UpSampling2D(e)}function depthwiseConv2d4(e){return new DepthwiseConv2D(e)}function activation(e){return new Activation5(e)}function dense(e){return new Dense(e)}function dropout3(e){return new Dropout(e)}function spatialDropout1d(e){return new SpatialDropout1D(e)}function flatten3(e){return new Flatten(e)}function repeatVector(e){return new RepeatVector(e)}function reshape2(e){return new Reshape2(e)}function permute(e){return new Permute(e)}function embedding(e){return new Embedding(e)}function add3(e){return new Add2(e)}function average(e){return new Average(e)}function concatenate2(e){return new Concatenate(e)}function maximum2(e){return new Maximum2(e)}function minimum2(e){return new Minimum2(e)}function multiply(e){return new Multiply2(e)}function dot3(e){return new Dot(e)}function batchNormalization2(e){return new BatchNormalization(e)}function layerNormalization(e){return new LayerNormalization(e)}function zeroPadding2d(e){return new ZeroPadding2D(e)}function averagePooling1d(e){return new AveragePooling1D(e)}function avgPool1d(e){return averagePooling1d(e)}function avgPooling1d(e){return averagePooling1d(e)}function averagePooling2d(e){return new AveragePooling2D(e)}function avgPool2d(e){return averagePooling2d(e)}function avgPooling2d(e){return averagePooling2d(e)}function averagePooling3d(e){return new AveragePooling3D(e)}function avgPool3d2(e){return averagePooling3d(e)}function avgPooling3d(e){return averagePooling3d(e)}function globalAveragePooling1d(e){return new GlobalAveragePooling1D(e)}function globalAveragePooling2d(e){return new GlobalAveragePooling2D(e)}function globalMaxPooling1d(e){return new GlobalMaxPooling1D(e)}function globalMaxPooling2d(e){return new GlobalMaxPooling2D(e)}function maxPooling1d(e){return new MaxPooling1D(e)}function maxPooling2d(e){return new MaxPooling2D(e)}function maxPooling3d(e){return new MaxPooling3D(e)}function gru(e){return new GRU(e)}function gruCell(e){return new GRUCell(e)}function lstm(e){return new LSTM(e)}function lstmCell(e){return new LSTMCell(e)}function simpleRNN(e){return new SimpleRNN(e)}function simpleRNNCell(e){return new SimpleRNNCell(e)}function convLstm2d(e){return new ConvLSTM2D(e)}function convLstm2dCell(e){return new ConvLSTM2DCell(e)}function rnn2(e){return new RNN(e)}function stackedRNNCells(e){return new StackedRNNCells(e)}function bidirectional(e){return new Bidirectional(e)}function timeDistributed(e){return new TimeDistributed(e)}Bidirectional.className="Bidirectional",serialization_exports.registerClass(Bidirectional);var globalMaxPool1d=globalMaxPooling1d,globalMaxPool2d=globalMaxPooling2d,maxPool1d=maxPooling1d,maxPool2d=maxPooling2d;function gaussianNoise(e){return new GaussianNoise(e)}function gaussianDropout(e){return new GaussianDropout(e)}function alphaDropout(e){return new AlphaDropout(e)}function masking(e){return new Masking(e)}var exports_metrics_exports={};function binaryAccuracy2(e,t){return binaryAccuracy(e,t)}function binaryCrossentropy3(e,t){return binaryCrossentropy2(e,t)}function sparseCategoricalAccuracy2(e,t){return sparseCategoricalAccuracy(e,t)}function categoricalAccuracy2(e,t){return categoricalAccuracy(e,t)}function categoricalCrossentropy3(e,t){return categoricalCrossentropy2(e,t)}function precision2(e,t){return precision(e,t)}function recall2(e,t){return recall(e,t)}function cosineProximity2(e,t){return cosineProximity(e,t)}function meanAbsoluteError2(e,t){return meanAbsoluteError(e,t)}function meanAbsolutePercentageError2(e,t){return meanAbsolutePercentageError(e,t)}function MAPE2(e,t){return meanAbsolutePercentageError(e,t)}function mape2(e,t){return meanAbsolutePercentageError(e,t)}function meanSquaredError3(e,t){return meanSquaredError2(e,t)}function MSE2(e,t){return meanSquaredError2(e,t)}function mse2(e,t){return meanSquaredError2(e,t)}__export2(exports_metrics_exports,{MAPE:()=>MAPE2,MSE:()=>MSE2,binaryAccuracy:()=>binaryAccuracy2,binaryCrossentropy:()=>binaryCrossentropy3,categoricalAccuracy:()=>categoricalAccuracy2,categoricalCrossentropy:()=>categoricalCrossentropy3,cosineProximity:()=>cosineProximity2,mape:()=>mape2,meanAbsoluteError:()=>meanAbsoluteError2,meanAbsolutePercentageError:()=>meanAbsolutePercentageError2,meanSquaredError:()=>meanSquaredError3,mse:()=>mse2,precision:()=>precision2,recall:()=>recall2,sparseCategoricalAccuracy:()=>sparseCategoricalAccuracy2});var exports_models_exports={};__export2(exports_models_exports,{modelFromJSON:()=>modelFromJSON});var exports_regularizers_exports={};function l1l2(e){return new L1L2(e)}function l12(e){return l1(e)}function l22(e){return l2(e)}__export2(exports_regularizers_exports,{l1:()=>l12,l1l2:()=>l1l2,l2:()=>l22});var Callback=class extends BaseCallback{constructor(){super(...arguments),this.model=null}setModel(e){if(!(e instanceof LayersModel))throw new Error("model must be a LayersModel, not some other Container");this.model=e}};function less2(e,t){return e<t}function greater2(e,t){return e>t}var EarlyStopping=class extends Callback{constructor(e){if(super(),null==e&&(e={}),e.restoreBestWeights)throw new NotImplementedError("restoreBestWeights = True is not implemented in EarlyStopping yet.");this.monitor=e.monitor||"val_loss",this.minDelta=Math.abs(e.minDelta||0),this.patience=e.patience||0,this.verbose=e.verbose||0,this.mode=e.mode||"auto",this.baseline=e.baseline,-1===["auto","min","max"].indexOf(this.mode)&&(console.warn(`EarlyStopping mode '${this.mode}' is invalid. Falling back to mode 'auto'.`),this.mode="auto"),"min"===this.mode?this.monitorFunc=less2:"max"===this.mode||-1!==this.monitor.indexOf("acc")?this.monitorFunc=greater2:this.monitorFunc=less2,this.monitorFunc===less2&&(this.minDelta*=-1)}async onTrainBegin(e){this.wait=0,this.stoppedEpoch=0,null!=this.baseline?this.best=this.baseline:this.best=this.monitorFunc===less2?1/0:-1/0}async onEpochEnd(e,t){await resolveScalarsInLogs(t);const n=this.getMonitorValue(t);null!=n&&(this.monitorFunc(n-this.minDelta,this.best)?(this.best=n,this.wait=0):(this.wait++,this.wait>=this.patience&&(this.stoppedEpoch=e,this.model.stopTraining=!0)))}async onTrainEnd(e){this.stoppedEpoch>0&&this.verbose&&console.log(`Epoch ${this.stoppedEpoch}: early stopping.`)}getMonitorValue(e){null==e&&(e={});const t=e[this.monitor];return null==t&&console.warn(`Metric for EarlyStopping ${this.monitor} is not available. Available metrics are: ${Object.keys(e)}`),t}};function earlyStopping(e){return new EarlyStopping(e)}var DataType8,SaverDef,callbacks={earlyStopping:earlyStopping},ENV3=env();ENV3.registerFlag("KEEP_INTERMEDIATE_TENSORS",(()=>!1),(e=>{e&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")})),function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF"}(DataType8||(DataType8={})),function(e){let t;var n;(n=t=e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))[n.LEGACY=0]="LEGACY",n[n.V1=1]="V1",n[n.V2=2]="V2"}(SaverDef||(SaverDef={}));var CUSTOM_OPS={};function registerOp(e,t){const n={tfOpName:e,category:"custom",inputs:[],attrs:[],customExecutor:t};CUSTOM_OPS[e]=n}function getRegisteredOp(e){return CUSTOM_OPS[e]}function deregisterOp(e){delete CUSTOM_OPS[e]}function getParamValue(e,t,n,a,r){const s=t.inputParams[e];if(s&&void 0!==s.inputIndexStart){const e=s.inputIndexStart,o=0===s.inputIndexEnd?void 0:void 0===s.inputIndexEnd?e+1:s.inputIndexEnd;if("tensor"===s.type)return getTensor(t.inputNames[s.inputIndexStart],n,a,r);if("tensors"===s.type){return t.inputNames.slice(e,o).map((e=>getTensor(e,n,a,r)))}const i=getTensor(t.inputNames.slice(e)[0],n,a,r),l=i.dataSync();return"number"===s.type?l[0]:util_exports.toNestedArray(i.shape,l)}const o=t.attrParams[e];return o&&o.value}function getTensor(e,t,n,a){const[r,s]=parseNodeName(e);if(null!=a){const e=a.getHashTableHandleByName(r);if(null!=e)return e}const o=n.currentContextIds.find((e=>!!t[getNodeNameWithContextId(r,e)]));return void 0!==o?t[getNodeNameWithContextId(r,o)][s]:void 0}function getTensorsForCurrentContenxt(e,t,n){return t[getNodeNameWithContextId(e,n.currentContextId)]}function getNodeNameAndIndex(e,t){const[n,a,r]=parseNodeName(e);return[getNodeNameWithContextId(n,t&&t.currentContextId),a,r]}function getNodeNameWithContextId(e,t){return t?`${e}-${t}`:e}function parseNodeName(e){const t=e.split(":");if(1===t.length)return[e,0,void 0];const n=t[0],a=3===t.length?t[1]:void 0;return[n,Number(t[t.length-1]),a]}function getPadding(e,t,n){let a=getParamValue("pad",e,t,n);if("explicit"===a){a=getParamValue("explicitPaddings",e,t,n);const r=[[0,0],[0,0],[0,0],[0,0]];for(let e=0;e<4;e++)r[e][0]=a[2*e],r[e][1]=a[2*e+1];return r}return a}function cloneTensor(e){return e.kept?e:clone(e)}var arithmetic_exports={};__export2(arithmetic_exports,{json:()=>json});var json=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],basic_math_exports={};__export2(basic_math_exports,{json:()=>json2});var json2=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],control_exports={};__export2(control_exports,{json:()=>json3});var json3=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]}],convolution_exports={};__export2(convolution_exports,{json:()=>json4});var json4=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number"}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],creation_exports={};__export2(creation_exports,{json:()=>json5});var json5=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],dynamic_exports={};__export2(dynamic_exports,{json:()=>json6});var json6=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],evaluation_exports={};__export2(evaluation_exports,{json:()=>json7});var json7=[{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],graph_exports={};__export2(graph_exports,{json:()=>json8});var json8=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],hash_table_exports={};__export2(hash_table_exports,{json:()=>json9});var json9=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]}],image_exports={};__export2(image_exports,{json:()=>json10});var json10=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]}],logical_exports={};__export2(logical_exports,{json:()=>json11});var json11=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],matrices_exports={};__export2(matrices_exports,{json:()=>json12});var json12=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]}],normalization_exports={};__export2(normalization_exports,{json:()=>json13});var json13=[{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}],reduction_exports={};__export2(reduction_exports,{json:()=>json14});var json14=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],slice_join_exports={};__export2(slice_join_exports,{json:()=>json15});var json15=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}],sparse_exports={};__export2(sparse_exports,{json:()=>json16});var json16=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],spectral_exports={};__export2(spectral_exports,{json:()=>json17});var json17=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],string_exports={};__export2(string_exports,{json:()=>json18});var json18=[{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],transformation_exports={};__export2(transformation_exports,{json:()=>json19});var json19=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],OperationMapper=class{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[].concat(...[arithmetic_exports,basic_math_exports,control_exports,convolution_exports,creation_exports,dynamic_exports,evaluation_exports,graph_exports,hash_table_exports,image_exports,logical_exports,matrices_exports,normalization_exports,reduction_exports,slice_join_exports,sparse_exports,spectral_exports,string_exports,transformation_exports].map((e=>e.json)));this.opMappers=e.reduce(((e,t)=>(e[t.tfOpName]=t,e)),{})}transformGraph(e,t={}){const n=e.node,a=[],r=[],s=[],o=n.reduce(((e,t)=>(e[t.name]=this.mapNode(t),t.op.startsWith("Placeholder")?a.push(e[t.name]):"Const"===t.op?r.push(e[t.name]):null!=t.input&&0!==t.input.length||s.push(e[t.name]),e)),{});let i=[];const l=[];let u={},c={};null!=t&&(u=this.mapSignatureEntries(t.inputs),c=this.mapSignatureEntries(t.outputs));const d=Object.keys(o);d.forEach((e=>{const t=o[e];t.inputNames.forEach(((e,n)=>{const[a,,r]=getNodeNameAndIndex(e),s=o[a];if(null!=s.outputs){const e=s.outputs.indexOf(r);if(-1!==e){const r=`${a}:${e}`;t.inputNames[n]=r}}t.inputs.push(s),s.children.push(t)}))})),0===Object.keys(c).length?d.forEach((e=>{const t=o[e];0===t.children.length&&l.push(t)})):Object.keys(c).forEach((e=>{const[t]=getNodeNameAndIndex(e),n=o[t];null!=n&&(n.signatureKey=c[e],l.push(n))})),Object.keys(u).length>0?Object.keys(u).forEach((e=>{const[t]=getNodeNameAndIndex(e),n=o[t];n&&(n.signatureKey=u[e],i.push(n))})):i=a;let p={};null!=e.library&&null!=e.library.function&&(p=e.library.function.reduce(((e,t)=>(e[t.signature.name]=this.mapFunction(t),e)),{}));const h={nodes:o,inputs:i,outputs:l,weights:r,placeholders:a,signature:t,functions:p};return s.length>0&&(h.initNodes=s),h}mapSignatureEntries(e){return Object.keys(e||{}).reduce(((t,n)=>(t[e[n].name]=n,t)),{})}mapNode(e){const t=getRegisteredOp(e.op)||this.opMappers[e.op]||{};null==e.attr&&(e.attr={});const n={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map((e=>e.startsWith("^")?e.substr(1):e)),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return null!=t.inputs&&(n.inputParams=t.inputs.reduce(((e,t)=>(e[t.name]={type:t.type,inputIndexStart:t.start,inputIndexEnd:t.end},e)),{})),null!=t.attrs&&(n.attrParams=t.attrs.reduce(((t,n)=>{const a=n.type;let r;switch(n.type){case"string":r=getStringParam(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=getStringParam(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"string[]":r=getStringArrayParam(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=getStringArrayParam(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number":r=getNumberParam(e.attr,n.tfName,n.defaultValue||0),void 0===r&&n.tfDeprecatedName&&(r=getNumberParam(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number[]":r=getNumericArrayParam(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=getNumericArrayParam(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool":r=getBoolParam(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=getBoolParam(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool[]":r=getBoolArrayParam(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=getBoolArrayParam(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape":r=getTensorShapeParam(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=getTensorShapeParam(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape[]":r=getTensorShapeArrayParam(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=getTensorShapeArrayParam(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype":r=getDtypeParam(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=getDtypeParam(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype[]":r=getDtypeArrayParam(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=getDtypeArrayParam(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"func":r=getFuncParam(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=getFuncParam(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${n.type} for op: ${e.op}`)}return t[n.name]={value:r,type:a},t}),{})),n}mapFunction(e){const t=e.nodeDef,n=[];let a={};null!=t&&(a=t.reduce(((e,t)=>(e[t.name]=this.mapNode(t),"Const"===t.op&&n.push(e[t.name]),e)),{}));const r=[],s=[];e.signature.inputArg.forEach((e=>{const[t]=getNodeNameAndIndex(e.name),n={name:t,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:parseDtypeParam(e.type),type:"dtype"}},children:[]};n.signatureKey=e.name,r.push(n),a[t]=n}));Object.keys(a).forEach((e=>{const t=a[e];t.inputNames.forEach(((e,n)=>{const[r,,s]=getNodeNameAndIndex(e),o=a[r];if(null!=o.outputs){const e=o.outputs.indexOf(s);if(-1!==e){const a=`${r}:${e}`;t.inputNames[n]=a}}t.inputs.push(o),o.children.push(t)}))}));const o=e.ret;e.signature.outputArg.forEach((e=>{const[t,n]=getNodeNameAndIndex(o[e.name]),r=a[t];null!=r&&(r.defaultOutput=n,s.push(r))}));const i=this.mapArgsToSignature(e);return{nodes:a,inputs:r,outputs:s,weights:n,placeholders:[],signature:i}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce(((e,t)=>(e[t.name]=this.mapArgToTensorInfo(t),e)),{}),outputs:e.signature.outputArg.reduce(((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n,e.ret),t)),{})}}mapArgToTensorInfo(e,t){let n=e.name;return null!=t&&(n=t[n]),{name:n,dtype:e.type}}};function decodeBase64(e){const t=env().global;if(void 0!==t.atob)return t.atob(e);if("undefined"!=typeof Buffer)return new Buffer(e,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function parseStringParam(e,t){const n=Array.isArray(e)?String.fromCharCode.apply(null,e):decodeBase64(e);return t?n:n.toLowerCase()}function getStringParam(e,t,n,a=!1){const r=e[t];return null!=r?parseStringParam(r.s,a):n}function getBoolParam(e,t,n){const a=e[t];return a?a.b:n}function getNumberParam(e,t,n){const a=e[t]||{},r=null!=a.i?a.i:null!=a.f?a.f:n;return"number"==typeof r?r:parseInt(r,10)}function parseDtypeParam(e){switch("string"==typeof e&&(e=DataType8[e]),e){case DataType8.DT_FLOAT:return"float32";case DataType8.DT_INT32:case DataType8.DT_INT64:case DataType8.DT_INT8:case DataType8.DT_UINT8:return"int32";case DataType8.DT_BOOL:return"bool";case DataType8.DT_DOUBLE:return"float32";case DataType8.DT_STRING:return"string";default:return null}}function getFuncParam(e,t,n){const a=e[t];return a&&a.func?a.func.name:n}function getDtypeParam(e,t,n){const a=e[t];return a&&a.type?parseDtypeParam(a.type):n}function getDtypeArrayParam(e,t,n){const a=e[t];return a&&a.list&&a.list.type?a.list.type.map((e=>parseDtypeParam(e))):n}function parseTensorShapeParam(e){if(!e.unknownRank)return null!=e.dim?e.dim.map((e=>"number"==typeof e.size?e.size:parseInt(e.size,10))):[]}function getTensorShapeParam(e,t,n){const a=e[t];return a&&a.shape?parseTensorShapeParam(a.shape):n}function getNumericArrayParam(e,t,n){const a=e[t];return a?((a.list.f&&a.list.f.length?a.list.f:a.list.i)||[]).map((e=>"number"==typeof e?e:parseInt(e,10))):n}function getStringArrayParam(e,t,n,a=!1){const r=e[t];return r&&r.list&&r.list.s?r.list.s.map((e=>parseStringParam(e,a))):n}function getTensorShapeArrayParam(e,t,n){const a=e[t];return a&&a.list&&a.list.shape?a.list.shape.map((e=>parseTensorShapeParam(e))):n}function getBoolArrayParam(e,t,n){const a=e[t];return a&&a.list&&a.list.b?a.list.b:n}var NodeValueImpl=class{constructor(e,t,n){this.node=e,this.tensorMap=t,this.context=n,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map((e=>this.getInput(e))),null!=e.rawAttrs&&(this.attrs=Object.keys(e.rawAttrs).reduce(((e,t)=>(e[t]=this.getAttr(t),e)),{}))}getInput(e){return getTensor(e,this.tensorMap,this.context)}getAttr(e,t){const n=this.node.rawAttrs[e];if(null!=n.tensor)return getTensor(e,this.tensorMap,this.context);if(null!=n.i||null!=n.f)return getNumberParam(this.node.rawAttrs,e,t);if(null!=n.s)return getStringParam(this.node.rawAttrs,e,t);if(null!=n.b)return getBoolParam(this.node.rawAttrs,e,t);if(null!=n.shape)return getTensorShapeParam(this.node.rawAttrs,e,t);if(null!=n.type)return getDtypeParam(this.node.rawAttrs,e,t);if(null!=n.list){if(null!=n.list.i||null!=n.list.f)return getNumericArrayParam(this.node.rawAttrs,e,t);if(null!=n.list.s)return getStringArrayParam(this.node.rawAttrs,e,t);if(null!=n.list.shape)return getTensorShapeArrayParam(this.node.rawAttrs,e,t);if(null!=n.list.b)return getBoolArrayParam(this.node.rawAttrs,e,t);if(null!=n.list.type)return getDtypeArrayParam(this.node.rawAttrs,e,t)}return t}},executeOp=(e,t,n)=>{switch(e.op){case"BiasAdd":case"AddV2":case"Add":return[add2(getParamValue("a",e,t,n),getParamValue("b",e,t,n))];case"AddN":return[addN(getParamValue("tensors",e,t,n))];case"FloorMod":case"Mod":return[mod(getParamValue("a",e,t,n),getParamValue("b",e,t,n))];case"Mul":return[mul(getParamValue("a",e,t,n),getParamValue("b",e,t,n))];case"RealDiv":case"Div":return[div(getParamValue("a",e,t,n),getParamValue("b",e,t,n))];case"DivNoNan":return[divNoNan(getParamValue("a",e,t,n),getParamValue("b",e,t,n))];case"FloorDiv":return[floorDiv(getParamValue("a",e,t,n),getParamValue("b",e,t,n))];case"Sub":return[sub(getParamValue("a",e,t,n),getParamValue("b",e,t,n))];case"Minimum":return[minimum(getParamValue("a",e,t,n),getParamValue("b",e,t,n))];case"Maximum":return[maximum(getParamValue("a",e,t,n),getParamValue("b",e,t,n))];case"Pow":return[pow(getParamValue("a",e,t,n),getParamValue("b",e,t,n))];case"SquaredDifference":return[squaredDifference(getParamValue("a",e,t,n),getParamValue("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},executeOp2=(e,t,n)=>{switch(e.op){case"Abs":case"ComplexAbs":return[abs(getParamValue("x",e,t,n))];case"Acos":return[acos(getParamValue("x",e,t,n))];case"Acosh":return[acosh(getParamValue("x",e,t,n))];case"Asin":return[asin(getParamValue("x",e,t,n))];case"Asinh":return[asinh(getParamValue("x",e,t,n))];case"Atan":return[atan(getParamValue("x",e,t,n))];case"Atan2":return[atan2(getParamValue("x",e,t,n),getParamValue("y",e,t,n))];case"Atanh":return[atanh(getParamValue("x",e,t,n))];case"Ceil":return[ceil(getParamValue("x",e,t,n))];case"Complex":return[complex(getParamValue("real",e,t,n),getParamValue("imag",e,t,n))];case"Cos":return[cos(getParamValue("x",e,t,n))];case"Cosh":return[cosh(getParamValue("x",e,t,n))];case"Elu":return[elu(getParamValue("x",e,t,n))];case"Erf":return[erf(getParamValue("x",e,t,n))];case"Exp":return[exp(getParamValue("x",e,t,n))];case"Expm1":return[expm1(getParamValue("x",e,t,n))];case"Floor":return[floor(getParamValue("x",e,t,n))];case"Log":return[log4(getParamValue("x",e,t,n))];case"Log1p":return[log1p(getParamValue("x",e,t,n))];case"Imag":return[imag(getParamValue("x",e,t,n))];case"Neg":return[neg(getParamValue("x",e,t,n))];case"Reciprocal":return[reciprocal(getParamValue("x",e,t,n))];case"Real":return[real(getParamValue("x",e,t,n))];case"Relu":return[relu(getParamValue("x",e,t,n))];case"Round":return[round2(getParamValue("x",e,t,n))];case"Selu":return[selu(getParamValue("x",e,t,n))];case"Sigmoid":return[sigmoid(getParamValue("x",e,t,n))];case"Sin":return[sin(getParamValue("x",e,t,n))];case"Sign":return[sign(getParamValue("x",e,t,n))];case"Sinh":return[sinh(getParamValue("x",e,t,n))];case"Softplus":return[softplus(getParamValue("x",e,t,n))];case"Sqrt":return[sqrt(getParamValue("x",e,t,n))];case"Square":return[square(getParamValue("x",e,t,n))];case"Tanh":return[tanh2(getParamValue("x",e,t,n))];case"Tan":return[tan(getParamValue("x",e,t,n))];case"ClipByValue":return[clipByValue(getParamValue("x",e,t,n),getParamValue("clipValueMin",e,t,n),getParamValue("clipValueMax",e,t,n))];case"Relu6":return[relu6(getParamValue("x",e,t,n))];case"Rsqrt":return[rsqrt(getTensor(e.inputNames[0],t,n))];case"Prod":return[prod(getParamValue("x",e,t,n),getParamValue("axes",e,t,n))];case"LeakyRelu":return[leakyRelu(getParamValue("x",e,t,n),getParamValue("alpha",e,t,n))];case"Prelu":return[prelu(getParamValue("x",e,t,n),getParamValue("alpha",e,t,n))];case"IsNan":return[isNaN2(getTensor(e.inputNames[0],t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};function assertShapesMatchAllowUndefinedSize(e,t,n=""){if("number"!=typeof e&&"number"!=typeof t){util_exports.assert(e.length===t.length,(()=>n+` Shapes ${e} and ${t} must match`));for(let a=0;a<e.length;a++){const r=e[a],s=t[a];util_exports.assert(r<0||s<0||r===s,(()=>n+` Shapes ${e} and ${t} must match`))}}}function fullDefinedShape(e){return"number"!=typeof e&&!e.some((e=>e<0))}function inferElementShape(e,t,n){let a=mergeElementShape(e,n);const r=!fullDefinedShape(a);if(r&&0===t.length)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${a}`);if(r&&t.forEach((e=>{a=mergeElementShape(e.shape,a)})),!fullDefinedShape(a))throw new Error(`Non-fully-defined elementShape: ${a}`);return a}function mergeElementShape(e,t){if("number"==typeof e)return t;if("number"==typeof t)return e;if(e.length!==t.length)throw new Error(`Incompatible ranks during merge: ${e} vs. ${t}`);const n=[];for(let a=0;a<e.length;++a){const r=e[a],s=t[a];if(r>=0&&s>=0&&r!==s)throw new Error(`Incompatible shape during merge: ${e} vs. ${t}`);n[a]=r>=0?r:s}return n}var TensorArray=class{constructor(e,t,n,a,r,s,o){this.name=e,this.dtype=t,this.maxSize=n,this.elementShape=a,this.identicalElementShapes=r,this.dynamicSize=s,this.clearAfterRead=o,this.tensors=[],this.closed_=!1,this.idTensor=scalar(0),keep(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach((t=>{null!=e&&e.has(t.tensor.id)||t.tensor.dispose()})),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map((e=>this.read(e)))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const n=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},\n          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(0!==this.size()||null!=this.elementShape&&0!==this.elementShape.length||(this.elementShape=t.shape),assertShapesMatchAllowUndefinedSize(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),n.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(n.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);n.tensor=t,keep(t),n.written=!0,this.tensors[e]=n}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach(((e,n)=>this.write(e,t[n])))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let t=0;t<this.size();t++)e.push(t)}if(0===e.length)return tensor([],[0].concat(this.elementShape));const n=this.readMany(e);return assertShapesMatchAllowUndefinedSize(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),stack(n,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(0===this.size())return tensor([],[0].concat(this.elementShape));const t=[];for(let e=0;e<this.size();e++)t.push(e);const n=this.readMany(t);return assertShapesMatchAllowUndefinedSize(this.elementShape,n[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n[0].shape})`),concat(n,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const n=Math.max(...e);if(!this.dynamicSize&&n>=this.maxSize)throw new Error(`Max index must be < array size (${n}  vs. ${this.maxSize})`);this.writeMany(e,unstack(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let n=0;const a=e.map((e=>(n+=e,n)));if(n!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${n}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const r=0===n?0:t.size/n,s=[];tidy((()=>{t=reshape(t,[1,n,r]);for(let n=0;n<e.length;++n){const o=[0,0===n?0:a[n-1],0],i=[1,e[n],r];s[n]=reshape(slice(t,o,i),this.elementShape)}return s}));const o=[];for(let t=0;t<e.length;t++)o[t]=t;this.writeMany(o,s)}},TensorList=class{constructor(e,t,n,a=-1){this.tensors=e,this.elementShape=t,this.elementDtype=n,null!=e&&e.forEach((e=>{if(n!==e.dtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${e.dtype}`);assertShapesMatchAllowUndefinedSize(t,e.shape,"TensorList shape mismatch: "),keep(e)})),this.idTensor=scalar(0),this.maxNumElements=a,keep(this.idTensor)}get id(){return this.idTensor.id}copy(){return new TensorList([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach((t=>{null!=e&&e.has(t.id)||t.dispose()})),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,n=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(-1!==n&&this.tensors.length!==n)throw new Error(`Operation expected a list with ${n} elements but got a list with ${this.tensors.length} elements.`);assertShapesMatchAllowUndefinedSize(e,this.elementShape,"TensorList shape mismatch: ");const a=inferElementShape(this.elementShape,this.tensors,e);return tidy((()=>{const e=this.tensors.map((e=>reshape(e,a)));return stack(e,0)}))}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(0===this.size())throw new Error("Trying to pop from an empty list.");const n=inferElementShape(this.elementShape,this.tensors,e),a=this.tensors.pop();return assertShapesMatchAllowUndefinedSize(a.shape,e,"TensorList shape mismatch: "),reshape(a,n)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(assertShapesMatchAllowUndefinedSize(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");keep(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(-1!==this.maxNumElements&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);this.tensors.length=e}getItem(e,t,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(null==this.tensors[e])throw new Error(`element at index ${e} is null.`);assertShapesMatchAllowUndefinedSize(this.tensors[e].shape,t,"TensorList shape mismatch: ");const a=inferElementShape(this.elementShape,this.tensors,t);return reshape(this.tensors[e],a)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||-1!==this.maxNumElements&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);assertShapesMatchAllowUndefinedSize(this.elementShape,t.shape,"TensorList shape mismatch: "),keep(t),this.tensors[e]=t}gather(e,t,n){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);assertShapesMatchAllowUndefinedSize(this.elementShape,n,"TensorList shape mismatch: "),e=e.slice(0,this.size());const a=inferElementShape(this.elementShape,this.tensors,n);return 0===e.length?tensor([],[0].concat(a)):tidy((()=>{const t=e.map((e=>reshape(this.tensors[e],a)));return stack(t,0)}))}concat(e,t){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);assertShapesMatchAllowUndefinedSize(this.elementShape,t,"TensorList shape mismatch: ");const n=inferElementShape(this.elementShape,this.tensors,t);return 0===this.size()?tensor([],[0].concat(n)):tidy((()=>{const e=this.tensors.map((e=>reshape(e,n)));return concat(e,0)}))}};function fromTensor(e,t,n){const a=e.dtype;if(e.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${e.shape}`);if(e.dtype!==n)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${n}`);assertShapesMatchAllowUndefinedSize(e.shape.slice(1),t,"TensorList shape mismatch: ");const r=unstack(e);return new TensorList(r,t,a)}function reserve(e,t,n){return new TensorList([],e,t,n)}function scatter(e,t,n,a){if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);const r=Math.max(...t);if(null!=a&&-1!==a&&r>=a)throw new Error(`Max index must be < array size (${r}  vs. ${a})`);const s=new TensorList([],n,e.dtype,a),o=unstack(e,0);return t.forEach(((e,t)=>{s.setItem(e,o[t])})),s}function split2(e,t,n){let a=0;const r=t.map((e=>(a+=e,a)));if(a!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${a}, and tensor's shape is: ${e.shape}`);const s=mergeElementShape(e.shape.slice(1),n),o=0===a?0:e.size/a,i=tidy((()=>{const n=[];e=reshape(e,[1,a,o]);for(let a=0;a<t.length;++a){const i=[0,0===a?0:r[a-1],0],l=[1,t[a],o];n[a]=reshape(slice(e,i,l),s)}return e.dispose(),n})),l=new TensorList([],n,e.dtype,t.length);for(let e=0;e<i.length;e++)l.setItem(e,i[e]);return l}var executeOp3=async(e,t,n)=>{switch(e.op){case"If":case"StatelessIf":{const a=getParamValue("thenBranch",e,t,n),r=getParamValue("elseBranch",e,t,n),s=getParamValue("cond",e,t,n),o=getParamValue("args",e,t,n);return(await s.data())[0]?n.functionMap[a].executeFunctionAsync(o,n.tensorArrayMap,n.tensorListMap):n.functionMap[r].executeFunctionAsync(o,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{const a=getParamValue("body",e,t,n),r=getParamValue("cond",e,t,n),s=getParamValue("args",e,t,n),o=await n.functionMap[r].executeFunctionAsync(s,n.tensorArrayMap,n.tensorListMap),i=s.map((e=>e.id));let l=await o[0].data();o.forEach((e=>{e.kept||-1!==i.indexOf(e.id)||e.dispose()}));let u=s;for(;l[0];){const e=u;u=await n.functionMap[a].executeFunctionAsync(u,n.tensorArrayMap,n.tensorListMap);const t=u.map((e=>e.id));e.forEach((e=>{e.kept||-1!==i.indexOf(e.id)||-1!==t.indexOf(e.id)||e.dispose()}));const s=await n.functionMap[r].executeFunctionAsync(u,n.tensorArrayMap,n.tensorListMap);l=await s[0].data(),s.forEach((e=>{e.kept||-1!==i.indexOf(e.id)||-1!==t.indexOf(e.id)||e.dispose()}))}return u}case"LoopCond":return[cloneTensor(getParamValue("pred",e,t,n))];case"Switch":{const a=getParamValue("pred",e,t,n);let r=getParamValue("data",e,t,n);return r.kept||(r=cloneTensor(r)),(await a.data())[0]?[void 0,r]:[r,void 0]}case"Merge":{const a=e.inputNames.find((e=>void 0!==getTensor(e,t,n)));if(a){return[cloneTensor(getTensor(a,t,n))]}return}case"Enter":{const a=getParamValue("frameName",e,t,n),r=getParamValue("tensor",e,t,n);return n.enterFrame(a),[cloneTensor(r)]}case"Exit":{const a=getParamValue("tensor",e,t,n);return n.exitFrame(),[cloneTensor(a)]}case"NextIteration":{const a=getParamValue("tensor",e,t,n);return n.nextIteration(),[cloneTensor(a)]}case"TensorArrayV3":{const a=getParamValue("size",e,t,n),r=getParamValue("dtype",e,t,n),s=getParamValue("elementShape",e,t,n),o=getParamValue("dynamicSize",e,t,n),i=getParamValue("clearAfterRead",e,t,n),l=getParamValue("identicalElementShapes",e,t,n),u=getParamValue("name",e,t,n),c=new TensorArray(u,r,a,s,l,o,i);return n.addTensorArray(c),[c.idTensor,scalar(1)]}case"TensorArrayWriteV3":{const a=getParamValue("tensorArrayId",e,t,n),r=getParamValue("index",e,t,n),s=getParamValue("tensor",e,t,n),o=n.getTensorArray(a.id);return o.write(r,s),[o.idTensor]}case"TensorArrayReadV3":{const a=getParamValue("tensorArrayId",e,t,n),r=getParamValue("index",e,t,n);return[n.getTensorArray(a.id).read(r)]}case"TensorArrayGatherV3":{const a=getParamValue("tensorArrayId",e,t,n),r=getParamValue("indices",e,t,n),s=getParamValue("dtype",e,t,n);return[n.getTensorArray(a.id).gather(r,s)]}case"TensorArrayScatterV3":{const a=getParamValue("tensorArrayId",e,t,n),r=getParamValue("indices",e,t,n),s=getParamValue("tensor",e,t,n),o=n.getTensorArray(a.id);return o.scatter(r,s),[o.idTensor]}case"TensorArrayConcatV3":{const a=getParamValue("tensorArrayId",e,t,n),r=n.getTensorArray(a.id),s=getParamValue("dtype",e,t,n);return[r.concat(s)]}case"TensorArraySplitV3":{const a=getParamValue("tensorArrayId",e,t,n),r=getParamValue("tensor",e,t,n),s=getParamValue("lengths",e,t,n),o=n.getTensorArray(a.id);return o.split(s,r),[o.idTensor]}case"TensorArraySizeV3":{const a=getParamValue("tensorArrayId",e,t,n);return[scalar(n.getTensorArray(a.id).size(),"int32")]}case"TensorArrayCloseV3":{const a=getParamValue("tensorArrayId",e,t,n),r=n.getTensorArray(a.id);return r.clearAndClose(),[r.idTensor]}case"TensorListSetItem":{const a=getParamValue("tensorListId",e,t,n),r=getParamValue("index",e,t,n),s=getParamValue("tensor",e,t,n),o=n.getTensorList(a.id);return o.setItem(r,s),[o.idTensor]}case"TensorListGetItem":{const a=getParamValue("tensorListId",e,t,n),r=getParamValue("index",e,t,n),s=getParamValue("elementShape",e,t,n),o=getParamValue("elementDType",e,t,n);return[n.getTensorList(a.id).getItem(r,s,o)]}case"TensorListScatterV2":case"TensorListScatter":{const a=getParamValue("indices",e,t,n),r=scatter(getParamValue("tensor",e,t,n),a,getParamValue("elementShape",e,t,n),getParamValue("numElements",e,t,n));return n.addTensorList(r),[r.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const a=getParamValue("elementShape",e,t,n),r=getParamValue("elementDType",e,t,n);let s;s="TensorListReserve"===e.op?"numElements":"maxNumElements";const o=reserve(a,r,getParamValue(s,e,t,n));return n.addTensorList(o),[o.idTensor]}case"TensorListGather":{const a=getParamValue("tensorListId",e,t,n),r=getParamValue("indices",e,t,n),s=getParamValue("elementShape",e,t,n),o=getParamValue("elementDType",e,t,n);return[n.getTensorList(a.id).gather(r,o,s)]}case"TensorListStack":{const a=getParamValue("tensorListId",e,t,n),r=getParamValue("elementShape",e,t,n),s=getParamValue("elementDType",e,t,n),o=getParamValue("numElements",e,t,n);return[n.getTensorList(a.id).stack(r,s,o)]}case"TensorListFromTensor":{const a=fromTensor(getParamValue("tensor",e,t,n),getParamValue("elementShape",e,t,n),getParamValue("elementDType",e,t,n));return n.addTensorList(a),[a.idTensor]}case"TensorListConcat":{const a=getParamValue("tensorListId",e,t,n),r=n.getTensorList(a.id),s=getParamValue("dtype",e,t,n),o=getParamValue("elementShape",e,t,n);return[r.concat(s,o)]}case"TensorListPushBack":{const a=getParamValue("tensorListId",e,t,n),r=getParamValue("tensor",e,t,n),s=n.getTensorList(a.id);return s.pushBack(r),[s.idTensor]}case"TensorListPopBack":{const a=getParamValue("tensorListId",e,t,n),r=getParamValue("elementShape",e,t,n),s=getParamValue("elementDType",e,t,n);return[n.getTensorList(a.id).popBack(r,s)]}case"TensorListSplit":{const a=getParamValue("tensor",e,t,n),r=getParamValue("elementShape",e,t,n),s=split2(a,getParamValue("lengths",e,t,n),r);return n.addTensorList(s),[s.idTensor]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};function fusedConvAndDepthWiseParams(e,t,n){const[a,r]=getParamValue("fusedOps",e,t,n),s="biasadd"===a,o=!s,i="prelu"===r,l="fusedbatchnorm"===a,u=getParamValue("numArgs",e,t,n);if(s){if(i&&2!==u)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!i&&s&&1!==u)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const c=getParamValue("strides",e,t,n),d=getPadding(e,t,n),p=getParamValue("dataFormat",e,t,n).toUpperCase(),h=getParamValue("dilations",e,t,n);let[m,f]=getParamValue("args",e,t,n);o&&(f=m,m=void 0);return{stride:c,pad:d,dataFormat:p,dilations:h,biasArg:m,preluArg:f,activationFunc:r,leakyreluAlpha:getParamValue("leakyreluAlpha",e,t,n)}}var executeOp4=(e,t,n)=>{switch(e.op){case"Conv1D":{const a=getParamValue("stride",e,t,n),r=getParamValue("pad",e,t,n),s=getParamValue("dataFormat",e,t,n).toUpperCase(),o=getParamValue("dilation",e,t,n);return[conv1d(getParamValue("x",e,t,n),getParamValue("filter",e,t,n),a,r,s,o)]}case"Conv2D":{const a=getParamValue("strides",e,t,n),r=getPadding(e,t,n),s=getParamValue("dataFormat",e,t,n).toUpperCase(),o=getParamValue("dilations",e,t,n);return[conv2d(getParamValue("x",e,t,n),getParamValue("filter",e,t,n),[a[1],a[2]],r,s,[o[1],o[2]])]}case"_FusedConv2D":{const{stride:a,pad:r,dataFormat:s,dilations:o,biasArg:i,preluArg:l,activationFunc:u,leakyreluAlpha:c}=fusedConvAndDepthWiseParams(e,t,n);return[fused_ops_exports.conv2d({x:getParamValue("x",e,t,n),filter:getParamValue("filter",e,t,n),strides:[a[1],a[2]],pad:r,dataFormat:s,dilations:[o[1],o[2]],bias:i,activation:u,preluActivationWeights:l,leakyreluAlpha:c})]}case"FusedDepthwiseConv2dNative":{const{stride:a,pad:r,dataFormat:s,dilations:o,biasArg:i,preluArg:l,activationFunc:u,leakyreluAlpha:c}=fusedConvAndDepthWiseParams(e,t,n);return[fused_ops_exports.depthwiseConv2d({x:getParamValue("x",e,t,n),filter:getParamValue("filter",e,t,n),strides:[a[1],a[2]],pad:r,dataFormat:s,dilations:[o[1],o[2]],bias:i,activation:u,preluActivationWeights:l,leakyreluAlpha:c})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const a=getParamValue("outputShape",e,t,n),r=getParamValue("strides",e,t,n),s=getPadding(e,t,n);return[conv2dTranspose(getParamValue("x",e,t,n),getParamValue("filter",e,t,n),a,[r[1],r[2]],s)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const a=getParamValue("strides",e,t,n),r=getPadding(e,t,n),s=getParamValue("dilations",e,t,n),o=getParamValue("dataFormat",e,t,n).toUpperCase();return[depthwiseConv2d(getParamValue("input",e,t,n),getParamValue("filter",e,t,n),[a[1],a[2]],r,o,[s[1],s[2]])]}case"Conv3D":{const a=getParamValue("strides",e,t,n),r=getParamValue("pad",e,t,n),s=getParamValue("dataFormat",e,t,n).toUpperCase(),o=getParamValue("dilations",e,t,n);return[conv3d(getParamValue("x",e,t,n),getParamValue("filter",e,t,n),[a[1],a[2],a[3]],r,s,[o[1],o[2],o[3]])]}case"AvgPool":{const a=getParamValue("strides",e,t,n),r=getParamValue("pad",e,t,n),s=getParamValue("kernelSize",e,t,n);return[avgPool(getParamValue("x",e,t,n),[s[1],s[2]],[a[1],a[2]],r)]}case"MaxPool":{const a=getParamValue("strides",e,t,n),r=getParamValue("pad",e,t,n),s=getParamValue("kernelSize",e,t,n);return[maxPool(getParamValue("x",e,t,n),[s[1],s[2]],[a[1],a[2]],r)]}case"MaxPoolWithArgmax":{const a=getParamValue("strides",e,t,n),r=getParamValue("pad",e,t,n),s=getParamValue("kernelSize",e,t,n),o=getParamValue("includeBatchInIndex",e,t,n),{result:i,indexes:l}=maxPoolWithArgmax(getParamValue("x",e,t,n),[s[1],s[2]],[a[1],a[2]],r,o);return[i,l]}case"AvgPool3D":{const a=getParamValue("strides",e,t,n),r=getParamValue("pad",e,t,n),s=getParamValue("kernelSize",e,t,n);return[avgPool3d(getParamValue("x",e,t,n),[s[1],s[2],s[3]],[a[1],a[2],a[3]],r)]}case"MaxPool3D":{const a=getParamValue("strides",e,t,n),r=getParamValue("pad",e,t,n),s=getParamValue("kernelSize",e,t,n);return[maxPool3d(getParamValue("x",e,t,n),[s[1],s[2],s[3]],[a[1],a[2],a[3]],r)]}case"Dilation2D":{const a=getParamValue("strides",e,t,n),r=getParamValue("pad",e,t,n),s=getParamValue("dilations",e,t,n),o=a[1],i=a[2],l=s[1],u=s[2];return[dilation2d(getParamValue("x",e,t,n),getParamValue("filter",e,t,n),[o,i],r,[l,u],"NHWC")]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},executeOp5=(e,t,n)=>{switch(e.op){case"Fill":{const a=getParamValue("shape",e,t,n),r=getParamValue("dtype",e,t,n);return[fill(a,getParamValue("value",e,t,n),r)]}case"LinSpace":return[linspace(getParamValue("start",e,t,n),getParamValue("stop",e,t,n),getParamValue("num",e,t,n))];case"Multinomial":{const a=getParamValue("logits",e,t,n),r=getParamValue("numSamples",e,t,n),s=getParamValue("seed",e,t,n);return[multinomial(a,r,s)]}case"OneHot":{const a=getParamValue("indices",e,t,n),r=getParamValue("depth",e,t,n),s=getParamValue("onValue",e,t,n),o=getParamValue("offValue",e,t,n);return[oneHot(a,r,s,o)]}case"Ones":return[ones2(getParamValue("shape",e,t,n),getParamValue("dtype",e,t,n))];case"OnesLike":return[onesLike(getParamValue("x",e,t,n))];case"RandomUniform":return[randomUniform(getParamValue("shape",e,t,n),getParamValue("minval",e,t,n),getParamValue("maxval",e,t,n),getParamValue("dtype",e,t,n))];case"Range":return[range(getParamValue("start",e,t,n),getParamValue("stop",e,t,n),getParamValue("step",e,t,n),getParamValue("dtype",e,t,n))];case"TruncatedNormal":{const a=getParamValue("shape",e,t,n),r=getParamValue("mean",e,t,n),s=getParamValue("stdDev",e,t,n),o=getParamValue("seed",e,t,n);return[truncatedNormal(a,r,s,getParamValue("dtype",e,t,n),o)]}case"Zeros":return[zeros(getParamValue("shape",e,t,n),getParamValue("dtype",e,t,n))];case"ZerosLike":return[zerosLike(getParamValue("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};function nmsParams(e,t,n){return{boxes:getParamValue("boxes",e,t,n),scores:getParamValue("scores",e,t,n),maxOutputSize:getParamValue("maxOutputSize",e,t,n),iouThreshold:getParamValue("iouThreshold",e,t,n),scoreThreshold:getParamValue("scoreThreshold",e,t,n),softNmsSigma:getParamValue("softNmsSigma",e,t,n)}}var executeOp6=async(e,t,n)=>{switch(e.op){case"NonMaxSuppressionV5":{const{boxes:a,scores:r,maxOutputSize:s,iouThreshold:o,scoreThreshold:i,softNmsSigma:l}=nmsParams(e,t,n),u=await image.nonMaxSuppressionWithScoreAsync(a,r,s,o,i,l);return[u.selectedIndices,u.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:a,scores:r,maxOutputSize:s,iouThreshold:o,scoreThreshold:i}=nmsParams(e,t,n),l=getParamValue("padToMaxOutputSize",e,t,n),u=await image.nonMaxSuppressionPaddedAsync(a,r,s,o,i,l);return[u.selectedIndices,u.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:a,scores:r,maxOutputSize:s,iouThreshold:o,scoreThreshold:i}=nmsParams(e,t,n);return[await image.nonMaxSuppressionAsync(a,r,s,o,i)]}case"Where":{const a=cast(getParamValue("condition",e,t,n),"bool"),r=[await whereAsync(a)];return a.dispose(),r}case"ListDiff":return setdiff1dAsync(getParamValue("x",e,t,n),getParamValue("y",e,t,n));default:throw TypeError(`Node type ${e.op} is not implemented`)}},executeOp7=(e,t,n)=>{switch(e.op){case"TopKV2":{const a=getParamValue("x",e,t,n),r=getParamValue("k",e,t,n),s=getParamValue("sorted",e,t,n),o=topk(a,r,s);return[o.values,o.indices]}case"Unique":{const a=getParamValue("x",e,t,n),r=unique(a);return[r.values,r.indices]}case"UniqueV2":{const a=getParamValue("x",e,t,n),r=getParamValue("axis",e,t,n),s=unique(a,r);return[s.values,s.indices]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},executeOp8=(e,t,n)=>{switch(e.op){case"Const":return t[e.name];case"PlaceholderWithDefault":const a=getParamValue("default",e,t,n);return[getTensor(e.name,t,n)||a];case"Placeholder":return[getTensor(e.name,t,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":return[cloneTensor(getParamValue("x",e,t,n))];case"IdentityN":return getParamValue("x",e,t,n).map((e=>cloneTensor(e)));case"Snapshot":return[cloneTensor(getParamValue("x",e,t,n))];case"Shape":return[tensor1d(getParamValue("x",e,t,n).shape,"int32")];case"ShapeN":return getParamValue("x",e,t,n).map((e=>tensor1d(e.shape)));case"Size":return[scalar(getParamValue("x",e,t,n).size,"int32")];case"Rank":return[scalar(getParamValue("x",e,t,n).rank,"int32")];case"NoOp":return[scalar(1)];case"Print":const r=getParamValue("x",e,t,n),s=getParamValue("data",e,t,n),o=getParamValue("message",e,t,n),i=getParamValue("summarize",e,t,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(o);for(let e=0;e<s.length;e++)console.log(Array.prototype.slice.call(s[e].dataSync()).slice(0,i));return[r];default:throw TypeError(`Node type ${e.op} is not implemented`)}},HashTable=class{constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=scalar(0),this.tensorMap=new Map,keep(this.handle)}get id(){return this.handle.id}clearAndClose(){this.tensorMap.forEach((e=>e.dispose())),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return scalar(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);const n=await e.data();return this.tensorMap.forEach((e=>e.dispose())),this.tensorMap.clear(),tidy((()=>{const e=unstack(t),a=n.length,r=e.length;util_exports.assert(a===r,(()=>`The number of elements doesn't match, keys has ${a} elements, the values has ${r} elements.`));for(let t=0;t<a;t++){const a=n[t],r=e[t];keep(r),this.tensorMap.set(a,r)}return this.handle}))}async find(e,t){this.checkKeyAndValueTensor(e,t);const n=await e.data();return tidy((()=>{const e=[];for(let a=0;a<n.length;a++){const r=n[a],s=this.findWithDefault(r,t);e.push(s)}return stack(e)}))}findWithDefault(e,t){const n=this.tensorMap.get(e);return null!=n?n:t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}},executeOp9=async(e,t,n,a)=>{switch(e.op){case"HashTable":case"HashTableV2":{const r=getParamValue("keyDType",e,t,n),s=getParamValue("valueDType",e,t,n),o=new HashTable(r,s);return a.addHashTable(e.name,o),[o.handle]}case"LookupTableImport":case"LookupTableImportV2":{const r=getParamValue("tableHandle",e,t,n,a),s=getParamValue("keys",e,t,n),o=getParamValue("values",e,t,n),i=a.getHashTableById(r.id);return[await i.import(s,o)]}case"LookupTableFind":case"LookupTableFindV2":{const r=getParamValue("tableHandle",e,t,n,a),s=getParamValue("keys",e,t,n),o=getParamValue("defaultValue",e,t,n),i=a.getHashTableById(r.id);return[await i.find(s,o)]}case"LookupTableSize":case"LookupTableSizeV2":{const r=getParamValue("tableHandle",e,t,n,a);return[a.getHashTableById(r.id).tensorSize()]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},executeOp10=(e,t,n)=>{switch(e.op){case"ResizeBilinear":{const a=getParamValue("images",e,t,n),r=getParamValue("size",e,t,n),s=getParamValue("alignCorners",e,t,n),o=getParamValue("halfPixelCenters",e,t,n);return[image.resizeBilinear(a,[r[0],r[1]],s,o)]}case"ResizeNearestNeighbor":{const a=getParamValue("images",e,t,n),r=getParamValue("size",e,t,n),s=getParamValue("alignCorners",e,t,n),o=getParamValue("halfPixelCenters",e,t,n);return[image.resizeNearestNeighbor(a,[r[0],r[1]],s,o)]}case"CropAndResize":{const a=getParamValue("image",e,t,n),r=getParamValue("boxes",e,t,n),s=getParamValue("boxInd",e,t,n),o=getParamValue("cropSize",e,t,n),i=getParamValue("method",e,t,n),l=getParamValue("extrapolationValue",e,t,n);return[image.cropAndResize(a,r,s,o,i,l)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},executeOp11=(e,t,n)=>{switch(e.op){case"Equal":return[equal(getParamValue("a",e,t,n),getParamValue("b",e,t,n))];case"NotEqual":return[notEqual(getParamValue("a",e,t,n),getParamValue("b",e,t,n))];case"Greater":return[greater(getParamValue("a",e,t,n),getParamValue("b",e,t,n))];case"GreaterEqual":return[greaterEqual(getParamValue("a",e,t,n),getParamValue("b",e,t,n))];case"Less":return[less(getParamValue("a",e,t,n),getParamValue("b",e,t,n))];case"LessEqual":return[lessEqual(getParamValue("a",e,t,n),getParamValue("b",e,t,n))];case"LogicalAnd":return[logicalAnd(getParamValue("a",e,t,n),getParamValue("b",e,t,n))];case"LogicalNot":return[logicalNot(getParamValue("a",e,t,n))];case"LogicalOr":return[logicalOr(getParamValue("a",e,t,n),getParamValue("b",e,t,n))];case"Select":case"SelectV2":return[where(getParamValue("condition",e,t,n),getParamValue("a",e,t,n),getParamValue("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},executeOp12=(e,t,n)=>{switch(e.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[matMul(getParamValue("a",e,t,n),getParamValue("b",e,t,n),getParamValue("transposeA",e,t,n),getParamValue("transposeB",e,t,n))];case"Einsum":return[einsum(getParamValue("equation",e,t,n),...getParamValue("tensors",e,t,n))];case"Transpose":return[transpose(getParamValue("x",e,t,n),getParamValue("perm",e,t,n))];case"_FusedMatMul":const[a,r]=getParamValue("fusedOps",e,t,n),s="biasadd"===a,o="prelu"===r,i=getParamValue("numArgs",e,t,n),l=getParamValue("leakyreluAlpha",e,t,n);if(s){if(o&&2!==i)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&1!==i)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[u,c]=getParamValue("args",e,t,n);return[fused_ops_exports.matMul({a:getParamValue("a",e,t,n),b:getParamValue("b",e,t,n),transposeA:getParamValue("transposeA",e,t,n),transposeB:getParamValue("transposeB",e,t,n),bias:u,activation:r,preluActivationWeights:c,leakyreluAlpha:l})];default:throw TypeError(`Node type ${e.op} is not implemented`)}},executeOp13=(e,t,n)=>{switch(e.op){case"FusedBatchNorm":case"FusedBatchNormV2":case"FusedBatchNormV3":return[batchNorm(getParamValue("x",e,t,n),getParamValue("mean",e,t,n),getParamValue("variance",e,t,n),getParamValue("offset",e,t,n),getParamValue("scale",e,t,n),getParamValue("epsilon",e,t,n))];case"LRN":return[localResponseNormalization(getParamValue("x",e,t,n),getParamValue("radius",e,t,n),getParamValue("bias",e,t,n),getParamValue("alpha",e,t,n),getParamValue("beta",e,t,n))];case"Softmax":return[softmax(getParamValue("x",e,t,n))];case"LogSoftmax":return[logSoftmax(getParamValue("x",e,t,n))];case"SparseToDense":return[sparseToDense(getParamValue("sparseIndices",e,t,n),getParamValue("outputShape",e,t,n),getParamValue("sparseValues",e,t,n),getParamValue("defaultValue",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},executeOp14=(e,t,n)=>{switch(e.op){case"Max":{const a=getParamValue("axis",e,t,n),r=getParamValue("keepDims",e,t,n);return[max(getParamValue("x",e,t,n),a,r)]}case"Mean":{const a=getParamValue("axis",e,t,n),r=getParamValue("keepDims",e,t,n);return[mean(getParamValue("x",e,t,n),a,r)]}case"Min":{const a=getParamValue("axis",e,t,n),r=getParamValue("keepDims",e,t,n);return[min(getParamValue("x",e,t,n),a,r)]}case"Sum":{const a=getParamValue("axis",e,t,n),r=getParamValue("keepDims",e,t,n);return[sum2(getParamValue("x",e,t,n),a,r)]}case"All":{const a=getParamValue("axis",e,t,n),r=getParamValue("keepDims",e,t,n);return[all(getParamValue("x",e,t,n),a,r)]}case"Any":{const a=getParamValue("axis",e,t,n),r=getParamValue("keepDims",e,t,n);return[any(getParamValue("x",e,t,n),a,r)]}case"ArgMax":{const a=getParamValue("axis",e,t,n);return[argMax(getParamValue("x",e,t,n),a)]}case"ArgMin":{const a=getParamValue("axis",e,t,n);return[argMin(getParamValue("x",e,t,n),a)]}case"Prod":{const a=getParamValue("axis",e,t,n),r=getParamValue("keepDims",e,t,n);return[prod(getParamValue("x",e,t,n),a,r)]}case"Cumsum":{const a=getParamValue("axis",e,t,n),r=getParamValue("exclusive",e,t,n),s=getParamValue("reverse",e,t,n);return[cumsum(getParamValue("x",e,t,n),a,r,s)]}case"Bincount":const a=getParamValue("x",e,t,n),r=getParamValue("weights",e,t,n),s=getParamValue("size",e,t,n);return[bincount(a,r,s)];case"DenseBincount":{const a=getParamValue("x",e,t,n),r=getParamValue("weights",e,t,n),s=getParamValue("size",e,t,n),o=getParamValue("binaryOutput",e,t,n);return[denseBincount(a,r,s,o)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},executeOp15=(e,t,n)=>{switch(e.op){case"ConcatV2":case"Concat":{const a=getParamValue("n",e,t,n),r=getParamValue("axis",e,t,n);let s=getParamValue("tensors",e,t,n);return s=s.slice(0,a),[concat(s,r)]}case"Gather":{const a=getParamValue("x",e,t,n),r=getParamValue("indices",e,t,n);return[gather(a,cast(r,"int32"),0)]}case"GatherV2":{const a=getParamValue("axis",e,t,n),r=getParamValue("batchDims",e,t,n),s=getParamValue("x",e,t,n),o=getParamValue("indices",e,t,n);return[gather(s,cast(o,"int32"),a,r)]}case"Reverse":{const a=getParamValue("dims",e,t,n),r=[];for(let e=0;e<a.length;e++)a[e]&&r.push(e);const s=getParamValue("x",e,t,n);return[reverse(s,r)]}case"ReverseV2":{const a=getParamValue("axis",e,t,n),r=getParamValue("x",e,t,n);return[reverse(r,a)]}case"Slice":{const a=getParamValue("begin",e,t,n),r=getParamValue("size",e,t,n);return[slice(getParamValue("x",e,t,n),a,r)]}case"StridedSlice":{const a=getParamValue("begin",e,t,n),r=getParamValue("end",e,t,n),s=getParamValue("strides",e,t,n),o=getParamValue("beginMask",e,t,n),i=getParamValue("endMask",e,t,n),l=getParamValue("ellipsisMask",e,t,n),u=getParamValue("newAxisMask",e,t,n),c=getParamValue("shrinkAxisMask",e,t,n),d=getParamValue("x",e,t,n);return[stridedSlice(d,a,r,s,o,i,l,u,c)]}case"Pack":return tidy((()=>{const a=getParamValue("axis",e,t,n),r=getParamValue("tensors",e,t,n),s=r[0].shape,o=squeeze(r[0]).shape,i=r.map((e=>{const t=util_exports.arraysEqual(e.shape,s);if(!t&&!util_exports.arraysEqual(squeeze(e).shape,o))throw new Error("the input tensors shape does not match");return t?e:reshape(e,s)}));return[stack(i,a)]}));case"Unpack":{const a=getParamValue("axis",e,t,n),r=getParamValue("tensor",e,t,n);return unstack(r,a)}case"Tile":{const a=getParamValue("reps",e,t,n);return[tile(getParamValue("x",e,t,n),a)]}case"Split":case"SplitV":{const a=getParamValue("axis",e,t,n),r=getParamValue("numOrSizeSplits",e,t,n),s=getParamValue("x",e,t,n);return split(s,r,a)}case"ScatterNd":{const a=getParamValue("indices",e,t,n),r=getParamValue("values",e,t,n),s=getParamValue("shape",e,t,n);return[scatterND(a,r,s)]}case"GatherNd":{const a=getParamValue("x",e,t,n),r=getParamValue("indices",e,t,n);return[gatherND(a,r)]}case"SparseToDense":{const a=getParamValue("sparseIndices",e,t,n),r=getParamValue("outputShape",e,t,n),s=getParamValue("sparseValues",e,t,n),o=getParamValue("defaultValue",e,t,n);return[sparseToDense(a,s,r,s.dtype===o.dtype?o:cast(o,s.dtype))]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},executeOp16=(e,t,n)=>{switch(e.op){case"SparseFillEmptyRows":{const{outputIndices:a,outputValues:r,emptyRowIndicator:s,reverseIndexMap:o}=sparse.sparseFillEmptyRows(getParamValue("indices",e,t,n),getParamValue("values",e,t,n),getParamValue("denseShape",e,t,n),getParamValue("defaultValue",e,t,n));return[a,r,s,o]}case"SparseReshape":{const{outputIndices:a,outputShape:r}=sparse.sparseReshape(getParamValue("inputIndices",e,t,n),getParamValue("inputShape",e,t,n),getParamValue("newShape",e,t,n));return[a,r]}case"SparseSegmentMean":return[sparse.sparseSegmentMean(getParamValue("data",e,t,n),getParamValue("indices",e,t,n),getParamValue("segmentIds",e,t,n))];case"SparseSegmentSum":return[sparse.sparseSegmentSum(getParamValue("data",e,t,n),getParamValue("indices",e,t,n),getParamValue("segmentIds",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},executeOp17=(e,t,n)=>{switch(e.op){case"FFT":return[fft(getParamValue("x",e,t,n))];case"IFFT":return[ifft(getParamValue("x",e,t,n))];case"RFFT":return[rfft(getParamValue("x",e,t,n))];case"IRFFT":return[irfft(getParamValue("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},executeOp18=(e,t,n)=>{switch(e.op){case"StringNGrams":{const{nGrams:a,nGramsSplits:r}=string.stringNGrams(getParamValue("data",e,t,n),getParamValue("dataSplits",e,t,n),getParamValue("separator",e,t,n),getParamValue("nGramWidths",e,t,n),getParamValue("leftPad",e,t,n),getParamValue("rightPad",e,t,n),getParamValue("padWidth",e,t,n),getParamValue("preserveShortSequences",e,t,n));return[a,r]}case"StringSplit":{const{indices:a,values:r,shape:s}=string.stringSplit(getParamValue("input",e,t,n),getParamValue("delimiter",e,t,n),getParamValue("skipEmpty",e,t,n));return[a,r,s]}case"StringToHashBucketFast":return[string.stringToHashBucketFast(getParamValue("input",e,t,n),getParamValue("numBuckets",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},executeOp19=(e,t,n)=>{switch(e.op){case"Cast":return[cast(getParamValue("x",e,t,n),getParamValue("dtype",e,t,n))];case"ExpandDims":{const a=getParamValue("axis",e,t,n);return[expandDims(getParamValue("x",e,t,n),a)]}case"Squeeze":{const a=getParamValue("axis",e,t,n);return[squeeze(getParamValue("x",e,t,n),a)]}case"Reshape":return[reshape(getParamValue("x",e,t,n),getParamValue("shape",e,t,n))];case"MirrorPad":return[mirrorPad(getParamValue("x",e,t,n),getParamValue("padding",e,t,n),getParamValue("mode",e,t,n))];case"PadV2":case"Pad":return[pad(getParamValue("x",e,t,n),getParamValue("padding",e,t,n),getParamValue("constantValue",e,t,n))];case"SpaceToBatchND":{const a=getParamValue("blockShape",e,t,n),r=getParamValue("paddings",e,t,n);return[spaceToBatchND(getParamValue("x",e,t,n),a,r)]}case"BatchToSpaceND":{const a=getParamValue("blockShape",e,t,n),r=getParamValue("crops",e,t,n);return[batchToSpaceND(getParamValue("x",e,t,n),a,r)]}case"DepthToSpace":{const a=getParamValue("blockSize",e,t,n),r=getParamValue("dataFormat",e,t,n).toUpperCase();return[depthToSpace(getParamValue("x",e,t,n),a,r)]}case"BroadcastTo":return[broadcastTo(getParamValue("x",e,t,n),getParamValue("shape",e,t,n))];case"BroadcastArgs":return[broadcastArgs(getParamValue("s0",e,t,n),getParamValue("s1",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};function executeOp20(e,t,n,a){const r=((e,t,n)=>{switch(e.category){case"arithmetic":return tidy((()=>executeOp(e,t,n)));case"basic_math":return tidy((()=>executeOp2(e,t,n)));case"control":return executeOp3(e,t,n);case"convolution":return tidy((()=>executeOp4(e,t,n)));case"creation":return tidy((()=>executeOp5(e,t,n)));case"dynamic":return executeOp6(e,t,n);case"evaluation":return tidy((()=>executeOp7(e,t,n)));case"image":return tidy((()=>executeOp10(e,t,n)));case"graph":return tidy((()=>executeOp8(e,t,n)));case"logical":return tidy((()=>executeOp11(e,t,n)));case"matrices":return tidy((()=>executeOp12(e,t,n)));case"normalization":return tidy((()=>executeOp13(e,t,n)));case"reduction":return tidy((()=>executeOp14(e,t,n)));case"slice_join":return tidy((()=>executeOp15(e,t,n)));case"sparse":return tidy((()=>executeOp16(e,t,n)));case"spectral":return tidy((()=>executeOp17(e,t,n)));case"string":return tidy((()=>executeOp18(e,t,n)));case"transformation":return tidy((()=>executeOp19(e,t,n)));case"hash_table":return executeOp9(e,t,n,a);case"custom":const r=getRegisteredOp(e.op);if(r&&r.customExecutor)return r.customExecutor(new NodeValueImpl(e,t,n));throw TypeError(`Custom op ${e.op} is not registered.`);default:throw TypeError(`Unknown op '${e.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(e,t,n);return util_exports.isPromise(r)?r.then((e=>[].concat(e))):[].concat(r)}var ExecutionContext=class{constructor(e={},t={},n={},a={}){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=n,this.functionMap=a,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let t=0;t<this.contexts.length-1;t++){const n=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(n))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map((e=>0===e.id&&0===e.iterationId?"":`${e.frameName}-${e.iterationId}`)).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()}nextIteration(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");{this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(const t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}};function getExecutionSubgraph(e,t,n,a){const r=new Set,s=[];let o=null,i=null;const l=new Set,u=Object.keys(e).map((e=>parseNodeName(e)[0]));let c=[];null!=a&&(c=a.map((e=>parseNodeName(e.name)[0])));const d=[...t];for(;d.length>0;){const e=d.pop();(isControlFlow(e)||isDynamicShape(e)||isHashTable(e))&&null==o&&(o=e,i=o.children.map((e=>e.name)).filter((e=>r.has(e)))),r.add(e.name),null==n[e.name]&&(-1===u.indexOf(e.name)&&-1===c.indexOf(e.name)&&(0!==e.inputs.length?e.inputs.forEach((e=>{l.has(e.name)||(l.add(e.name),d.push(e))})):s.push(e.name)))}return{inputs:e,outputs:t,usedNodes:r,missingInputs:s,dynamicNode:o,syncInputs:i}}function getNodesInTopologicalOrder(e,t,n){const{usedNodes:a,inputs:r}=n,s=[],o=Object.keys(r).map((e=>parseNodeName(e)[0])).map((t=>e.nodes[t])),i=e.initNodes;o.forEach((e=>{a.has(e.name)&&s.push(e)})),e.weights.forEach((e=>{a.has(e.name)&&s.push(e)})),null!=i&&i.forEach((e=>{a.has(e.name)&&s.push(e)}));const l=new Set,u=[];for(;s.length>0;){const e=s.pop();l.add(e.name),t[e.name]||u.push(e),e.children.forEach((e=>{!l.has(e.name)&&a.has(e.name)&&e.inputs.every((e=>l.has(e.name)))&&s.push(e)}))}return u}var CONTROL_FLOW_OPS=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"],DYNAMIC_SHAPE_OPS=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"],HASH_TABLE_OPS=["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"];function isControlFlow(e){return CONTROL_FLOW_OPS.indexOf(e.op)>=0}function isDynamicShape(e){return DYNAMIC_SHAPE_OPS.indexOf(e.op)>=0}function isHashTable(e){return HASH_TABLE_OPS.indexOf(e.op)>=0}var GraphExecutor=class{constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this._weightMap={},this.SEPERATOR=",",this._functions={},this._functionExecutorMap={},this.intermediateTensors={},this.keepTensorForDebug=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,null!=e.functions&&Object.keys(e.functions).forEach((t=>{this._functionExecutorMap[t]=new GraphExecutor(e.functions[t],this)}))}get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const t=Object.keys(e).map((t=>e[t].map((e=>e.id))));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map((e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0})))}get outputs(){return this._outputs.map((e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0})))}get inputNodes(){return this._inputs.map((e=>e.signatureKey||e.name))}get outputNodes(){return this._outputs.map((e=>{const t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t}))}get functions(){return Object.keys(this._functions).reduce(((e,t)=>(e[t]=this._functions[t].signature,e)),{})}getCompilationKey(e,t){const n=e.map((e=>e.name)).sort(),a=t.map((e=>e.name)).sort();return n.join(this.SEPERATOR)+"--"+a.join(this.SEPERATOR)}compile(e,t){const n=getExecutionSubgraph(e,t,this.weightMap,this._initNodes),{missingInputs:a,dynamicNode:r,syncInputs:s}=n;if(null!=r)throw new Error(`This execution contains the node '${r.name}', which has the dynamic op '${r.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${s}]`);if(a.length>0){const n=t.map((e=>e.name)),r=Object.keys(e);throw new Error(`Cannot compute the outputs [${n}] from the provided inputs [${r}]. Missing the following inputs: [${a}]`)}return getNodesInTopologicalOrder(this.graph,this.weightMap,n)}execute(e,t){e=this.mapInputs(e);const n=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);const a=n.map((e=>this.graph.nodes[parseNodeName(e)[0]])),r=t.map((e=>parseNodeName(e)[0]));let s=r.map((e=>this.graph.nodes[e]));this.resetIntermediateTensors(),0===s.length&&(s=this._outputs);const o=this.getCompilationKey(a,s);let i=this.compiledMap.get(o);null==i&&(i=this.compile(e,s),this.compiledMap.set(o,i));const l={},u={};return tidy((()=>{const n=new ExecutionContext(this.weightMap,l,u,this.functionExecutorMap),a={...this.weightMap};Object.keys(e).forEach((t=>{const[n,r]=parseNodeName(t),s=[];s[r]=e[t],a[n]=s}));const s=this.getFrozenTensorIds(a),o={};for(let e=0;e<i.length;e++){const t=i[e];if(!a[t.name]){const e=executeOp20(t,a,n,this._resourceManager);if(util_exports.isPromise(e))throw new Error(`The execution of the op '${t.op}' returned a promise. Please use model.executeAsync() instead.`);a[t.name]=e,this.checkTensorForDisposal(t.name,t,a,n,s,r,o)}}return null==this.parent&&n.dispose(s),t.map((e=>getTensor(e,a,n)))}))}getFrozenTensorIds(e){const t=[].concat.apply([],Object.keys(e).map((t=>e[t])).map((e=>e.map((e=>e.id)))));return new Set(t)}checkTensorForDisposal(e,t,n,a,r,s,o){"control"!==t.category&&-1===s.indexOf(e)&&(n[e].forEach((e=>{null!=e&&(o[e.id]=(o[e.id]||0)+t.children.length)})),t.inputs.forEach((e=>{if("control"!==e.category){const s=getTensorsForCurrentContenxt(e.name,n,a);null!=s&&s.forEach((e=>{if(e&&!e.kept&&!r.has(e.id)){const n=o[e.id];if(1===n){if(this.keepTensorForDebug){const[n,r]=getNodeNameAndIndex(t.name,a);this.intermediateTensors[n]||(this.intermediateTensors[n]=[]),this.intermediateTensors[n][r]=e}else e.dispose();delete o[e.id]}else null!=n&&o[e.id]--}}))}})))}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){this.intermediateTensors&&(Object.keys(this.intermediateTensors).forEach((e=>this.intermediateTensors[e].forEach((e=>e.dispose())))),this.disposeTensorsMap())}disposeTensorsMap(){this.tensorsMap&&Object.keys(this.tensorsMap).forEach((e=>{this.tensorsMap[e].forEach((e=>{!e||e.kept||e.isDisposed||this.keepIds.has(e.id)||e.dispose()}))}))}getIntermediateTensors(){return this.tensorsMap}resetIntermediateTensors(){for(const e in this.intermediateTensors)this.intermediateTensors[e].forEach((e=>e.dispose())),delete this.intermediateTensors[e]}async _executeAsync(e,t,n=!1,a={},r={}){n||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepTensorForDebug=env().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(e){console.warn(e.message)}this.resetIntermediateTensors();const s=new ExecutionContext(this.weightMap,a,r,this.functionExecutorMap);this.tensorsMap=await this.executeWithControlFlow(e,s,t,n);const o=t.map((e=>getTensor(e,this.tensorsMap,s))),i=o.map((e=>e.id)),l=Object.keys(e).map((t=>e[t].id));return this.keepIds=new Set([...i,...l,...this.weightIds]),this.keepTensorForDebug||this.disposeTensorsMap(),null==this.parent&&s.dispose(this.keepIds),o}async executeFunctionAsync(e,t,n){const a=e.reduce(((e,t,n)=>(e[this.inputs[n].name]=t,e)),{});return this._executeAsync(a,this.outputNodes,!0,t,n)}async executeWithControlFlow(e,t,n,a){const r=Object.keys(e),s=r.map((e=>this.graph.nodes[parseNodeName(e)[0]])),o=n.map((e=>parseNodeName(e)[0]));let i=o.map((e=>this.graph.nodes[e]));0===i.length&&(i=this._outputs);const{usedNodes:l,missingInputs:u,dynamicNode:c,syncInputs:d}=getExecutionSubgraph(e,i,this.weightMap,this._initNodes),p=[...s,...this.graph.weights,...this._initNodes||[]].map((e=>({node:e,contexts:t.currentContext}))),h={...this.weightMap};Object.keys(e).forEach((t=>{const[n,a]=parseNodeName(t),r=[];r[a]=e[t],h[n]=r}));const m={},f=this.getFrozenTensorIds(h),g={};for(;p.length>0;){const e=this.processStack(s,p,t,h,g,f,o,m,l);await Promise.all(e)}null!=c||a||console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const x=i.filter((e=>!isControlFlow(e)&&!getTensor(e.name,h,t))).map((e=>e.name));if(x.length>0){let e="";throw null!=c&&(e=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${d}]`),new Error(`Cannot compute the outputs [${x}] from the provided inputs [${r}]. Consider providing the following inputs: [${u}]. ${e}`)}return h}processStack(e,t,n,a,r,s,o,i,l){const u=[];for(;t.length>0;){const e=t.pop();n.currentContext=e.contexts;let c="";if("Enter"===e.node.op&&getParamValue("isConstant",e.node,a,n)&&([c]=getNodeNameAndIndex(e.node.name,n)),null==a[e.node.name]){const d=executeOp20(e.node,a,n,this._resourceManager);c||([c]=getNodeNameAndIndex(e.node.name,n));const p=n.currentContext;util_exports.isPromise(d)?u.push(d.then((u=>(a[c]=u,n.currentContext=p,this.checkTensorForDisposal(c,e.node,a,n,s,o,i),this.processChildNodes(e.node,t,n,a,r,l),u)))):(a[c]=d,this.checkTensorForDisposal(c,e.node,a,n,s,o,i),this.processChildNodes(e.node,t,n,a,r,l))}else this.processChildNodes(e.node,t,n,a,r,l)}return u}processChildNodes(e,t,n,a,r,s){e.children.forEach((e=>{const[o]=getNodeNameAndIndex(e.name,n);!r[o]&&s.has(e.name)&&("Merge"===e.op?e.inputNames.some((e=>!!getTensor(e,a,n)))&&(r[o]=!0,t.push({contexts:n.currentContext,node:e})):e.inputNames.every((e=>!!getTensor(e,a,n)))&&(r[o]=!0,t.push({contexts:n.currentContext,node:e})))}))}dispose(){Object.keys(this.weightMap).forEach((e=>this.weightMap[e].forEach((e=>e.dispose()))))}checkInputShapeAndType(e){Object.keys(e).forEach((t=>{const n=e[t],[a]=parseNodeName(t),r=this.graph.nodes[a];if(r.attrParams.shape&&r.attrParams.shape.value){const e=r.attrParams.shape.value,t=e.length===n.shape.length&&n.shape.every(((t,n)=>-1===e[n]||e[n]===t));util_exports.assert(t,(()=>`The shape of dict['${r.name}'] provided in model.execute(dict) must be [${e}], but was [${n.shape}]`))}r.attrParams.dtype&&r.attrParams.dtype.value&&util_exports.assert(n.dtype===r.attrParams.dtype.value,(()=>`The dtype of dict['${r.name}'] provided in model.execute(dict) must be ${r.attrParams.dtype.value}, but was ${n.dtype}`))}))}mapInputs(e){const t={};for(const n in e)if(null!=this._signature&&null!=this._signature.inputs&&null!=this._signature.inputs[n]){t[this._signature.inputs[n].name]=e[n]}else t[n]=e[n];return t}checkInputs(e){const t=Object.keys(e).filter((e=>{const[t]=parseNodeName(e);return null==this.graph.nodes[t]}));if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map((e=>{if(null!=this._signature&&null!=this._signature.outputs&&null!=this._signature.outputs[e]){return this._signature.outputs[e].name}return e}),{})}checkOutputs(e){e.forEach((e=>{const[t]=parseNodeName(e);if(!this.graph.nodes[t])throw new Error(`The output '${e}' is not found in the graph`)}))}},ResourceManager=class{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}},TFHUB_SEARCH_PARAM="?tfjs-format=file",DEFAULT_MODEL_NAME="model.json",GraphModel=class{constructor(e,t={}){this.modelUrl=e,this.loadOptions=t,this.version="n/a",null==t&&(this.loadOptions={}),this.resourceManager=new ResourceManager}get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}findIOHandler(){const e=this.modelUrl;if(null!=e.load)this.handler=e;else if(null!=this.loadOptions.requestInit)this.handler=io_exports.browserHTTPRequest(e,this.loadOptions);else{const t=io_exports.getLoadHandlers(e,this.loadOptions);if(0===t.length)t.push(io_exports.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}async load(){if(this.findIOHandler(),null==this.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=await this.handler.load();return this.loadSync(e)}loadSync(e){this.artifacts=e;const t=this.artifacts.modelTopology;let n;n=null!=this.artifacts.userDefinedMetadata&&null!=this.artifacts.userDefinedMetadata.signature?this.artifacts.userDefinedMetadata.signature:this.artifacts.signature,this.signature=n,this.version=`${t.versions.producer}.${t.versions.minConsumer}`;const a=io_exports.decodeWeights(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new GraphExecutor(OperationMapper.Instance.transformGraph(t,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(a),this.executor.resourceManager=this.resourceManager,null!=e.modelInitializer&&null!=e.modelInitializer.node){const t=OperationMapper.Instance.transformGraph(e.modelInitializer);this.initializer=new GraphExecutor(t),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializer.executeAsync({},[])}return!0}async save(e,t){if("string"==typeof e){const t=io_exports.getSaveHandlers(e);if(0===t.length)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(t.length>1)throw new Error(`Found more than one (${t.length}) save handlers for URL '${e}'`);e=t[0]}if(null==e.save)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}predict(e,t){return this.execute(e,this.outputNodes)}normalizeInputs(e){if(!(e instanceof Tensor||Array.isArray(e)))return e;if((e=Array.isArray(e)?e:[e]).length!==this.inputNodes.length)throw new Error(`Input tensor count mismatch,the graph model has ${this.inputNodes.length} placeholders, while there are ${e.length} input tensors.`);return this.inputNodes.reduce(((t,n,a)=>(t[n]=e[a],t)),{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}execute(e,t){e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const n=this.executor.execute(e,t);return n.length>1?n:n[0]}async executeAsync(e,t){e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const n=await this.executor.executeAsync(e,t);return n.length>1?n:n[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce(((t,n)=>(t[n]=[e[n]],t)),{})}dispose(){this.executor.dispose(),this.initializer&&this.initializer.dispose(),this.resourceManager.dispose()}};async function loadGraphModel(e,t={}){if(null==e)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");null==t&&(t={}),t.fromTFHub&&null==e.load&&(e.endsWith("/")||(e+="/"),e=`${e}${DEFAULT_MODEL_NAME}${TFHUB_SEARCH_PARAM}`);const n=new GraphModel(e,t);return await n.load(),n}var version3="0.0.0",src_exports={};__export2(src_exports,{CSVDataset:()=>CSVDataset,Dataset:()=>Dataset,FileDataSource:()=>FileDataSource,TextLineDataset:()=>TextLineDataset,URLDataSource:()=>URLDataSource,array:()=>array,csv:()=>csv,func:()=>func,generator:()=>generator,microphone:()=>microphone,version_data:()=>version4,webcam:()=>webcam,zip:()=>zip});var seedrandom3=__toModule(require_seedrandom2()),seedrandom2=__toModule(require_seedrandom2());function deepMap(e,t){return deepMapInternal(e,t)}function deepMapInternal(e,t,n=new Map,a=new Set){if(null==e)return null;if("function"==typeof Blob&&e instanceof Blob)return e.slice();if(a.has(e))throw new Error("Circular references are not supported.");if(n.has(e))return n.get(e);const r=t(e);if(r.recurse&&null!==r.value)throw new Error("A deep map function may not return both a value and recurse=true.");if(r.recurse){if(isIterable2(e)){const r=Array.isArray(e)?[]:{};a.add(e);for(const s in e){const o=deepMapInternal(e[s],t,n,a);r[s]=o}return a.delete(e),e.__proto__&&(r.__proto__=e.__proto__),r}throw new Error(`Can't recurse into non-iterable type: ${e}`)}return n.set(e,r.value),r.value}function deepZip(e,t=zipToList){return deepZipInternal(e,t)}function deepZipInternal(e,t,n=new Set){const a=e[0];if(n.has(a))throw new Error("Circular references are not supported.");const r=t(e);if(r.recurse&&null!==r.value)throw new Error("A deep zip function may not return both a value and recurse=true.");if(r.recurse){if(isIterable2(a)){const r=Array.isArray(a)?[]:{};n.add(a);for(const s in a){const a=deepZipInternal(e.map((e=>e[s])),t,n);r[s]=a}return n.delete(a),r}throw new Error(`Can't recurse into non-iterable type: ${a}`)}return r.value}function zipToList(e){return null===e?null:isIterable2(e[0])?{value:null,recurse:!0}:{value:e,recurse:!1}}async function deepMapAndAwaitAll(e,t){const n=new Map;deepMapInternal(e,t,n);for(const e of Array.from(n.keys())){const t=n.get(e);if(util_exports.isPromise(t)){const a=await t;n.set(e,a)}}return deepMapInternal(e,t,n)}function isIterable2(e){let t=!1;if(env().get("IS_BROWSER"))t=e instanceof TextDecoder;else{const{StringDecoder:n}=require_string_decoder();t=e instanceof n}return null!=e&&!ArrayBuffer.isView(e)&&(Array.isArray(e)||"object"==typeof e&&!(e instanceof Tensor)&&!(e instanceof Promise)&&!t)}function canTensorify(e){return null==e||isPrimitive(e)||Array.isArray(e)||"object"==typeof e&&e instanceof Tensor||util_exports.isTypedArray(e)}function isPrimitive(e){return null===e||"object"!=typeof e&&"function"!=typeof e}function deepClone(e){return deepMap(e,cloneIfTensor)}function cloneIfTensor(e){return e instanceof Tensor?{value:e.clone(),recurse:!1}:isIterable2(e)?{value:null,recurse:!0}:{value:e,recurse:!1}}var RingBuffer=class{constructor(e){if(this.capacity=e,this.begin=0,this.end=0,null==e)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(e<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(e),this.doubledCapacity=2*e}wrap(e){for(;e<0;)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw new RangeError("Can't get item at a negative index.");return this.data[e%this.capacity]}set(e,t){if(e<0)throw new RangeError("Can't set item at a negative index.");this.data[e%this.capacity]=t}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return 0===this.length()}push(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(const t of e)this.push(t)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);const e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const t=this.wrap(this.begin+e),n=this.get(t);return this.set(t,this.pop()),n}},_GrowingRingBuffer=class extends RingBuffer{constructor(){super(_GrowingRingBuffer.INITIAL_CAPACITY)}isFull(){return!1}push(e){super.isFull()&&this.expand(),super.push(e)}unshift(e){super.isFull()&&this.expand(),super.unshift(e)}expand(){const e=2*this.capacity,t=new Array(e),n=this.length();for(let e=0;e<n;e++)t[e]=this.get(this.wrap(this.begin+e));this.data=t,this.capacity=e,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=n}},GrowingRingBuffer=_GrowingRingBuffer;function iteratorFromItems(e){return new ArrayIterator(e)}function iteratorFromFunction(e){return new FunctionCallIterator(e)}function iteratorFromConcatenated(e,t){return new ChainedIterator(e,t)}function iteratorFromZipped(e,t=ZipMismatchMode.FAIL){return new ZipIterator(e,t)}GrowingRingBuffer.INITIAL_CAPACITY=32;var ZipMismatchMode,LazyIterator=class{async toArray(){const e=[];let t=await this.next();for(;!t.done;)e.push(t.value),t=await this.next();return e}async toArrayForTest(){const e=this.prefetch(100),t=[];let n=await e.next();for(;!n.done;)t.push(n.value),n=await e.next();return t}async resolveFully(){let e=await this.next();for(;!e.done;)e=await this.next()}async resolveWhile(e){let t=await this.next(),n=e(t.value);for(;!t.done&&n;)t=await this.next(),n=e(t.value)}handleErrors(e){return new ErrorHandlingLazyIterator(this,e)}filter(e){return new FilterIterator(this,e)}map(e){return new MapIterator(this,e)}mapAsync(e){return new AsyncMapIterator(this,e)}serialMapAsync(e){return new AsyncMapIterator(this,e).serial()}flatmap(e){return new FlatmapIterator(this,e)}async forEachAsync(e){return this.map(e).resolveFully()}async serialForEach(e){return this.serialMapAsync(e).resolveWhile((e=>!0===e))}rowMajorBatch(e,t=!0){return new RowMajorBatchIterator(this,e,t)}columnMajorBatch(e,t=!0,n=zipToList){return this.rowMajorBatch(e,t).map((e=>deepZip(e,n)))}concatenate(e,t){return new ChainedIterator(iteratorFromItems([this,e]),t)}take(e){return e<0||null==e?this:new TakeIterator(this,e)}skip(e){return e<0||null==e?this:new SkipIterator(this,e)}prefetch(e){return new PrefetchIterator(this,e)}shuffle(e,t){return new ShuffleIterator(this,e,t)}serial(){return new SerialIterator(this)}},ArrayIterator=class extends LazyIterator{constructor(e){super(),this.items=e,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};const e=this.items[this.trav];return this.trav++,{value:deepClone(e),done:!1}}},FunctionCallIterator=class extends LazyIterator{constructor(e){super(),this.nextFn=e}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(e){throw e.message=`Error thrown while iterating through a dataset: ${e.message}`,e}}},SerialIterator=class extends LazyIterator{constructor(e){super(),this.upstream=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){return this.upstream.next()}},SkipIterator=class extends LazyIterator{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){const e=await this.upstream.next();if(e.done)return e;dispose(e.value)}return this.upstream.next()}},TakeIterator=class extends LazyIterator{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}},RowMajorBatchIterator=class extends LazyIterator{constructor(e,t,n=!0){super(),this.upstream=e,this.batchSize=t,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){const e=[];for(;e.length<this.batchSize;){const t=await this.upstream.next();if(t.done)return this.enableSmallLastBatch&&e.length>0?{value:e,done:!1}:{value:null,done:!0};e.push(t.value)}return{value:e,done:!1}}},FilterIterator=class extends LazyIterator{constructor(e,t){super(),this.upstream=e,this.predicate=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;;){const e=await this.upstream.next();if(e.done||this.predicate(e.value))return e;dispose(e.value)}}},MapIterator=class extends LazyIterator{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Map`}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const t=tensor_util_exports.getTensorsInContainer(e.value),n=this.transform(e.value),a=tensor_util_exports.getTensorsInContainer(n);for(const e of t)tensor_util_exports.isTensorInList(e,a)||e.dispose();return{value:n,done:!1}}},ErrorHandlingLazyIterator=class extends LazyIterator{constructor(e,t){super(),this.upstream=e,this.handler=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(e){if(!this.handler(e))return{value:null,done:!0}}}},AsyncMapIterator=class extends LazyIterator{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const t=tensor_util_exports.getTensorsInContainer(e.value),n=await this.transform(e.value),a=tensor_util_exports.getTensorsInContainer(n);for(const e of t)tensor_util_exports.isTensorInList(e,a)||e.dispose();return{value:n,done:!1}}},OneToManyIterator=class extends LazyIterator{constructor(){super(),this.outputQueue=new GrowingRingBuffer,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;0===this.outputQueue.length();)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}},FlatmapIterator=class extends OneToManyIterator{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){const e=await this.upstream.next();if(e.done)return!1;const t=tensor_util_exports.getTensorsInContainer(e.value),n=this.transform(e.value),a=tensor_util_exports.getTensorsInContainer(n);this.outputQueue.pushAll(n);for(const e of t)tensor_util_exports.isTensorInList(e,a)||e.dispose();return!0}},ChainedIterator=class extends LazyIterator{constructor(e,t){super(),this.baseErrorHandler=t,this.lastRead=null,this.iterator=null,this.moreIterators=e}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(e){if(await e,null==this.iterator){const e=await this.moreIterators.next();if(e.done)return{value:null,done:!0};this.iterator=e.value,null!=this.baseErrorHandler&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}const t=await this.iterator.next();return t.done?(this.iterator=null,this.readFromChain(e)):t}};!function(e){e[e.FAIL=0]="FAIL",e[e.SHORTEST=1]="SHORTEST",e[e.LONGEST=2]="LONGEST"}(ZipMismatchMode||(ZipMismatchMode={}));var ZipIterator=class extends LazyIterator{constructor(e,t=0){super(),this.iterators=e,this.mismatchMode=t,this.count=0,this.currentPromise=null}summary(){return"{TODO: fill in upstream of zip summaries} -> Zip"}async nextState(e){await e;let t=0,n=0;const a=await deepMapAndAwaitAll(this.iterators,(function(e){if(e instanceof LazyIterator){return{value:e.next().then((e=>(t++,e.done&&n++,e.value))),recurse:!1}}return{value:null,recurse:!0}}));if(t===n)return{value:null,done:!0};if(n>0)switch(this.mismatchMode){case 0:throw new Error(`Zipped streams should have the same length. Mismatched at element ${this.count}.`);case 1:return{value:null,done:!0}}return this.count++,{value:a,done:!1}}async next(){return this.currentPromise=this.nextState(this.currentPromise),this.currentPromise}},PrefetchIterator=class extends LazyIterator{constructor(e,t){super(),this.upstream=e,this.bufferSize=t,this.buffer=new RingBuffer(t)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){const e=this.upstream.next();this.buffer.push(e)}}next(){return this.refill(),this.buffer.shift()}},ShuffleIterator=class extends PrefetchIterator{constructor(e,t,n){super(e,t),this.upstream=e,this.windowSize=t,this.upstreamExhausted=!1,this.random=seedrandom2.alea(n||util_exports.now().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}randomInt(e){return Math.floor(this.random()*e)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){const e=this.chooseIndex(),t=await this.buffer.shuffleExcise(e);if(!t.done)return this.refill(),t;this.upstreamExhausted=!0}return{value:null,done:!0}}},Dataset=class{constructor(){this.size=null}batch(e,t=!0){const n=this;let a;return util_exports.assert(e>0,(()=>`batchSize needs to be positive, but it is\n      ${e}`)),a=this.size===1/0||null==this.size?this.size:t?Math.ceil(this.size/e):Math.floor(this.size/e),datasetFromIteratorFn((async()=>(await n.iterator()).columnMajorBatch(e,t,deepBatchConcat)),a)}concatenate(e){const t=this;let n;return n=this.size===1/0||e.size===1/0?1/0:null!=this.size&&null!=e.size?this.size+e.size:null,datasetFromIteratorFn((async()=>(await t.iterator()).concatenate(await e.iterator())),n)}filter(e){const t=this;let n;return n=this.size===1/0?1/0:null,datasetFromIteratorFn((async()=>(await t.iterator()).filter((t=>tidy((()=>e(t)))))),n)}async forEachAsync(e){return(await this.iterator()).forEachAsync(e)}map(e){const t=this;return datasetFromIteratorFn((async()=>(await t.iterator()).map((t=>tidy((()=>e(t)))))),this.size)}mapAsync(e){const t=this;return datasetFromIteratorFn((async()=>(await t.iterator()).mapAsync(e)),this.size)}prefetch(e){if(null==e)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");const t=this;return datasetFromIteratorFn((async()=>(await t.iterator()).prefetch(e)),this.size)}repeat(e){const t=this;let n;return n=null!=this.size&&e>0?this.size*e:0===e?0:null!=this.size&&(void 0===e||e<0)?1/0:null,datasetFromIteratorFn((async()=>iteratorFromConcatenated(iteratorFromFunction((async()=>({value:await t.iterator(),done:!1}))).take(e))),n)}skip(e){const t=this;let n;return n=null!=this.size&&e>=0&&this.size>=e?this.size-e:null!=this.size&&(this.size<e||void 0===e||e<0)?0:null,datasetFromIteratorFn((async()=>(await t.iterator()).skip(e)),n)}shuffle(e,t,n=!0){if(null==e||e<0)throw null==this.size?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);const a=this,r=seedrandom3.alea(t||util_exports.now().toString());return datasetFromIteratorFn((async()=>{let t=r.int32();return n&&(t+=r.int32()),(await a.iterator()).shuffle(e,t.toString())}),this.size)}take(e){const t=this;let n;return n=null!=this.size&&this.size>e?e:null!=this.size&&this.size<=e?this.size:null,datasetFromIteratorFn((async()=>(await t.iterator()).take(e)),n)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}};function datasetFromIteratorFn(e,t=null){return new class extends Dataset{constructor(){super(...arguments),this.size=t}async iterator(){return e()}}}function array(e){return datasetFromIteratorFn((async()=>iteratorFromItems(e)),e.length)}function zip(e){if(!isIterable2(e))throw new Error("The argument to zip() must be an object or array.");let t;if(Array.isArray(e))for(let n=0;n<e.length;n++)t=null==t?e[n].size:Math.min(t,e[n].size);else if(e instanceof Object)for(const n in e)t=null==t?e[n].size:Math.min(t,e[n].size);return datasetFromIteratorFn((async()=>iteratorFromZipped(await deepMapAndAwaitAll(e,(e=>{if(e instanceof Dataset)return{value:e.iterator(),recurse:!1};if(isIterable2(e))return{value:null,recurse:!0};throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.")})),ZipMismatchMode.SHORTEST)),t)}function deepBatchConcat(e){if(null===e)return null;if(canTensorify(e[0])){return{value:batchConcat(e),recurse:!1}}return{value:null,recurse:!0}}function batchConcat(e){if(0===e.length)throw new Error("Can't make a batch of zero elements.");return e[0]instanceof Tensor?stack(e):tensor(e)}Dataset.MAX_BUFFER_SIZE=1e4;var TextLineDataset=class extends Dataset{constructor(e){super(),this.input=e}async iterator(){return(await this.input.iterator()).decodeUTF8().split("\n").map((e=>(e.endsWith("\r")&&(e=e.slice(0,-1)),e)))}},CODE_QUOTE='"',STATE_OUT=Symbol("out"),STATE_FIELD=Symbol("field"),STATE_QUOTE=Symbol("quote"),STATE_QUOTE_AFTER_QUOTE=Symbol("quoteafterquote"),STATE_WITHIN_QUOTE_IN_QUOTE=Symbol("quoteinquote"),CSVDataset=class extends Dataset{constructor(e,t){super(),this.input=e,this.hasHeader=!0,this.fullColumnNames=null,this.columnNamesValidated=!1,this.columnConfigs=null,this.configuredColumnsOnly=!1,this.delimiter=",",this.delimWhitespace=!1,this.base=new TextLineDataset(e),t||(t={}),this.hasHeader=!1!==t.hasHeader,this.fullColumnNames=t.columnNames,this.columnConfigs=t.columnConfigs,this.configuredColumnsOnly=t.configuredColumnsOnly,t.delimWhitespace?(util_exports.assert(null==t.delimiter,(()=>"Delimiter should not be provided when delimWhitespace is true.")),this.delimWhitespace=!0,this.delimiter=" "):this.delimiter=t.delimiter?t.delimiter:","}async columnNames(){return this.columnNamesValidated||await this.setColumnNames(),this.configuredColumnsOnly?Object.keys(this.columnConfigs):this.fullColumnNames}async setColumnNames(){const e=await this.maybeReadHeaderLine();if(!this.fullColumnNames&&!e)throw new Error("Column names must be provided if there is no header line.");this.fullColumnNames&&e&&util_exports.assert(e.length===this.fullColumnNames.length,(()=>"The length of provided columnNames ("+this.fullColumnNames.length.toString()+") does not match the length of the header line read from file ("+e.length.toString()+").")),this.fullColumnNames||(this.fullColumnNames=e);const t=this.fullColumnNames.reduce(((e,t)=>(e[t]=e[t]+1||1,e)),{}),n=Object.keys(t).filter((e=>t[e]>1));if(util_exports.assert(0===n.length,(()=>"Duplicate column names found: "+n.toString())),this.columnConfigs)for(const e of Object.keys(this.columnConfigs)){if(-1===this.fullColumnNames.indexOf(e))throw new Error('The key "'+e+'" provided in columnConfigs does not match any of the column names ('+this.fullColumnNames.toString()+").")}this.columnNamesValidated=!0}async maybeReadHeaderLine(){if(this.hasHeader){const e=await this.base.iterator(),t=await e.next();if(t.done)throw new Error("No data was found for CSV parsing.");const n=t.value;return this.parseRow(n,!1)}return null}async iterator(){this.columnNamesValidated||await this.setColumnNames();let e=await this.base.iterator();return this.hasHeader&&(e=e.skip(1)),e.map((e=>this.makeDataElement(e)))}makeDataElement(e){const t=this.parseRow(e),n={},a={};for(let r=0;r<this.fullColumnNames.length;r++){const s=this.fullColumnNames[r],o=this.columnConfigs?this.columnConfigs[s]:null;if(!this.configuredColumnsOnly||o){const i=t[r];let l=null;if(""===i)if(o&&void 0!==o.default)l=o.default;else{if(o&&(o.required||o.isLabel))throw new Error(`Required column ${s} is empty in this line: ${e}`);l=void 0}else{const e=Number(i);if(isNaN(e))l=o&&"bool"===o.dtype?this.getBoolean(i):i;else if(o&&o.dtype)switch(o.dtype){case"float32":default:l=e;break;case"int32":l=Math.floor(e);break;case"bool":l=this.getBoolean(i)}else l=e}o&&o.isLabel?a[s]=l:n[s]=l}}return 0===Object.keys(a).length?n:{xs:n,ys:a}}getBoolean(e){return"1"===e||"true"===e.toLowerCase()?1:0}parseRow(e,t=!0){const n=[];let a=0;const r=e.length;let s=STATE_OUT;for(let t=0;t<r;t++)switch(s){case STATE_OUT:switch(e.charAt(t)){case CODE_QUOTE:a=t+1,s=STATE_QUOTE;break;case this.delimiter:if(a=t+1," "===this.delimiter&&this.delimWhitespace)break;n.push(""),s=STATE_OUT;break;default:s=STATE_FIELD,a=t}break;case STATE_FIELD:if(e.charAt(t)===this.delimiter)n.push(e.substring(a,t)),s=STATE_OUT,a=t+1;break;case STATE_QUOTE:if(e.charAt(t)===CODE_QUOTE)s=STATE_QUOTE_AFTER_QUOTE;break;case STATE_QUOTE_AFTER_QUOTE:switch(e.charAt(t)){case this.delimiter:n.push(e.substring(a,t-1)),s=STATE_OUT,a=t+1;break;case CODE_QUOTE:s=STATE_QUOTE;break;default:s=STATE_WITHIN_QUOTE_IN_QUOTE}break;case STATE_WITHIN_QUOTE_IN_QUOTE:if(e.charAt(t)===CODE_QUOTE)s=STATE_QUOTE}if(s===STATE_QUOTE_AFTER_QUOTE?n.push(e.substring(a,r-1)):n.push(e.substring(a)),t&&n.length!==this.fullColumnNames.length)throw new Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${n}`);return n}},MicrophoneIterator=class extends LazyIterator{constructor(e){super(),this.microphoneConfig=e,this.isClosed=!1,this.fftSize=e.fftSize||1024;const t=Math.log2(this.fftSize);if(this.fftSize<0||t<4||t>14||!Number.isInteger(t))throw new Error(`Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got ${this.fftSize}`);if(this.numFrames=e.numFramesPerSpectrogram||43,this.sampleRateHz=e.sampleRateHz,this.columnTruncateLength=e.columnTruncateLength||this.fftSize,this.audioTrackConstraints=e.audioTrackConstraints,this.smoothingTimeConstant=e.smoothingTimeConstant||0,this.includeSpectrogram=!1!==e.includeSpectrogram,this.includeWaveform=!0===e.includeWaveform,!this.includeSpectrogram&&!this.includeWaveform)throw new Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.")}summary(){return"microphone"}static async create(e={}){if(env().get("IS_NODE"))throw new Error("microphone API is only supported in browser environment.");const t=new MicrophoneIterator(e);return await t.start(),t}async start(){try{this.stream=await navigator.mediaDevices.getUserMedia({audio:null==this.audioTrackConstraints||this.audioTrackConstraints,video:!1})}catch(e){throw new Error(`Error thrown while initializing video stream: ${e.message}`)}if(!this.stream)throw new Error("Could not obtain audio from microphone.");const e=window.AudioContext||window.webkitAudioContext;if(this.audioContext=new e,this.sampleRateHz){if(this.audioContext.sampleRate!==this.sampleRateHz)throw new Error(`Mismatch in sampling rate: Expected: ${this.sampleRateHz}; Actual: ${this.audioContext.sampleRate}`)}else this.sampleRateHz=this.audioContext.sampleRate;const t=this.audioContext.createMediaStreamSource(this.stream);this.analyser=this.audioContext.createAnalyser(),this.analyser.fftSize=2*this.fftSize,this.analyser.smoothingTimeConstant=this.smoothingTimeConstant,t.connect(this.analyser),this.freqData=new Float32Array(this.fftSize),this.timeData=new Float32Array(this.fftSize)}async next(){if(this.isClosed)return{value:null,done:!0};let e,t;const n=await this.getAudioData();if(this.includeSpectrogram){const t=this.flattenQueue(n.freqDataQueue);e=this.getTensorFromAudioDataArray(t,[this.numFrames,this.columnTruncateLength,1])}if(this.includeWaveform){const e=this.flattenQueue(n.timeDataQueue);t=this.getTensorFromAudioDataArray(e,[this.numFrames*this.fftSize,1])}return{value:{spectrogram:e,waveform:t},done:!1}}async capture(){return(await this.next()).value}async getAudioData(){const e=[],t=[];let n=0;return new Promise((a=>{const r=setInterval((()=>{this.includeSpectrogram&&(this.analyser.getFloatFrequencyData(this.freqData),this.freqData[0]===-1/0&&a({freqDataQueue:e,timeDataQueue:t}),e.push(this.freqData.slice(0,this.columnTruncateLength))),this.includeWaveform&&(this.analyser.getFloatTimeDomainData(this.timeData),t.push(this.timeData.slice())),++n===this.numFrames&&(clearInterval(r),a({freqDataQueue:e,timeDataQueue:t}))}),this.fftSize/this.sampleRateHz*1e3)}))}stop(){this.isClosed||(this.isClosed=!0,this.analyser.disconnect(),this.audioContext.close(),null!=this.stream&&this.stream.getTracks().length>0&&this.stream.getTracks()[0].stop())}toArray(){throw new Error("Can not convert infinite audio stream to array.")}getSampleRate(){return this.sampleRateHz}flattenQueue(e){const t=e[0].length,n=new Float32Array(e.length*t);return e.forEach(((e,a)=>n.set(e,a*t))),n}getTensorFromAudioDataArray(e,t){const n=new Float32Array(util_exports.sizeFromShape(t));return n.set(e,n.length-e.length),tensor(n,t)}},WebcamIterator=class extends LazyIterator{constructor(e,t){if(super(),this.webcamVideoElement=e,this.webcamConfig=t,this.isClosed=!0,this.resize=!1,this.needToResize())if(this.resize=!0,this.cropSize=[this.webcamConfig.resizeHeight,this.webcamConfig.resizeWidth],this.cropBoxInd=tensor1d([0],"int32"),this.webcamConfig.centerCrop){const e=1*this.webcamConfig.resizeWidth/this.webcamVideoElement.width,t=1*this.webcamConfig.resizeHeight/this.webcamVideoElement.height,n=(1-e)/2,a=(1-t)/2,r=n+e,s=t+a;this.cropBox=tensor2d([a,n,s,r],[1,4])}else this.cropBox=tensor2d([0,0,1,1],[1,4])}summary(){return"webcam"}static async create(e,t={}){if(env().get("IS_NODE"))throw new Error("tf.data.webcam is only supported in browser environment.");if(!e){if(e=document.createElement("video"),!t.resizeWidth||!t.resizeHeight)throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");e.width=t.resizeWidth,e.height=t.resizeHeight}const n=new WebcamIterator(e,t);return await n.start(),n}async start(){this.webcamConfig.facingMode&&util_exports.assert("user"===this.webcamConfig.facingMode||"environment"===this.webcamConfig.facingMode,(()=>`Invalid webcam facing mode: ${this.webcamConfig.facingMode}. Please provide 'user' or 'environment'`));try{this.stream=await navigator.mediaDevices.getUserMedia({video:{deviceId:this.webcamConfig.deviceId,facingMode:this.webcamConfig.facingMode?this.webcamConfig.facingMode:"user",width:this.webcamVideoElement.width,height:this.webcamVideoElement.height}})}catch(e){throw e.message=`Error thrown while initializing video stream: ${e.message}`,e}if(!this.stream)throw new Error("Could not obtain video from webcam.");try{this.webcamVideoElement.srcObject=this.stream}catch(e){console.log(e),this.webcamVideoElement.src=window.URL.createObjectURL(this.stream)}return this.webcamVideoElement.play(),this.isClosed=!1,new Promise((e=>{this.webcamVideoElement.onloadedmetadata=()=>{e()}}))}async next(){if(this.isClosed)return{value:null,done:!0};let e;try{e=browser_exports.fromPixels(this.webcamVideoElement)}catch(e){throw new Error(`Error thrown converting video to pixels: ${JSON.stringify(e)}`)}if(!this.resize)return{value:e,done:!1};try{return{value:this.cropAndResizeFrame(e),done:!1}}catch(e){throw new Error(`Error thrown cropping the video: ${e.message}`)}finally{e.dispose()}}needToResize(){return!(!this.webcamConfig.resizeWidth||!this.webcamConfig.resizeHeight||this.webcamVideoElement.width===this.webcamConfig.resizeWidth&&this.webcamVideoElement.height===this.webcamConfig.resizeHeight)}cropAndResizeFrame(e){return tidy((()=>{const t=expandDims(cast(e,"float32"),0);let n;n=image.cropAndResize(t,this.cropBox,this.cropBoxInd,this.cropSize,"bilinear");const a=n.shape;return reshape(n,a.slice(1))}))}async capture(){return(await this.next()).value}stop(){this.stream.getTracks().forEach((e=>e.stop()));try{this.webcamVideoElement.srcObject=null}catch(e){console.log(e),this.webcamVideoElement.src=null}this.isClosed=!0}toArray(){throw new Error("Can not convert infinite video stream to array.")}},DataSource=class{},StringIterator=class extends LazyIterator{split(e){return new SplitIterator(this,e)}},SplitIterator=class extends StringIterator{constructor(e,t){super(),this.upstream=e,this.impl=new SplitIteratorImpl(e,t)}summary(){return this.impl.summary()}async next(){return this.impl.next()}},SplitIteratorImpl=class extends OneToManyIterator{constructor(e,t){super(),this.upstream=e,this.separator=t,this.carryover=""}summary(){return`${this.upstream.summary()} -> Split('${this.separator}')`}async pump(){const e=await this.upstream.next();if(e.done)return""!==this.carryover&&(this.outputQueue.push(this.carryover),this.carryover="",!0);const t=e.value.split(this.separator);t[0]=this.carryover+t[0];for(const e of t.slice(0,-1))this.outputQueue.push(e);return this.carryover=t[t.length-1],!0}},ByteChunkIterator=class extends LazyIterator{decodeUTF8(){return new Utf8Iterator(this)}},Utf8Iterator=class extends StringIterator{constructor(e){super(),this.upstream=e,this.impl=new Utf8IteratorImpl(e)}summary(){return this.impl.summary()}async next(){return this.impl.next()}},Utf8IteratorImpl=class extends OneToManyIterator{constructor(e){if(super(),this.upstream=e,env().get("IS_BROWSER"))this.decoder=new TextDecoder("utf-8");else{const{StringDecoder:e}=require_string_decoder();this.decoder=new e("utf8")}}summary(){return`${this.upstream.summary()} -> Utf8`}async pump(){const e=await this.upstream.next();let t,n;return!e.done&&(t=e.value,n=env().get("IS_BROWSER")?this.decoder.decode(t,{stream:!0}):this.decoder.write(Buffer.from(t.buffer)),this.outputQueue.push(n),!0)}},FileChunkIterator=class extends ByteChunkIterator{constructor(e,t={}){super(),this.file=e,this.options=t,util_exports.assert(e instanceof Uint8Array||!!env().get("IS_BROWSER")&&(e instanceof File||e instanceof Blob),(()=>"FileChunkIterator only supports File, Blob and Uint8Array right now.")),this.offset=t.offset||0,this.chunkSize=t.chunkSize||1048576}summary(){return`FileChunks ${this.file}`}async next(){if(this.offset>=(this.file instanceof Uint8Array?this.file.byteLength:this.file.size))return{value:null,done:!0};const e=new Promise(((e,t)=>{const n=this.offset+this.chunkSize;if(this.file instanceof Uint8Array)e(new Uint8Array(this.file.slice(this.offset,n)));else{const a=new FileReader;a.onload=n=>{let r=a.result;if(r instanceof ArrayBuffer&&(r=new Uint8Array(r)),!(r instanceof Uint8Array))return t(new TypeError("FileReader returned unknown type."));e(r)},a.onabort=e=>t(new Error("Aborted")),a.onerror=e=>t(new Error(e.type));const r=this.file.slice(this.offset,n);a.readAsArrayBuffer(r)}this.offset=n}));return{value:await e,done:!1}}};async function urlChunkIterator(e,t={},n){let a,r;"string"==typeof e?a=e:(a=e.url,r=getRequestInitFromRequest(e));const s=await(n||util_exports.fetch)(a,r);if(s.ok){const e=new Uint8Array(await s.arrayBuffer());return new FileChunkIterator(e,t)}throw new Error(s.statusText)}var getRequestInitFromRequest=e=>({method:e.method,headers:e.headers,body:e.body,mode:e.mode,credentials:e.credentials,cache:e.cache,redirect:e.redirect,referrer:e.referrer,integrity:e.integrity});function isLocalPath(e){return"string"==typeof e&&"file://"===e.substr(0,7)}var FileDataSource=class extends DataSource{constructor(e,t={}){super(),this.input=e,this.options=t}async iterator(){if(isLocalPath(this.input)&&env().get("IS_NODE")){const e=__require22("fs");this.input=e.readFileSync(this.input.substr(7))}return new FileChunkIterator(this.input,this.options)}},URLDataSource=class extends DataSource{constructor(e,t={}){super(),this.url=e,this.fileOptions=t}async iterator(){return isLocalPath(this.url)?new FileDataSource(this.url,this.fileOptions).iterator():urlChunkIterator(this.url,this.fileOptions)}};function csv(e,t={}){return new CSVDataset(new URLDataSource(e),t)}function func(e){const t=iteratorFromFunction(e);return datasetFromIteratorFn((async()=>t))}function generator(e){return datasetFromIteratorFn((async()=>{const t=await e();return iteratorFromFunction((()=>t.next()))}))}async function webcam(e,t){return WebcamIterator.create(e,t)}async function microphone(e){return MicrophoneIterator.create(e)}var version4="0.0.0";function assertNotComplex(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&util_exports.assert("complex64"!==e.dtype,(()=>`${t} does not support complex64 tensors in the CPU backend.`))}))}var whereImpl2=kernel_impls_exports.whereImpl,_MathBackendCPU=class extends KernelBackend{constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new DataStorage(this,engine())}nextDataId(){return _MathBackendCPU.nextDataId++}write(e,t,n){this.firstUse&&(this.firstUse=!1,env().get("IS_NODE")&&backend_util_exports.warn("\n============================\nHi there 👋. Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.\n============================"));const a={id:this.nextDataId()};return this.data.set(a,{values:e,dtype:n,refCount:1}),a}makeTensorInfo(e,t,n){let a;if("string"===t&&null!=n&&n.length>0&&util_exports.isString(n[0])){const r=n.map((e=>util_exports.encodeString(e)));a=this.write(r,e,t)}else a=this.write(n,e,t);return{dataId:a,shape:e,dtype:t}}refCount(e){if(this.data.has(e)){return this.data.get(e).refCount}return 0}incRef(e){this.data.get(e).refCount++}decRef(e){if(this.data.has(e)){this.data.get(e).refCount--}}move(e,t,n,a,r){this.data.set(e,{values:t,dtype:a,refCount:r})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){const{dtype:t,complexTensorInfos:n}=this.data.get(e);if("complex64"===t){const e=this.readSync(n.real.dataId),t=this.readSync(n.imag.dataId);return backend_util_exports.mergeRealAndImagArrays(e,t)}return this.data.get(e).values}bufferSync(e){const t=this.readSync(e.dataId);let n=t;if("string"===e.dtype)try{n=t.map((e=>util_exports.decodeString(e)))}catch(e){throw new Error("Failed to decode encoded string bytes into utf-8")}return buffer(e.shape,e.dtype,n)}makeOutput(e,t,n){const a=this.write(e,t,n);return engine().makeTensorFromDataId(a,t,n,this)}disposeData(e,t=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:n}=this.data.get(e);null!=n&&(this.disposeData(n.real.dataId,!0),this.disposeData(n.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){const t=util_exports.now();e();return{kernelMs:util_exports.now()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){assertNotComplex([e],"where");const t=this.readSync(e.dataId);return whereImpl2(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}},MathBackendCPU=_MathBackendCPU;MathBackendCPU.nextDataId=0;var shared_exports={};function simpleAbsImpl(e){const t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t}__export2(shared_exports,{addImpl:()=>addImpl,bincountImpl:()=>bincountImpl,bincountReduceImpl:()=>bincountReduceImpl,ceilImpl:()=>ceilImpl,concatImpl:()=>concatImpl,equalImpl:()=>equalImpl,expImpl:()=>expImpl,expm1Impl:()=>expm1Impl,floorImpl:()=>floorImpl,gatherNdImpl:()=>gatherNdImpl,gatherV2Impl:()=>gatherV2Impl,greaterEqualImpl:()=>greaterEqualImpl,greaterImpl:()=>greaterImpl,lessEqualImpl:()=>lessEqualImpl,lessImpl:()=>lessImpl,linSpaceImpl:()=>linSpaceImpl,logImpl:()=>logImpl,maxImpl:()=>maxImpl,maximumImpl:()=>maximumImpl,minimumImpl:()=>minimumImpl,multiplyImpl:()=>multiplyImpl,negImpl:()=>negImpl,notEqualImpl:()=>notEqualImpl,prodImpl:()=>prodImpl,rangeImpl:()=>rangeImpl,rsqrtImpl:()=>rsqrtImpl,sigmoidImpl:()=>sigmoidImpl,simpleAbsImpl:()=>simpleAbsImpl,sliceImpl:()=>sliceImpl,sparseFillEmptyRowsImpl:()=>sparseFillEmptyRowsImpl,sparseReshapeImpl:()=>sparseReshapeImpl,sparseSegmentReductionImpl:()=>sparseSegmentReductionImpl,sqrtImpl:()=>sqrtImpl,squaredDifferenceImpl:()=>squaredDifferenceImpl,stridedSliceImpl:()=>stridedSliceImpl,stringNGramsImpl:()=>stringNGramsImpl,stringSplitImpl:()=>stringSplitImpl,stringToHashBucketFastImpl:()=>stringToHashBucketFastImpl,subImpl:()=>subImpl,tileImpl:()=>tileImpl,topKImpl:()=>topKImpl,transposeImpl:()=>transposeImpl,uniqueImpl:()=>uniqueImpl});var abs2=e=>{const{x:t}=e.inputs,n=e.backend;assertNotComplex(t,"abs");let a=new Float32Array(util_exports.sizeFromShape(t.shape));return a=simpleAbsImpl(n.data.get(t.dataId).values),n.makeOutput(a,t.shape,t.dtype)},absConfig={kernelName:Abs,backendName:"cpu",kernelFunc:abs2};function createSimpleBinaryKernelImpl(e){return(t,n,a,r,s)=>{const o=backend_util_exports.assertAndGetBroadcastShape(t,n),i=o.length,l=util_exports.computeStrides(o),u=util_exports.sizeFromShape(o),c=util_exports.getTypedArrayFromDType(s,u),d=t.length,p=n.length,h=util_exports.computeStrides(t),m=util_exports.computeStrides(n),f=backend_util_exports.getBroadcastDims(t,o),g=backend_util_exports.getBroadcastDims(n,o);if(f.length+g.length===0)for(let t=0;t<c.length;++t)c[t]=e(a[t%a.length],r[t%r.length]);else for(let t=0;t<c.length;++t){const n=util_exports.indexToLoc(t,i,l),s=n.slice(-d);f.forEach((e=>s[e]=0));const o=util_exports.locToIndex(s,d,h),u=n.slice(-p);g.forEach((e=>u[e]=0));const x=util_exports.locToIndex(u,p,m);c[t]=e(a[o],r[x])}return[c,o]}}function complex2(e){const{inputs:t,backend:n}=e,{real:a,imag:r}=t,s=n.data.get(a.dataId).values,o=n.data.get(r.dataId).values,i=n.makeTensorInfo(a.shape,"complex64");return n.data.get(i.dataId).complexTensorInfos={real:n.makeTensorInfo(a.shape,"float32",s),imag:n.makeTensorInfo(r.shape,"float32",o)},i}var complexConfig={kernelName:Complex,backendName:"cpu",kernelFunc:complex2};function zeros3(e,t,n="float32"){if("complex64"===n){return complex2({inputs:{real:zeros3(e,t,"float32"),imag:zeros3(e,t,"float32")},backend:e})}const a=util_exports.makeZerosTypedArray(util_exports.sizeFromShape(t),n);return e.makeTensorInfo(t,n,a)}function identity2(e){const{inputs:t,backend:n}=e,{x:a}=t;return n.incRef(a.dataId),{dataId:a.dataId,shape:a.shape,dtype:a.dtype}}var identityConfig={kernelName:Identity,backendName:"cpu",kernelFunc:identity2};function real2(e){const{inputs:t,backend:n}=e,{input:a}=t,r=n.data.get(a.dataId).complexTensorInfos.real,s=n.data.get(r.dataId).values;return n.makeTensorInfo(r.shape,r.dtype,s)}var realConfig={kernelName:Real,backendName:"cpu",kernelFunc:real2};function cast3(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{dtype:s}=a;if("complex64"===s){if("complex64"===r.dtype)return identity2({inputs:{x:r},backend:n});const e=zeros3(n,r.shape,r.dtype),t=cast3({inputs:{x:r},backend:n,attrs:{dtype:"float32"}}),a=complex2({inputs:{real:t,imag:e},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),a}if("complex64"===r.dtype){const e=real2({inputs:{input:r},backend:n}),t=cast3({inputs:{x:e},backend:n,attrs:{dtype:s}});return n.disposeIntermediateTensorInfo(e),t}if(!util_exports.hasEncodingLoss(r.dtype,s)){const e=identity2({inputs:{x:r},backend:n});return{dataId:e.dataId,shape:e.shape,dtype:s}}if("int32"===s){const e=n.data.get(r.dataId).values,t=Int32Array.from(e);return n.makeTensorInfo(r.shape,"int32",t)}if("bool"===s){const e=n.data.get(r.dataId).values,t=util_exports.toTypedArray([0],r.dtype),[a,s]=createSimpleBinaryKernelImpl(((e,t)=>e!==t?1:0))(r.shape,[],e,t,"bool");return n.makeTensorInfo(s,"bool",a)}throw new Error(`Error in Cast: failed to cast ${r.dtype} to ${s}`)}var castConfig={kernelName:Cast,backendName:"cpu",kernelFunc:cast3};function binaryKernelFunc(e,t,n,a){return null==n?({inputs:n,backend:r})=>{const{a:s,b:o}=n,i=r;assertNotComplex([s,o],e);const l=i.data.get(s.dataId).values,u=i.data.get(o.dataId).values,c="string"===s.dtype?backend_util_exports.fromUint8ToStringArray(l):l,d="string"===s.dtype?backend_util_exports.fromUint8ToStringArray(u):u,p=a||s.dtype,[h,m]=t(s.shape,o.shape,c,d,p);return i.makeTensorInfo(m,p,h)}:({inputs:e,backend:r})=>{const{a:s,b:o}=e,i=r;if("complex64"===s.dtype||"complex64"===o.dtype){const e=cast3({inputs:{x:s},backend:i,attrs:{dtype:"complex64"}}),t=i.data.get(e.dataId),a=t.complexTensorInfos.real,r=t.complexTensorInfos.imag,l=i.data.get(a.dataId).values,u=i.data.get(r.dataId).values,c=cast3({inputs:{x:o},backend:i,attrs:{dtype:"complex64"}}),d=i.data.get(c.dataId),p=d.complexTensorInfos.real,h=d.complexTensorInfos.imag,m=i.data.get(p.dataId).values,f=i.data.get(h.dataId).values,[g,x,y]=n(s.shape,o.shape,l,u,m,f),A=i.makeTensorInfo(y,"float32",g),b=i.makeTensorInfo(y,"float32",x),v=complex2({inputs:{real:A,imag:b},backend:i});return i.disposeIntermediateTensorInfo(e),i.disposeIntermediateTensorInfo(c),i.disposeIntermediateTensorInfo(A),i.disposeIntermediateTensorInfo(b),v}{const e=i.data.get(s.dataId).values,n=i.data.get(o.dataId).values,r=a||s.dtype,[l,u]=t(s.shape,o.shape,e,n,r);return i.makeTensorInfo(u,r,l)}}}function createComplexBinaryKernelImpl(e){return(t,n,a,r,s,o)=>{const i=backend_util_exports.assertAndGetBroadcastShape(t,n),l=util_exports.sizeFromShape(i),u=i.length,c=util_exports.computeStrides(i),d=util_exports.getTypedArrayFromDType("float32",l),p=util_exports.getTypedArrayFromDType("float32",l),h=backend_util_exports.getBroadcastDims(t,i),m=backend_util_exports.getBroadcastDims(n,i),f=backend_util_exports.mergeRealAndImagArrays(a,r),g=backend_util_exports.mergeRealAndImagArrays(s,o),x=t.length,y=util_exports.computeStrides(t),A=n.length,b=util_exports.computeStrides(n);if(h.length+m.length===0)for(let t=0;t<d.length;t++){const n=t%f.length,a=t%g.length,r=e(f[2*n],f[2*n+1],g[2*a],g[2*a+1]);d[t]=r.real,p[t]=r.imag}else for(let t=0;t<d.length;t++){const n=util_exports.indexToLoc(t,u,c),a=n.slice(-x);h.forEach((e=>a[e]=0));const r=util_exports.locToIndex(a,x,y),s=n.slice(-A);m.forEach((e=>s[e]=0));const o=util_exports.locToIndex(s,A,b),i=e(f[2*r],f[2*r+1],g[2*o],g[2*o+1]);d[t]=i.real,p[t]=i.imag}return[d,p,i]}}var addImpl=createSimpleBinaryKernelImpl(((e,t)=>e+t)),addComplexImpl=createComplexBinaryKernelImpl(((e,t,n,a)=>({real:e+n,imag:t+a}))),add4=binaryKernelFunc(Add,addImpl,addComplexImpl),addConfig={kernelName:Add,backendName:"cpu",kernelFunc:add4};function bincountImpl(e,t,n,a,r){const s=util_exports.sizeFromShape(a),o=util_exports.makeZerosTypedArray(r,n);for(let n=0;n<e.length;n++){const a=e[n];if(a<0)throw new Error("Input x must be non-negative!");a>=r||(o[a]+=s>0?t[n]:1)}return o}function bincountReduceImpl(e,t,n,a=!1){const r=e.shape[0],s=e.shape[1],o=buffer([r,n],t.dtype);for(let i=0;i<r;i++)for(let r=0;r<s;r++){const s=e.get(i,r);if(s<0)throw new Error("Input x must be non-negative!");s>=n||(a?o.set(1,i,s):t.size>0?o.set(o.get(i,s)+t.get(i,r),i,s):o.set(o.get(i,s)+1,i,s))}return o}function createSimpleUnaryImpl(e){return(t,n,a)=>{const r=util_exports.getTypedArrayFromDType(n,t.length);for(let n=0;n<t.length;++n)r[n]=e(t[n],a);return r}}function unaryKernelFunc(e,t,n){return({inputs:a,attrs:r,backend:s})=>{const{x:o}=a;if(assertNotComplex(o,e),"string"===o.dtype||"string"===n)throw new Error("unaryKernelFunc does not support string input/output");const i=s,l=i.data.get(o.dataId).values,u=util_exports.sizeFromShape(o.shape),c=n||o.dtype,d=util_exports.getArrayFromDType(c,u);for(let e=0;e<u;++e)d[e]=t(l[e],r);return i.makeTensorInfo(o.shape,c,d)}}function unaryKernelFuncFromImpl(e,t,n){return({inputs:a,attrs:r,backend:s})=>{const{x:o}=a;if(assertNotComplex(o,e),"string"===o.dtype||"string"===n)throw new Error("unaryKernelFunc does not support string input/output");const i=s,l=i.data.get(o.dataId).values,u=n||o.dtype,c=t(l,u,r);return i.makeTensorInfo(o.shape,u,c)}}var ceilImpl=createSimpleUnaryImpl((e=>Math.ceil(e))),ceil2=unaryKernelFuncFromImpl(Ceil,ceilImpl),ceilConfig={kernelName:Ceil,backendName:"cpu",kernelFunc:ceil2};function concatImpl(e,t,n,a){const r=util_exports.getArrayFromDType(n,util_exports.sizeFromShape(t));if(a&&"string"!==n){let t=0;e.forEach((e=>{const n=util_exports.sizeFromShape(e.shape);r.set(e.vals,t),t+=n}))}else{let a=0;e.forEach((e=>{const s="string"===n?backend_util_exports.fromUint8ToStringArray(e.vals):e.vals;let o=0;for(let n=0;n<e.shape[0];++n){const i=n*t[1]+a;for(let t=0;t<e.shape[1];++t)r[i+t]=s[o++]}a+=e.shape[1]}))}return r}var equalImpl=createSimpleBinaryKernelImpl(((e,t)=>e===t?1:0)),equal2=binaryKernelFunc(Equal,equalImpl,null,"bool"),equalConfig={kernelName:Equal,backendName:"cpu",kernelFunc:equal2},expImpl=createSimpleUnaryImpl((e=>Math.exp(e))),exp2=unaryKernelFuncFromImpl(Exp,expImpl,"float32"),expConfig={kernelName:Exp,backendName:"cpu",kernelFunc:exp2},expm1Impl=createSimpleUnaryImpl((e=>Math.expm1(e))),expm12=unaryKernelFuncFromImpl(Expm1,expm1Impl),expm1Config={kernelName:Expm1,backendName:"cpu",kernelFunc:expm12},floorImpl=createSimpleUnaryImpl((e=>Math.floor(e))),floor2=unaryKernelFuncFromImpl(Floor,floorImpl),floorConfig={kernelName:Floor,backendName:"cpu",kernelFunc:floor2};function gatherNdImpl(e,t,n,a,r,s,o,i,l){const u=buffer([a,s],n);for(let n=0;n<a;n++){const a=[];let c=0;for(let t=0;t<r;t++){const s=e[n*r+t];c+=s*o[t],a.push(s)}if(c<0||c>=l/s)throw new Error(`Invalid indices: ${a} does not index into ${i}`);for(let e=0;e<s;e++)u.values[n*s+e]=t.get(...t.indexToLoc(c*s+e))}return u}function gatherV2Impl(e,t,n){const a=buffer(n,e.dtype);for(let n=0;n<a.size;++n){const r=a.indexToLoc(n).slice(),s=r[0],o=r[2],i=t.locToIndex([s,o]);r[2]=t.values[i];const l=e.locToIndex(r);a.values[n]=e.values[l]}return a}var greaterImpl=createSimpleBinaryKernelImpl(((e,t)=>e>t?1:0)),greater3=binaryKernelFunc(Greater,greaterImpl,null,"bool"),greaterConfig={kernelName:Greater,backendName:"cpu",kernelFunc:greater3},greaterEqualImpl=createSimpleBinaryKernelImpl(((e,t)=>e>=t?1:0)),greaterEqual2=binaryKernelFunc(GreaterEqual,greaterEqualImpl,null,"bool"),greaterEqualConfig={kernelName:GreaterEqual,backendName:"cpu",kernelFunc:greaterEqual2},lessImpl=createSimpleBinaryKernelImpl(((e,t)=>e<t?1:0)),less3=binaryKernelFunc(Less,lessImpl,null,"bool"),lessConfig={kernelName:Less,backendName:"cpu",kernelFunc:less3},lessEqualImpl=createSimpleBinaryKernelImpl(((e,t)=>e<=t?1:0)),lessEqual2=binaryKernelFunc(LessEqual,lessEqualImpl,null,"bool"),lessEqualConfig={kernelName:LessEqual,backendName:"cpu",kernelFunc:lessEqual2};function linSpaceImpl(e,t,n){const a=(t-e)/(n-1),r=util_exports.makeZerosTypedArray(n,"float32");r[0]=e;for(let e=1;e<r.length;e++)r[e]=r[e-1]+a;return r}var logImpl=createSimpleUnaryImpl((e=>Math.log(e))),log5=unaryKernelFuncFromImpl(Log,logImpl),logConfig={kernelName:Log,backendName:"cpu",kernelFunc:log5};function maxImpl(e,t,n,a){const r=util_exports.getTypedArrayFromDType(a,util_exports.sizeFromShape(n));for(let n=0;n<r.length;++n){const a=n*t;let s=e[a];for(let n=0;n<t;++n){const t=e[a+n];(Number.isNaN(t)||t>s)&&(s=t)}r[n]=s}return r}var maximumImpl=createSimpleBinaryKernelImpl(((e,t)=>Math.max(e,t))),maximum3=binaryKernelFunc(Maximum,maximumImpl),maximumConfig={kernelName:Maximum,backendName:"cpu",kernelFunc:maximum3},minimumImpl=createSimpleBinaryKernelImpl(((e,t)=>Math.min(e,t))),minimum3=binaryKernelFunc(Minimum,minimumImpl),minimumConfig={kernelName:Minimum,backendName:"cpu",kernelFunc:minimum3},multiplyImpl=createSimpleBinaryKernelImpl(((e,t)=>e*t)),multiplyComplexImpl=createComplexBinaryKernelImpl(((e,t,n,a)=>({real:e*n-t*a,imag:e*a+t*n}))),multiply2=binaryKernelFunc(Multiply,multiplyImpl,multiplyComplexImpl),multiplyConfig={kernelName:Multiply,backendName:"cpu",kernelFunc:multiply2};function negImpl(e,t,n){const a=util_exports.createScalarValue(-1,n);return multiplyImpl([],t,a,e,n)}function neg2(e){const{inputs:t,backend:n}=e,{x:a}=t;assertNotComplex(a,"neg");const r=n.data.get(a.dataId).values,[s,o]=negImpl(r,a.shape,a.dtype);return n.makeTensorInfo(o,a.dtype,s)}var negConfig={kernelName:Neg,backendName:"cpu",kernelFunc:neg2},notEqualImpl=createSimpleBinaryKernelImpl(((e,t)=>e!==t?1:0)),notEqual2=binaryKernelFunc(NotEqual,notEqualImpl,null,"bool"),notEqualConfig={kernelName:NotEqual,backendName:"cpu",kernelFunc:notEqual2};function transposeImpl(e,t,n,a,r){const s=t.length,o=util_exports.sizeFromShape(t),i=util_exports.computeStrides(t),l=util_exports.computeStrides(r),u=util_exports.getTypedArrayFromDType(n,util_exports.sizeFromShape(r));for(let t=0;t<o;++t){const n=util_exports.indexToLoc(t,s,i),r=new Array(n.length);for(let e=0;e<r.length;e++)r[e]=n[a[e]];u[util_exports.locToIndex(r,s,l)]=e[t]}return u}function transpose2(e){const{inputs:t,attrs:n,backend:a}=e,{x:r}=t,{perm:s}=n;assertNotComplex(r,"transpose");const o=r.shape.length,i=new Array(o);for(let e=0;e<i.length;e++)i[e]=r.shape[s[e]];const l=transposeImpl(a.data.get(r.dataId).values,r.shape,r.dtype,s,i);return{dataId:a.write(l,i,r.dtype),shape:i,dtype:r.dtype}}var transposeConfig={kernelName:Transpose,backendName:"cpu",kernelFunc:transpose2};function prodImpl(e,t,n,a){const[r,s]=backend_util_exports.computeOutAndReduceShapes(e,a),o=upcastType(t,"int32"),i=util_exports.makeZerosTypedArray(util_exports.sizeFromShape(r),o),l=util_exports.sizeFromShape(s);for(let e=0;e<i.length;++e){const t=e*l;let a=1;for(let e=0;e<l;++e)a*=n[t+e];i[e]=a}return{outVals:i,outShape:r,outDtype:o}}function prod2(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:o}=a;assertNotComplex(r,"prod");const i=r.shape.length,l=util_exports.parseAxisParam(s,r.shape),u=backend_util_exports.getAxesPermutation(l,i);let c=l,d=r;const p=[];null!=u&&(d=transpose2({inputs:{x:r},backend:n,attrs:{perm:u}}),p.push(d),c=backend_util_exports.getInnerMostAxes(c.length,i));const h=n.data.get(d.dataId).values,{outVals:m,outShape:f,outDtype:g}=prodImpl(d.shape,d.dtype,h,c);let x=f;return o&&(x=backend_util_exports.expandShapeToKeepDim(f,l)),p.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(x,g,m)}var prodConfig={kernelName:Prod,backendName:"cpu",kernelFunc:prod2};function rangeImpl(e,t,n,a){if(e===t||e<t&&n<0||t<e&&n>1)return util_exports.makeZerosTypedArray(0,a);const r=Math.abs(Math.ceil((t-e)/n)),s=util_exports.makeZerosTypedArray(r,a);t<e&&1===n&&(n=-1),s[0]=e;for(let e=1;e<s.length;e++)s[e]=s[e-1]+n;return s}var rsqrtImpl=createSimpleUnaryImpl((e=>1/Math.sqrt(e))),rsqrt2=unaryKernelFuncFromImpl(Rsqrt,rsqrtImpl),rsqrtConfig={kernelName:Rsqrt,backendName:"cpu",kernelFunc:rsqrt2},sigmoidImpl=createSimpleUnaryImpl((e=>1/(1+Math.exp(-e)))),sigmoid2=unaryKernelFunc(Sigmoid,(e=>1/(1+Math.exp(-e)))),sigmoidConfig={kernelName:Sigmoid,backendName:"cpu",kernelFunc:sigmoid2};function sliceImpl(e,t,n,a,r){const s=slice_util_exports.isSliceContinous(a,t,n),o=util_exports.sizeFromShape(n),i=util_exports.computeStrides(a);if(s){const n=slice_util_exports.computeFlatOffset(t,i);return"string"===r?e.slice(n,n+o):e.subarray(n,n+o)}const l=buffer(a,r,"string"===r?backend_util_exports.fromUint8ToStringArray(e):e),u=buffer(n,r);for(let e=0;e<u.size;++e){const n=u.indexToLoc(e),a=n.map(((e,n)=>e+t[n]));u.set(l.get(...a),...n)}return"string"===r?backend_util_exports.fromStringArrayToUint8(u.values):u.values}function slice2(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{begin:s,size:o}=a;assertNotComplex(r,"slice");const[i,l]=slice_util_exports.parseSliceParams(r,s,o);slice_util_exports.assertParamsValid(r,i,l);const u=sliceImpl(n.data.get(r.dataId).values,i,l,r.shape,r.dtype);return n.makeTensorInfo(l,r.dtype,u)}var sliceConfig={kernelName:Slice,backendName:"cpu",kernelFunc:slice2};function sparseFillEmptyRowsImpl(e,t,n,a,r,s,o){const i=t[0],l=s[0],u=new Array(l),c=new Array(i),d=t[1];if(0===l){if(0!==i)throw new Error(`Received SparseTensor with denseShape[0] = 0 but\n         indices.shape[0] = ${i}`);return[util_exports.getArrayFromDType(n,0),[0,d],util_exports.getArrayFromDType(r,0),u,c]}let p=!0,h=0;const m=new Array(l).fill(0);for(let t=0;t<i;++t){const n=e[t*d];if(n<0)throw new Error(`indices(${t}, 0) is invalid: ${n} < 0`);if(n>=l)throw new Error(`indices(${t}, 0) is invalid: ${n} >= ${l}`);++m[n],p=p&&n>=h,h=n}let f=!0;for(let e=0;e<l;++e){const t=0===m[e];u[e]=t,f=f&&!t,m[e]=Math.max(m[e],1),e>0&&(m[e]+=m[e-1])}if(f&&p){const t=e,n=a;for(let e=0;e<i;++e)c[e]=e;return[t,[i,d],n,u,c]}{const t=m[l-1],s=util_exports.getArrayFromDType(n,t*d),p=util_exports.getArrayFromDType(r,t),h=new Array(l).fill(0);for(let t=0;t<i;++t){const n=e[t*d],r=h[n],o=(0===n?0:m[n-1])+r;h[n]++;for(let n=0;n<d;++n)s[o*d+n]=e[t*d+n];p[o]=a[t],c[t]=o}for(let e=0;e<l;++e){if(0===h[e]){const t=0===e?0:m[e-1];s[t*d+0]=e;for(let e=1;e<d;++e)s[t*d+e]=0;p[t]=o}}return[s,[t,d],p,u,c]}}function sparseReshapeImpl(e,t,n,a,r){const s=util_exports.sizeFromShape(a),o=t[0],i=r.length,l=[];let u=1,c=-1;for(let e=0;e<i;++e){const t=r[e];if(-1===t){if(-1!==c)throw new Error(`only one output dimension may be -1, not both ${c} and ${e}`);c=e,l.push(1)}else{if(t<0)throw new Error(`size ${e} must be non-negative, not ${t}`);u*=t,l.push(t)}}if(-1!==c){if(u<=0)throw new Error("reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero");const e=Math.trunc(s/u);if(u*e!==s)throw new Error(`Input to reshape is a SparseTensor with ${s}\n          dense values, but the requested shape requires a multiple of ${u}. inputShape=${a} outputShape= ${l}`);l[c]=e}const d=util_exports.sizeFromShape(l);if(d!==s)throw new Error(`Input to reshape is a tensor with ${s} dense values, but the requested shape has ${d}. inputShape=${a} outputShape=${l}`);const p=a.length,h=[];if(p>0){h[p-1]=1;for(let e=p-2;e>=0;--e)h[e]=h[e+1]*a[e+1]}const m=[];if(i>0){m[i-1]=1;for(let e=i-2;e>=0;--e)m[e]=m[e+1]*l[e+1]}const f=util_exports.getArrayFromDType(n,o*i);for(let t=0;t<o;++t){let n=0;for(let a=0;a<p;++a)n+=e[t*p+a]*h[a];for(let e=0;e<i;++e)f[t*i+e]=Math.trunc(n/m[e]),n%=m[e]}return[f,[o,i],l]}function sparseSegmentReductionImpl(e,t,n,a,r,s=!1,o=0){const i=a.length;if(i!==r.length)throw new Error("segmentIds and indices should have same size.");const l=[t[0],e.length/t[0]],u=l[1],c=i>0?r[i-1]+1:0;if(c<0)throw new Error("segment ids must be >= 0");const d=t.slice();d[0]=c;const p=d.reduce(((e,t)=>e*t),1),h=util_exports.getArrayFromDType(n,p);if(0===i)return c>0&&h.fill(o),[h,d];if(c<=0)throw new Error("segment ids must be >= 0");let m=0,f=1,g=0,x=r[m];for(;;){let t=0;if(f<i){if(t=r[f],x===t){++f;continue}if(x>=t)throw new Error("segment ids are not increasing")}if(x<0||x>=c)throw new Error(`Segment id ${x} out of range [0, ${c}), possibly because segmentIds input is not sorted.`);x>g&&h.fill(o,g*u,x*u);for(let t=m;t<f;++t){const n=a[t];if(n<0||n>=l[0])throw new Error(`Bad: indices[${t}] == ${a[t]} out of range [0, ${l[0]})`);for(let t=0;t<u;t++)h[x*u+t]+=e[n*u+t]}if(s)for(let e=0;e<u;e++)h[x*u+e]/=f-m;if(m=f,++f,g=x+1,x=t,f>i)break}return g<c&&h.fill(o,g*u,c*u),[h,d]}var sqrtImpl=createSimpleUnaryImpl((e=>Math.sqrt(e))),sqrt2=unaryKernelFunc(Sqrt,(e=>Math.sqrt(e))),sqrtConfig={kernelName:Sqrt,backendName:"cpu",kernelFunc:sqrt2},squaredDifferenceImpl=createSimpleBinaryKernelImpl(((e,t)=>{const n=e-t;return n*n})),squaredDifference2=binaryKernelFunc(SquaredDifference,squaredDifferenceImpl),squaredDifferenceConfig={kernelName:SquaredDifference,backendName:"cpu",kernelFunc:squaredDifference2};function stridedSliceImpl(e,t,n,a){const r=buffer(e,t.dtype);for(let e=0;e<r.size;e++){const s=r.indexToLoc(e),o=new Array(s.length);for(let e=0;e<o.length;e++)o[e]=s[e]*n[e]+a[e];r.set(t.get(...o),...s)}return r}var StringNGramsOp=class{constructor(e,t,n,a,r,s){this.separator=util_exports.encodeString(e),this.nGramWidths=t,this.leftPad=util_exports.encodeString(n),this.rightPad=util_exports.encodeString(a),this.padWidth=r,this.preserveShort=s}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,a,r,s){for(let o=0;o<r;++o){const i=this.getPadWidth(s),l=Math.max(0,i-o),u=Math.max(0,i-(r-(o+1))),c=s-(l+u),d=t+(l>0?0:o-i);let p=0;p+=l*this.leftPad.length;for(let t=0;t<c;++t)p+=e[d+t].length;p+=u*this.rightPad.length;p+=(l+u+c-1)*this.separator.length,n[a+o]=new Uint8Array(p);const h=n[a+o];let m=0;const f=e=>e.forEach((e=>h[m++]=e));for(let e=0;e<l;++e)f(this.leftPad),f(this.separator);for(let t=0;t<c-1;++t)f(e[d+t]),f(this.separator);if(c>0){f(e[d+c-1]);for(let e=0;e<u;++e)f(this.separator),f(this.rightPad)}else{for(let e=0;e<u-1;++e)f(this.rightPad),f(this.separator);f(this.rightPad)}}}compute(e,t){const n=e.length,a=t.length;if(a>0){let e=t[0];if(0!==e)throw new Error(`First split value must be 0, got ${e}`);for(let r=1;r<a;++r){let a=t[r]>=e;if(a=a&&t[r]<=n,!a)throw new Error(`Invalid split value ${t[r]}, must be in [${e}, ${n}]`);e=t[r]}if(e!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${e}`)}const r=a-1,s=util_exports.getArrayFromDType("int32",a);if(0===n||0===a){const e=new Array(n);for(let e=0;e<=r;++e)s[e]=0;return[e,s]}s[0]=0;for(let e=1;e<=r;++e){const n=t[e]-t[e-1];let a=0;this.nGramWidths.forEach((e=>{a+=this.getNumNGrams(n,e)})),this.preserveShort&&n>0&&0===a&&(a=1),s[e]=s[e-1]+a}const o=new Array(s[r]);for(let n=0;n<r;++n){const a=t[n];let r=s[n];if(this.nGramWidths.forEach((s=>{const i=t[n+1]-t[n],l=this.getNumNGrams(i,s);this.createNGrams(e,a,o,r,l,s),r+=l})),this.preserveShort&&r===s[n]){const s=t[n+1]-t[n];if(0===s)continue;const i=s+2*this.padWidth,l=1;this.createNGrams(e,a,o,r,l,i)}}return[o,s]}};function stringNGramsImpl(e,t,n,a,r,s,o,i){return new StringNGramsOp(n,a,r,s,o,i).compute(e,t)}function split3(e,t,n,a){if(!e.length)return;if(0===t.length){for(let t=0;t<e.length;++t)a.push(e.subarray(t,t+1));return}if(1===t.length){const r=t[0];let s=e.indexOf(r);for(;-1!==s;){const t=e.subarray(0,s);n&&0===t.length||a.push(t),s=(e=e.subarray(s+1)).indexOf(r)}return void(n&&0===e.length||a.push(e))}let r=0;for(let s=0;s<e.length+1;s++)if(s===e.length||-1!==t.indexOf(e[s])){const t=e.subarray(r,s);n&&0===t.length||a.push(t),r=s+1}}function stringSplitImpl(e,t,n){const a=e.length,r=[];let s=0,o=0;const i=new Array(a);for(let l=0;l<a;++l){const a=r.length;split3(e[l],t,n,r);const u=r.length-a;i[l]=u,s+=u,o=Math.max(o,u)}const l=util_exports.getArrayFromDType("int32",2*s),u=new Array(s),c=[a,o];let d=0;for(let e=0;e<a;++e)for(let t=0;t<i[e];++t)l[2*d]=e,l[2*d+1]=t,u[d]=r[d],++d;return[l,u,c]}function stringToHashBucketFastImpl(e,t){const n=util_exports.getArrayFromDType("int32",e.length);for(let a=0;a<e.length;++a)n[a]=util_exports.fingerPrint64(e[a]).modulo(t).getLowBitsUnsigned();return n}var subImpl=createSimpleBinaryKernelImpl(((e,t)=>e-t)),subComplexImpl=createComplexBinaryKernelImpl(((e,t,n,a)=>({real:e-n,imag:t-a}))),sub2=binaryKernelFunc(Sub,subImpl,subComplexImpl),subConfig={kernelName:Sub,backendName:"cpu",kernelFunc:sub2};function tileImpl(e,t){const n=new Array(e.rank);for(let a=0;a<n.length;a++)n[a]=e.shape[a]*t[a];const a=buffer(n,e.dtype);for(let t=0;t<a.values.length;++t){const n=a.indexToLoc(t),r=new Array(e.rank);for(let t=0;t<r.length;t++)r[t]=n[t]%e.shape[t];const s=e.locToIndex(r);a.values[t]=e.values[s]}return a}var comparePair=(e,t)=>{const n=t.value-e.value;return 0===n?e.index-t.index:n};function select(e,t,n=0,a=e.length-1){for(;a>n;){if(a-n>600){const r=a-n+1,s=t-n+1,o=Math.log(r),i=.5*Math.exp(2*o/3),l=.5*Math.sqrt(o*i*(r-i)/r)*Math.sign(s-r/2);select(e,t,Math.max(n,Math.floor(t-s*i/r+l)),Math.min(a,Math.floor(t+(r-s)*i/r+l)))}const r=e[t];let s=n,o=a;for(util_exports.swap(e,n,t),comparePair(e[a],r)>0&&util_exports.swap(e,n,a);s<o;){for(util_exports.swap(e,s,o),s++,o--;comparePair(e[s],r)<0;)s+=1;for(;comparePair(e[o],r)>0;)o-=1}0===comparePair(e[n],r)?util_exports.swap(e,n,o):(o+=1,util_exports.swap(e,o,a)),o<=t&&(n=o+1),t<=o&&(a=o-1)}}function topKImpl(e,t,n,a,r){const s=t[t.length-1],[o,i]=[e.length/s,s],l=util_exports.getTypedArrayFromDType(n,o*a),u=util_exports.getTypedArrayFromDType("int32",o*a);for(let t=0;t<o;t++){const n=t*i,s=e.subarray(n,n+i);let o=new Array(s.length);s.forEach(((e,t)=>o[t]={value:e,index:t})),a<o.length&&(select(o,a),o=o.slice(0,a)),r&&o.sort(comparePair);const c=t*a,d=l.subarray(c,c+a),p=u.subarray(c,c+a);for(let e=0;e<a;e++)d[e]=o[e].value,p[e]=o[e].index}const c=t.slice();return c[c.length-1]=a,[buffer(c,n,l),buffer(c,"int32",u)]}function uniqueImpl(e,t,n,a){const r=util_exports.parseAxisParam(t,n)[0],s=[1,n[0],1];for(let e=0;e<r;e++)s[0]*=n[e];s[1]=n[r];for(let e=r+1;e<n.length;e++)s[2]*=n[e];const o={},i=new Int32Array(n[r]),l=new TensorBuffer(s,a,e),u=[],c=1===s[0]&&1===s[2];for(let t=0;t<n[r];t++){let n;if(c)n=e[t].toString();else{const e=[];for(let n=0;n<s[0];n++)for(let a=0;a<s[2];a++)e.push(l.get(n,t,a));n=e.join(",")}if(void 0!==o[n])i[t]=o[n];else{const e=Object.keys(o).length;o[n]=e,i[t]=e,u.push(t)}}const d=s.slice();d[1]=Object.keys(o).length;const p=new TensorBuffer(d,a);u.forEach(((e,t)=>{for(let n=0;n<s[0];n++)for(let a=0;a<s[2];a++)p.set(l.get(n,e,a),n,t,a)}));const h=n.slice();return h[r]=d[1],{outputValues:p.values,outputShape:h,indices:i}}var version5="0.0.0";registerBackend("cpu",(()=>new MathBackendCPU),1);var elu4=unaryKernelFunc(Elu,(e=>e>=0?e:Math.exp(e)-1)),eluConfig={kernelName:Elu,backendName:"cpu",kernelFunc:elu4};function leakyRelu2(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{alpha:s}=a;assertNotComplex([r],"leakyRelu");const o=util_exports.sizeFromShape(r.shape),i=n.data.get(r.dataId).values,l=util_exports.getTypedArrayFromDType("float32",o);for(let e=0;e<i.length;e++)l[e]=i[e]<0?s*i[e]:i[e];return n.makeTensorInfo(r.shape,"float32",l)}var leakyReluConfig={kernelName:LeakyRelu,backendName:"cpu",kernelFunc:leakyRelu2},preluImpl=createSimpleBinaryKernelImpl(((e,t)=>e<0?t*e:e));function prelu3(e){const{inputs:t,backend:n}=e,{x:a,alpha:r}=t;assertNotComplex([a,r],"prelu");const s=n.data.get(a.dataId).values,o=n.data.get(r.dataId).values,[i,l]=preluImpl(a.shape,r.shape,s,o,"float32");return n.makeTensorInfo(l,"float32",i)}var preluConfig={kernelName:Prelu,backendName:"cpu",kernelFunc:prelu3},relu2=unaryKernelFunc(Relu,(e=>Math.max(0,e))),reluConfig={kernelName:Relu,backendName:"cpu",kernelFunc:relu2},relu62=unaryKernelFunc(Relu6,(e=>Math.min(Math.max(0,e),6))),relu6Config={kernelName:Relu6,backendName:"cpu",kernelFunc:relu62};function applyActivation2(e,t,n,a,r){if("linear"===n)return identity2({inputs:{x:t},backend:e});if("relu"===n)return relu2({inputs:{x:t},backend:e});if("elu"===n)return elu4({inputs:{x:t},backend:e});if("relu6"===n)return relu62({inputs:{x:t},backend:e});if("prelu"===n)return prelu3({inputs:{x:t,alpha:a},backend:e});if("leakyrelu"===n)return leakyRelu2({inputs:{x:t},backend:e,attrs:{alpha:r}});if("sigmoid"===n)return sigmoid2({inputs:{x:t},backend:e});throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}function reshape3(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{shape:s}=a,o=util_exports.sizeFromShape(r.shape),i=util_exports.inferFromImplicitShape(s,o),l=util_exports.sizeFromShape(i);util_exports.assert(o===l,(()=>`The new shape (${i}) has ${l} elements and the old shape (${r.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`)),n.incRef(r.dataId);const u=n.data.get(r.dataId);if(null!=u.complexTensorInfos){const e=u.complexTensorInfos.real,t=u.complexTensorInfos.imag;e.shape=i,t.shape=i}return{dataId:r.dataId,shape:i,dtype:r.dtype}}var reshapeConfig={kernelName:Reshape,backendName:"cpu",kernelFunc:reshape3};function batchMatMul(e){const{inputs:t,backend:n,attrs:a}=e,{a:r,b:s}=t,{transposeA:o,transposeB:i}=a;assertNotComplex([r,s],"matMul");const l=r.shape.length,u=s.shape.length,c=o?r.shape[l-2]:r.shape[l-1],d=i?s.shape[u-1]:s.shape[u-2],p=o?r.shape[l-1]:r.shape[l-2],h=i?s.shape[u-2]:s.shape[u-1],m=r.shape.slice(0,-2),f=s.shape.slice(0,-2),g=util_exports.sizeFromShape(m),x=util_exports.sizeFromShape(f),y=broadcast_util_exports.assertAndGetBroadcastShape(r.shape.slice(0,-2),s.shape.slice(0,-2)).concat([p,h]);util_exports.assert(c===d,(()=>`Error in matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${r.shape} and ${s.shape} and transposeA=${o} and transposeB=${i} must match.`));const A=i?[x,h,d]:[x,d,h],b=reshape3({inputs:{x:r},backend:n,attrs:{shape:o?[g,c,p]:[g,p,c]}}),v=reshape3({inputs:{x:s},backend:n,attrs:{shape:A}}),k=o?b.shape[1]:b.shape[2],S=o?b.shape[2]:b.shape[1],w=i?v.shape[1]:v.shape[2],C=Math.max(g,x),I=n.data.get(b.dataId).values,T=n.data.get(v.dataId).values,N=util_exports.computeStrides(b.shape),_=util_exports.computeStrides(v.shape),[E,P,R]=o?[N[0],1,N[1]]:[N[0],N[1],1],[M,F,D]=i?[1,_[1],_[0]]:[_[1],1,_[0]],O=S*w,z=buffer([C,S,w],b.dtype),L=z.values,$=n.blockSize;for(let e=0;e<C;e++)for(let t=0;t<S;t+=$)for(let n=0;n<w;n+=$)for(let a=0;a<k;a+=$){const r=Math.min(t+$,S),s=Math.min(n+$,w),o=Math.min(a+$,k);for(let i=t;i<r;i++)for(let t=n;t<s;t++){let n=0;for(let r=a;r<o;r++){const a=Math.min(e,g-1)*E,s=Math.min(e,x-1)*D;n+=I[a+i*P+r*R]*T[r*M+t*F+s]}L[e*O+(i*w+t)]+=n}}return n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(v),n.makeTensorInfo(y,z.dtype,z.values)}var batchMatMulConfig={kernelName:BatchMatMul,backendName:"cpu",kernelFunc:batchMatMul};function _fusedMatMul(e){const{inputs:t,backend:n,attrs:a}=e,{a:r,b:s,bias:o,preluActivationWeights:i}=t,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:d}=a;let p,h,m;const f=[];p=batchMatMul({inputs:{a:r,b:s},attrs:{transposeA:l,transposeB:u},backend:n}),o&&(h=add4({inputs:{a:p,b:o},backend:n}),f.push(p),p=h),c&&(m=applyActivation2(n,p,c,i,d),f.push(p),p=m);for(const e of f)n.disposeIntermediateTensorInfo(e);return p}var _fusedMatMulConfig={kernelName:_FusedMatMul,backendName:"cpu",kernelFunc:_fusedMatMul},acos2=unaryKernelFunc(Acos,(e=>Math.acos(e))),acosConfig={kernelName:Acos,backendName:"cpu",kernelFunc:acos2},acosh2=unaryKernelFunc(Acosh,(e=>Math.acosh(e))),acoshConfig={kernelName:Acosh,backendName:"cpu",kernelFunc:acosh2};function addN2(e){const{inputs:t,backend:n}=e,a=t;assertNotComplex(t,"addN");const r=a.map((e=>n.data.get(e.dataId).values)),s=buffer(a[0].shape,a[0].dtype),o=s.values;for(let e=0;e<a.length;e++){const t=r[e];for(let e=0;e<o.length;e++)o[e]+=t[e]}return n.makeTensorInfo(s.shape,s.dtype,s.values)}var addNConfig={kernelName:AddN,backendName:"cpu",kernelFunc:addN2};function all2(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:o}=a;assertNotComplex(r,"all");const i=util_exports.parseAxisParam(s,r.shape);let l=i;const u=backend_util_exports.getAxesPermutation(l,r.shape.length);let c=r;null!=u&&(c=transpose2({inputs:{x:r},backend:n,attrs:{perm:u}}),l=backend_util_exports.getInnerMostAxes(l.length,r.shape.length)),backend_util_exports.assertAxesAreInnerMostDims("all",l,c.shape.length);const[d,p]=backend_util_exports.computeOutAndReduceShapes(c.shape,l),h=util_exports.sizeFromShape(p),m=util_exports.makeZerosTypedArray(util_exports.sizeFromShape(d),c.dtype),f=n.data.get(c.dataId).values;for(let e=0;e<m.length;++e){const t=e*h;let n=f[t];for(let e=0;e<h;++e){const a=f[t+e];n=n&&a}m[e]=n}null!=u&&n.disposeIntermediateTensorInfo(c);const g=n.makeTensorInfo(d,c.dtype,m);if(o){const e=reshape3({inputs:{x:g},backend:n,attrs:{shape:backend_util_exports.expandShapeToKeepDim(d,i)}});return n.disposeIntermediateTensorInfo(g),e}return g}var allConfig={kernelName:All,backendName:"cpu",kernelFunc:all2};function any2(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:o}=a;assertNotComplex(r,"any");const i=util_exports.parseAxisParam(s,r.shape);let l=i;const u=backend_util_exports.getAxesPermutation(l,r.shape.length);let c=r;null!=u&&(c=transpose2({inputs:{x:r},backend:n,attrs:{perm:u}}),l=backend_util_exports.getInnerMostAxes(l.length,r.shape.length)),backend_util_exports.assertAxesAreInnerMostDims("any",l,c.shape.length);const[d,p]=backend_util_exports.computeOutAndReduceShapes(c.shape,l),h=util_exports.sizeFromShape(p),m=util_exports.makeZerosTypedArray(util_exports.sizeFromShape(d),c.dtype),f=n.data.get(c.dataId).values;for(let e=0;e<m.length;++e){const t=e*h;let n=f[t];for(let e=0;e<h;++e){const a=f[t+e];n=n||a}m[e]=n}null!=u&&n.disposeIntermediateTensorInfo(c);const g=n.makeTensorInfo(d,c.dtype,m);if(o){const e=reshape3({inputs:{x:g},backend:n,attrs:{shape:backend_util_exports.expandShapeToKeepDim(d,i)}});return n.disposeIntermediateTensorInfo(g),e}return g}var anyConfig={kernelName:Any,backendName:"cpu",kernelFunc:any2};function argMax2(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s}=a;assertNotComplex(r,"argMax");let o=util_exports.parseAxisParam(s,r.shape);const i=backend_util_exports.getAxesPermutation(o,r.shape.length);let l=r;const u=[];null!=i&&(l=transpose2({inputs:{x:r},backend:n,attrs:{perm:i}}),u.push(l),o=backend_util_exports.getInnerMostAxes(o.length,l.shape.length)),o=[o[0]],backend_util_exports.assertAxesAreInnerMostDims("argMax",o,l.shape.length);const[c,d]=backend_util_exports.computeOutAndReduceShapes(l.shape,o),p=util_exports.sizeFromShape(c),h=util_exports.makeZerosTypedArray(p,"int32"),m=util_exports.sizeFromShape(d),f=n.data.get(l.dataId).values;for(let e=0;e<h.length;++e){const t=e*m;let n=f[t],a=0;for(let e=0;e<m;++e){const r=f[t+e];r>n&&(n=r,a=e)}h[e]=a}return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(c,"int32",h)}var argMaxConfig={kernelName:ArgMax,backendName:"cpu",kernelFunc:argMax2};function argMin2(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s}=a;assertNotComplex(r,"argMin");let o=util_exports.parseAxisParam(s,r.shape);const i=backend_util_exports.getAxesPermutation(o,r.shape.length);let l=r;const u=[];null!=i&&(l=transpose2({inputs:{x:r},backend:n,attrs:{perm:i}}),u.push(l),o=backend_util_exports.getInnerMostAxes(o.length,l.shape.length)),o=[o[0]],backend_util_exports.assertAxesAreInnerMostDims("argMin",o,l.shape.length);const[c,d]=backend_util_exports.computeOutAndReduceShapes(l.shape,o),p=util_exports.sizeFromShape(c),h=util_exports.makeZerosTypedArray(p,"int32"),m=util_exports.sizeFromShape(d),f=n.data.get(l.dataId).values;for(let e=0;e<h.length;++e){const t=e*m;let n=f[t],a=0;for(let e=0;e<m;++e){const r=f[t+e];r<n&&(n=r,a=e)}h[e]=a}return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(c,"int32",h)}var argMinConfig={kernelName:ArgMin,backendName:"cpu",kernelFunc:argMin2},asin2=unaryKernelFunc(Asin,(e=>Math.asin(e))),asinConfig={kernelName:Asin,backendName:"cpu",kernelFunc:asin2},asinh2=unaryKernelFunc(Asinh,(e=>Math.asinh(e))),asinhConfig={kernelName:Asinh,backendName:"cpu",kernelFunc:asinh2},atan3=unaryKernelFunc(Atan,(e=>Math.atan(e))),atanConfig={kernelName:Atan,backendName:"cpu",kernelFunc:atan3},atan2Impl=createSimpleBinaryKernelImpl(((e,t)=>Math.atan2(e,t))),atan22=binaryKernelFunc(Atan2,atan2Impl),atan2Config={kernelName:Atan2,backendName:"cpu",kernelFunc:atan22},atanh2=unaryKernelFunc(Atanh,(e=>Math.atanh(e))),atanhConfig={kernelName:Atanh,backendName:"cpu",kernelFunc:atanh2};function pool2(e,t,n,a,r,s){const o=r.strideHeight,i=r.strideWidth,l=r.dilationHeight,u=r.dilationWidth,c=r.effectiveFilterHeight,d=r.effectiveFilterWidth,p=r.padInfo.top,h=r.padInfo.left,m="max"===s?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,f=buffer(r.outShape,n),g=f.values,x=r.outShape[1]*r.outShape[2]*r.outShape[3],y=r.outShape[2]*r.outShape[3],A=r.outShape[3];for(let t=0;t<r.batchSize;++t){const n=t*x,f=t*a[0];for(let t=0;t<r.inChannels;++t)for(let x=0;x<r.outHeight;++x){const b=x*o-p,v=Math.max(0,b),k=Math.min(r.inHeight,c+b),S=n+x*y;for(let n=0;n<r.outWidth;++n){const o=n*i-h,c=Math.max(0,o),p=Math.min(r.inWidth,d+o);let x=m,y=0,b=0;for(let n=v;n<k;n+=l){const r=f+n*a[1];for(let n=c;n<p;n+=u){const o=e[r+n*a[2]+t];"max"===s&&o>x?x=o:"avg"===s&&(y+=o,b++)}if(isNaN(x))break}g[S+n*A+t]="avg"===s?y/b:x}}}return f}function maxPoolPositions(e,t,n,a,r=!1,s=!1){const o=buffer(a.outShape,"int32"),i=a.strideHeight,l=a.strideWidth,u=a.dilationHeight,c=a.dilationWidth,d=a.effectiveFilterHeight,p=a.effectiveFilterWidth,h=a.padInfo.top,m=a.padInfo.left,f=buffer(t,n,e);for(let e=0;e<a.batchSize;++e)for(let t=0;t<a.inChannels;++t)for(let n=0;n<a.outHeight;++n){const g=n*i-h;let x=g;for(;x<0;)x+=u;const y=Math.min(a.inHeight,d+g);for(let i=0;i<a.outWidth;++i){const d=i*l-m;let h=d;for(;h<0;)h+=c;const A=Math.min(a.inWidth,p+d);let b=Number.NEGATIVE_INFINITY,v=-1;for(let n=x;n<y;n+=u){const o=n-g;for(let i=h;i<A;i+=c){const l=i-d,u=f.get(e,n,i,t);u>b&&(b=u,v=r?s?((e*a.inHeight+n)*a.inWidth+i)*a.inChannels+t:(n*a.inWidth+i)*a.inChannels+t:o*p+l)}}o.set(v,e,n,i,t)}}return o}function pool3d2(e,t,n,a,r,s){const o=r.strideDepth,i=r.strideHeight,l=r.strideWidth,u=r.dilationDepth,c=r.dilationHeight,d=r.dilationWidth,p=r.effectiveFilterDepth,h=r.effectiveFilterHeight,m=r.effectiveFilterWidth,f=r.padInfo.front,g=r.padInfo.top,x=r.padInfo.left,y="max"===s?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,A=buffer(r.outShape,n),b=A.values,v=r.outShape[1]*r.outShape[2]*r.outShape[3]*r.outShape[4],k=r.outShape[2]*r.outShape[3]*r.outShape[4],S=r.outShape[3]*r.outShape[4],w=r.outShape[4];for(let t=0;t<r.batchSize;++t){const n=t*v,A=t*a[0];for(let t=0;t<r.inChannels;++t)for(let v=0;v<r.outDepth;++v){const C=v*o-f;let I=C;for(;I<0;)I+=u;const T=Math.min(r.inDepth,p+C),N=n+v*k;for(let n=0;n<r.outHeight;++n){const o=n*i-g;let p=o;for(;p<0;)p+=c;const f=Math.min(r.inHeight,h+o),v=N+n*S;for(let n=0;n<r.outWidth;++n){const o=n*l-x;let i=o;for(;i<0;)i+=d;const h=Math.min(r.inWidth,m+o),g=v+n*w;let k=y,S=0,C=0;for(let n=I;n<T;n+=u){const r=A+n*a[1];for(let n=p;n<f;n+=c){const o=r+n*a[2];for(let n=i;n<h;n+=d){const r=e[o+n*a[3]+t];if("max"===s&&r>k?k=r:"avg"===s&&(S+=r,C++),isNaN(k))break}if(isNaN(k))break}if(isNaN(k))break}b[g+t]="avg"===s?S/C:k}}}}return A}function maxPool3dPositions(e,t){const n=buffer(t.outShape,"int32"),a=t.strideDepth,r=t.strideHeight,s=t.strideWidth,o=t.dilationDepth,i=t.dilationHeight,l=t.dilationWidth,u=t.effectiveFilterDepth,c=t.effectiveFilterHeight,d=t.effectiveFilterWidth,p=t.padInfo.front,h=t.padInfo.top,m=t.padInfo.left;for(let f=0;f<t.batchSize;++f)for(let g=0;g<t.inChannels;++g)for(let x=0;x<t.outDepth;++x){const y=x*a-p;let A=y;for(;A<0;)A+=o;const b=Math.min(t.inDepth,u+y);for(let a=0;a<t.outHeight;++a){const u=a*r-h;let p=u;for(;p<0;)p+=i;const v=Math.min(t.inHeight,c+u);for(let r=0;r<t.outWidth;++r){const h=r*s-m;let k=h;for(;k<0;)k+=l;const S=Math.min(t.inWidth,d+h);let w=Number.NEGATIVE_INFINITY,C=-1;for(let t=A;t<b;t+=o){const n=t-y;for(let a=p;a<v;a+=i){const r=a-u;for(let s=k;s<S;s+=l){const o=s-h,i=e.get(f,t,a,s,g);i>=w&&(w=i,C=n*c*d+r*c+o)}}}n.set(C,f,x,a,r,g)}}}return n}function avgPool2(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t;assertNotComplex(r,"avgPool");const{filterSize:s,strides:o,pad:i,dimRoundingMode:l}=a;util_exports.assert(backend_util_exports.eitherStridesOrDilationsAreOne(o,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`));const u=backend_util_exports.computePool2DInfo(r.shape,s,o,1,i,l);let c;if(1===u.filterWidth&&1===u.filterHeight&&util_exports.arraysEqual(u.inShape,u.outShape))c=identity2({inputs:{x:r},backend:n});else{const e=n.data.get(r.dataId).values,t=util_exports.computeStrides(r.shape),a=pool2(e,r.shape,r.dtype,t,u,"avg");c=n.makeTensorInfo(u.outShape,r.dtype,a.values)}return c}var avgPoolConfig={kernelName:AvgPool,backendName:"cpu",kernelFunc:avgPool2};function avgPool3D(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:s,strides:o,pad:i,dimRoundingMode:l,dataFormat:u}=a;assertNotComplex(r,"avgPool3d");const c=backend_util_exports.computePool3DInfo(r.shape,s,o,1,i,l,u),d=pool3d2(n.data.get(r.dataId).values,r.shape,r.dtype,util_exports.computeStrides(r.shape),c,"avg");return n.makeTensorInfo(d.shape,"float32",d.values)}var avgPool3DConfig={kernelName:AvgPool3D,backendName:"cpu",kernelFunc:avgPool3D};function avgPool3DGrad(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,{filterSize:o,strides:i,pad:l,dimRoundingMode:u}=a;assertNotComplex([r,s],"avgPool3DGrad");const c=backend_util_exports.computePool3DInfo(s.shape,o,i,1,l,u),d=c.strideDepth,p=c.strideHeight,h=c.strideWidth,m=c.filterDepth,f=c.filterHeight,g=c.filterWidth,x=c.dilationDepth,y=c.dilationHeight,A=c.dilationWidth,b=c.effectiveFilterDepth,v=c.effectiveFilterHeight,k=c.effectiveFilterWidth,S=b-1-c.padInfo.front,w=k-1-c.padInfo.left,C=v-1-c.padInfo.top,I=buffer(s.shape,"float32"),T=1/(m*f*g),N=n.bufferSync(r);for(let e=0;e<c.batchSize;++e)for(let t=0;t<c.inChannels;++t)for(let n=0;n<c.inDepth;++n)for(let a=0;a<c.inHeight;++a)for(let r=0;r<c.inWidth;++r){const s=n-S,o=a-C,i=r-w;let l=0;for(let n=0;n<b;n+=x){const a=(s+n)/d;if(!(a<0||a>=c.outDepth||Math.floor(a)!==a))for(let n=0;n<v;n+=y){const r=(o+n)/p;if(!(r<0||r>=c.outHeight||Math.floor(r)!==r))for(let n=0;n<k;n+=A){const s=(i+n)/h;if(s<0||s>=c.outWidth||Math.floor(s)!==s)continue;l+=N.get(e,a,r,s,t)}}}I.set(l*T,e,n,a,r,t)}return n.makeTensorInfo(I.shape,I.dtype,I.values)}var avgPool3DGradConfig2={kernelName:AvgPool3DGrad,backendName:"cpu",kernelFunc:avgPool3DGrad};function avgPoolGrad2(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,o=s;assertNotComplex([r,s],"avgPoolGrad");const{filterSize:i,strides:l,pad:u}=a,c=backend_util_exports.computePool2DInfo(o.shape,i,l,1,u),d=c.strideHeight,p=c.strideWidth,h=c.filterHeight,m=c.filterWidth,f=c.dilationHeight,g=c.dilationWidth,x=c.effectiveFilterHeight,y=c.effectiveFilterWidth,A=y-1-c.padInfo.left,b=x-1-c.padInfo.top,v=buffer(o.shape,"float32"),k=1/(h*m),S=n.data.get(r.dataId).values,w=buffer(r.shape,"float32",S);for(let e=0;e<c.batchSize;++e)for(let t=0;t<c.inChannels;++t)for(let n=0;n<c.inHeight;++n)for(let a=0;a<c.inWidth;++a){const r=n-b,s=a-A;let o=0;for(let n=0;n<x;n+=f){const a=(r+n)/d;if(!(a<0||a>=c.outHeight||Math.floor(a)!==a))for(let n=0;n<y;n+=g){const r=(s+n)/p;if(r<0||r>=c.outWidth||Math.floor(r)!==r)continue;o+=w.get(e,a,r,t)}}v.set(o*k,e,n,a,t)}return n.makeTensorInfo(v.shape,v.dtype,v.values)}var avgPoolGradConfig2={kernelName:AvgPoolGrad,backendName:"cpu",kernelFunc:avgPoolGrad2};function batchNorm2(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,scale:s,offset:o,mean:i,variance:l}=t;util_exports.assert(i.shape.length===l.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),util_exports.assert(null==o||i.shape.length===o.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),util_exports.assert(null==s||i.shape.length===s.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks.")),assertNotComplex([r,i,l,s,o],"batchNorm");let{varianceEpsilon:u}=a;null==u&&(u=.001);const c=n.data.get(r.dataId).values,d=n.data.get(i.dataId).values,p=n.data.get(l.dataId).values,h=s?n.data.get(s.dataId).values:new Float32Array([1]),m=o?n.data.get(o.dataId).values:new Float32Array([0]),f=new Float32Array(c.length),g=m.length,x=h.length,y=p.length,A=d.length;let b=0,v=0,k=0,S=0;for(let e=0;e<c.length;++e)f[e]=m[b++]+(c[e]-d[v++])*h[k++]/Math.sqrt(p[S++]+u),b>=g&&(b=0),v>=A&&(v=0),k>=x&&(k=0),S>=y&&(S=0);return n.makeTensorInfo(r.shape,r.dtype,f)}var batchNormConfig={kernelName:FusedBatchNorm,backendName:"cpu",kernelFunc:batchNorm2};function batchToSpaceND2(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:s,crops:o}=a;assertNotComplex([r],"batchToSpaceND");const i=s.reduce(((e,t)=>e*t)),l=backend_util_exports.getReshaped(r.shape,s,i),u=backend_util_exports.getPermuted(l.length,s.length),c=backend_util_exports.getReshapedPermuted(r.shape,s,i),d=backend_util_exports.getSliceBeginCoords(o,s.length),p=backend_util_exports.getSliceSize(c,o,s.length),h=reshape3({inputs:{x:r},backend:n,attrs:{shape:l}}),m=transpose2({inputs:{x:h},backend:n,attrs:{perm:u}}),f=reshape3({inputs:{x:m},backend:n,attrs:{shape:c}}),g=slice2({inputs:{x:f},backend:n,attrs:{begin:d,size:p}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(f),g}var batchToSpaceNDConfig={kernelName:BatchToSpaceND,backendName:"cpu",kernelFunc:batchToSpaceND2};function bincount2(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,weights:s}=t,{size:o}=a,i=bincountImpl(n.data.get(r.dataId).values,n.data.get(s.dataId).values,s.dtype,s.shape,o);return n.makeTensorInfo([o],s.dtype,i)}var bincountConfig={kernelName:Bincount,backendName:"cpu",kernelFunc:bincount2};function broadcastArgs2(e){const{inputs:t,backend:n}=e,{s0:a,s1:r}=t,s=n.data.get(a.dataId).values,o=n.data.get(r.dataId).values,i=backend_util_exports.assertAndGetBroadcastShape(Array.from(s),Array.from(o));return n.makeTensorInfo([i.length],"int32",Int32Array.from(i))}var broadcastArgsConfig={kernelName:BroadcastArgs,backendName:"cpu",kernelFunc:broadcastArgs2},clip=unaryKernelFunc(ClipByValue,((e,t)=>{const n=t;return e>n.clipValueMax?n.clipValueMax:e<n.clipValueMin?n.clipValueMin:e})),clipConfig={kernelName:ClipByValue,backendName:"cpu",kernelFunc:clip},complexAbs=e=>{const{x:t}=e.inputs,n=e.backend,a=new Float32Array(util_exports.sizeFromShape(t.shape)),r=n.data.get(t.dataId),s=r.complexTensorInfos.real,o=r.complexTensorInfos.imag,i=n.data.get(s.dataId).values,l=n.data.get(o.dataId).values;for(let e=0;e<i.length;e++){const t=i[e],n=l[e];a[e]=Math.hypot(t,n)}return n.makeOutput(a,t.shape,"float32")},complexAbsConfig={kernelName:ComplexAbs,backendName:"cpu",kernelFunc:complexAbs};function imag2(e){const{inputs:t,backend:n}=e,{input:a}=t,r=n.data.get(a.dataId).complexTensorInfos.imag,s=n.data.get(r.dataId).values;return n.makeTensorInfo(r.shape,r.dtype,s)}var imagConfig={kernelName:Imag,backendName:"cpu",kernelFunc:imag2};function concat2(e){const{inputs:t,backend:n,attrs:a}=e,{axis:r}=a,s=util_exports.parseAxisParam(r,t[0].shape)[0];let o=backend_util_exports.computeOutShape(t.map((e=>e.shape)),s);if(0===util_exports.sizeFromShape(o))return n.makeTensorInfo(o,t[0].dtype,[]);const i=t.filter((e=>util_exports.sizeFromShape(e.shape)>0));if(1===i.length)return identity2({inputs:{x:i[0]},backend:n});const l=i.map((e=>e.shape));if(backend_util_exports.assertParamsConsistent(l,s),"complex64"===i[0].dtype){const e=i.map((e=>real2({inputs:{input:e},backend:n}))),t=i.map((e=>imag2({inputs:{input:e},backend:n}))),a=concat2({inputs:e,backend:n,attrs:{axis:s}}),r=concat2({inputs:t,backend:n,attrs:{axis:s}}),o=complex2({inputs:{real:a,imag:r},backend:n});return e.forEach((e=>n.disposeIntermediateTensorInfo(e))),t.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(r),o}const u=i.map((e=>{const t=util_exports.sizeFromShape(e.shape.slice(s));return reshape3({inputs:{x:e},backend:n,attrs:{shape:[-1,t]}})})),c=u.map((e=>({vals:n.data.get(e.dataId).values,shape:e.shape})));o=backend_util_exports.computeOutShape(u.map((e=>e.shape)),1);const d=1===u[0].shape[0],p=concatImpl(c,o,t[0].dtype,d),h=backend_util_exports.computeOutShape(i.map((e=>e.shape)),s),m=n.makeTensorInfo(h,t[0].dtype,p);return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),m}var concatConfig={kernelName:Concat,backendName:"cpu",kernelFunc:concat2};function conv2D(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:o,pad:i,dataFormat:l,dilations:u,dimRoundingMode:c}=a;assertNotComplex([r,s],"conv2d");const d=backend_util_exports.convertConv2DDataFormat(l),p=backend_util_exports.computeConv2DInfo(r.shape,s.shape,o,u,i,c,!1,d),h=p.filterHeight,m=p.filterWidth,f=p.dilationHeight,g=p.dilationWidth,x=p.padInfo.left,y=p.padInfo.top,A="channelsLast"===p.dataFormat,b=new TensorBuffer(p.outShape,r.dtype),v=util_exports.computeStrides(r.shape),k=util_exports.computeStrides(s.shape),S=v[0],w=A?v[1]:v[2],C=A?v[2]:1,I=A?1:v[1],T=b.strides[0],N=A?b.strides[1]:b.strides[2],_=A?b.strides[2]:1,E=A?1:b.strides[1],P=n.data.get(r.dataId).values,R=n.data.get(s.dataId).values,M=b.values;for(let e=0;e<p.batchSize;++e){const t=e*S,n=e*T;for(let e=0;e<p.outHeight;++e){const a=n+e*N,r=e*p.strideHeight-y;for(let e=0;e<h;++e){const n=r+e*f;if(n<0||n>=p.inHeight)continue;const s=e*k[0],o=t+n*w;for(let e=0;e<p.outWidth;++e){const t=a+e*_,n=e*p.strideWidth-x;for(let e=0;e<m;++e){const a=n+e*g;if(a<0||a>=p.inWidth)continue;const r=o+a*C;let i=s+e*k[1];for(let e=0;e<p.inChannels;++e){const n=P[r+e*I];for(let e=0;e<p.outChannels;++e)M[t+e*E]+=n*R[i+e];i+=p.outChannels}}}}}}return n.makeTensorInfo(b.shape,b.dtype,M)}var conv2DConfig={kernelName:Conv2D,backendName:"cpu",kernelFunc:conv2D};function conv2DBackpropFilter2(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,dy:s}=t,{strides:o,pad:i,dataFormat:l,dimRoundingMode:u,filterShape:c}=a;assertNotComplex([r,s],"conv2dBackpropFilter");const d=backend_util_exports.convertConv2DDataFormat(l),p=backend_util_exports.computeConv2DInfo(r.shape,c,o,1,i,u,!1,d),{strideHeight:h,strideWidth:m,filterHeight:f,filterWidth:g}=p,x="channelsLast"===p.dataFormat,y=new TensorBuffer(p.filterShape,"float32"),A=p.padInfo.left,b=p.padInfo.top,v=n.data.get(r.dataId).values,k=n.data.get(s.dataId).values,S=new TensorBuffer(r.shape,r.dtype,v),w=new TensorBuffer(s.shape,s.dtype,k);for(let e=0;e<f;++e){const t=Math.max(0,Math.ceil((b-e)/h)),n=Math.min(p.outHeight,(p.inHeight+b-e)/h);for(let a=0;a<g;++a){const r=Math.max(0,Math.ceil((A-a)/m)),s=Math.min(p.outWidth,(p.inWidth+A-a)/m);for(let o=0;o<p.inChannels;++o)for(let i=0;i<p.outChannels;++i){let l=0;for(let u=0;u<p.batchSize;++u)for(let c=t;c<n;++c){const t=e+c*h-b;for(let e=r;e<s;++e){const n=a+e*m-A;l+=x?S.get(u,t,n,o)*w.get(u,c,e,i):S.get(u,o,t,n)*w.get(u,i,c,e)}}y.set(l,e,a,o,i)}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}var conv2DBackpropFilterConfig={kernelName:Conv2DBackpropFilter,backendName:"cpu",kernelFunc:conv2DBackpropFilter2};function conv2DBackpropInput2(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:s}=t,{inputShape:o,strides:i,pad:l,dataFormat:u,dimRoundingMode:c}=a;assertNotComplex([r,s],"conv2dBackpropInput");const d=util_exports.computeStrides(s.shape),p=util_exports.computeStrides(r.shape);let h=backend_util_exports.convertConv2DDataFormat(u);const m=backend_util_exports.computeConv2DInfo(o,s.shape,i,1,l,c,!1,h),f=new TensorBuffer(m.inShape,"float32"),g=f.values,x=n.data.get(r.dataId).values,y=n.data.get(s.dataId).values,[A,b,v]=d,{batchSize:k,filterHeight:S,filterWidth:w,inChannels:C,inHeight:I,inWidth:T,outChannels:N,outHeight:_,outWidth:E,strideHeight:P,strideWidth:R}=m;h=m.dataFormat;const M=S-1-m.padInfo.top,F=w-1-m.padInfo.left,D="channelsLast"===h,O=f.strides[0],z=D?f.strides[1]:f.strides[2],L=D?f.strides[2]:1,$=D?1:f.strides[1],B=p[0],V=D?p[1]:p[2],U=D?p[2]:1,G=D?1:p[1];for(let e=0;e<k;++e)for(let t=0;t<C;++t)for(let n=0;n<I;++n){const a=n-M,r=Math.max(0,Math.ceil(a/P)),s=Math.min(_,(S+a)/P);for(let o=0;o<T;++o){const i=o-F,l=Math.max(0,Math.ceil(i/R)),u=Math.min(E,(w+i)/R);let c=0;for(let n=r;n<s;++n){const r=n*P-a;for(let a=l;a<u;++a){const s=B*e+V*n+U*a,o=A*(S-1-r)+b*(w-1-(a*R-i))+v*t;for(let e=0;e<N;++e){c+=x[s+G*e]*y[o+e]}}}g[O*e+z*n+L*o+$*t]=c}}return n.makeTensorInfo(f.shape,f.dtype,f.values)}var conv2DBackpropInputConfig={kernelName:Conv2DBackpropInput,backendName:"cpu",kernelFunc:conv2DBackpropInput2};function conv3D(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:o,pad:i,dilations:l}=a;assertNotComplex([r,s],"conv3d");const u=backend_util_exports.computeConv3DInfo(r.shape,s.shape,o,l,i),{filterDepth:c,filterHeight:d,filterWidth:p,dilationDepth:h,dilationHeight:m,dilationWidth:f,padInfo:g}=u,x=g.front,y=g.left,A=g.top,b=new TensorBuffer(u.outShape,r.dtype),v=n.data.get(r.dataId).values,k=n.data.get(s.dataId).values,S=b.values,w=util_exports.computeStrides(r.shape),C=util_exports.computeStrides(s.shape);for(let e=0;e<u.batchSize;++e){const t=e*w[0],n=e*b.strides[0];for(let e=0;e<u.outDepth;++e){const a=n+e*b.strides[1],r=e*u.strideDepth-x;for(let e=0;e<c;++e){const n=r+e*h;if(n<0||n>=u.inDepth)continue;const s=e*C[0],o=t+n*w[1];for(let e=0;e<u.outHeight;++e){const t=a+e*b.strides[2],n=e*u.strideHeight-A;for(let e=0;e<d;++e){const a=n+e*m;if(a<0||a>=u.inHeight)continue;const r=s+e*C[1],i=o+a*w[2];for(let e=0;e<u.outWidth;++e){const n=t+e*u.outChannels,a=e*u.strideWidth-y;for(let e=0;e<p;++e){const t=a+e*f;if(t<0||t>=u.inWidth)continue;const s=r+e*C[2],o=i+t*u.inChannels;let l=s;for(let e=0;e<u.inChannels;++e){const t=v[o+e];for(let e=0;e<u.outChannels;++e)S[n+e]+=t*k[l+e];l+=u.outChannels}}}}}}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}var conv3DConfig={kernelName:Conv3D,backendName:"cpu",kernelFunc:conv3D};function conv3DBackpropFilterV2(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,dy:s}=t,{strides:o,pad:i,filterShape:l}=a;assertNotComplex([r,s],"conv3dBackpropFilterV2");const u=util_exports.computeStrides(r.shape),c=util_exports.computeStrides(s.shape),d=backend_util_exports.computeConv3DInfo(r.shape,l,o,1,i),p=d.strideDepth,h=d.strideHeight,m=d.strideWidth,f=d.filterDepth,g=d.filterHeight,x=d.filterWidth,y=new TensorBuffer(d.filterShape,"float32"),A=y.values,[b,v,k,S]=y.strides,w=n.data.get(s.dataId).values,[C,I,T,N]=c,_=n.data.get(r.dataId).values,[E,P,R,M]=u,F=d.padInfo.front,D=d.padInfo.left,O=d.padInfo.top;for(let e=0;e<f;++e){const t=Math.max(0,Math.ceil((F-e)/p)),n=Math.min(d.outDepth,(d.inDepth+F-e)/p),a=e*b;for(let r=0;r<g;++r){const s=Math.max(0,Math.ceil((O-r)/h)),o=Math.min(d.outHeight,(d.inHeight+O-r)/h),i=r*v+a;for(let a=0;a<x;++a){const l=Math.max(0,Math.ceil((D-a)/m)),u=Math.min(d.outWidth,(d.inWidth+D-a)/m),c=a*k+i;for(let i=0;i<d.inChannels;++i){const f=i*S+c;for(let c=0;c<d.outChannels;++c){let g=0;for(let f=0;f<d.batchSize;++f){const d=f*E,x=f*C;for(let f=t;f<n;++f){const t=(e+f*p-F)*P+d,n=f*I+x;for(let e=s;e<o;++e){const s=(r+e*h-O)*R+t,o=e*T+n;for(let e=l;e<u;++e){const t=e*N+o;g+=_[(a+e*m-D)*M+s+i]*w[t+c]}}}}A[f+c]=g}}}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}var conv3DBackpropFilterV2Config={kernelName:Conv3DBackpropFilterV2,backendName:"cpu",kernelFunc:conv3DBackpropFilterV2};function conv3DBackpropInputV2(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:s}=t,{pad:o,strides:i,inputShape:l}=a;assertNotComplex([r],"conv3dBackpropInputV2");const u=util_exports.computeStrides(r.shape),c=util_exports.computeStrides(s.shape),d=backend_util_exports.computeConv3DInfo(l,s.shape,i,1,o),p=new TensorBuffer(d.inShape,"float32"),h=p.values,[m,f,g,x]=p.strides,y=n.data.get(r.dataId).values,[A,b,v,k]=u,S=n.data.get(s.dataId).values,[w,C,I,T]=c,{batchSize:N,filterDepth:_,filterHeight:E,filterWidth:P,inChannels:R,inDepth:M,inHeight:F,inWidth:D,outChannels:O,outDepth:z,outHeight:L,outWidth:$,strideDepth:B,strideHeight:V,strideWidth:U}=d,G=_-1-d.padInfo.front,W=E-1-d.padInfo.top,H=P-1-d.padInfo.left;for(let e=0;e<N;++e)for(let t=0;t<R;++t)for(let n=0;n<M;++n){const a=n-G,r=Math.max(0,Math.ceil(a/B)),s=Math.min(z,(_+a)/B);for(let o=0;o<F;++o){const i=o-W,l=Math.max(0,Math.ceil(i/V)),u=Math.min(L,(E+i)/V);for(let c=0;c<D;++c){const d=c-H,p=Math.max(0,Math.ceil(d/U)),N=Math.min($,(P+d)/U);let R=0;for(let n=r;n<s;++n){const r=n*B-a;for(let a=l;a<u;++a){const s=a*V-i;for(let o=p;o<N;++o){const i=A*e+b*n+v*a+k*o,l=w*(_-1-r)+C*(E-1-s)+I*(P-1-(o*U-d))+T*t;for(let e=0;e<O;++e){R+=y[i+e]*S[l+e]}}}}h[m*e+f*n+g*o+x*c+t]=R}}}return n.makeTensorInfo(p.shape,p.dtype,p.values)}var conv3DBackpropInputV2Config={kernelName:Conv3DBackpropInputV2,backendName:"cpu",kernelFunc:conv3DBackpropInputV2},cos2=unaryKernelFunc(Cos,(e=>Math.cos(e))),cosConfig={kernelName:Cos,backendName:"cpu",kernelFunc:cos2},cosh2=unaryKernelFunc(Cosh,(e=>Math.cosh(e))),coshConfig={kernelName:Cosh,backendName:"cpu",kernelFunc:cosh2};function cropAndResize2(e){const{inputs:t,backend:n,attrs:a}=e,{image:r,boxes:s,boxInd:o}=t,{cropSize:i,method:l,extrapolationValue:u}=a,[c,d,p,h]=r.shape,m=s.shape[0],[f,g]=i,x=buffer([m,f,g,h],"float32"),y=n.data.get(s.dataId).values,A=n.data.get(o.dataId).values,b=n.data.get(r.dataId).values,v=util_exports.computeStrides(r.shape),k=util_exports.computeStrides(x.shape);for(let e=0;e<m;e++){const t=4*e,n=y[t],a=y[t+1],r=y[t+2],s=y[t+3],o=A[e];if(o>=c)continue;const i=f>1?(r-n)*(d-1)/(f-1):0,m=g>1?(s-a)*(p-1)/(g-1):0;for(let t=0;t<f;t++){const c=f>1?n*(d-1)+t*i:.5*(n+r)*(d-1);if(c<0||c>d-1)for(let n=0;n<g;n++)for(let a=0;a<h;a++){const r=a+n*k[2]+t*k[1]+e*k[0];x.values[r]=u}else if("bilinear"===l){const n=Math.floor(c),r=Math.ceil(c),i=c-n;for(let l=0;l<g;l++){const c=g>1?a*(p-1)+l*m:.5*(a+s)*(p-1);if(c<0||c>p-1){for(let n=0;n<h;n++){const a=n+l*k[2]+t*k[1]+e*k[0];x.values[a]=u}continue}const d=Math.floor(c),f=Math.ceil(c),y=c-d;for(let a=0;a<h;a++){let s=a+d*v[2]+n*v[1]+o*v[0];const u=b[s];s=a+f*v[2]+n*v[1]+o*v[0];const c=b[s];s=a+d*v[2]+r*v[1]+o*v[0];const p=b[s];s=a+f*v[2]+r*v[1]+o*v[0];const h=u+(c-u)*y,m=p+(b[s]-p)*y;s=a+l*k[2]+t*k[1]+e*k[0],x.values[s]=h+(m-h)*i}}}else for(let n=0;n<g;++n){const r=g>1?a*(p-1)+n*m:.5*(a+s)*(p-1);if(r<0||r>p-1){for(let a=0;a<h;a++){const r=a+n*k[2]+t*k[1]+e*k[0];x.values[r]=u}continue}const i=Math.round(r),l=Math.round(c);for(let a=0;a<h;a++){const r=a+i*v[2]+l*v[1]+o*v[0],s=a+n*k[2]+t*k[1]+e*k[0];x.values[s]=b[r]}}}}return n.makeTensorInfo(x.shape,x.dtype,x.values)}var cropAndResizeConfig={kernelName:CropAndResize,backendName:"cpu",kernelFunc:cropAndResize2};function cumsum2(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,exclusive:o,reverse:i}=a;assertNotComplex(r,"cumsum");const l=backend_util_exports.getAxesPermutation([s],r.shape.length);let u=r;null!=l&&(u=transpose2({inputs:{x:r},backend:n,attrs:{perm:l}}));const c=backend_util_exports.getInnerMostAxes(1,r.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);const d=upcastType(u.dtype,"int32"),p=util_exports.makeZerosTypedArray(util_exports.sizeFromShape(u.shape),d),h=n.data.get(u.dataId).values,m=u.shape[u.shape.length-1],f=i?(e,t)=>e+m-t-1:(e,t)=>e+t;for(let e=0;e<h.length;e+=m)for(let t=0;t<m;t++){const n=f(e,t);if(0===t)p[n]=o?0:h[n];else{const a=f(e,t-1);p[n]=o?h[a]+p[a]:h[n]+p[a]}}const g=n.makeTensorInfo(u.shape,d,p);if(null!=l){const e=transpose2({inputs:{x:g},backend:n,attrs:{perm:backend_util_exports.getUndoAxesPermutation(l)}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(u),e}return g}var cumsumConfig={kernelName:Cumsum,backendName:"cpu",kernelFunc:cumsum2};function denseBincount2(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,weights:s}=t,{size:o,binaryOutput:i}=a;if(1===r.shape.length){const e=bincountImpl(n.data.get(r.dataId).values,n.data.get(s.dataId).values,s.dtype,s.shape,o);return n.makeTensorInfo([o],s.dtype,e)}if(2===r.shape.length){const e=bincountReduceImpl(n.bufferSync(r),n.bufferSync(s),o,i);return n.makeTensorInfo(e.shape,s.dtype,e.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}var denseBincountConfig={kernelName:DenseBincount,backendName:"cpu",kernelFunc:denseBincount2};function depthToSpace2(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockSize:s,dataFormat:o}=a;util_exports.assert("NHWC"===o,(()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${o}`));const i=r.shape[0],l=r.shape[1],u=r.shape[2],c=r.shape[3],d=l*s,p=u*s,h=c/(s*s),m=n.data.get(r.dataId).values,f=new Float32Array(i*d*p*h);let g=0;for(let e=0;e<i;++e)for(let t=0;t<d;++t){const n=Math.floor(t/s),a=t%s;for(let t=0;t<p;++t){const r=Math.floor(t/s),o=(a*s+t%s)*h;for(let t=0;t<h;++t){const a=t+o+c*(r+u*(n+l*e));f[g++]=m[a]}}}return n.makeTensorInfo([i,d,p,h],r.dtype,f)}var depthToSpaceConfig={kernelName:DepthToSpace,backendName:"cpu",kernelFunc:depthToSpace2};function depthwiseConv2dNative(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:o,pad:i,dilations:l,dimRoundingMode:u}=a;assertNotComplex([r,s],"depthwiseConv2DNative");const c=util_exports.computeStrides(r.shape),d=util_exports.computeStrides(s.shape);let p=l;null==p&&(p=[1,1]),util_exports.assert(backend_util_exports.eitherStridesOrDilationsAreOne(o,p),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${p}'`));const h=backend_util_exports.computeConv2DInfo(r.shape,s.shape,o,p,i,u,!0),{filterHeight:m,filterWidth:f,dilationHeight:g,dilationWidth:x,padInfo:y}=h,A=y.left,b=y.top,v=h.outChannels/h.inChannels,k=new TensorBuffer(h.outShape,r.dtype),S=n.data.get(r.dataId).values,w=n.data.get(s.dataId).values,C=k.values;for(let e=0;e<h.batchSize;++e){const t=e*c[0],n=e*k.strides[0];for(let e=0;e<h.outHeight;++e){const a=n+e*k.strides[1],r=e*h.strideHeight-b;for(let e=0;e<m;++e){const n=r+e*g;if(n<0||n>=h.inHeight)continue;const s=e*d[0],o=t+n*c[1];for(let e=0;e<h.outWidth;++e){const t=a+e*k.strides[2],n=e*h.strideWidth-A;for(let e=0;e<f;++e){const a=n+e*x;if(a<0||a>=h.inWidth)continue;const r=s+e*d[1],i=o+a*h.inChannels;let l=t,u=r;for(let e=0;e<h.inChannels;++e){const t=S[i+e];for(let e=0;e<v;++e)C[l+e]+=t*w[u+e];l+=v,u+=v}}}}}}return n.makeTensorInfo(k.shape,k.dtype,k.values)}var depthwiseConv2dNativeConfig={kernelName:DepthwiseConv2dNative,backendName:"cpu",kernelFunc:depthwiseConv2dNative};function depthwiseConv2dNativeBackpropFilter2(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,dy:s}=t,{strides:o,dilations:i,pad:l,dimRoundingMode:u,filterShape:c}=a;assertNotComplex([r,s],"depthwiseConv2dNativeBackpropFilter");const d=backend_util_exports.computeConv2DInfo(r.shape,c,o,i,l,u,!0),{strideHeight:p,strideWidth:h,filterHeight:m,filterWidth:f}=d,g=new TensorBuffer(d.filterShape,"float32"),x=d.padInfo.left,y=d.padInfo.top,A=d.outChannels/d.inChannels,b=n.data.get(r.dataId).values,v=new TensorBuffer(r.shape,r.dtype,b),k=n.data.get(s.dataId).values,S=new TensorBuffer(s.shape,s.dtype,k);for(let e=0;e<m;++e){const t=Math.max(0,Math.ceil((y-e)/p)),n=Math.min(d.outHeight,(d.inHeight+y-e)/p);for(let a=0;a<f;++a){const r=Math.max(0,Math.ceil((x-a)/h)),s=Math.min(d.outWidth,(d.inWidth+x-a)/h);for(let o=0;o<d.outChannels;++o){const i=Math.trunc(o/A),l=o%A;let u=0;for(let l=0;l<d.batchSize;++l)for(let c=t;c<n;++c){const t=e+c*p-y;for(let e=r;e<s;++e){const n=a+e*h-x;u+=v.get(l,t,n,i)*S.get(l,c,e,o)}}g.set(u,e,a,i,l)}}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}var depthwiseConv2dNativeBackpropFilterConfig={kernelName:DepthwiseConv2dNativeBackpropFilter,backendName:"cpu",kernelFunc:depthwiseConv2dNativeBackpropFilter2};function depthwiseConv2dNativeBackpropInput2(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:s}=t,{strides:o,dilations:i,pad:l,dimRoundingMode:u,inputShape:c}=a;assertNotComplex([r,s],"depthwiseConv2DNativeBackpropInput");const d=util_exports.computeStrides(r.shape),p=util_exports.computeStrides(s.shape),h=backend_util_exports.computeConv2DInfo(c,s.shape,o,i,l,u,!0),m=new TensorBuffer(h.inShape,"float32"),f=m.values,[g,x,y]=m.strides,A=n.data.get(r.dataId).values,[b,v,k]=d,S=n.data.get(s.dataId).values,[w,C,I]=p,{batchSize:T,filterHeight:N,filterWidth:_,inChannels:E,inHeight:P,inWidth:R,outChannels:M,outHeight:F,outWidth:D,strideHeight:O,strideWidth:z}=h,L=N-1-h.padInfo.top,$=_-1-h.padInfo.left,B=M/E;for(let e=0;e<T;++e)for(let t=0;t<E;++t)for(let n=0;n<P;++n){const a=n-L,r=Math.max(0,Math.ceil(a/O)),s=Math.min(F,(N+a)/O);for(let o=0;o<R;++o){const i=o-$,l=Math.max(0,Math.ceil(i/z)),u=Math.min(D,(_+i)/z);let c=0;for(let n=r;n<s;++n){const r=n*O-a;for(let a=l;a<u;++a){const s=b*e+v*n+k*a,o=w*(N-1-r)+C*(_-1-(a*z-i))+I*t;for(let e=0;e<B;++e){c+=A[s+(t*B+e)]*S[o+e]}}}f[g*e+x*n+y*o+t]=c}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}var depthwiseConv2dNativeBackpropInputConfig={kernelName:DepthwiseConv2dNativeBackpropInput,backendName:"cpu",kernelFunc:depthwiseConv2dNativeBackpropInput2};function diag2(e){const{inputs:t,backend:n}=e,{x:a}=t,r=util_exports.sizeFromShape(a.shape),s=n.data.get(a.dataId).values,o=buffer([r,r],a.dtype),i=o.values;for(let e=0;e<s.length;e++)i[e*r+e]=s[e];const l=[...a.shape,...a.shape];return n.makeTensorInfo(l,o.dtype,o.values)}var diagConfig={kernelName:Diag,backendName:"cpu",kernelFunc:diag2},dilation2dConfig={kernelName:Dilation2D,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:a,filter:r}=e,{strides:s,pad:o,dilations:i}=n,l=t,u=l.data.get(a.dataId).values,c=a.shape.length,d=l.data.get(r.dataId).values,p=r.shape.length,{batchSize:h,inHeight:m,inWidth:f,inChannels:g,outHeight:x,outWidth:y,padInfo:A,strideHeight:b,strideWidth:v,filterHeight:k,filterWidth:S,dilationHeight:w,dilationWidth:C,outShape:I}=backend_util_exports.computeDilation2DInfo(a.shape,r.shape,s,o,"NHWC",i),T=util_exports.sizeFromShape(I),N=I.length,_=util_exports.getArrayFromDType(a.dtype,T);for(let e=0;e<h;++e)for(let t=0;t<x;++t){const n=t*b-A.top;for(let s=0;s<y;++s){const o=s*v-A.left;for(let i=0;i<g;++i){let l=Number.MIN_SAFE_INTEGER;for(let t=0;t<k;++t){const s=n+t*w;if(s>=0&&s<m)for(let n=0;n<S;++n){const h=o+n*C;if(h>=0&&h<f){const o=util_exports.locToIndex([e,s,h,i],c,util_exports.computeStrides(a.shape)),m=util_exports.locToIndex([t,n,i],p,util_exports.computeStrides(r.shape)),f=u[o]+d[m];f>l&&(l=f)}}}_[util_exports.locToIndex([e,t,s,i],N,util_exports.computeStrides(I))]=l}}}return{dataId:l.write(util_exports.toTypedArray(_,a.dtype),I,a.dtype),shape:I,dtype:a.dtype}}},dilation2dBackpropFilterConfig={kernelName:Dilation2DBackpropFilter,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:a,filter:r,dy:s}=e,{strides:o,pad:i,dilations:l}=n,u=t,c=util_exports.toNestedArray(a.shape,u.data.get(a.dataId).values),d=util_exports.toNestedArray(r.shape,u.data.get(r.dataId).values),{batchSize:p,inHeight:h,inWidth:m,inChannels:f,outHeight:g,outWidth:x,padInfo:y,strideHeight:A,strideWidth:b,filterHeight:v,filterWidth:k,dilationHeight:S,dilationWidth:w,outShape:C}=backend_util_exports.computeDilation2DInfo(a.shape,r.shape,o,i,"NHWC",l);util_exports.assert(s.rank===C.length,(()=>`Error in ${Dilation2DBackpropFilter}, dy must have the same rank as output ${C.length}, but got ${s.rank}`));const I=util_exports.toNestedArray(C,u.data.get(s.dataId).values),T=util_exports.makeZerosNestedTypedArray(r.shape,r.dtype);for(let e=0;e<p;++e)for(let t=0;t<g;++t){const n=t*A-y.top;for(let a=0;a<x;++a){const r=a*b-y.left;for(let s=0;s<f;++s){let o=Number.MIN_SAFE_INTEGER,i=0,l=0;for(let t=0;t<v;++t){const a=n+t*S;if(a>=0&&a<h)for(let n=0;n<k;++n){const u=r+n*w;if(u>=0&&u<m){const r=c[e][a][u][s]+d[t][n][s];r>o&&(o=r,i=t,l=n)}}}T[i][l][s]+=I[e][t][a][s]}}}return{dataId:u.write(util_exports.toTypedArray(T,a.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},dilation2dBackpropInputConfig={kernelName:Dilation2DBackpropInput,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:a,filter:r,dy:s}=e,{strides:o,pad:i,dilations:l}=n,u=t,c=util_exports.toNestedArray(a.shape,u.data.get(a.dataId).values),d=util_exports.toNestedArray(r.shape,u.data.get(r.dataId).values),{batchSize:p,inHeight:h,inWidth:m,inChannels:f,outHeight:g,outWidth:x,padInfo:y,strideHeight:A,strideWidth:b,filterHeight:v,filterWidth:k,dilationHeight:S,dilationWidth:w,outShape:C}=backend_util_exports.computeDilation2DInfo(a.shape,r.shape,o,i,"NHWC",l);util_exports.assert(s.rank===C.length,(()=>`Error in ${Dilation2DBackpropInput}, dy must have the same rank as output ${C.length}, but got ${s.rank}`));const I=util_exports.toNestedArray(C,u.data.get(s.dataId).values),T=util_exports.makeZerosNestedTypedArray(a.shape,a.dtype);for(let e=0;e<p;++e)for(let t=0;t<g;++t){const n=t*A-y.top;for(let a=0;a<x;++a){const r=a*b-y.left;for(let s=0;s<f;++s){let o=Number.MIN_SAFE_INTEGER,i=n<0?0:n,l=r<0?0:r;for(let t=0;t<v;++t){const a=n+t*S;if(a>=0&&a<h)for(let n=0;n<k;++n){const u=r+n*w;if(u>=0&&u<m){const r=c[e][a][u][s]+d[t][n][s];r>o&&(o=r,i=a,l=u)}}}T[e][i][l][s]+=I[e][t][a][s]}}}return{dataId:u.write(util_exports.toTypedArray(T,a.dtype),a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}};function sum3(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:o}=a;let i;assertNotComplex(r,"sum"),i="bool"===r.dtype?cast3({inputs:{x:r},backend:n,attrs:{dtype:"int32"}}):identity2({inputs:{x:r},backend:n});const l=i.shape.length,u=util_exports.parseAxisParam(s,i.shape),c=backend_util_exports.getAxesPermutation(u,l);let d=u,p=i;null!=c&&(p=transpose2({inputs:{x:i},backend:n,attrs:{perm:c}}),d=backend_util_exports.getInnerMostAxes(d.length,l)),backend_util_exports.assertAxesAreInnerMostDims("sum",d,p.shape.length);const[h,m]=backend_util_exports.computeOutAndReduceShapes(p.shape,d);let f=zeros3(n,h,backend_util_exports.upcastType(p.dtype,"int32"));const g=util_exports.sizeFromShape(m),x=n.data.get(f.dataId).values,y=n.data.get(p.dataId).values;for(let e=0;e<x.length;++e){const t=e*g;let n=0;for(let e=0;e<g;++e)n+=y[t+e];x[e]=n}if(o){const e=f;f=reshape3({inputs:{x:f},backend:n,attrs:{shape:backend_util_exports.expandShapeToKeepDim(f.shape,u)}}),n.disposeIntermediateTensorInfo(e)}return n.disposeIntermediateTensorInfo(i),null!=c&&n.disposeIntermediateTensorInfo(p),f}var sumConfig={kernelName:Sum,backendName:"cpu",kernelFunc:sum3};function einsum2(e){const{inputs:t,backend:n,attrs:a}=e,{equation:r}=a,s=t,{allDims:o,summedDims:i,idDims:l}=backend_util_exports.decodeEinsumEquation(r,s.length);backend_util_exports.checkEinsumDimSizes(o.length,l,s);const{path:u,steps:c}=backend_util_exports.getEinsumComputePath(i,l),d=c.length;let p=null,h=o.length;const m=[];for(let e=0;e<d;++e){for(const t of c[e]){const{permutationIndices:e,expandDims:a}=backend_util_exports.getEinsumPermutation(h,l[t]);let r;backend_util_exports.isIdentityPermutation(e)?r=s[t]:(r=transpose2({inputs:{x:s[t]},backend:n,attrs:{perm:e}}),m.push(r));const o=r.shape.slice();for(let e=0;e<a.length;++e)o.splice(a[e],0,1);util_exports.arraysEqual(r.shape,o)||(r=reshape3({inputs:{x:r},backend:n,attrs:{shape:o}}),m.push(r)),null===p?p=r:(p=multiply2({inputs:{a:r,b:p},backend:n}),m.push(p))}e<d-1&&(u[e]>=0&&(p=sum3({inputs:{x:p},backend:n,attrs:{axis:u[e]-(o.length-h),keepDims:!1}}),m.push(p)),h--)}for(const e of m)e!==p&&n.disposeIntermediateTensorInfo(e);return p}var einsumConfig={kernelName:Einsum,backendName:"cpu",kernelFunc:einsum2};function eluGrad(e){const{inputs:t,backend:n}=e,{dy:a,y:r}=t;assertNotComplex([a,r],"eluGrad");const s=new Float32Array(util_exports.sizeFromShape(r.shape)),o=n.data.get(r.dataId).values,i=n.data.get(a.dataId).values;for(let e=0;e<o.length;++e){const t=o[e];s[e]=t>=1?i[e]:i[e]*(t+1)}return n.makeTensorInfo(r.shape,"float32",s)}var eluGradConfig2={kernelName:EluGrad,backendName:"cpu",kernelFunc:eluGrad},p=backend_util_exports.ERF_P,a1=backend_util_exports.ERF_A1,a2=backend_util_exports.ERF_A2,a3=backend_util_exports.ERF_A3,a4=backend_util_exports.ERF_A4,a5=backend_util_exports.ERF_A5,erf2=unaryKernelFunc(Erf,(e=>{const t=Math.sign(e),n=Math.abs(e),a=1/(1+p*n);return t*(1-((((a5*a+a4)*a+a3)*a+a2)*a+a1)*a*Math.exp(-n*n))})),erfConfig={kernelName:Erf,backendName:"cpu",kernelFunc:erf2};function expandDims3(e){const{inputs:t,backend:n,attrs:a}=e,{input:r}=t,{dim:s}=a,o=r.shape.length,i=r.shape.slice();let l=s;return s<0&&(util_exports.assert(-(o+1)<=s,(()=>`Axis must be in the interval [${-(o+1)}, ${o}]`)),l=o+s+1),i.splice(l,0,1),reshape3({inputs:{x:r},backend:n,attrs:{shape:i}})}var expandDimsConfig={kernelName:ExpandDims,backendName:"cpu",kernelFunc:expandDims3},realDivImpl=createSimpleBinaryKernelImpl(((e,t)=>e/t)),div2=binaryKernelFunc(RealDiv,realDivImpl),realDivConfig={kernelName:RealDiv,backendName:"cpu",kernelFunc:div2};function fftBatch(e,t,n){const a=e.shape,r=a[0],s=a[1],o=n.data.get(e.dataId),i=o.complexTensorInfos.real,l=o.complexTensorInfos.imag,u=[r,s],c=util_exports.sizeFromShape(u),d=util_exports.getTypedArrayFromDType("float32",c),p=util_exports.getTypedArrayFromDType("float32",c);for(let e=0;e<r;e++){const a=slice2({inputs:{x:i},backend:n,attrs:{begin:[e,0],size:[1,s]}}),r=slice2({inputs:{x:l},backend:n,attrs:{begin:[e,0],size:[1,s]}}),o=complex2({inputs:{real:a,imag:r},backend:n}),{real:u,imag:c}=fftImpl(o,t,n),h=backend_util_exports.mergeRealAndImagArrays(u,c);for(let t=0;t<s;t++){const n=backend_util_exports.getComplexWithIndex(h,t);d[e*s+t]=n.real,p[e*s+t]=n.imag}n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(o)}const h=n.makeTensorInfo(u,"float32",d),m=n.makeTensorInfo(u,"float32",p),f=complex2({inputs:{real:h,imag:m},backend:n});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(m),f}function fftImpl(e,t,n){const a=util_exports.sizeFromShape(e.shape),r=n.data.get(e.dataId),s=n.data.get(r.complexTensorInfos.real.dataId).values,o=n.data.get(r.complexTensorInfos.imag.dataId).values;if(isExponentOf2(a)){const r=fftRadix2(s,o,a,t,n),i=[e.shape[0],e.shape[1]];if(t){const e=n.makeTensorInfo(i,"float32",r.real),t=n.makeTensorInfo(i,"float32",r.imag),s=n.makeTensorInfo([],"float32",util_exports.createScalarValue(a,"float32")),o=identity2({inputs:{x:s},backend:n}),l=realDivConfig.kernelFunc({inputs:{a:e,b:s},backend:n}),u=realDivConfig.kernelFunc({inputs:{a:t,b:o},backend:n}),c=n.data.get(l.dataId).values,d=n.data.get(u.dataId).values;return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(u),{real:c,imag:d}}return r}{const e=fourierTransformByMatmul(backend_util_exports.mergeRealAndImagArrays(s,o),a,t);return backend_util_exports.splitRealAndImagArrays(e)}}function isExponentOf2(e){return 0==(e&e-1)}function fftRadix2(e,t,n,a,r){if(1===n)return{real:e,imag:t};const s=backend_util_exports.mergeRealAndImagArrays(e,t),o=n/2,i=backend_util_exports.complexWithEvenIndex(s),l=i.real,u=i.imag,c=[l.length],d=r.makeTensorInfo(c,"float32",l),p=r.makeTensorInfo(c,"float32",u),h=complex2({inputs:{real:d,imag:p},backend:r}),m=backend_util_exports.complexWithOddIndex(s),f=m.real,g=m.imag,x=[f.length],y=r.makeTensorInfo(x,"float32",f),A=r.makeTensorInfo(x,"float32",g),b=complex2({inputs:{real:y,imag:A},backend:r}),v=fftRadix2(l,u,o,a,r),k=v.real,S=v.imag,w=[k.length],C=r.makeTensorInfo(w,"float32",k),I=r.makeTensorInfo(w,"float32",S),T=complex2({inputs:{real:C,imag:I},backend:r}),N=fftRadix2(f,g,o,a,r),_=N.real,E=N.imag,P=[_.length],R=r.makeTensorInfo(P,"float32",_),M=r.makeTensorInfo(P,"float32",E),F=complex2({inputs:{real:R,imag:M},backend:r}),D=backend_util_exports.exponents(n,a),O=[D.real.length],z=r.makeTensorInfo(O,"float32",D.real),L=r.makeTensorInfo(O,"float32",D.imag),$=complex2({inputs:{real:z,imag:L},backend:r}),B=multiply2({inputs:{a:$,b:F},backend:r}),V=add4({inputs:{a:T,b:B},backend:r}),U=sub2({inputs:{a:T,b:B},backend:r}),G=real2({inputs:{input:V},backend:r}),W=real2({inputs:{input:U},backend:r}),H=imag2({inputs:{input:V},backend:r}),q=imag2({inputs:{input:U},backend:r}),j=concat2({inputs:[G,W],backend:r,attrs:{axis:0}}),K=concat2({inputs:[H,q],backend:r,attrs:{axis:0}}),X=r.data.get(j.dataId).values,Z=r.data.get(K.dataId).values;return r.disposeIntermediateTensorInfo(d),r.disposeIntermediateTensorInfo(p),r.disposeIntermediateTensorInfo(h),r.disposeIntermediateTensorInfo(y),r.disposeIntermediateTensorInfo(A),r.disposeIntermediateTensorInfo(b),r.disposeIntermediateTensorInfo(C),r.disposeIntermediateTensorInfo(I),r.disposeIntermediateTensorInfo(T),r.disposeIntermediateTensorInfo(R),r.disposeIntermediateTensorInfo(M),r.disposeIntermediateTensorInfo(F),r.disposeIntermediateTensorInfo(z),r.disposeIntermediateTensorInfo(L),r.disposeIntermediateTensorInfo($),r.disposeIntermediateTensorInfo(B),r.disposeIntermediateTensorInfo(V),r.disposeIntermediateTensorInfo(U),r.disposeIntermediateTensorInfo(G),r.disposeIntermediateTensorInfo(H),r.disposeIntermediateTensorInfo(W),r.disposeIntermediateTensorInfo(q),r.disposeIntermediateTensorInfo(j),r.disposeIntermediateTensorInfo(K),{real:X,imag:Z}}function fourierTransformByMatmul(e,t,n){const a=new Float32Array(2*t);for(let r=0;r<t;r++){let s=0,o=0;for(let a=0;a<t;a++){const i=backend_util_exports.exponent(r*a,t,n),l=backend_util_exports.getComplexWithIndex(e,a);s+=l.real*i.real-l.imag*i.imag,o+=l.real*i.imag+l.imag*i.real}n&&(s/=t,o/=t),backend_util_exports.assignToTypedArray(a,s,o,r)}return a}function fft2(e){const{inputs:t,backend:n}=e,{input:a}=t,r=util_exports.sizeFromShape(a.shape),s=a.shape[a.shape.length-1],o=reshape3({inputs:{x:a},backend:n,attrs:{shape:[r/s,s]}}),i=fftBatch(o,!1,n),l=reshape3({inputs:{x:i},backend:n,attrs:{shape:a.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(i),l}var fftConfig={kernelName:FFT,backendName:"cpu",kernelFunc:fft2};function fill2(e){const{backend:t,attrs:n}=e,{shape:a,value:r,dtype:s}=n,o=s||util_exports.inferDtype(r),i=util_exports.getArrayFromDType(o,util_exports.sizeFromShape(a));return fillValues(i,r,o),t.makeTensorInfo(a,o,i)}var fillConfig={kernelName:Fill,backendName:"cpu",kernelFunc:fill2};function fillValues(e,t,n){e.fill(t)}var flipLeftRightConfig={kernelName:FlipLeftRight,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:a}=e,r=n,s=util_exports.getTypedArrayFromDType(a.dtype,util_exports.sizeFromShape(a.shape)),[o,i,l,u]=a.shape,c=r.data.get(a.dataId).values;for(let e=0;e<o;e++){const t=e*l*i*u;for(let e=0;e<i;e++){const n=e*(l*u);for(let e=0;e<l;e++){const a=e*u;for(let r=0;r<u;r++){const o=Math.round(l-e-1),i=t+n+a+r;let d=c[i];if(o>=0&&o<l){d=c[t+n+o*u+r]}s[i]=d}}}}return{dataId:r.write(s,a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}},floorDivImpl=createSimpleBinaryKernelImpl(((e,t)=>Math.floor(e/t))),floorDiv2=binaryKernelFunc(FloorDiv,floorDivImpl,null,"int32"),floorDivConfig={kernelName:FloorDiv,backendName:"cpu",kernelFunc:floorDiv2};function fusedConv2D(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s,bias:o,preluActivationWeights:i}=t,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:p,activation:h,leakyreluAlpha:m}=a;let f=conv2D({inputs:{x:r,filter:s},backend:n,attrs:{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:p}});if(o){const e=f;f=add4({inputs:{a:f,b:o},backend:n}),n.disposeIntermediateTensorInfo(e)}if(h){const e=f;f=applyActivation2(n,f,h,i,m),n.disposeIntermediateTensorInfo(e)}return f}var fusedConv2DConfig={kernelName:FusedConv2D,backendName:"cpu",kernelFunc:fusedConv2D};function fusedDepthwiseConv2D(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s,bias:o,preluActivationWeights:i}=t,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:p,activation:h,leakyreluAlpha:m}=a;let f=depthwiseConv2dNative({inputs:{x:r,filter:s},backend:n,attrs:{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:p}});if(o){const e=f;f=add4({inputs:{a:f,b:o},backend:n}),n.disposeIntermediateTensorInfo(e)}if(h){const e=f;f=applyActivation2(n,f,h,i,m),n.disposeIntermediateTensorInfo(e)}return f}var fusedDepthwiseConv2DConfig={kernelName:FusedDepthwiseConv2D,backendName:"cpu",kernelFunc:fusedDepthwiseConv2D};function gatherNd(e){const{inputs:t,backend:n}=e,{params:a,indices:r}=t,s=util_exports.sizeFromShape(a.shape),o=r.shape,i=o[o.length-1],[l,u,c,d]=backend_util_exports.prepareAndValidate(a,r);if(0===u)return n.makeTensorInfo(l,a.dtype,[]);const p=gatherNdImpl(n.data.get(r.dataId).values,n.bufferSync(a),a.dtype,u,i,c,d,a.shape,s);return n.makeTensorInfo(l,a.dtype,p.values)}var gatherNdConfig={kernelName:GatherNd,backendName:"cpu",kernelFunc:gatherNd};function gatherV2(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,indices:s}=t,{axis:o,batchDims:i}=a;assertNotComplex([r,s],"gatherV2");const l=util_exports.parseAxisParam(o,r.shape)[0],u=n.data.get(s.dataId).values,c=r.shape[l];for(let e=0;e<u.length;++e){const t=u[e];util_exports.assert(t<=c-1&&t>=0,(()=>`GatherV2: the index value ${t} is not in [0, ${c-1}]`))}let d=i;null==i&&(d=0);const p=util_exports.sizeFromShape(s.shape),h=backend_util_exports.segment_util.collectGatherOpShapeInfo(r,s,l,d),m=reshape3({inputs:{x:r},backend:n,attrs:{shape:[h.batchSize,h.outerSize,h.dimSize,h.sliceSize]}}),f=reshape3({inputs:{x:s},backend:n,attrs:{shape:[h.batchSize,p/h.batchSize]}}),g=[h.batchSize,h.outerSize,p/h.batchSize,h.sliceSize],x=n.bufferSync(f),y=gatherV2Impl(n.bufferSync(m),x,g);return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(f),n.makeTensorInfo(h.outputShape,y.dtype,y.values)}var gatherV2Config={kernelName:GatherV2,backendName:"cpu",kernelFunc:gatherV2};function ifft2(e){const{inputs:t,backend:n}=e,{input:a}=t,r=util_exports.sizeFromShape(a.shape),s=a.shape[a.shape.length-1],o=reshape3({inputs:{x:a},backend:n,attrs:{shape:[r/s,s]}}),i=fftBatch(o,!0,n),l=reshape3({inputs:{x:i},backend:n,attrs:{shape:a.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(i),l}var ifftConfig={kernelName:IFFT,backendName:"cpu",kernelFunc:ifft2},isFinite3=unaryKernelFunc(IsFinite,(e=>Number.isFinite(e)?1:0),"bool"),isFiniteConfig={kernelName:IsFinite,backendName:"cpu",kernelFunc:isFinite3},isInf2=unaryKernelFunc(IsInf,(e=>Math.abs(e)===1/0?1:0),"bool"),isInfConfig={kernelName:IsInf,backendName:"cpu",kernelFunc:isInf2},isNaN3=unaryKernelFunc(IsNan,(e=>Number.isNaN(e)?1:0),"bool"),isNaNConfig={kernelName:IsNan,backendName:"cpu",kernelFunc:isNaN3};function linSpace(e){const{backend:t,attrs:n}=e,{start:a,stop:r,num:s}=n,o=linSpaceImpl(a,r,s);return t.makeTensorInfo([o.length],"float32",o)}var linSpaceConfig={kernelName:LinSpace,backendName:"cpu",kernelFunc:linSpace},log1p2=unaryKernelFunc(Log1p,(e=>Math.log1p(e))),log1pConfig={kernelName:Log1p,backendName:"cpu",kernelFunc:log1p2},logicalAndImpl=createSimpleBinaryKernelImpl(((e,t)=>e&&t)),logicalAnd2=binaryKernelFunc(LogicalAnd,logicalAndImpl,null,"bool"),logicalAndConfig={kernelName:LogicalAnd,backendName:"cpu",kernelFunc:logicalAnd2},logicalNot2=unaryKernelFunc(LogicalNot,(e=>e?0:1),"bool"),logicalNotConfig={kernelName:LogicalNot,backendName:"cpu",kernelFunc:logicalNot2},logicalOrImpl=createSimpleBinaryKernelImpl(((e,t)=>e||t)),logicalOr2=binaryKernelFunc(LogicalOr,logicalOrImpl,null,"bool"),logicalOrConfig={kernelName:LogicalOr,backendName:"cpu",kernelFunc:logicalOr2};function lRN(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{depthRadius:s,bias:o,alpha:i,beta:l}=a;assertNotComplex(r,"LRN");const u=r.shape[3],c=u-1,d=n.data.get(r.dataId).values,p=util_exports.sizeFromShape(r.shape),h=new Float32Array(p);function m(e){const t=e%u;let n=e-t+Math.max(0,t-s);const a=e-t+Math.min(t+s,c);let r=0;for(;n<=a;n++){const e=d[n];r+=e*e}return r}for(let e=0;e<p;e++){const t=m(e),n=d[e]*Math.pow(o+i*t,-l);h[e]=n}return n.makeTensorInfo(r.shape,r.dtype,h)}var lRNConfig={kernelName:LRN,backendName:"cpu",kernelFunc:lRN};function lRNGrad(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,y:s,dy:o}=t,{depthRadius:i,bias:l,alpha:u,beta:c}=a;assertNotComplex(o,"LRNGrad");const d=util_exports.sizeFromShape(o.shape),p=o.shape[3],h=n.data.get(o.dataId).values,m=n.data.get(r.dataId).values,f=n.data.get(s.dataId).values,g=new Float32Array(d),x=d;for(let e=0;e<x;e++){const t=e%p,n=e-t+Math.max(0,t-i),a=e-t+Math.min(p,t+i+1);let r=0;for(let e=n;e<a;e++)r+=Math.pow(m[e],2);r=u*r+l;for(let t=n;t<a;t++){let n=-2*u*c*m[t]*f[e]/r;e===t&&(n+=Math.pow(r,-c)),n*=h[e],g[t]+=n}}return n.makeTensorInfo(o.shape,r.dtype,g)}var lRNGradConfig={kernelName:LRNGrad,backendName:"cpu",kernelFunc:lRNGrad};function max3(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{reductionIndices:s,keepDims:o}=a,i=n;let l=r.shape;const u=l.length,c=util_exports.parseAxisParam(s,l);let d=c;const p=backend_util_exports.getAxesPermutation(d,u);let h=i.data.get(r.dataId).values;if(null!=p){const e=new Array(u);for(let t=0;t<e.length;t++)e[t]=l[p[t]];h=transposeImpl(h,l,r.dtype,p,e),d=backend_util_exports.getInnerMostAxes(d.length,u),l=e}assertNotComplex(r,"max"),backend_util_exports.assertAxesAreInnerMostDims("max",d,u);const[m,f]=backend_util_exports.computeOutAndReduceShapes(l,d),g=maxImpl(h,util_exports.sizeFromShape(f),m,r.dtype),x=i.write(g,m,r.dtype);let y=m;if(o){y=backend_util_exports.expandShapeToKeepDim(m,c)}return{dataId:x,shape:y,dtype:r.dtype}}var maxConfig={kernelName:Max,backendName:"cpu",kernelFunc:max3};function maxPool2(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t;assertNotComplex(r,"maxPool");const{filterSize:s,strides:o,pad:i,dimRoundingMode:l}=a;util_exports.assert(backend_util_exports.eitherStridesOrDilationsAreOne(o,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`));const u=backend_util_exports.computePool2DInfo(r.shape,s,o,1,i,l);let c;if(1===u.filterWidth&&1===u.filterHeight&&util_exports.arraysEqual(u.inShape,u.outShape))c=identity2({inputs:{x:r},backend:n});else{const e=n.data.get(r.dataId).values,t=util_exports.computeStrides(r.shape),a=pool2(e,r.shape,r.dtype,t,u,"max");c=n.makeTensorInfo(u.outShape,r.dtype,a.values)}return c}var maxPoolConfig={kernelName:MaxPool,backendName:"cpu",kernelFunc:maxPool2};function maxPool3D(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:s,strides:o,pad:i,dimRoundingMode:l,dataFormat:u}=a;assertNotComplex(r,"maxPool3d");const c=backend_util_exports.computePool3DInfo(r.shape,s,o,1,i,l,u),d=pool3d2(n.data.get(r.dataId).values,r.shape,r.dtype,util_exports.computeStrides(r.shape),c,"max");return n.makeTensorInfo(d.shape,"float32",d.values)}var maxPool3DConfig={kernelName:MaxPool3D,backendName:"cpu",kernelFunc:maxPool3D};function maxPool3DGrad(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,{filterSize:o,strides:i,pad:l,dimRoundingMode:u}=a;assertNotComplex([r,s],"maxPool3DGrad");const c=backend_util_exports.computePool3DInfo(s.shape,o,i,1,l,u),d=maxPool3dPositions(n.bufferSync(s),c),p=c.strideDepth,h=c.strideHeight,m=c.strideWidth,f=c.dilationDepth,g=c.dilationHeight,x=c.dilationWidth,y=c.effectiveFilterDepth,A=c.effectiveFilterHeight,b=c.effectiveFilterWidth,v=y-1-c.padInfo.front,k=b-1-c.padInfo.left,S=A-1-c.padInfo.top,w=buffer(s.shape,"float32"),C=n.bufferSync(r);for(let e=0;e<c.batchSize;++e)for(let t=0;t<c.inChannels;++t)for(let n=0;n<c.inDepth;++n)for(let a=0;a<c.inHeight;++a)for(let r=0;r<c.inWidth;++r){const s=n-v,o=a-S,i=r-k;let l=0;for(let n=0;n<y;n+=f){const a=(s+n)/p;if(!(a<0||a>=c.outDepth||Math.floor(a)!==a))for(let r=0;r<A;r+=g){const s=(o+r)/h;if(!(s<0||s>=c.outHeight||Math.floor(s)!==s))for(let o=0;o<b;o+=x){const u=(i+o)/m;if(u<0||u>=c.outWidth||Math.floor(u)!==u)continue;const p=y*A*b-1-d.get(e,a,s,u,t)===n*A*b+r*b+o?1:0;if(0===p)continue;l+=C.get(e,a,s,u,t)*p}}}w.set(l,e,n,a,r,t)}return n.makeTensorInfo(w.shape,w.dtype,w.values)}var maxPool3DGradConfig2={kernelName:MaxPool3DGrad,backendName:"cpu",kernelFunc:maxPool3DGrad};function maxPoolGrad2(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s,output:o}=t,i=s;assertNotComplex([s,o],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:d}=a,p=backend_util_exports.computePool2DInfo(i.shape,l,u,1,c,d),h=n.data.get(i.dataId).values,m=buffer(p.outShape,i.dtype,maxPoolPositions(h,i.shape,i.dtype,p).values),f=p.strideHeight,g=p.strideWidth,x=p.dilationHeight,y=p.dilationWidth,A=p.effectiveFilterHeight,b=p.effectiveFilterWidth,v=b-1-p.padInfo.left,k=A-1-p.padInfo.top,S=buffer(i.shape,"float32"),w=n.data.get(r.dataId).values,C=buffer(r.shape,"float32",w);for(let e=0;e<p.batchSize;++e)for(let t=0;t<p.inChannels;++t)for(let n=0;n<p.inHeight;++n)for(let a=0;a<p.inWidth;++a){const r=n-k,s=a-v;let o=0;for(let n=0;n<A;n+=x){const a=(r+n)/f;if(!(a<0||a>=p.outHeight||Math.floor(a)!==a))for(let r=0;r<b;r+=y){const i=(s+r)/g;if(i<0||i>=p.outWidth||Math.floor(i)!==i)continue;const l=A*b-1-m.get(e,a,i,t)===n*b+r?1:0;if(0===l)continue;o+=C.get(e,a,i,t)*l}}S.set(o,e,n,a,t)}return n.makeTensorInfo(S.shape,S.dtype,S.values)}var maxPoolGradConfig2={kernelName:MaxPoolGrad,backendName:"cpu",kernelFunc:maxPoolGrad2};function maxPoolWithArgmaxImpl(e,t,n,a,r){const s=pool2(e,t,n,util_exports.computeStrides(t),r,"max"),o=maxPoolPositions(e,t,n,r,!0,a);return[s.values,o.values]}var maxPoolWithArgmaxConfig={kernelName:MaxPoolWithArgmax,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:a}=e,{filterSize:r,strides:s,pad:o,includeBatchInIndex:i}=t,l=n;assertNotComplex(a,"MaxPoolWithArgmax");const u=l.data.get(a.dataId).values,c=backend_util_exports.computePool2DInfo(a.shape,r,s,[1,1],o),[d,p]=maxPoolWithArgmaxImpl(u,a.shape,a.dtype,i,c),h=l.write(d,c.outShape,a.dtype),m=l.write(p,c.outShape,a.dtype);return[{dataId:h,shape:c.outShape,dtype:a.dtype},{dataId:m,shape:c.outShape,dtype:"int32"}]}};function mean2(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:o}=a,i=util_exports.parseAxisParam(s,r.shape),l=backend_util_exports.computeOutAndReduceShapes(r.shape,i)[1],u=util_exports.sizeFromShape(l),c=[],d=n.makeTensorInfo([],"float32",new Float32Array([u]));c.push(d);const p=cast3({inputs:{x:r},backend:n,attrs:{dtype:"float32"}});c.push(p);const h=div2({inputs:{a:p,b:d},backend:n});c.push(h);const m=sum3({inputs:{x:h},backend:n,attrs:{axis:s,keepDims:o}});return c.forEach((e=>n.disposeIntermediateTensorInfo(e))),m}var meanConfig={kernelName:Mean,backendName:"cpu",kernelFunc:mean2};function min3(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:o}=a;assertNotComplex(r,"min");const i=util_exports.parseAxisParam(s,r.shape);let l=i;const u=backend_util_exports.getAxesPermutation(l,r.shape.length);let c=r;null!=u&&(c=transpose2({inputs:{x:r},backend:n,attrs:{perm:u}}),l=backend_util_exports.getInnerMostAxes(l.length,r.shape.length)),backend_util_exports.assertAxesAreInnerMostDims("min",l,c.shape.length);const[d,p]=backend_util_exports.computeOutAndReduceShapes(c.shape,l),h=util_exports.sizeFromShape(p),m=util_exports.makeZerosTypedArray(util_exports.sizeFromShape(d),c.dtype),f=n.data.get(c.dataId).values;for(let e=0;e<m.length;++e){const t=e*h;let n=f[t];for(let e=0;e<h;++e){const a=f[t+e];(Number.isNaN(a)||a<n)&&(n=a)}m[e]=n}null!=u&&n.disposeIntermediateTensorInfo(c);const g=n.makeTensorInfo(d,c.dtype,m);if(o){const e=reshape3({inputs:{x:g},backend:n,attrs:{shape:backend_util_exports.expandShapeToKeepDim(d,i)}});return n.disposeIntermediateTensorInfo(g),e}return g}var minConfig={kernelName:Min,backendName:"cpu",kernelFunc:min3};function mirrorPad2(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{paddings:s,mode:o}=a;assertNotComplex(r,"mirrorPad");const i=s.map(((e,t)=>e[0]+r.shape[t]+e[1])),l=s.map((e=>e[0])),u=s.map(((e,t)=>e[0]+r.shape[t])),c="reflect"===o?0:1,d=n.data.get(r.dataId).values,p=r.shape.length,h=util_exports.computeStrides(r.shape),m=util_exports.sizeFromShape(i),f=i.length,g=util_exports.computeStrides(i),x=util_exports.getTypedArrayFromDType(r.dtype,m);for(let e=0;e<m;e++){let t=util_exports.indexToLoc(e,f,g);for(let e=0;e<f;e++)t[e]<l[e]?t[e]=2*l[e]-t[e]-c:t[e]>=u[e]&&(t[e]=2*(u[e]-1)-t[e]+c);t=t.map(((e,t)=>e-l[t]));const n=util_exports.locToIndex(t,p,h);x[e]=d[n]}return{dataId:n.write(x,i,r.dtype),shape:i,dtype:r.dtype}}var mirrorPadConfig={kernelName:MirrorPad,backendName:"cpu",kernelFunc:mirrorPad2},modImpl=createSimpleBinaryKernelImpl(((e,t)=>{const n=e%t;return e<0&&t<0||e>=0&&t>=0?n:(n+t)%t})),mod2=binaryKernelFunc(Mod,modImpl),modConfig={kernelName:Mod,backendName:"cpu",kernelFunc:mod2},seedrandom4=__toModule(require_seedrandom2());function softmax3(e){const{inputs:t,backend:n,attrs:a}=e,{logits:r}=t,{dim:s}=a,o=r.shape.length;let i=s;if(-1===i&&(i=o-1),i!==o-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${o} and dim was ${i}`);const l=util_exports.parseAxisParam([i],r.shape),u=max3({inputs:{x:r},backend:n,attrs:{reductionIndices:l,keepDims:!1}}),c=backend_util_exports.expandShapeToKeepDim(u.shape,l),d=reshape3({inputs:{x:u},backend:n,attrs:{shape:c}}),p=sub2({inputs:{a:r,b:d},backend:n}),h=exp2({inputs:{x:p},backend:n}),m=sum3({inputs:{x:h},backend:n,attrs:{axis:l,keepDims:!1}}),f=reshape3({inputs:{x:m},backend:n,attrs:{shape:c}}),g=div2({inputs:{a:h,b:f},backend:n});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(f),g}var softmaxConfig={kernelName:Softmax,backendName:"cpu",kernelFunc:softmax3};function multinomial2(e){const{inputs:t,backend:n,attrs:a}=e,{logits:r}=t,{numSamples:s,seed:o,normalized:i}=a;assertNotComplex(r,"multinomial");const l=i?r:softmax3({inputs:{logits:r},backend:n,attrs:{dim:-1}}),u=l.shape[0],c=l.shape[1],d=n.data.get(l.dataId).values,p=[u,s],h=util_exports.makeZerosTypedArray(util_exports.sizeFromShape(p),"int32");for(let e=0;e<u;++e){const t=e*c,n=new Float32Array(c-1);n[0]=d[t];for(let e=1;e<n.length;++e)n[e]=n[e-1]+d[t+e];const a=seedrandom4.alea(o.toString()),r=e*s;for(let e=0;e<s;++e){const t=a();h[r+e]=n.length;for(let a=0;a<n.length;a++)if(t<n[a]){h[r+e]=a;break}}}return i||n.disposeIntermediateTensorInfo(l),n.makeTensorInfo(p,"int32",h)}var multinomialConfig={kernelName:Multinomial,backendName:"cpu",kernelFunc:multinomial2},nonMaxSuppressionV3Impl2=kernel_impls_exports.nonMaxSuppressionV3Impl;function nonMaxSuppressionV3(e){const{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:s}=t,{maxOutputSize:o,iouThreshold:i,scoreThreshold:l}=a;assertNotComplex(r,"NonMaxSuppression");const u=n.data.get(r.dataId).values,c=n.data.get(s.dataId).values,{selectedIndices:d}=nonMaxSuppressionV3Impl2(u,c,o,i,l);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}var nonMaxSuppressionV3Config={kernelName:NonMaxSuppressionV3,backendName:"cpu",kernelFunc:nonMaxSuppressionV3},nonMaxSuppressionV4Impl2=kernel_impls_exports.nonMaxSuppressionV4Impl;function nonMaxSuppressionV4(e){const{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:s}=t,{maxOutputSize:o,iouThreshold:i,scoreThreshold:l,padToMaxOutputSize:u}=a;assertNotComplex(r,"NonMaxSuppressionPadded");const c=n.data.get(r.dataId).values,d=n.data.get(s.dataId).values,{selectedIndices:p,validOutputs:h}=nonMaxSuppressionV4Impl2(c,d,o,i,l,u);return[n.makeTensorInfo([p.length],"int32",new Int32Array(p)),n.makeTensorInfo([],"int32",new Int32Array([h]))]}var nonMaxSuppressionV4Config={kernelName:NonMaxSuppressionV4,backendName:"cpu",kernelFunc:nonMaxSuppressionV4},nonMaxSuppressionV5Impl2=kernel_impls_exports.nonMaxSuppressionV5Impl;function nonMaxSuppressionV5(e){const{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:s}=t,{maxOutputSize:o,iouThreshold:i,scoreThreshold:l,softNmsSigma:u}=a;assertNotComplex(r,"NonMaxSuppressionWithScore");const c=n.data.get(r.dataId).values,d=n.data.get(s.dataId).values,p=o,h=i,m=l,f=u,{selectedIndices:g,selectedScores:x}=nonMaxSuppressionV5Impl2(c,d,p,h,m,f);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([x.length],"float32",new Float32Array(x))]}var nonMaxSuppressionV5Config={kernelName:NonMaxSuppressionV5,backendName:"cpu",kernelFunc:nonMaxSuppressionV5};function oneHot2(e){const{inputs:t,backend:n,attrs:a}=e,{indices:r}=t,{depth:s,onValue:o,offValue:i}=a;assertNotComplex(r,"oneHot");const l=util_exports.sizeFromShape(r.shape),u=new Float32Array(l*s);u.fill(i);const c=n.data.get(r.dataId).values;for(let e=0;e<l;++e)c[e]>=0&&c[e]<s&&(u[e*s+c[e]]=o);return n.makeTensorInfo([...r.shape,s],"int32",u)}var oneHotConfig={kernelName:OneHot,backendName:"cpu",kernelFunc:oneHot2};function zerosLike2(e){const{inputs:t,backend:n}=e,{x:a}=t;if("string"===a.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===a.dtype){const e=real2({inputs:{input:a},backend:n}),t=zerosLike2({inputs:{x:e},backend:n}),r=imag2({inputs:{input:a},backend:n}),s=zerosLike2({inputs:{x:r},backend:n}),o=complex2({inputs:{real:t,imag:s},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(s),o}return fill2({backend:n,attrs:{shape:a.shape,value:0,dtype:a.dtype}})}var zerosLikeConfig={kernelName:ZerosLike,backendName:"cpu",kernelFunc:zerosLike2};function onesLike2(e){const{inputs:t,backend:n}=e,{x:a}=t;if("string"===a.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===a.dtype){const e=real2({inputs:{input:a},backend:n}),t=onesLike2({inputs:{x:e},backend:n}),r=imag2({inputs:{input:a},backend:n}),s=zerosLike2({inputs:{x:r},backend:n}),o=complex2({inputs:{real:t,imag:s},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(s),o}return fill2({backend:n,attrs:{shape:a.shape,value:1,dtype:a.dtype}})}var onesLikeConfig={kernelName:OnesLike,backendName:"cpu",kernelFunc:onesLike2};function pack(e){const{inputs:t,backend:n,attrs:a}=e,{axis:r}=a;if(1===t.length)return expandDims3({inputs:{input:t[0]},backend:n,attrs:{dim:r}});const s=t[0].shape,o=t[0].dtype;t.forEach((e=>{util_exports.assertShapesMatch(s,e.shape,"All tensors passed to stack must have matching shapes"),util_exports.assert(o===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const i=[],l=concat2({inputs:t.map((e=>{const t=expandDims3({inputs:{input:e},backend:n,attrs:{dim:r}});return i.push(t),t})),backend:n,attrs:{axis:r}});return i.forEach((e=>n.disposeIntermediateTensorInfo(e))),l}var packConfig={kernelName:Pack,backendName:"cpu",kernelFunc:pack};function padV2(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{paddings:s,constantValue:o}=a;assertNotComplex(r,"pad");const i=s.map(((e,t)=>e[0]+r.shape[t]+e[1])),l=s.map((e=>e[0])),u=n.data.get(r.dataId).values,c=util_exports.sizeFromShape(r.shape),d=r.shape.length,p=util_exports.computeStrides(r.shape),h=util_exports.sizeFromShape(i),m=i.length,f=util_exports.computeStrides(i),g=util_exports.getTypedArrayFromDType(r.dtype,h);0!==o&&g.fill(o);for(let e=0;e<c;e++){const t=util_exports.indexToLoc(e,d,p).map(((e,t)=>e+l[t]));g[util_exports.locToIndex(t,m,f)]=u[e]}return{dataId:n.write(g,i,r.dtype),shape:i,dtype:r.dtype}}var padV2Config={kernelName:PadV2,backendName:"cpu",kernelFunc:padV2},powImpl=createSimpleBinaryKernelImpl(((e,t)=>Math.pow(e,t))),pow2=binaryKernelFunc(Pow,powImpl),powConfig={kernelName:Pow,backendName:"cpu",kernelFunc:pow2};function range3(e){const{backend:t,attrs:n}=e,{start:a,stop:r,dtype:s,step:o}=n,i=rangeImpl(a,r,o,s);return t.makeTensorInfo([i.length],s,i)}var rangeConfig={kernelName:Range,backendName:"cpu",kernelFunc:range3},reciprocal2=unaryKernelFunc(Reciprocal,(e=>1/e)),reciprocalConfig={kernelName:Reciprocal,backendName:"cpu",kernelFunc:reciprocal2};function resizeBilinear2(e){const{inputs:t,backend:n,attrs:a}=e,{images:r}=t,{alignCorners:s,halfPixelCenters:o,size:i}=a;assertNotComplex(r,"resizeBilinear");const l=util_exports.computeStrides(r.shape),[u,c]=i,[d,p,h,m]=r.shape,f=n.data.get(r.dataId).values,g=new Float32Array(util_exports.sizeFromShape([d,u,c,m])),x=[s&&u>1?p-1:p,s&&c>1?h-1:h],y=[s&&u>1?u-1:u,s&&c>1?c-1:c];let A=0;const b=x[0]/y[0],v=x[1]/y[1];for(let e=0;e<d;e++)for(let t=0;t<u;t++){let n;n=o?b*(t+.5)-.5:b*t;const a=Math.max(0,Math.floor(n)),r=n-a,s=Math.min(p-1,Math.ceil(n)),i=e*l[0]+a*l[1],u=e*l[0]+s*l[1];for(let e=0;e<c;e++){let t;t=o?v*(e+.5)-.5:v*e;const n=Math.max(0,Math.floor(t)),a=t-n,s=Math.min(h-1,Math.ceil(t)),c=i+n*l[2],d=u+n*l[2],p=i+s*l[2],x=u+s*l[2];for(let e=0;e<m;e++){const t=f[c+e],n=f[d+e],s=t+(f[p+e]-t)*a,o=s+(n+(f[x+e]-n)*a-s)*r;g[A++]=o}}}return n.makeTensorInfo([d,u,c,m],"float32",g)}var resizeBilinearConfig={kernelName:ResizeBilinear,backendName:"cpu",kernelFunc:resizeBilinear2};function resizeBilinearGrad(e){const{inputs:t,backend:n,attrs:a}=e,{images:r,dy:s}=t,{alignCorners:o}=a;assertNotComplex([s,r],"resizeBilinearGrad");const i=util_exports.computeStrides(r.shape),[l,u,c,d]=r.shape,[,p,h]=s.shape,m=new Float32Array(l*u*c*d),f=[o&&p>1?u-1:u,o&&h>1?c-1:c],g=[o&&p>1?p-1:p,o&&h>1?h-1:h],x=f[0]/g[0],y=f[1]/g[1],A=n.data.get(s.dataId).values;let b=0;for(let e=0;e<l;e++){const t=e*i[0];for(let e=0;e<p;e++){const n=e*x,a=Math.floor(n),r=Math.min(Math.ceil(n),u-1),s=t+a*i[1],o=t+r*i[1],l=n-a,p=1-l;for(let e=0;e<h;e++){const t=e*y,n=Math.floor(t),a=Math.min(Math.ceil(t),c-1),r=t-n,u=1-r,h=s+n*i[2],f=s+a*i[2],g=o+n*i[2],x=o+a*i[2],v=p*u,k=p*r,S=l*u,w=l*r;for(let e=0;e<d;e++){const t=A[b++];m[h+e]+=t*v,m[f+e]+=t*k,m[g+e]+=t*S,m[x+e]+=t*w}}}}return n.makeTensorInfo([l,c,u,d],"float32",m)}var resizeBilinearGradConfig2={kernelName:ResizeBilinearGrad,backendName:"cpu",kernelFunc:resizeBilinearGrad};function resizeNearestNeighbor2(e){const{inputs:t,backend:n,attrs:a}=e,{images:r}=t,{alignCorners:s,halfPixelCenters:o,size:i}=a;assertNotComplex(r,"resizeNearestNeighbor");const l=util_exports.computeStrides(r.shape),[u,c]=i,[d,p,h,m]=r.shape,f=n.data.get(r.dataId).values,g=new Float32Array(d*u*c*m),x=[s&&u>1?p-1:p,s&&c>1?h-1:h],y=[s&&u>1?u-1:u,s&&c>1?c-1:c],A=x[0]/y[0],b=x[1]/y[1];let v=0;for(let e=0;e<d;e++){const t=e*l[0];for(let e=0;e<u;e++){const n=o?A*(e+.5):A*e;let a=Math.min(p-1,s?Math.round(n):Math.floor(n));o&&(a=Math.max(0,a));const r=t+a*l[1];for(let e=0;e<c;e++){const t=o?b*(e+.5):b*e;let n=Math.min(h-1,s?Math.round(t):Math.floor(t));o&&(n=Math.max(0,n));const a=r+n*l[2];for(let e=0;e<m;e++){const t=f[a+e];g[v++]=t}}}}return n.makeTensorInfo([d,u,c,m],r.dtype,g)}var resizeNearestNeighborConfig={kernelName:ResizeNearestNeighbor,backendName:"cpu",kernelFunc:resizeNearestNeighbor2};function resizeNearestNeighborGrad(e){const{inputs:t,backend:n,attrs:a}=e,{images:r,dy:s}=t,{alignCorners:o}=a;assertNotComplex([s,r],"resizeNearestNeighborGrad");const i=util_exports.computeStrides(r.shape),l=util_exports.computeStrides(s.shape),[u,c,d,p]=r.shape,[,h,m]=s.shape,f=new Float32Array(u*c*d*p),g=n.data.get(s.dataId).values,x=[o&&h>1?c-1:c,o&&m>1?d-1:d],y=[o&&h>1?h-1:h,o&&m>1?m-1:m],A=x[0]/y[0],b=x[1]/y[1],v=1/A,k=1/b,S=2*Math.ceil(v)+2,w=2*Math.ceil(k)+2;for(let e=0;e<u;e++){const t=e*i[0];for(let e=0;e<c;e++){const n=t+e*i[1],a=Math.floor(e*v),r=Math.floor(a-S/2);for(let a=0;a<d;a++){const s=n+a*i[2],u=Math.floor(a*k),x=Math.floor(u-w/2);for(let n=0;n<p;n++){let i=0;for(let s=0;s<S;s++){const u=s+r;if(u<0||u>=h)continue;const p=t+u*l[1],f=u*A;if(e===Math.min(c-1,o?Math.round(f):Math.floor(f)))for(let e=0;e<w;e++){const t=e+x;if(t<0||t>=m)continue;const r=p+t*l[2],s=t*b;a===Math.min(d-1,o?Math.round(s):Math.floor(s))&&(i+=g[r+n])}}f[s+n]=i}}}}return n.makeTensorInfo(r.shape,r.dtype,f)}var resizeNearestNeighborGradConfig2={kernelName:ResizeNearestNeighborGrad,backendName:"cpu",kernelFunc:resizeNearestNeighborGrad};function reverse2(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{dims:s}=a;assertNotComplex(r,"reverse");const o=r.shape.length,i=util_exports.parseAxisParam(s,r.shape);if(0===o)return identity2({inputs:{x:r},backend:n});const l=new TensorBuffer(r.shape,r.dtype),u=n.bufferSync(r);for(let e=0;e<l.size;e++){const t=l.indexToLoc(e),n=t.slice();i.forEach((e=>n[e]=r.shape[e]-1-n[e])),l.set(u.get(...n),...t)}return n.makeTensorInfo(l.shape,l.dtype,l.values)}var reverseConfig={kernelName:Reverse,backendName:"cpu",kernelFunc:reverse2},rotateWithOffsetConfig={kernelName:RotateWithOffset,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:a}=e,{radians:r,fillValue:s,center:o}=t,i=n,l=util_exports.getTypedArrayFromDType(a.dtype,util_exports.sizeFromShape(a.shape)),[u,c,d,p]=a.shape,[h,m]=backend_util_exports.getImageCenter(o,c,d),f=Math.sin(r),g=Math.cos(r),x=i.data.get(a.dataId).values;for(let e=0;e<u;e++){const t=e*d*c*p;for(let e=0;e<c;e++){const n=e*(d*p);for(let a=0;a<d;a++){const r=a*p;for(let o=0;o<p;o++){const i=[u,e,a,o],y=i[2],A=i[1];let b=(y-h)*g-(A-m)*f,v=(y-h)*f+(A-m)*g;b=Math.round(b+h),v=Math.round(v+m);let k=s;if("number"!=typeof s&&(k=3===o?255:s[o]),b>=0&&b<d&&v>=0&&v<c){k=x[t+v*(d*p)+b*p+o]}l[t+n+r+o]=k}}}}return{dataId:i.write(l,a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}},round3=unaryKernelFunc(Round,(e=>{const t=Math.floor(e);return e-t<.5?Math.floor(e):e-t>.5?Math.ceil(e):t%2==0?t:t+1})),roundConfig={kernelName:Round,backendName:"cpu",kernelFunc:round3};function scatterImpl(e,t,n,a,r,s,o,i,l,u){const c=[a/r,r],d=e.values,p=t.values;if(0===a)return buffer(n,t.dtype);const h=buffer(c,t.dtype);h.values.fill(l);for(let e=0;e<s;e++){const s=[];let l=0;for(let t=0;t<o;t++){const n=d[e*o+t];s.push(n),l+=n*i[t]}if(l<0||l>=a/r)throw new Error(`Invalid indices: ${s} does not index into ${n}`);for(let n=0;n<r;n++)u?h.values[l*r+n]+=p[e*r+n]:h.values[l*r+n]=0===t.rank?p[0]:p[e*r+n]}return h}function scatterNd(e){const{inputs:t,backend:n,attrs:a}=e,{indices:r,updates:s}=t,{shape:o}=a,{sliceRank:i,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=backend_util_exports.calculateShapes(s,r,o),p=scatterImpl(n.bufferSync(r),n.bufferSync(s),o,d,u,l,i,c,0,!0);return n.makeTensorInfo(o,p.dtype,p.values)}var scatterNdConfig={kernelName:ScatterNd,backendName:"cpu",kernelFunc:scatterNd};function select2(e){const{inputs:t,backend:n}=e,{condition:a,t:r,e:s}=t;assertNotComplex([a,r,s],"select");const o=a.shape.length,i=n.data.get(a.dataId).values,l=n.data.get(r.dataId).values,u=n.data.get(s.dataId).values,c=upcastType(r.dtype,s.dtype),d=util_exports.makeZerosTypedArray(util_exports.sizeFromShape(r.shape),c);let p=0;const h=0===o||o>1||1===r.shape.length?1:util_exports.sizeFromShape(r.shape.slice(1));for(let e=0;e<i.length;e++)for(let t=0;t<h;t++)1===i[e]?d[p++]=l[e]:d[p++]=u[e];return n.makeTensorInfo(r.shape,c,d)}var selectConfig={kernelName:Select,backendName:"cpu",kernelFunc:select2},scaleAlpha=backend_util_exports.SELU_SCALEALPHA,scale=backend_util_exports.SELU_SCALE,selu2=unaryKernelFunc(Selu,(e=>e>=0?scale*e:scaleAlpha*(Math.exp(e)-1))),seluConfig={kernelName:Selu,backendName:"cpu",kernelFunc:selu2},sign2=unaryKernelFunc(Sign,(e=>e<0?-1:e>0?1:0)),signConfig={kernelName:Sign,backendName:"cpu",kernelFunc:sign2},sin2=unaryKernelFunc(Sin,(e=>Math.sin(e))),sinConfig={kernelName:Sin,backendName:"cpu",kernelFunc:sin2},sinh2=unaryKernelFunc(Sinh,(e=>Math.sinh(e))),sinhConfig={kernelName:Sinh,backendName:"cpu",kernelFunc:sinh2},epsilon2=1.1920928955078125e-7,threshold2=Math.log(epsilon2)+2,softplus2=unaryKernelFunc(Softplus,(e=>{const t=e>-threshold2,n=e<threshold2,a=Math.exp(e);let r;return r=n?a:t?e:Math.log(1+a),r})),softplusConfig={kernelName:Softplus,backendName:"cpu",kernelFunc:softplus2};function spaceToBatchND2(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:s,paddings:o}=a;assertNotComplex([r],"spaceToBatchND");const i=util_exports.sizeFromShape(s),l=[[0,0]];l.push(...o);for(let e=1+s.length;e<r.shape.length;++e)l.push([0,0]);const u=padV2Config.kernelFunc({inputs:{x:r},backend:n,attrs:{paddings:l,constantValue:0}}),c=backend_util_exports.getReshaped(u.shape,s,i,!1),d=backend_util_exports.getPermuted(c.length,s.length,!1),p=backend_util_exports.getReshapedPermuted(u.shape,s,i,!1),h=reshape3({inputs:{x:u},backend:n,attrs:{shape:c}}),m=transpose2({inputs:{x:h},backend:n,attrs:{perm:d}}),f=reshape3({inputs:{x:m},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(m),f}var spaceToBatchNDConfig={kernelName:SpaceToBatchND,backendName:"cpu",kernelFunc:spaceToBatchND2};function sparseFillEmptyRows2(e){const{inputs:t,backend:n}=e,{indices:a,values:r,denseShape:s,defaultValue:o}=t;if(1!==s.shape.length)throw new Error(`Dense shape must be a vector, saw:\n        ${s.shape}`);if(2!==a.shape.length)throw new Error(`Indices must be a matrix, saw:\n        ${a.shape}`);if(1!==r.shape.length)throw new Error(`Values must be a vector, saw:\n        ${r.shape}`);if(0!==o.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${o.shape}`);const i=n.data.get(a.dataId).values,l=n.data.get(r.dataId).values,u=n.data.get(s.dataId).values,c=n.data.get(o.dataId).values[0],[d,p,h,m,f]=sparseFillEmptyRowsImpl(i,a.shape,a.dtype,l,r.dtype,u,c);return[n.makeTensorInfo(p,a.dtype,d),n.makeTensorInfo([p[0]],r.dtype,h),n.makeTensorInfo([m.length],"bool",new Uint8Array(m.map((e=>Number(e))))),n.makeTensorInfo([f.length],a.dtype,new Int32Array(f))]}var sparseFillEmptyRowsConfig={kernelName:SparseFillEmptyRows,backendName:"cpu",kernelFunc:sparseFillEmptyRows2};function sparseReshape2(e){const{inputs:t,backend:n}=e,{inputIndices:a,inputShape:r,newShape:s}=t;if(2!==a.shape.length)throw new Error(`Input indices should be a matrix but received shape\n        ${a.shape}`);if(1!==r.shape.length)throw new Error(`Input shape should be a vector but received shape\n        ${r.shape}`);if(1!==s.shape.length)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);const o=Array.from(n.data.get(r.dataId).values),i=n.data.get(a.dataId).values,l=Array.from(n.data.get(s.dataId).values),[u,c,d]=sparseReshapeImpl(i,a.shape,a.dtype,o,l);return[n.makeTensorInfo(c,a.dtype,u),n.makeTensorInfo([d.length],s.dtype,new Int32Array(d))]}var sparseReshapeConfig={kernelName:SparseReshape,backendName:"cpu",kernelFunc:sparseReshape2};function sparseSegmentMean2(e){const{inputs:t,backend:n}=e,{data:a,indices:r,segmentIds:s}=t;if(a.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error(`Indices should be a vector but received shape\n          ${r.shape}`);if(1!==s.shape.length)throw new Error(`Segment ids should be a vector but received shape\n          ${s.shape}`);const o=n.data.get(a.dataId).values,i=n.data.get(r.dataId).values,l=n.data.get(s.dataId).values,[u,c]=sparseSegmentReductionImpl(o,a.shape,a.dtype,i,l,!0);return n.makeTensorInfo(c,a.dtype,u)}var sparseSegmentMeanConfig={kernelName:SparseSegmentMean,backendName:"cpu",kernelFunc:sparseSegmentMean2};function sparseSegmentSum2(e){const{inputs:t,backend:n}=e,{data:a,indices:r,segmentIds:s}=t;if(a.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error(`Indices should be a vector but received shape\n         ${r.shape}`);if(1!==s.shape.length)throw new Error(`Segment ids should be a vector but received shape\n         ${s.shape}`);const o=n.data.get(a.dataId).values,i=n.data.get(r.dataId).values,l=n.data.get(s.dataId).values,[u,c]=sparseSegmentReductionImpl(o,a.shape,a.dtype,i,l);return n.makeTensorInfo(c,a.dtype,u)}var sparseSegmentSumConfig={kernelName:SparseSegmentSum,backendName:"cpu",kernelFunc:sparseSegmentSum2};function sparseToDense2(e){const{inputs:t,backend:n,attrs:a}=e,{sparseIndices:r,sparseValues:s,defaultValue:o}=t,{outputShape:i}=a,{sliceRank:l,numUpdates:u,sliceSize:c,strides:d,outputSize:p}=backend_util_exports.calculateShapes(s,r,i),h=scatterImpl(n.bufferSync(r),n.bufferSync(s),i,p,c,u,l,d,n.data.get(o.dataId).values[0],!1);return n.makeTensorInfo(i,h.dtype,h.values)}var sparseToDenseConfig={kernelName:SparseToDense,backendName:"cpu",kernelFunc:sparseToDense2};function splitV(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{numOrSizeSplits:s,axis:o}=a,i=util_exports.parseAxisParam(o,r.shape)[0],l=backend_util_exports.prepareSplitSize(r,s,i),u=new Array(r.shape.length).fill(0),c=r.shape.slice();return l.map((e=>{const t=[...c];t[i]=e;const a=slice2({inputs:{x:r},backend:n,attrs:{begin:u,size:t}});return u[i]+=e,a}))}var splitVConfig={kernelName:SplitV,backendName:"cpu",kernelFunc:splitV},squareConfig={kernelName:Square,backendName:"cpu",kernelFunc:({inputs:e,backend:t})=>{const{x:n}=e,a=t;assertNotComplex(n,"square");const r=a.data.get(n.dataId).values,s=new Float32Array(r.length);for(let e=0;e<r.length;++e){const t=r[e];s[e]=t*t}return{dataId:a.write(s,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}},step2=unaryKernelFunc(Step,((e,t)=>{const n=t;return isNaN(e)?NaN:e>0?1:n.alpha})),stepConfig={kernelName:Step,backendName:"cpu",kernelFunc:step2};function stridedSlice2(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{begin:s,end:o,strides:i,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:d,shrinkAxisMask:p}=a;assertNotComplex(r,"stridedSlice");const{finalShapeSparse:h,finalShape:m,isIdentity:f,sliceDim0:g,isSimpleSlice:x,begin:y,end:A,strides:b}=slice_util_exports.sliceInfo(r.shape,s,o,i,l,u,c,d,p);let v;if(f)v=reshape3({inputs:{x:r},backend:n,attrs:{shape:m}});else if(g||x){util_exports.assert(r.shape.length>=1,(()=>`Input must have rank at least 1, got: ${r.shape.length}`));const e=slice_util_exports.computeOutShape(y,A,b),t=slice2({inputs:{x:r},backend:n,attrs:{begin:y,size:e}});v=reshape3({inputs:{x:t},backend:n,attrs:{shape:m}}),n.disposeIntermediateTensorInfo(t)}else{const e=stridedSliceImpl(h,n.bufferSync(r),b,y);v=n.makeTensorInfo(m,e.dtype,e.values)}return v}var stridedSliceConfig={kernelName:StridedSlice,backendName:"cpu",kernelFunc:stridedSlice2};function stringNGrams2(e){const{inputs:t,backend:n,attrs:a}=e,{separator:r,nGramWidths:s,leftPad:o,rightPad:i,padWidth:l,preserveShortSequences:u}=a,{data:c,dataSplits:d}=t,p=n.data.get(c.dataId).values,h=n.data.get(d.dataId).values,[m,f]=stringNGramsImpl(p,h,r,s,o,i,l,u);return[n.makeTensorInfo([m.length],"string",m),n.makeTensorInfo(d.shape,"int32",f)]}var stringNGramsConfig={kernelName:StringNGrams,backendName:"cpu",kernelFunc:stringNGrams2};function stringSplit2(e){const{inputs:t,backend:n,attrs:a}=e,{skipEmpty:r}=a,{input:s,delimiter:o}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(1!==s.shape.length)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(0!==o.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const i=n.data.get(s.dataId).values,l=n.data.get(o.dataId).values[0],[u,c,d]=stringSplitImpl(i,l,r),p=c.length;return[n.makeTensorInfo([p,2],"int32",u),n.makeTensorInfo([p],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(d))]}var stringSplitConfig={kernelName:StringSplit,backendName:"cpu",kernelFunc:stringSplit2};function stringToHashBucketFast2(e){const{inputs:t,backend:n,attrs:a}=e,{numBuckets:r}=a,{input:s}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const o=stringToHashBucketFastImpl(n.data.get(s.dataId).values,r);return n.makeTensorInfo(s.shape,"int32",o)}var stringToHashBucketFastConfig={kernelName:StringToHashBucketFast,backendName:"cpu",kernelFunc:stringToHashBucketFast2},tan2=unaryKernelFunc(Tan,(e=>Math.tan(e))),tanConfig={kernelName:Tan,backendName:"cpu",kernelFunc:tan2},tanh3=unaryKernelFunc(Tanh,(e=>Math.tanh(e))),tanhConfig={kernelName:Tanh,backendName:"cpu",kernelFunc:tanh3};function tile3(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{reps:s}=a;assertNotComplex(r,"tile");const o=tileImpl(n.bufferSync(r),s);return n.makeTensorInfo(o.shape,o.dtype,o.values)}var tileConfig={kernelName:Tile,backendName:"cpu",kernelFunc:tile3};function topK(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{k:s,sorted:o}=a;assertNotComplex(r,"topk");const i=n.data.get(r.dataId).values,[l,u]=topKImpl(i,r.shape,r.dtype,s,o);return[n.makeTensorInfo(l.shape,l.dtype,l.values),n.makeTensorInfo(u.shape,u.dtype,u.values)]}var topKConfig={kernelName:TopK,backendName:"cpu",kernelFunc:topK};function transform2(e){const{inputs:t,attrs:n,backend:a}=e,{image:r,transforms:s}=t,{interpolation:o,fillMode:i,fillValue:l,outputShape:u}=n,[c,d,p,h]=r.shape,[m,f]=null!=u?u:[d,p],g=[c,m,f,h],x=util_exports.computeStrides(r.shape),y=x[0],A=x[1],b=x[2],v=util_exports.getTypedArrayFromDType(r.dtype,util_exports.sizeFromShape(g));v.fill(l);const k=a.data.get(r.dataId).values,S=a.data.get(s.dataId).values;for(let e=0;e<c;++e){const t=1===s.shape[0]?S:S.subarray(8*e,8*e+8);for(let n=0;n<m;++n)for(let a=0;a<f;++a)for(let r=0;r<h;++r){let s;const u=t[6]*a+t[7]*n+1;if(0===u)continue;const c=(t[0]*a+t[1]*n+t[2])/u,h=(t[3]*a+t[4]*n+t[5])/u,m=mapCoord(c,p,i),f=mapCoord(h,d,i);switch(o){case"nearest":s=nearestInterpolation(k,d,p,y,A,b,e,f,m,r,l);break;case"bilinear":s=bilinearInterpolation(k,d,p,y,A,b,e,f,m,r,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${o}`)}v[e*y+n*A+a*b+r]=s}return a.makeTensorInfo(g,r.dtype,v)}return{dataId:a.write(v,g,r.dtype),shape:r.shape,dtype:r.dtype}}var transformConfig={kernelName:Transform,backendName:"cpu",kernelFunc:transform2};function mapCoord(e,t,n){switch(n){case"reflect":return mapCoordReflect(e,t);case"wrap":return mapCoordWrap(e,t);case"nearest":return mapCoordNearest(e,t);default:return mapCoordConstant(e,t)}}function mapCoordReflect(e,t){let n=e;if(n<0)if(t<=1)n=0;else{const e=2*t;n<e&&(n=e*Math.trunc(-n/e)+n),n=n<-t?n+e:-n-1}else if(n>t-1)if(t<=1)n=0;else{const e=2*t;n-=e*Math.trunc(n/e),n>=t&&(n=e-n-1)}return util_exports.clamp(0,n,t-1)}function mapCoordWrap(e,t){let n=e;if(n<0)if(t<=1)n=0;else{const e=t-1;n+=t*(Math.trunc(-n/e)+1)}else if(n>t-1)if(t<=1)n=0;else{const e=t-1;n-=t*Math.trunc(n/e)}return util_exports.clamp(0,n,t-1)}function mapCoordConstant(e,t){return e}function mapCoordNearest(e,t){return util_exports.clamp(0,e,t-1)}function readWithFillValue(e,t,n,a,r,s,o,i,l,u,c){return 0<=i&&i<t&&0<=l&&l<n?e[o*a+i*r+l*s+u]:c}function nearestInterpolation(e,t,n,a,r,s,o,i,l,u,c){return readWithFillValue(e,t,n,a,r,s,o,Math.round(i),Math.round(l),u,c)}function bilinearInterpolation(e,t,n,a,r,s,o,i,l,u,c){const d=Math.floor(i),p=Math.floor(l),h=d+1,m=p+1;return(h-i)*((m-l)*readWithFillValue(e,t,n,a,r,s,o,d,p,u,c)+(l-p)*readWithFillValue(e,t,n,a,r,s,o,d,m,u,c))+(i-d)*((m-l)*readWithFillValue(e,t,n,a,r,s,o,h,p,u,c)+(l-p)*readWithFillValue(e,t,n,a,r,s,o,h,m,u,c))}function unique3(e){const{inputs:t,attrs:n,backend:a}=e,{axis:r}=n,{x:s}=t;assertNotComplex(s,"unique");const o=a.data.get(s.dataId).values,{outputValues:i,outputShape:l,indices:u}=uniqueImpl(o,r,s.shape,s.dtype);return[a.makeTensorInfo(l,s.dtype,i),a.makeTensorInfo([u.length],"int32",u)]}var uniqueConfig={kernelName:Unique,backendName:"cpu",kernelFunc:unique3};function unpack(e){const{inputs:t,backend:n,attrs:a}=e,{value:r}=t;let{axis:s}=a;s<0&&(s+=r.shape.length);const o=r.shape.length,i=r.shape[s],l=new Array(o-1);let u=0;for(let e=0;e<o;e++)e!==s&&(l[u++]=r.shape[e]);const c=new Array(o).fill(0),d=r.shape.slice();d[s]=1;const p=new Array(i);for(let e=0;e<p.length;e++){c[s]=e;const t=slice2({inputs:{x:r},backend:n,attrs:{begin:c,size:d}});p[e]=reshape3({inputs:{x:t},backend:n,attrs:{shape:l}}),n.disposeIntermediateTensorInfo(t)}return p}var unpackConfig={kernelName:Unpack,backendName:"cpu",kernelFunc:unpack};function unsortedSegmentSum2(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,segmentIds:s}=t,{numSegments:o}=a;assertNotComplex(r,"unsortedSegmentSum");const i=[],l=[],u=r.shape.length-s.shape.length;let c=s;for(let e=0;e<u;++e){const t=expandDims3({inputs:{input:c},backend:n,attrs:{dim:e+1}});c=t,l.push(t)}for(let e=0;e<o;++e){const t=util_exports.createScalarValue(e,"int32"),a=n.makeTensorInfo([],"int32",t),s=equal2({inputs:{a:a,b:c},backend:n}),o=cast3({inputs:{x:s},backend:n,attrs:{dtype:"float32"}}),u=multiply2({inputs:{a:o,b:r},backend:n}),d=sum3({inputs:{x:u},backend:n,attrs:{axis:0,keepDims:!1}});i.push(d),l.push(a),l.push(s),l.push(o),l.push(u),l.push(d)}const d=pack({inputs:i,backend:n,attrs:{axis:0}});return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),d}var unsortedSegmentSumConfig={kernelName:UnsortedSegmentSum,backendName:"cpu",kernelFunc:unsortedSegmentSum2},kernelConfigs=[_fusedMatMulConfig,absConfig,acosConfig,acoshConfig,addConfig,addNConfig,allConfig,anyConfig,argMaxConfig,argMinConfig,asinConfig,asinhConfig,atanConfig,atan2Config,atanhConfig,avgPoolConfig,avgPool3DConfig,avgPool3DGradConfig2,avgPoolGradConfig2,batchMatMulConfig,batchNormConfig,batchToSpaceNDConfig,bincountConfig,broadcastArgsConfig,castConfig,ceilConfig,clipConfig,complexConfig,complexAbsConfig,concatConfig,conv2DBackpropFilterConfig,conv2DBackpropInputConfig,conv2DConfig,conv3DBackpropFilterV2Config,conv3DBackpropInputV2Config,conv3DConfig,cosConfig,coshConfig,cropAndResizeConfig,cumsumConfig,denseBincountConfig,depthToSpaceConfig,depthwiseConv2dNativeConfig,depthwiseConv2dNativeBackpropFilterConfig,depthwiseConv2dNativeBackpropInputConfig,diagConfig,dilation2dConfig,dilation2dBackpropInputConfig,dilation2dBackpropFilterConfig,realDivConfig,einsumConfig,eluConfig,eluGradConfig2,equalConfig,erfConfig,expConfig,expandDimsConfig,expm1Config,fftConfig,fillConfig,flipLeftRightConfig,floorConfig,floorDivConfig,fusedConv2DConfig,fusedDepthwiseConv2DConfig,gatherNdConfig,gatherV2Config,greaterConfig,greaterEqualConfig,identityConfig,ifftConfig,imagConfig,isFiniteConfig,isInfConfig,isNaNConfig,leakyReluConfig,lessConfig,lessEqualConfig,linSpaceConfig,logConfig,log1pConfig,logicalAndConfig,logicalNotConfig,logicalOrConfig,lRNConfig,lRNGradConfig,maximumConfig,maxPoolConfig,maxPool3DConfig,maxPool3DGradConfig2,maxPoolGradConfig2,maxPoolWithArgmaxConfig,maxConfig,meanConfig,minConfig,minimumConfig,mirrorPadConfig,modConfig,multinomialConfig,multiplyConfig,negConfig,nonMaxSuppressionV3Config,nonMaxSuppressionV4Config,nonMaxSuppressionV5Config,notEqualConfig,oneHotConfig,onesLikeConfig,packConfig,padV2Config,powConfig,preluConfig,prodConfig,rangeConfig,realConfig,reciprocalConfig,reluConfig,relu6Config,reshapeConfig,resizeBilinearConfig,resizeBilinearGradConfig2,resizeNearestNeighborConfig,resizeNearestNeighborGradConfig2,reverseConfig,rotateWithOffsetConfig,roundConfig,rsqrtConfig,scatterNdConfig,selectConfig,seluConfig,sigmoidConfig,signConfig,sinConfig,sinhConfig,sliceConfig,softmaxConfig,softplusConfig,spaceToBatchNDConfig,sparseFillEmptyRowsConfig,sparseReshapeConfig,sparseSegmentMeanConfig,sparseSegmentSumConfig,sparseToDenseConfig,splitVConfig,sqrtConfig,squareConfig,squaredDifferenceConfig,stepConfig,stridedSliceConfig,stringNGramsConfig,stringSplitConfig,stringToHashBucketFastConfig,subConfig,sumConfig,tanConfig,tanhConfig,tileConfig,topKConfig,transposeConfig,transformConfig,uniqueConfig,unpackConfig,unsortedSegmentSumConfig,zerosLikeConfig];for(const e of kernelConfigs)registerKernel(e);var webgl_util_exports={};__export2(webgl_util_exports,{assertNotComplex:()=>assertNotComplex2,bindCanvasToFramebuffer:()=>bindCanvasToFramebuffer,bindColorTextureToFramebuffer:()=>bindColorTextureToFramebuffer,bindTextureToProgramUniformSampler:()=>bindTextureToProgramUniformSampler,bindTextureUnit:()=>bindTextureUnit,bindVertexBufferToProgramAttribute:()=>bindVertexBufferToProgramAttribute,callAndCheck:()=>callAndCheck,canBeRepresented:()=>canBeRepresented,createFragmentShader:()=>createFragmentShader,createFramebuffer:()=>createFramebuffer,createProgram:()=>createProgram,createStaticIndexBuffer:()=>createStaticIndexBuffer,createStaticVertexBuffer:()=>createStaticVertexBuffer,createTexture:()=>createTexture,createVertexShader:()=>createVertexShader,getBatchDim:()=>getBatchDim,getExtensionOrThrow:()=>getExtensionOrThrow,getFramebufferErrorMessage:()=>getFramebufferErrorMessage,getMaxTexturesInShader:()=>getMaxTexturesInShader,getNumChannels:()=>getNumChannels,getProgramUniformLocation:()=>getProgramUniformLocation,getProgramUniformLocationOrThrow:()=>getProgramUniformLocationOrThrow,getRowsCols:()=>getRowsCols,getShapeAs3D:()=>getShapeAs3D,getTextureShapeFromLogicalShape:()=>getTextureShapeFromLogicalShape,getWebGLDisjointQueryTimerVersion:()=>getWebGLDisjointQueryTimerVersion,getWebGLErrorMessage:()=>getWebGLErrorMessage,getWebGLMaxTextureSize:()=>getWebGLMaxTextureSize,hasExtension:()=>hasExtension,isCapableOfRenderingToFloatTexture:()=>isCapableOfRenderingToFloatTexture,isDownloadFloatTextureEnabled:()=>isDownloadFloatTextureEnabled,isReshapeFree:()=>isReshapeFree,isWebGLFenceEnabled:()=>isWebGLFenceEnabled,isWebGLVersionEnabled:()=>isWebGLVersionEnabled,linkProgram:()=>linkProgram,resetMaxTextureSize:()=>resetMaxTextureSize,resetMaxTexturesInShader:()=>resetMaxTexturesInShader,unbindColorTextureFromFramebuffer:()=>unbindColorTextureFromFramebuffer,unbindTextureUnit:()=>unbindTextureUnit,validateFramebuffer:()=>validateFramebuffer,validateProgram:()=>validateProgram,validateTextureSize:()=>validateTextureSize});var PackingScheme,TextureUsage,PhysicalTextureType,contexts={},WEBGL_ATTRIBUTES={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function setWebGLContext(e,t){contexts[e]=t}function getWebGLContext(e){if(!(e in contexts)){const t=getWebGLRenderingContext(e);if(null===t)return console.log("Could not get context for WebGL version",e),null;contexts[e]=t}const t=contexts[e];return null==t||t.isContextLost()?(delete contexts[e],getWebGLContext(e)):(t.disable(t.DEPTH_TEST),t.disable(t.STENCIL_TEST),t.disable(t.BLEND),t.disable(t.DITHER),t.disable(t.POLYGON_OFFSET_FILL),t.disable(t.SAMPLE_COVERAGE),t.enable(t.SCISSOR_TEST),t.enable(t.CULL_FACE),t.cullFace(t.BACK),contexts[e])}function createCanvas(e){if("undefined"!=typeof OffscreenCanvas&&2===e)return new OffscreenCanvas(300,150);if("undefined"!=typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function getWebGLRenderingContext(e){if(1!==e&&2!==e)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const t=createCanvas(e);return t.addEventListener("webglcontextlost",(t=>{t.preventDefault(),delete contexts[e]}),!1),1===e?t.getContext("webgl",WEBGL_ATTRIBUTES)||t.getContext("experimental-webgl",WEBGL_ATTRIBUTES):t.getContext("webgl2",WEBGL_ATTRIBUTES)}function getUnpackedMatrixTextureShapeWidthHeight(e,t){return[t,e]}function getUnpackedArraySizeFromMatrixSize(e,t){return e*t}function getDenseTexShape(e){const t=util_exports.sizeFromShape(e),n=Math.ceil(t/4);return util_exports.sizeToSquarishShape(n)}function getPackedMatrixTextureShapeWidthHeight(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function getPackedRGBAArraySizeFromMatrixShape(e,t){const[n,a]=getPackedMatrixTextureShapeWidthHeight(e,t);return n*a*4}function getTextureConfig(e,t){const n=e;let a,r,s,o,i,l,u,c,d,p;return 2===env().getNumber("WEBGL_VERSION")?(a=n.R32F,r=n.R16F,s=n.RGBA16F,o=n.RGBA32F,i=n.RED,u=4,c=1,d=n.HALF_FLOAT,p=n.FLOAT):(a=e.RGBA,r=e.RGBA,s=e.RGBA,o=n.RGBA,i=e.RGBA,u=4,c=4,d=null!=t?t.HALF_FLOAT_OES:null,p=e.FLOAT),l=e.RGBA,{internalFormatFloat:a,internalFormatHalfFloat:r,internalFormatPackedHalfFloat:s,internalFormatPackedFloat:o,textureFormatFloat:i,downloadTextureFormat:l,downloadUnpackNumChannels:u,defaultNumChannels:c,textureTypeHalfFloat:d,textureTypeFloat:p}}function callAndCheck(e,t){const n=t();return env().getBool("DEBUG")&&checkWebGLError(e),n}function checkWebGLError(e){const t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+getWebGLErrorMessage(e,t))}!function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"}(PackingScheme||(PackingScheme={})),function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"}(TextureUsage||(TextureUsage={})),function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(PhysicalTextureType||(PhysicalTextureType={}));var MIN_FLOAT16=5.96e-8,MAX_FLOAT16=65504;function canBeRepresented(e){return!!(env().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===e||MIN_FLOAT16<Math.abs(e)&&Math.abs(e)<MAX_FLOAT16)}function getWebGLErrorMessage(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}function getExtensionOrThrow(e,t){return throwIfNull(e,(()=>e.getExtension(t)),'Extension "'+t+'" not supported on this browser.')}function createVertexShader(e,t){const n=throwIfNull(e,(()=>e.createShader(e.VERTEX_SHADER)),"Unable to create vertex WebGLShader.");if(callAndCheck(e,(()=>e.shaderSource(n,t))),callAndCheck(e,(()=>e.compileShader(n))),!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw console.log(e.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}function createFragmentShader(e,t){const n=throwIfNull(e,(()=>e.createShader(e.FRAGMENT_SHADER)),"Unable to create fragment WebGLShader.");if(callAndCheck(e,(()=>e.shaderSource(n,t))),callAndCheck(e,(()=>e.compileShader(n))),!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw logShaderSourceAndInfoLog(t,e.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}var MAX_TEXTURE_SIZE,MAX_TEXTURES_IN_SHADER,lineNumberRegex=/ERROR: [0-9]+:([0-9]+):/g;function logShaderSourceAndInfoLog(e,t){const n=lineNumberRegex.exec(t);if(null==n)return console.log(`Couldn't parse line number in error: ${t}`),void console.log(e);const a=+n[1],r=e.split("\n"),s=r.length.toString().length+2,o=r.map(((e,t)=>util_exports.rightPad((t+1).toString(),s)+e));let i=0;for(let e=0;e<o.length;e++)i=Math.max(o[e].length,i);const l=o.slice(0,a-1),u=o.slice(a-1,a),c=o.slice(a);console.log(l.join("\n")),console.log(t.split("\n")[0]),console.log(`%c ${util_exports.rightPad(u[0],i)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join("\n"))}function createProgram(e){return throwIfNull(e,(()=>e.createProgram()),"Unable to create WebGLProgram.")}function linkProgram(e,t){if(callAndCheck(e,(()=>e.linkProgram(t))),!1===e.getProgramParameter(t,e.LINK_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}function validateProgram(e,t){if(callAndCheck(e,(()=>e.validateProgram(t))),!1===e.getProgramParameter(t,e.VALIDATE_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function createStaticVertexBuffer(e,t){const n=throwIfNull(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return callAndCheck(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n))),callAndCheck(e,(()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW))),n}function createStaticIndexBuffer(e,t){const n=throwIfNull(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return callAndCheck(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n))),callAndCheck(e,(()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW))),n}function getNumChannels(){return 2===env().getNumber("WEBGL_VERSION")?1:4}function createTexture(e){return throwIfNull(e,(()=>e.createTexture()),"Unable to create WebGLTexture.")}function validateTextureSize(e,t){const n=env().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0){throw new Error("Requested texture size "+`[${e}x${t}]`+" is invalid.")}if(e>n||t>n){throw new Error("Requested texture size "+`[${e}x${t}]`+" greater than WebGL maximum on this browser / GPU "+`[${n}x${n}]`+".")}}function createFramebuffer(e){return throwIfNull(e,(()=>e.createFramebuffer()),"Unable to create WebGLFramebuffer.")}function bindVertexBufferToProgramAttribute(e,t,n,a,r,s,o){const i=e.getAttribLocation(t,n);return-1!==i&&(callAndCheck(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,a))),callAndCheck(e,(()=>e.vertexAttribPointer(i,r,e.FLOAT,!1,s,o))),callAndCheck(e,(()=>e.enableVertexAttribArray(i))),!0)}function bindTextureUnit(e,t,n){validateTextureUnit(e,n),callAndCheck(e,(()=>e.activeTexture(e.TEXTURE0+n))),callAndCheck(e,(()=>e.bindTexture(e.TEXTURE_2D,t)))}function unbindTextureUnit(e,t){validateTextureUnit(e,t),callAndCheck(e,(()=>e.activeTexture(e.TEXTURE0+t))),callAndCheck(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}function getProgramUniformLocationOrThrow(e,t,n){return throwIfNull(e,(()=>e.getUniformLocation(t,n)),'uniform "'+n+'" not present in program.')}function getProgramUniformLocation(e,t,n){return e.getUniformLocation(t,n)}function bindTextureToProgramUniformSampler(e,t,n,a){callAndCheck(e,(()=>bindTextureUnit(e,t,a))),callAndCheck(e,(()=>e.uniform1i(n,a)))}function bindCanvasToFramebuffer(e){callAndCheck(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,null))),callAndCheck(e,(()=>e.viewport(0,0,e.canvas.width,e.canvas.height))),callAndCheck(e,(()=>e.scissor(0,0,e.canvas.width,e.canvas.height)))}function bindColorTextureToFramebuffer(e,t,n){callAndCheck(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,n))),callAndCheck(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0)))}function unbindColorTextureFromFramebuffer(e,t){callAndCheck(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,t))),callAndCheck(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0)))}function validateFramebuffer(e){const t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+getFramebufferErrorMessage(e,t))}function getFramebufferErrorMessage(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}function throwIfNull(e,t,n){const a=callAndCheck(e,(()=>t()));if(null==a)throw new Error(n);return a}function validateTextureUnit(e,t){const n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,a=t+e.TEXTURE0;if(a<e.TEXTURE0||a>n){throw new Error(`textureUnit must be in ${`[gl.TEXTURE0, gl.TEXTURE${n}]`}.`)}}function getBatchDim(e,t=2){return util_exports.sizeFromShape(e.slice(0,e.length-t))}function getRowsCols(e){if(0===e.length)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function getShapeAs3D(e){let t=[1,1,1];return 0===e.length||1===e.length&&1===e[0]||(t=[getBatchDim(e),...getRowsCols(e)]),t}function getTextureShapeFromLogicalShape(e,t=!1){let n=env().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(t&&(n*=2,1===(e=e.map(((t,n)=>n>=e.length-2?util_exports.nearestLargerEven(e[n]):e[n]))).length&&(e=[2,e[0]])),2!==e.length){const t=util_exports.squeezeShape(e);e=t.newShape}let a=util_exports.sizeFromShape(e);if(e.length<=1&&a<=n)return[1,a];if(2===e.length&&e[0]<=n&&e[1]<=n)return e;if(3===e.length&&e[0]*e[1]<=n&&e[2]<=n)return[e[0]*e[1],e[2]];if(3===e.length&&e[0]<=n&&e[1]*e[2]<=n)return[e[0],e[1]*e[2]];if(4===e.length&&e[0]*e[1]*e[2]<=n&&e[3]<=n)return[e[0]*e[1]*e[2],e[3]];if(4===e.length&&e[0]<=n&&e[1]*e[2]*e[3]<=n)return[e[0],e[1]*e[2]*e[3]];if(t){const t=getBatchDim(e);let n=2,r=2;return e.length&&([n,r]=getRowsCols(e)),a=t*(n/2)*(r/2),util_exports.sizeToSquarishShape(a).map((e=>2*e))}return util_exports.sizeToSquarishShape(a)}function isEven(e){return e%2==0}function isReshapeFree(e,t){if(e=e.slice(-2),t=t.slice(-2),util_exports.arraysEqual(e,t))return!0;if(!e.length||!t.length)return!0;if(0===e[0]||0===e[1]||0===t[0]||0===t[1])return!0;if(e.length!==t.length){const n=e.slice(-1)[0],a=t.slice(-1)[0];if(n===a)return!0;if(isEven(n)&&isEven(a)&&(1===e[0]||1===t[0]))return!0}return e[1]===t[1]&&isEven(e[0])&&isEven(t[0])}function getWebGLMaxTextureSize(e){if(null==MAX_TEXTURE_SIZE){const t=getWebGLContext(e);MAX_TEXTURE_SIZE=t.getParameter(t.MAX_TEXTURE_SIZE)}return MAX_TEXTURE_SIZE}function resetMaxTextureSize(){MAX_TEXTURE_SIZE=null}function resetMaxTexturesInShader(){MAX_TEXTURES_IN_SHADER=null}function getMaxTexturesInShader(e){if(null==MAX_TEXTURES_IN_SHADER){const t=getWebGLContext(e);MAX_TEXTURES_IN_SHADER=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,MAX_TEXTURES_IN_SHADER)}function getWebGLDisjointQueryTimerVersion(e){if(0===e)return 0;let t;const n=getWebGLContext(e);return t=hasExtension(n,"EXT_disjoint_timer_query_webgl2")&&2===e?2:hasExtension(n,"EXT_disjoint_timer_query")?1:0,t}function hasExtension(e,t){return null!=e.getExtension(t)}function isWebGLVersionEnabled(e){try{if(null!=getWebGLContext(e))return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function isCapableOfRenderingToFloatTexture(e){if(0===e)return!1;const t=getWebGLContext(e);if(1===e){if(!hasExtension(t,"OES_texture_float"))return!1}else if(!hasExtension(t,"EXT_color_buffer_float"))return!1;return createFloatTextureAndBindToFramebuffer(t)}function isDownloadFloatTextureEnabled(e){if(0===e)return!1;const t=getWebGLContext(e);if(1!==e){if(hasExtension(t,"EXT_color_buffer_float"))return createFloatTextureAndBindToFramebuffer(t);const e="EXT_color_buffer_half_float";if(hasExtension(t,e)){const n=t.getExtension(e);return createHalfFloatTextureAndBindToFramebuffer(t,n)}return!1}if(!hasExtension(t,"OES_texture_float"))return!1;if(!hasExtension(t,"WEBGL_color_buffer_float"))return!1;return createFloatTextureAndBindToFramebuffer(t)}function createFloatTextureAndBindToFramebuffer(e){const t=getTextureConfig(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n);e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);const a=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,a),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);const r=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(a),r}function createHalfFloatTextureAndBindToFramebuffer(e,t){const n=getTextureConfig(e,t),a=e.createTexture();e.bindTexture(e.TEXTURE_2D,a);e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,1,1,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const r=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,a,0);const s=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(a),e.deleteFramebuffer(r),s}function isWebGLFenceEnabled(e){if(2!==e)return!1;return null!=getWebGLContext(e).fenceSync}function assertNotComplex2(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&util_exports.assert("complex64"!==e.dtype,(()=>`${t} does not support complex64 tensors in the WebGL backend.`))}))}var ENV4=env();function getGlslDifferences(){let e,t,n,a,r,s,o,i,l,u;return 2===env().getNumber("WEBGL_VERSION")?(e="#version 300 es",t="in",n="out",a="in",r="texture",s="outputColor",o="out vec4 outputColor;",i="\n      bool isnan_custom(float val) {\n        return (val > 0.0 || val < 0.0) ? false : val != 0.0;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ",l="",u="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(e="",t="attribute",n="varying",a="varying",r="texture2D",s="gl_FragColor",o="",i="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",l="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",u="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:e,attribute:t,varyingVs:n,varyingFs:a,texture2D:r,output:s,defineOutput:o,defineSpecialNaN:i,defineSpecialInf:l,defineRound:u}}function getLogicalCoordinatesFromFlatIndex(e,t,n="index"){const a=util_exports.computeStrides(t);return a.map(((t,r)=>`${`int ${e[r]} = ${n} / ${t}`}; ${r===a.length-1?`int ${e[r+1]} = ${n} - ${e[r]} * ${t}`:`index -= ${e[r]} * ${t}`};`)).join("")}function getOutputLogicalCoordinatesFromFlatIndexByUniform(e,t,n="index"){const a=util_exports.computeStrides(t);return a.map(((t,r)=>`${`int ${e[r]} = ${n} / outShapeStrides[${r}]`}; ${r===a.length-1?`int ${e[r+1]} = ${n} - ${e[r]} * outShapeStrides[${r}]`:`index -= ${e[r]} * outShapeStrides[${r}]`};`)).join("")}function symbolicallyComputeStrides(e,t){const n=e.length,a=e.map((e=>`${t}[${e}]`)),r=new Array(n-1);r[n-2]=a[n-1];for(let e=n-3;e>=0;--e)r[e]=`(${r[e+1]} * ${a[e+1]})`;return r}function getLogicalCoordinatesFromFlatIndexByUniform(e,t,n="index"){const a=symbolicallyComputeStrides(e.map(((e,t)=>t)),t);return a.map(((t,r)=>`${`int ${e[r]} = ${n} / ${a[r]}`}; ${r===a.length-1?`int ${e[r+1]} = ${n} - ${e[r]} * ${a[r]}`:`index -= ${e[r]} * ${a[r]}`};`)).join("")}function getFlatIndexFrom3D(e){const t=util_exports.computeStrides(e).map((e=>e.toString()));return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;\n  }\n`}function getFlatIndexFrom3DOutput(){return"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n"}ENV4.registerFlag("HAS_WEBGL",(()=>ENV4.getNumber("WEBGL_VERSION")>0)),ENV4.registerFlag("WEBGL_VERSION",(()=>isWebGLVersionEnabled(2)?2:isWebGLVersionEnabled(1)?1:0)),ENV4.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",(()=>!1)),ENV4.registerFlag("WEBGL_BUFFER_SUPPORTED",(()=>2===ENV4.get("WEBGL_VERSION"))),ENV4.registerFlag("WEBGL_CPU_FORWARD",(()=>!0)),ENV4.registerFlag("WEBGL_FORCE_F16_TEXTURES",(()=>!1)),ENV4.registerFlag("WEBGL_PACK",(()=>ENV4.getBool("HAS_WEBGL"))),ENV4.registerFlag("WEBGL_PACK_NORMALIZATION",(()=>ENV4.getBool("WEBGL_PACK"))),ENV4.registerFlag("WEBGL_PACK_CLIP",(()=>ENV4.getBool("WEBGL_PACK"))),ENV4.registerFlag("WEBGL_PACK_DEPTHWISECONV",(()=>ENV4.getBool("WEBGL_PACK"))),ENV4.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",(()=>ENV4.getBool("WEBGL_PACK"))),ENV4.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",(()=>ENV4.getBool("WEBGL_PACK"))),ENV4.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",(()=>ENV4.getBool("WEBGL_PACK"))),ENV4.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",(()=>ENV4.getBool("WEBGL_PACK"))),ENV4.registerFlag("WEBGL_PACK_REDUCE",(()=>ENV4.getBool("WEBGL_PACK"))),ENV4.registerFlag("WEBGL_LAZILY_UNPACK",(()=>ENV4.getBool("WEBGL_PACK"))),ENV4.registerFlag("WEBGL_CONV_IM2COL",(()=>ENV4.getBool("WEBGL_PACK"))),ENV4.registerFlag("WEBGL_MAX_TEXTURE_SIZE",(()=>getWebGLMaxTextureSize(ENV4.getNumber("WEBGL_VERSION")))),ENV4.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",(()=>getMaxTexturesInShader(ENV4.getNumber("WEBGL_VERSION")))),ENV4.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",(()=>{const e=ENV4.getNumber("WEBGL_VERSION");return 0===e?0:getWebGLDisjointQueryTimerVersion(e)})),ENV4.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",(()=>ENV4.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!device_util_exports.isMobile())),ENV4.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",(()=>isCapableOfRenderingToFloatTexture(ENV4.getNumber("WEBGL_VERSION")))),ENV4.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",(()=>!ENV4.getBool("WEBGL_FORCE_F16_TEXTURES")&&ENV4.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))),ENV4.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",(()=>isDownloadFloatTextureEnabled(ENV4.getNumber("WEBGL_VERSION")))),ENV4.registerFlag("WEBGL_FENCE_API_ENABLED",(()=>isWebGLFenceEnabled(ENV4.getNumber("WEBGL_VERSION")))),ENV4.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",(()=>ENV4.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0)),ENV4.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",(()=>-1),(e=>{if(e<0&&-1!==e)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e}.`)})),ENV4.registerFlag("WEBGL_FLUSH_THRESHOLD",(()=>device_util_exports.isMobile()?1:-1),(e=>{if(e<0&&-1!==e)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${e}.`)})),ENV4.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",(()=>128)),ENV4.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",(()=>!1)),ENV4.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",(()=>1e5)),ENV4.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",(()=>128));var ENCODE_FLOAT_SNIPPET="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:getBroadcastDims2}=backend_util_exports;function makeShader(e,t,n){const a=[];if(e.forEach((e=>{const t=util_exports.sizeFromShape(e.shapeInfo.logicalShape);if(e.shapeInfo.isUniform?a.push(`uniform float ${e.name}${t>1?`[${t}]`:""};`):(a.push(`uniform sampler2D ${e.name};`),a.push(`uniform int offset${e.name};`)),n.enableShapeUniforms){const{uniformShape:t}=getUniformInfoFromShape(n.packedInputs,e.shapeInfo.logicalShape,e.shapeInfo.texShape);switch(t.length){case 1:a.push(`uniform int ${e.name}Shape;`);break;case 2:a.push(`uniform ivec2 ${e.name}Shape;`);break;case 3:a.push(`uniform ivec3 ${e.name}Shape;`);break;case 4:a.push(`uniform ivec4 ${e.name}Shape;`)}a.push(`uniform ivec2 ${e.name}TexShape;`)}})),n.enableShapeUniforms){switch(t.logicalShape.length){case 1:a.push("uniform int outShape;");break;case 2:a.push("uniform ivec2 outShape;"),a.push("uniform int outShapeStrides;");break;case 3:a.push("uniform ivec3 outShape;"),a.push("uniform ivec2 outShapeStrides;");break;case 4:a.push("uniform ivec4 outShape;"),a.push("uniform ivec3 outShapeStrides;")}a.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach((e=>{a.push(`uniform ${e.type} ${e.name}${e.arrayIndex?`[${e.arrayIndex}]`:""};`)}));const r=a.join("\n"),s=e.map((e=>getInputSamplingSnippet(e,t,n.packedInputs,n.enableShapeUniforms))).join("\n"),o=t.texShape,i=getGlslDifferences(),l=getFloatTextureSampleSnippet(i);let u,c,d=getShaderPrefix(i);t.isPacked?(u=getPackedOutputSamplingSnippet(t.logicalShape,o,n.enableShapeUniforms),c=getFloatTextureSetRGBASnippet(i)):(u=getOutputSamplingSnippet(t.logicalShape,o,n.enableShapeUniforms),c=getFloatTextureSetRSnippet(i)),n.packedInputs&&(d+=SHADER_PACKED_PREFIX);return[d,l,c,r,u,s,n.userCode].join("\n")}function getSamplerFromInInfo(e,t=!1){const n=e.shapeInfo.logicalShape;switch(n.length){case 0:return getSamplerScalar(e,t);case 1:return getSampler1D(e,t);case 2:return getSampler2D(e,t);case 3:return getSampler3D(e,t);case 4:return getSampler4D(e,t);case 5:return getSampler5D(e);case 6:return getSampler6D(e);default:throw new Error(`${n.length}-D input sampling is not yet supported`)}}function getPackedSamplerFromInInfo(e,t){switch(e.shapeInfo.logicalShape.length){case 0:return getPackedSamplerScalar(e);case 1:return getPackedSampler1D(e,t);case 2:return getPackedSampler2D(e,t);case 3:return getPackedSampler3D(e,t);default:return getPackedSamplerND(e,t)}}function getInputSamplingSnippet(e,t,n=!1,a){let r="";r+=n?getPackedSamplerFromInInfo(e,a):getSamplerFromInInfo(e,a);const s=e.shapeInfo.logicalShape,o=t.logicalShape;return s.length<=o.length&&(r+=n?getPackedSamplerAtOutputCoords(e,t):getSamplerAtOutputCoords(e,t)),r}function getPackedOutputSamplingSnippet(e,t,n){switch(e.length){case 0:return getOutputScalarCoords();case 1:return getOutputPacked1DCoords(e,t,n);case 2:return getOutputPacked2DCoords(e,t,n);case 3:return getOutputPacked3DCoords(e,t,n);default:return getOutputPackedNDCoords(e,t,n)}}function getOutputSamplingSnippet(e,t,n){switch(e.length){case 0:return getOutputScalarCoords();case 1:return getOutput1DCoords(e,t,n);case 2:return getOutput2DCoords(e,t,n);case 3:return getOutput3DCoords(e,t,n);case 4:return getOutput4DCoords(e,t,n);case 5:return getOutput5DCoords(e,t);case 6:return getOutput6DCoords(e,t);default:throw new Error(`${e.length}-D output sampling is not yet supported`)}}function getFloatTextureSampleSnippet(e){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${e.texture2D}(textureSampler, uv).r;\n    }\n  `}function getFloatTextureSetRSnippet(e){return`\n    void setOutput(float val) {\n      ${e.output} = vec4(val, 0, 0, 0);\n    }\n  `}function getFloatTextureSetRGBASnippet(e){return`\n    void setOutput(vec4 val) {\n      ${e.output} = val;\n    }\n  `}function getShaderPrefix(e){return`${e.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${e.varyingFs} vec2 resultUV;\n    ${e.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${e.defineSpecialNaN}\n    ${e.defineSpecialInf}\n    ${e.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${SAMPLE_1D_SNIPPET}\n    ${SAMPLE_2D_SNIPPET}\n    ${SAMPLE_3D_SNIPPET}\n  `}var SAMPLE_1D_SNIPPET="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",SAMPLE_2D_SNIPPET="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",SAMPLE_3D_SNIPPET="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",SHADER_PACKED_PREFIX="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function getOutputScalarCoords(){return"\n    int getOutputCoords() {\n      return 0;\n    }\n  "}function getOutputPacked1DCoords(e,t,n){const a=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return 1===a[0]?n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${a[1]}.0);\n      }\n    `:1===a[1]?n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${a[0]}.0);\n      }\n    `:n?"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${a[0]}, ${a[1]}));\n      return 2 * (resTexRC.x * ${a[1]} + resTexRC.y);\n    }\n  `}function getOutput1DCoords(e,t,n){return 1===t[0]?n?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.x * ${t[1]}.0);\n      }\n    `:1===t[1]?n?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.y * ${t[0]}.0);\n      }\n    `:n?"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      return resTexRC.x * ${t[1]} + resTexRC.y;\n    }\n  `}function getOutputPacked3DCoords(e,t,n){if(n)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";const a=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],r=Math.ceil(e[2]/2),s=r*Math.ceil(e[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${a[0]}, ${a[1]}));\n      int index = resTexRC.x * ${a[1]} + resTexRC.y;\n\n      int b = index / ${s};\n      index -= b * ${s};\n\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}function getOutput3DCoords(e,t,n){if(n){return`\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ${getOutputLogicalCoordinatesFromFlatIndexByUniform(["r","c","d"],e)}\n    return ivec3(r, c, d);\n  }\n`}const a=getLogicalCoordinatesFromFlatIndex(["r","c","d"],e);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${a}\n      return ivec3(r, c, d);\n    }\n  `}function getOutputPackedNDCoords(e,t,n){if(n)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";const a=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],r=Math.ceil(e[e.length-1]/2),s=r*Math.ceil(e[e.length-2]/2);let o=s,i="",l="b, r, c";for(let t=2;t<e.length-1;t++)o*=e[e.length-t-1],i=`\n      int b${t} = index / ${o};\n      index -= b${t} * ${o};\n    `+i,l=`b${t}, `+l;return`\n    ivec${e.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${a[0]}, ${a[1]}));\n      int index = resTexRC.x * ${a[1]} + resTexRC.y;\n\n      ${i}\n\n      int b = index / ${s};\n      index -= b * ${s};\n\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec${e.length}(${l});\n    }\n  `}function getOutput4DCoords(e,t,n){if(n){return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ${getOutputLogicalCoordinatesFromFlatIndexByUniform(["r","c","d","d2"],e)}\n      return ivec4(r, c, d, d2);\n    }\n  `}const a=getLogicalCoordinatesFromFlatIndex(["r","c","d","d2"],e);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${a}\n      return ivec4(r, c, d, d2);\n    }\n  `}function getOutput5DCoords(e,t){const n=getLogicalCoordinatesFromFlatIndex(["r","c","d","d2","d3"],e);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},\n                             ${t[1]}));\n\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}function getOutput6DCoords(e,t){const n=getLogicalCoordinatesFromFlatIndex(["r","c","d","d2","d3","d4"],e);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}function getOutputPacked2DCoords(e,t,n){const a=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(util_exports.arraysEqual(e,t))return n?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${a[0]}, ${a[1]}));\n      }\n    `;const r=Math.ceil(e[1]/2);return n?"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${a[0]}, ${a[1]}));\n\n      int index = resTexRC.x * ${a[1]} + resTexRC.y;\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}function getOutput2DCoords(e,t,n){return util_exports.arraysEqual(e,t)?n?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));\n      }\n    `:1===e[1]?n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `:1===e[0]?n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `:n?"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      int r = index / ${e[1]};\n      int c = index - r * ${e[1]};\n      return ivec2(r, c);\n    }\n  `}function getFlatOffsetUniformName(e){return`offset${e}`}function getPackedSamplerScalar(e){const t=e.name;return`\n    vec4 ${"get"+t.charAt(0).toUpperCase()+t.slice(1)}() {\n      return ${getGlslDifferences().texture2D}(${t}, halfCR);\n    }\n  `}function getSamplerScalar(e,t){const n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`float ${a}() {return ${n};}`;const[r,s]=e.shapeInfo.texShape;if(1===r&&1===s)return`\n      float ${a}() {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;const o=getFlatOffsetUniformName(n);if(t)return`\n    float ${a}() {\n      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], ${o});\n      return sampleTexture(${n}, uv);\n    }\n  `;const[i,l]=e.shapeInfo.texShape;return`\n    float ${a}() {\n      vec2 uv = uvFromFlat(${i}, ${l}, ${o});\n      return sampleTexture(${n}, uv);\n    }\n  `}function getPackedSampler1D(e,t){const n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1),r=e.shapeInfo.texShape,s=getGlslDifferences();if(t)return`\n    vec4 ${a}(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ${s.texture2D}(${n}, uv);\n    }\n  `;const o=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];return`\n    vec4 ${a}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${o[0]}, ${o[1]}, index);\n      return ${s.texture2D}(${n}, uv);\n    }\n  `}function getSampler1D(e,t){const n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`\n      float ${a}(int index) {\n        ${getUniformSampler(e)}\n      }\n    `;const r=e.shapeInfo.texShape,s=r[0],o=r[1];if(1===o&&1===s)return`\n      float ${a}(int index) {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;const i=getFlatOffsetUniformName(n);return 1===o?t?`\n      float ${a}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${i}) + 0.5) / float(${n}TexShape[0]));\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n      float ${a}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${i}) + 0.5) / ${s}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:1===s?t?`\n      float ${a}(int index) {\n        vec2 uv = vec2((float(index + ${i}) + 0.5) / float(${n}TexShape[1]), 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n      float ${a}(int index) {\n        vec2 uv = vec2((float(index + ${i}) + 0.5) / ${o}.0, 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `:t?`\n    float ${a}(int index) {\n      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${i});\n      return sampleTexture(${n}, uv);\n    }\n  `:`\n    float ${a}(int index) {\n      vec2 uv = uvFromFlat(${s}, ${o}, index + ${i});\n      return sampleTexture(${n}, uv);\n    }\n  `}function getPackedSampler2D(e,t){const n=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),s=e.shapeInfo.texShape,o=s[0],i=s[1],l=getGlslDifferences();if(null!=s&&util_exports.arraysEqual(n,s))return t?`\n      vec4 ${r}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}TexShape[1], ${a}TexShape[0]);\n\n        return ${l.texture2D}(${a}, uv);\n      }\n    `:`\n      vec4 ${r}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${i}.0, ${o}.0);\n\n        return ${l.texture2D}(${a}, uv);\n      }\n    `;if(t)return`\n    vec4 ${r}(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${a}TexShape[0]) / 2.0), ceil(float(${a}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${a}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ${l.texture2D}(${a}, uv);\n    }\n  `;const u=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];return`\n    vec4 ${r}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${Math.ceil(n[1]/2)}, ${u[0]}, ${u[1]}, row, col);\n      return ${l.texture2D}(${a}, uv);\n    }\n  `}function getSampler2D(e,t){const n=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),s=e.shapeInfo.texShape;if(null!=s&&util_exports.arraysEqual(n,s)){if(t)return`\n      float ${r}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}TexShape[1], ${a}TexShape[0]);\n        return sampleTexture(${a}, uv);\n      }\n    `;const e=s[0];return`\n    float ${r}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${s[1]}.0, ${e}.0);\n      return sampleTexture(${a}, uv);\n    }\n  `}const{newShape:o,keptDims:i}=util_exports.squeezeShape(n),l=o;if(l.length<n.length){const n=["row","col"];return`\n      ${getSamplerFromInInfo(squeezeInputInfo(e,l),t)}\n      float ${r}(int row, int col) {\n        return ${r}(${getSqueezedParams(n,i)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));\n        ${getUniformSampler(e)}\n      }\n    `;const u=s[0],c=s[1],d=getFlatOffsetUniformName(a);return 1===c?t?`\n      float ${r}(int row, int col) {\n        float index = dot(vec3(row, col, ${d}), vec3(${a}Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(${a}TexShape[0]));\n        return sampleTexture(${a}, uv);\n      }\n    `:`\n    float ${r}(int row, int col) {\n      float index = dot(vec3(row, col, ${d}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${u}.0);\n      return sampleTexture(${a}, uv);\n    }\n  `:1===u?t?`\n      float ${r}(int row, int col) {\n        float index = dot(vec3(row, col, ${d}), vec3(${a}Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(${a}TexShape[1]), 0.5);\n        return sampleTexture(${a}, uv);\n      }\n    `:`\n    float ${r}(int row, int col) {\n      float index = dot(vec3(row, col, ${d}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${c}.0, 0.5);\n      return sampleTexture(${a}, uv);\n    }\n  `:t?`\n      float ${r}(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${a}Shape[1] + col + ${d};\n        vec2 uv = uvFromFlat(${a}TexShape[0], ${a}TexShape[1], index);\n        return sampleTexture(${a}, uv);\n      }\n    `:`\n  float ${r}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${n[1]} + col + ${d};\n    vec2 uv = uvFromFlat(${u}, ${c}, index);\n    return sampleTexture(${a}, uv);\n  }\n`}function getPackedSampler3D(e,t){const n=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),s=e.shapeInfo.texShape,o=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];if(1===n[0]){const a=[1,2],s=["b","row","col"];return`\n        ${getPackedSamplerFromInInfo(squeezeInputInfo(e,n.slice(1)),t)}\n        vec4 ${r}(int b, int row, int col) {\n          return ${r}(${getSqueezedParams(s,a)});\n        }\n      `}const i=getGlslDifferences();if(t)return`\n    vec4 ${r}(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${a}TexShape[0]) / 2.0), ceil(float(${a}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${a}Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${a}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ${i.texture2D}(${a}, uv);\n    }\n  `;const l=o[0],u=o[1],c=Math.ceil(n[2]/2);return`\n    vec4 ${r}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${l}, ${u}, ${c*Math.ceil(n[1]/2)}, ${c}, b, row, col);\n      return ${i.texture2D}(${a}, uv);\n    }\n  `}function getSampler3D(e,t){const n=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),s=n[1]*n[2],o=n[2],{newShape:i,keptDims:l}=util_exports.squeezeShape(n),u=i;if(u.length<n.length){const n=["row","col","depth"];return`\n        ${getSamplerFromInInfo(squeezeInputInfo(e,u),t)}\n        float ${r}(int row, int col, int depth) {\n          return ${r}(${getSqueezedParams(n,l)});\n        }\n      `}if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${s}, ${o}, 1)));\n        ${getUniformSampler(e)}\n      }\n    `;const c=e.shapeInfo.texShape,d=c[0],p=c[1],h=e.shapeInfo.flatOffset;if(p===s&&null==h)return t?`\n      float ${r}(int row, int col, int depth) {\n        int stride1 = ${a}Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${a}TexShape[1], ${a}TexShape[0]);\n        return sampleTexture(${a}, uv);\n      }\n    `:`\n        float ${r}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${o}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${p}.0, ${d}.0);\n          return sampleTexture(${a}, uv);\n        }\n      `;if(p===o&&null==h)return t?`\n      float ${r}(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(${a}Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${a}TexShape[1], ${a}TexShape[0]);\n        return sampleTexture(${a}, uv);\n      }\n    `:`\n    float ${r}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${p}.0, ${d}.0);\n      return sampleTexture(${a}, uv);\n    }\n  `;const m=getFlatOffsetUniformName(a);return t?`\n    float ${r}(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ${a}Shape[1] * ${a}Shape[2];\n      int stride1 = ${a}Shape[2];\n      int index = row * ${s} + col * ${o} + depth + ${m};\n      vec2 uv = uvFromFlat(${a}TexShape[0], ${a}TexShape[1], index);\n      return sampleTexture(${a}, uv);\n    }\n    `:`\n      float ${r}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${s} + col * ${o} + depth + ${m};\n        vec2 uv = uvFromFlat(${d}, ${p}, index);\n        return sampleTexture(${a}, uv);\n      }\n  `}function getPackedSamplerND(e,t){const n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1),r=getGlslDifferences();if(t)return`\n    vec4 ${a}(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ${n}Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${r.texture2D}(${n}, uv);\n    }\n  `;const s=e.shapeInfo.logicalShape,o=s.length,i=e.shapeInfo.texShape,l=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)],u=l[0],c=l[1],d=Math.ceil(s[o-1]/2);let p=d*Math.ceil(s[o-2]/2),h="int b, int row, int col",m=`b * ${p} + (row / 2) * ${d} + (col / 2)`;for(let e=2;e<o-1;e++)h=`int b${e}, `+h,p*=s[o-e-1],m=`b${e} * ${p} + `+m;return`\n    vec4 ${a}(${h}) {\n      int index = ${m};\n      int texR = index / ${c};\n      int texC = index - texR * ${c};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}, ${u});\n      return ${r.texture2D}(${n}, uv);\n    }\n  `}function getSampler4D(e,t){const n=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),s=n[3],o=n[2]*s,i=n[1]*o,{newShape:l,keptDims:u}=util_exports.squeezeShape(n);if(l.length<n.length){const n=["row","col","depth","depth2"];return`\n      ${getSamplerFromInInfo(squeezeInputInfo(e,l),t)}\n      float ${r}(int row, int col, int depth, int depth2) {\n        return ${r}(${getSqueezedParams(n,u)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${i}, ${o}, ${s}, 1)));\n        ${getUniformSampler(e)}\n      }\n    `;const c=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,p=d[0],h=d[1],m=`int stride2 = ${a}Shape[3];`,f=`int stride1 = ${a}Shape[2] * stride2;`,g=`int stride0 = ${a}Shape[1] * stride1;`;if(h===i&&null==c)return t?`\n      float ${r}(int row, int col, int depth, int depth2) {\n        ${m}\n        ${f}\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${a}TexShape[1], ${a}TexShape[0]);\n        return sampleTexture(${a}, uv);\n      }\n    `:`\n      float ${r}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${o}, ${s}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${h}.0, ${p}.0);\n        return sampleTexture(${a}, uv);\n      }\n    `;if(h===s&&null==c)return t?`\n      float ${r}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${a}Shape[1] * ${a}Shape[2], ${a}Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${a}TexShape[1], ${a}TexShape[0]);\n        return sampleTexture(${a}, uv);\n      }\n    `:`\n      float ${r}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${n[1]*n[2]}, ${n[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${h}.0, ${p}.0);\n        return sampleTexture(${a}, uv);\n      }\n    `;const x=getFlatOffsetUniformName(a);return t?`\n    float ${r}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ${m}\n      ${f}\n      ${g}\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(${a}TexShape[0], ${a}TexShape[1], index + ${x});\n      return sampleTexture(${a}, uv);\n    }\n  `:`\n    float ${r}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${i} + col * ${o} +\n          depth * ${s} + depth2;\n      vec2 uv = uvFromFlat(${p}, ${h}, index + ${x});\n      return sampleTexture(${a}, uv);\n    }\n  `}function getSampler5D(e){const t=e.shapeInfo.logicalShape,n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1),r=t[4],s=t[3]*r,o=t[2]*s,i=t[1]*o,{newShape:l,keptDims:u}=util_exports.squeezeShape(t);if(l.length<t.length){const t=["row","col","depth","depth2","depth3"];return`\n      ${getSamplerFromInInfo(squeezeInputInfo(e,l))}\n      float ${a}(int row, int col, int depth, int depth2, int depth3) {\n        return ${a}(${getSqueezedParams(t,u)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${a}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${i}, ${o}, ${s}, ${r})) +\n          depth3;\n        ${getUniformSampler(e)}\n      }\n    `;const c=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,p=d[0],h=d[1];if(h===i&&null==c)return`\n      float ${a}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${o}, ${s}, ${r}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${h}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(h===r&&null==c)return`\n      float ${a}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]},\n               ${t[2]*t[3]}, ${t[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${h}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;return`\n    float ${a}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${i} + col * ${o} + depth * ${s} +\n          depth2 * ${r} + depth3 + ${getFlatOffsetUniformName(n)};\n      vec2 uv = uvFromFlat(${p}, ${h}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}function getSampler6D(e){const t=e.shapeInfo.logicalShape,n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:r,keptDims:s}=util_exports.squeezeShape(t);if(r.length<t.length){const t=["row","col","depth","depth2","depth3","depth4"];return`\n      ${getSamplerFromInInfo(squeezeInputInfo(e,r))}\n      float ${a}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${a}(${getSqueezedParams(t,s)});\n      }\n    `}const o=t[5],i=t[4]*o,l=t[3]*i,u=t[2]*l,c=t[1]*u;if(e.shapeInfo.isUniform)return`\n      float ${a}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${c}, ${u}, ${l}, ${i})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${o}, 1)));\n        ${getUniformSampler(e)}\n      }\n    `;const d=e.shapeInfo.flatOffset,p=e.shapeInfo.texShape,h=p[0],m=p[1];if(m===c&&null==d)return`\n      float ${a}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${u}, ${l}, ${i}, ${o})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${m}.0, ${h}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(m===o&&null==d)return`\n      float ${a}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]*t[4]},\n               ${t[2]*t[3]*t[4]},\n               ${t[3]*t[4]},\n               ${t[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${m}.0, ${h}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;return`\n    float ${a}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${c} + col * ${u} + depth * ${l} +\n          depth2 * ${i} + depth3 * ${o} + depth4 + ${getFlatOffsetUniformName(n)};\n      vec2 uv = uvFromFlat(${h}, ${m}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}function getUniformSampler(e){const t=e.name,n=util_exports.sizeFromShape(e.shapeInfo.logicalShape);return n<2?`return ${t};`:`\n    for (int i = 0; i < ${n}; i++) {\n      if (i == index) {\n        return ${t}[i];\n      }\n    }\n  `}function getPackedSamplerAtOutputCoords(e,t){const n=e.name,a=n.charAt(0).toUpperCase()+n.slice(1),r="get"+a+"AtOutCoords",s=e.shapeInfo.logicalShape.length,o=t.logicalShape.length,i=getBroadcastDims2(e.shapeInfo.logicalShape,t.logicalShape),l=getCoordsDataType(o),u=o-s;let c;const d=["x","y","z","w","u","v"];c=0===s?"":o<2&&i.length>=1?"coords = 0;":i.map((e=>`coords.${d[e+u]} = 0;`)).join("\n");let p="";p=o<2&&s>0?"coords":e.shapeInfo.logicalShape.map(((e,t)=>`coords.${d[t+u]}`)).join(", ");let h="return outputValue;";const m=1===util_exports.sizeFromShape(e.shapeInfo.logicalShape),f=1===util_exports.sizeFromShape(t.logicalShape);if(1!==s||m||f){if(m&&!f)h=1===o?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(i.length){const e=s-2,t=s-1;i.indexOf(e)>-1&&i.indexOf(t)>-1?h="return vec4(outputValue.x);":i.indexOf(e)>-1?h="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":i.indexOf(t)>-1&&(h="return vec4(outputValue.xx, outputValue.zz);")}}else h="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${r}() {\n      ${l} coords = getOutputCoords();\n      ${c}\n      vec4 outputValue = get${a}(${p});\n      ${h}\n    }\n  `}function getSamplerAtOutputCoords(e,t){const n=e.name,a=n.charAt(0).toUpperCase()+n.slice(1),r="get"+a+"AtOutCoords",s=t.texShape,o=e.shapeInfo.texShape,i=e.shapeInfo.logicalShape.length,l=t.logicalShape.length;if(!e.shapeInfo.isUniform&&i===l&&null==e.shapeInfo.flatOffset&&util_exports.arraysEqual(o,s))return`\n      float ${r}() {\n        return sampleTexture(${n}, resultUV);\n      }\n    `;const u=getCoordsDataType(l),c=getBroadcastDims2(e.shapeInfo.logicalShape,t.logicalShape),d=l-i;let p;const h=["x","y","z","w","u","v"];p=0===i?"":l<2&&c.length>=1?"coords = 0;":c.map((e=>`coords.${h[e+d]} = 0;`)).join("\n");let m="";return m=l<2&&i>0?"coords":e.shapeInfo.logicalShape.map(((e,t)=>`coords.${h[t+d]}`)).join(", "),`\n    float ${r}() {\n      ${u} coords = getOutputCoords();\n      ${p}\n      return get${a}(${m});\n    }\n  `}function getCoordsDataType(e){if(e<=1)return"int";if(2===e)return"ivec2";if(3===e)return"ivec3";if(4===e)return"ivec4";if(5===e)return"ivec5";if(6===e)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)}function getUniformInfoFromShape(e,t,n){const{newShape:a,keptDims:r}=util_exports.squeezeShape(t),s=t.length,o=e&&3===s&&1===t[0],i=o?t.slice(1):a,l=!e&&s>1&&!util_exports.arraysEqual(t,n)&&a.length<s||o;return{useSqueezeShape:l,uniformShape:l?i:t,keptDims:r}}function squeezeInputInfo(e,t){const n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function getSqueezedParams(e,t){return t.map((t=>e[t])).join(", ")}function compileProgram(e,t,n,a){const r=n.map(((e,n)=>{const a={logicalShape:e.shape,texShape:e.isUniform?null:e.texData.texShape,isUniform:e.isUniform,isPacked:!e.isUniform&&e.texData.isPacked,flatOffset:null};return null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0&&(a.flatOffset=e.texData.slice.flatOffset),{name:t.variableNames[n],shapeInfo:a}})),s=r.map((e=>e.shapeInfo)),o={logicalShape:a.shape,texShape:a.texData.texShape,isUniform:!1,isPacked:a.texData.isPacked,flatOffset:null},i=makeShader(r,o,t),l=createFragmentShader(e.gl,i),u=e.createProgram(l);let c=null;const d=e.getUniformLocation(u,"NAN",!1);1===env().getNumber("WEBGL_VERSION")&&(c=e.getUniformLocation(u,"INFINITY",!1));const p=!1,h={},m={},f={};for(let n=0;n<t.variableNames.length;n++){const a=t.variableNames[n];h[a]=e.getUniformLocation(u,a,p),h[`offset${a}`]=e.getUniformLocation(u,`offset${a}`,p),t.enableShapeUniforms&&(m[`${a}Shape`]=e.getUniformLocation(u,`${a}Shape`,p),f[`${a}TexShape`]=e.getUniformLocation(u,`${a}TexShape`,p))}let g,x,y;t.enableShapeUniforms&&(g=e.getUniformLocation(u,"outShape",p),y=e.getUniformLocation(u,"outShapeStrides",p),x=e.getUniformLocation(u,"outTexShape",p));const A=[];return t.customUniforms&&t.customUniforms.forEach(((t,n)=>{A[n]=e.getUniformLocation(u,t.name,p)})),{program:t,fragmentShader:l,source:i,webGLProgram:u,uniformLocations:h,customUniformLocations:A,inShapeInfos:s,outShapeInfo:o,infLoc:c,nanLoc:d,inShapesLocations:m,inTexShapesLocations:f,outShapeLocation:g,outShapeStridesLocation:y,outTexShapeLocation:x}}function validateBinaryAndProgram(e,t){if(e.length!==t.length)throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${t.length} inputs`);e.forEach(((e,n)=>{const a=e.logicalShape,r=t[n],s=r.shape;if(!util_exports.arraysEqual(a,s))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${a} and ${s} must match`);if(e.isUniform&&r.isUniform)return;const o=e.texShape,i=r.isUniform?null:r.texData.texShape;if(!util_exports.arraysEqual(o,i))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${o} and ${i} must match`)}))}function runProgram(e,t,n,a,r){t.program.enableShapeUniforms||(validateBinaryAndProgram(t.inShapeInfos,n),validateBinaryAndProgram([t.outShapeInfo],[a]));const s=a.texData.texture,o=a.texData.texShape;a.texData.isPacked?e.setOutputPackedMatrixTexture(s,o[0],o[1]):e.setOutputMatrixTexture(s,o[0],o[1]),e.setProgram(t.webGLProgram),1===env().getNumber("WEBGL_VERSION")&&null!==t.infLoc&&e.gl.uniform1f(t.infLoc,1/0),null!==t.nanLoc&&e.gl.uniform1f(t.nanLoc,NaN),n.forEach(((n,a)=>{const r=t.program.variableNames[a],s=t.uniformLocations[r],o=t.uniformLocations[`offset${r}`],i=t.inShapesLocations[`${r}Shape`],l=t.inTexShapesLocations[`${r}TexShape`];if(i){const{uniformShape:a}=getUniformInfoFromShape(t.program.packedInputs,n.shape,n.texData.texShape);switch(a.length){case 1:e.gl.uniform1iv(i,new Int32Array(a));break;case 2:e.gl.uniform2iv(i,new Int32Array(a));break;case 3:e.gl.uniform3iv(i,new Int32Array(a));break;case 4:e.gl.uniform4iv(i,new Int32Array(a))}}if(l&&e.gl.uniform2i(l,n.texData.texShape[0],n.texData.texShape[1]),null!=s)if(n.isUniform)if(util_exports.sizeFromShape(n.shape)<2)e.gl.uniform1f(s,n.uniformValues[0]);else{let t=n.uniformValues;t instanceof Float32Array||(t=new Float32Array(t)),e.gl.uniform1fv(s,t)}else null!=n.texData.slice&&null!=o&&e.gl.uniform1i(o,n.texData.slice.flatOffset),e.setInputMatrixTexture(n.texData.texture,s,a)}));const i=t.outShapeLocation;if(i)switch(a.shape.length){case 1:e.gl.uniform1iv(i,new Int32Array(a.shape));break;case 2:e.gl.uniform2iv(i,new Int32Array(a.shape));break;case 3:e.gl.uniform3iv(i,new Int32Array(a.shape));break;case 4:e.gl.uniform4iv(i,new Int32Array(a.shape))}if(t.outShapeStridesLocation){const n=util_exports.computeStrides(a.shape);switch(a.shape.length){case 2:e.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(n));break;case 3:e.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(n));break;case 4:e.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(n))}}t.outTexShapeLocation&&e.gl.uniform2i(t.outTexShapeLocation,a.texData.texShape[0],a.texData.texShape[1]),t.program.customUniforms&&r&&t.program.customUniforms.forEach(((n,a)=>{const s=t.customUniformLocations[a],o=r[a];if("float"===n.type)e.gl.uniform1fv(s,o);else if("vec2"===n.type)e.gl.uniform2fv(s,o);else if("vec3"===n.type)e.gl.uniform3fv(s,o);else if("vec4"===n.type)e.gl.uniform4fv(s,o);else if("int"===n.type)e.gl.uniform1iv(s,o);else if("ivec2"===n.type)e.gl.uniform2iv(s,o);else if("ivec3"===n.type)e.gl.uniform3iv(s,o);else{if("ivec4"!==n.type)throw Error(`uniform type ${n.type} is not supported yet.`);e.gl.uniform4iv(s,o)}})),e.executeProgram()}function makeShaderKey(e,t,n){let a="";t.concat(n).forEach((t=>{const r=null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!t.isUniform){const s=t.texData.texShape,{useSqueezeShape:o,uniformShape:i,keptDims:l}=getUniformInfoFromShape(e.packedInputs,t.shape,s);let u="",c="",d="";if(1===i.length&&e.packedInputs){const e=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];u=`${e[0]>1}_${e[1]>1}`}else if(2!==i.length||e.packedInputs){if(i.length>2&&!e.packedInputs){const e=util_exports.computeStrides(i);d=`${e[0]===s[1]}_${e[e.length-1]===s[1]}`}}else c=`${i[0]>1}_${i[1]>1}`;const p=t.shape.length,h=2===i.length&&util_exports.arraysEqual(t.shape,s),m=1===util_exports.sizeFromShape(t.shape),f=backend_util_exports.getBroadcastDims(t.shape,n.shape),g=!e.packedInputs&&p===n.shape.length&&util_exports.arraysEqual(s,n.texData.texShape),x=e.packedInputs||i.length>2?"":`${s[0]>1}_${s[1]>1}`;a+=`${p}_${g}_${o?l:""}_${i.length}_${m}_${f}_${h}_${u}_${c}_${d}_${x}_${r}`}else{const e=t.isUniform?"uniform":t.texData.texShape;a+=`${t.shape}_${e}_${r}`}}));const r=e.userCode;let s=e.constructor.name;return s+="_"+a+"_"+r+`${env().getNumber("WEBGL_VERSION")}`,s}function useShapeUniforms(e){return env().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}var DecodeMatrixProgram=class{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=PackingScheme.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=getGlslDifferences();this.outputShape=e,this.enableShapeUniforms=useShapeUniforms(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?getOutputLogicalCoordinatesFromFlatIndexByUniform(["r","c","d"],e):getLogicalCoordinatesFromFlatIndex(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${t.output} = result;\n      }\n    `}},DecodeMatrixPackedProgram=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=PackingScheme.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=getGlslDifferences();this.outputShape=e,this.enableShapeUniforms=useShapeUniforms(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?getOutputLogicalCoordinatesFromFlatIndexByUniform(["r","c","d"],e):getLogicalCoordinatesFromFlatIndex(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${t.output} = result;\n      }\n    `}},EncodeFloatProgram=class{constructor(e){this.variableNames=["A"],this.outTexUsage=TextureUsage.DOWNLOAD;const t=getGlslDifferences();this.outputShape=e,this.userCode=`\n      ${ENCODE_FLOAT_SNIPPET}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${t.output} = encode_float(x);\n      }\n    `}},EncodeFloatPackedProgram=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=TextureUsage.DOWNLOAD;const t=getGlslDifferences();this.outputShape=e,this.userCode=`\n      ${ENCODE_FLOAT_SNIPPET}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${t.output} = encode_float(x);\n      }\n    `}},EncodeMatrixProgram=class{constructor(e,t=!1){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=getGlslDifferences();this.outputShape=e,this.enableShapeUniforms=useShapeUniforms(this.outputShape.length);let a="result";t&&(a="floor(result * 255. + 0.5)"),this.userCode=`\n      ${this.enableShapeUniforms?getFlatIndexFrom3DOutput():getFlatIndexFrom3D(e)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        int flatIndex = getFlatIndex(coords);\n        int offset = imod(flatIndex, 4);\n\n        flatIndex = idiv(flatIndex, 4, 1.);\n\n        int r = flatIndex / texShape[1];\n        int c = imod(flatIndex, texShape[1]);\n        vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n        vec4 values = ${n.texture2D}(A, uv);\n\n        float result;\n\n        if(offset == 0) {\n          result = values[0];\n        } else if(offset == 1) {\n          result = values[1];\n        } else if(offset == 2) {\n          result = values[2];\n        } else {\n          result = values[3];\n        }\n\n        ${n.output} = vec4(${a}, 0., 0., 0.);\n      }\n    `}},EncodeMatrixPackedProgram=class{constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=getGlslDifferences();this.outputShape=e,this.enableShapeUniforms=useShapeUniforms(this.outputShape.length);let a="",r="result";t&&(r="floor(result * 255. + 0.5)");for(let t=0;t<=1;t++)for(let r=0;r<=1;r++){const s=2*t+r;a+=`\n          localCoords = coords;\n          if(localCoords[2] + ${r} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {\n          localCoords[2] += ${r};\n          if (localCoords[1] + ${t} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {\n            localCoords[1] += ${t};\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ${n.texture2D}(A, uv);\n\n            if (offset == 0) {\n              result[${s}] = values[0];\n            } else if (offset == 1) {\n              result[${s}] = values[1];\n            } else if (offset == 2) {\n              result[${s}] = values[2];\n            } else {\n              result[${s}] = values[3];\n            }\n          }\n        }\n        `}this.userCode=`\n        ${this.enableShapeUniforms?getFlatIndexFrom3DOutput():getFlatIndexFrom3D(e)}\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ${a}\n\n          ${n.output} = ${r};\n        }\n    `}},gpgpu_util_exports={};function createVertexShader2(e){const t=getGlslDifferences();return createVertexShader(e,`${t.version}\n    precision highp float;\n    ${t.attribute} vec3 clipSpacePos;\n    ${t.attribute} vec2 uv;\n    ${t.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`)}function createVertexBuffer(e){return createStaticVertexBuffer(e,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}function createIndexBuffer(e){return createStaticIndexBuffer(e,new Uint16Array([0,1,2,2,1,3]))}function createAndConfigureTexture(e,t,n,a,r,s){validateTextureSize(t,n);const o=createTexture(e),i=e.TEXTURE_2D;return callAndCheck(e,(()=>e.bindTexture(i,o))),callAndCheck(e,(()=>e.texParameteri(i,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE))),callAndCheck(e,(()=>e.texParameteri(i,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE))),callAndCheck(e,(()=>e.texParameteri(i,e.TEXTURE_MIN_FILTER,e.NEAREST))),callAndCheck(e,(()=>e.texParameteri(i,e.TEXTURE_MAG_FILTER,e.NEAREST))),callAndCheck(e,(()=>e.texImage2D(i,0,a,t,n,0,r,s,null))),callAndCheck(e,(()=>e.bindTexture(e.TEXTURE_2D,null))),o}function getInternalFormatForFloat32MatrixTexture(e){return e.internalFormatFloat}function createFloat32MatrixTexture(e,t,n,a){const[r,s]=getUnpackedMatrixTextureShapeWidthHeight(t,n);return createAndConfigureTexture(e,r,s,getInternalFormatForFloat32MatrixTexture(a),a.textureFormatFloat,e.FLOAT)}function getInternalFormatForFloat16MatrixTexture(e){return e.internalFormatHalfFloat}function createFloat16MatrixTexture(e,t,n,a){const[r,s]=getUnpackedMatrixTextureShapeWidthHeight(t,n);return createAndConfigureTexture(e,r,s,getInternalFormatForFloat16MatrixTexture(a),a.textureFormatFloat,a.textureTypeHalfFloat)}function getInternalFormatForUnsignedBytesMatrixTexture(e){return e.downloadTextureFormat}function createUnsignedBytesMatrixTexture(e,t,n,a){const[r,s]=getUnpackedMatrixTextureShapeWidthHeight(t,n);return createAndConfigureTexture(e,r,s,getInternalFormatForUnsignedBytesMatrixTexture(a),e.RGBA,e.UNSIGNED_BYTE)}function getInternalFormatForPackedMatrixTexture(e){return e.internalFormatPackedFloat}function createPackedMatrixTexture(e,t,n,a){const[r,s]=getPackedMatrixTextureShapeWidthHeight(t,n);return createAndConfigureTexture(e,r,s,getInternalFormatForPackedMatrixTexture(a),e.RGBA,e.FLOAT)}function getInternalFormatForFloat16PackedMatrixTexture(e){return e.internalFormatPackedHalfFloat}function createFloat16PackedMatrixTexture(e,t,n,a){const[r,s]=getPackedMatrixTextureShapeWidthHeight(t,n);return createAndConfigureTexture(e,r,s,getInternalFormatForFloat16PackedMatrixTexture(a),e.RGBA,a.textureTypeHalfFloat)}function bindVertexProgramAttributeStreams(e,t,n){callAndCheck(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n)));return bindVertexBufferToProgramAttribute(e,t,"clipSpacePos",n,3,20,0)&&bindVertexBufferToProgramAttribute(e,t,"uv",n,2,20,12)}function uploadDenseMatrixToTexture(e,t,n,a,r,s){let o,i,l;callAndCheck(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),r instanceof Uint8Array?(o=new Uint8Array(n*a*4),i=e.UNSIGNED_BYTE,l=e.RGBA):(o=new Float32Array(n*a*4),i=e.FLOAT,l=s.internalFormatPackedFloat),o.set(r),callAndCheck(e,(()=>e.texImage2D(e.TEXTURE_2D,0,l,n,a,0,e.RGBA,i,o))),callAndCheck(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}function uploadPixelDataToTexture(e,t,n){callAndCheck(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),n.data instanceof Uint8Array?callAndCheck(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data))):callAndCheck(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n))),callAndCheck(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}function createBufferFromOutputTexture(e,t,n,a){const r=e.createBuffer();callAndCheck(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,r)));const s=16*t*n;return callAndCheck(e,(()=>e.bufferData(e.PIXEL_PACK_BUFFER,s,e.STREAM_READ))),callAndCheck(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0))),callAndCheck(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null))),r}function downloadFloat32MatrixFromBuffer(e,t,n){const a=e,r=new Float32Array(n);return a.bindBuffer(a.PIXEL_PACK_BUFFER,t),a.getBufferSubData(a.PIXEL_PACK_BUFFER,0,r),a.bindBuffer(a.PIXEL_PACK_BUFFER,null),r}function downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n,a){const[r,s]=getUnpackedMatrixTextureShapeWidthHeight(t,n),o=new Uint8Array(getUnpackedArraySizeFromMatrixSize(t*n,4));return callAndCheck(e,(()=>e.readPixels(0,0,r,s,a.downloadTextureFormat,e.UNSIGNED_BYTE,o))),new Float32Array(o.buffer)}function downloadPackedMatrixFromBuffer(e,t,n,a,r,s,o,i){const l=e,u=new Float32Array(getPackedRGBAArraySizeFromMatrixShape(s,o));return l.bindBuffer(l.PIXEL_PACK_BUFFER,t),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,u),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),u}function downloadMatrixFromPackedOutputTexture(e,t,n){const a=new Float32Array(t*n*4);return callAndCheck(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,a))),a}__export2(gpgpu_util_exports,{bindVertexProgramAttributeStreams:()=>bindVertexProgramAttributeStreams,createBufferFromOutputTexture:()=>createBufferFromOutputTexture,createFloat16MatrixTexture:()=>createFloat16MatrixTexture,createFloat16PackedMatrixTexture:()=>createFloat16PackedMatrixTexture,createFloat32MatrixTexture:()=>createFloat32MatrixTexture,createIndexBuffer:()=>createIndexBuffer,createPackedMatrixTexture:()=>createPackedMatrixTexture,createUnsignedBytesMatrixTexture:()=>createUnsignedBytesMatrixTexture,createVertexBuffer:()=>createVertexBuffer,createVertexShader:()=>createVertexShader2,downloadByteEncodedFloatMatrixFromOutputTexture:()=>downloadByteEncodedFloatMatrixFromOutputTexture,downloadFloat32MatrixFromBuffer:()=>downloadFloat32MatrixFromBuffer,downloadMatrixFromPackedOutputTexture:()=>downloadMatrixFromPackedOutputTexture,downloadPackedMatrixFromBuffer:()=>downloadPackedMatrixFromBuffer,getInternalFormatForFloat16MatrixTexture:()=>getInternalFormatForFloat16MatrixTexture,getInternalFormatForFloat16PackedMatrixTexture:()=>getInternalFormatForFloat16PackedMatrixTexture,getInternalFormatForFloat32MatrixTexture:()=>getInternalFormatForFloat32MatrixTexture,getInternalFormatForPackedMatrixTexture:()=>getInternalFormatForPackedMatrixTexture,getInternalFormatForUnsignedBytesMatrixTexture:()=>getInternalFormatForUnsignedBytesMatrixTexture,uploadDenseMatrixToTexture:()=>uploadDenseMatrixToTexture,uploadPixelDataToTexture:()=>uploadPixelDataToTexture});var GPGPUContext=class{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];const t=env().getNumber("WEBGL_VERSION");null!=e?(this.gl=e,setWebGLContext(t,e)):this.gl=getWebGLContext(t);let n="WEBGL_color_buffer_float";const a="EXT_color_buffer_half_float";if(1===env().getNumber("WEBGL_VERSION")){const e="OES_texture_float",t="OES_texture_half_float";if(this.textureFloatExtension=getExtensionOrThrow(this.gl,e),hasExtension(this.gl,t))this.textureHalfFloatExtension=getExtensionOrThrow(this.gl,t);else if(env().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),hasExtension(this.gl,a))this.colorBufferHalfFloatExtension=getExtensionOrThrow(this.gl,a);else if(env().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",hasExtension(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else{if(!hasExtension(this.gl,a))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(a)}this.vertexBuffer=createVertexBuffer(this.gl),this.indexBuffer=createIndexBuffer(this.gl),this.framebuffer=createFramebuffer(this.gl),this.textureConfig=getTextureConfig(this.gl,this.textureHalfFloatExtension)}get debug(){return env().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;callAndCheck(e,(()=>e.finish())),callAndCheck(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,null))),callAndCheck(e,(()=>e.deleteFramebuffer(this.framebuffer))),callAndCheck(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,null))),callAndCheck(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null))),callAndCheck(e,(()=>e.deleteBuffer(this.indexBuffer))),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),createFloat32MatrixTexture(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),createFloat16MatrixTexture(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),createUnsignedBytesMatrixTexture(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),uploadPixelDataToTexture(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,a){this.throwIfDisposed(),uploadDenseMatrixToTexture(this.gl,e,t,n,a,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),createFloat16PackedMatrixTexture(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),createPackedMatrixTexture(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(unbindColorTextureFromFramebuffer(this.gl,this.framebuffer),this.outputTexture=null),callAndCheck(this.gl,(()=>this.gl.deleteTexture(e)))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>downloadByteEncodedFloatMatrixFromOutputTexture(this.gl,t,n,this.textureConfig)))}downloadPackedMatrixFromBuffer(e,t,n,a,r,s){return downloadPackedMatrixFromBuffer(this.gl,e,t,n,a,r,s,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return downloadFloat32MatrixFromBuffer(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);const a=createBufferFromOutputTexture(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),a}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if(env().getBool("WEBGL_FENCE_API_ENABLED")){const a=e,r=a.fenceSync(a.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{const e=a.clientWaitSync(r,0,0);return e===a.ALREADY_SIGNALED||e===a.CONDITION_SATISFIED},t=r}else env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>downloadMatrixFromPackedOutputTexture(this.gl,t,n)))}createProgram(e){this.throwIfDisposed();const t=this.gl;null==this.vertexShader&&(this.vertexShader=createVertexShader2(t));const n=createProgram(t);return callAndCheck(t,(()=>t.attachShader(n,this.vertexShader))),callAndCheck(t,(()=>t.attachShader(n,e))),linkProgram(t,n),this.debug&&validateProgram(t,n),this.vertexAttrsAreBound||(this.setProgram(n),this.vertexAttrsAreBound=bindVertexProgramAttributeStreams(t,this.program,this.vertexBuffer)),n}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),null!=e&&callAndCheck(this.gl,(()=>this.gl.deleteProgram(e)))}setProgram(e){this.throwIfDisposed(),this.program=e,null!=this.program&&this.debug&&validateProgram(this.gl,this.program),callAndCheck(this.gl,(()=>this.gl.useProgram(e)))}getUniformLocation(e,t,n=!0){return this.throwIfDisposed(),n?getProgramUniformLocationOrThrow(this.gl,e,t):getProgramUniformLocation(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),callAndCheck(this.gl,(()=>this.gl.getAttribLocation(e,t)))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),bindTextureToProgramUniformSampler(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();const[a,r]=getPackedMatrixTextureShapeWidthHeight(t,n);this.setOutputMatrixTextureDriver(e,a,r)}setOutputMatrixWriteRegion(e,t,n,a){this.setOutputMatrixWriteRegionDriver(n,e,a,t)}setOutputPackedMatrixWriteRegion(e,t,n,a){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&validateProgram(this.gl,this.program),validateFramebuffer(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;this.debug&&this.debugValidate(),callAndCheck(e,(()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0)))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),callAndCheck(this.gl,(()=>this.gl.finish()))}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=getExtensionOrThrow(this.gl,2===env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2(),n=e.createQuery();return e.beginQuery(t.TIME_ELAPSED_EXT,n),n}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(2===env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2();return void e.endQuery(t.TIME_ELAPSED_EXT)}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await util_exports.repeatedTry((()=>this.disposed||this.isQueryAvailable(e,env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")))),this.getQueryTime(e,env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(0===t)return null;if(2===t){const t=this.gl;return t.getQueryParameter(e,t.QUERY_RESULT)/1e6}{const t=this.getQueryTimerExtensionWebGL1();return t.getQueryObjectEXT(e,t.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(0===t)return!0;if(2===t){const t=this.gl,n=this.getQueryTimerExtensionWebGL2(),a=t.getQueryParameter(e,t.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),a&&!this.disjoint}{const t=this.getQueryTimerExtensionWebGL1(),n=t.getQueryObjectEXT(e,t.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(t.GPU_DISJOINT_EXT)),n&&!this.disjoint}}pollFence(e){return new Promise((t=>{this.addItemToPoll((()=>e.isFencePassed()),(()=>t()))}))}pollItems(){const e=linearSearchLastTrue(this.itemsToPoll.map((e=>e.isDoneFn)));for(let t=0;t<=e;++t){const{resolveFn:e}=this.itemsToPoll[t];e()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1||util_exports.repeatedTry((()=>(this.pollItems(),0===this.itemsToPoll.length)))}bindTextureToFrameBuffer(e){this.throwIfDisposed(),bindColorTextureToFramebuffer(this.gl,e,this.framebuffer),this.debug&&validateFramebuffer(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(bindColorTextureToFramebuffer(this.gl,this.outputTexture,this.framebuffer),this.debug&&validateFramebuffer(this.gl)):unbindColorTextureFromFramebuffer(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();const a=this.gl;bindColorTextureToFramebuffer(a,e,this.framebuffer),this.debug&&validateFramebuffer(a),this.outputTexture=e,callAndCheck(a,(()=>a.viewport(0,0,t,n))),callAndCheck(a,(()=>a.scissor(0,0,t,n)))}setOutputMatrixWriteRegionDriver(e,t,n,a){this.throwIfDisposed(),callAndCheck(this.gl,(()=>this.gl.scissor(e,t,n,a)))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}};function linearSearchLastTrue(e){let t=0;for(;t<e.length;++t){if(!e[t]())break}return t-1}var{addImpl:addImplCPU,bincountImpl:bincountImplCPU,bincountReduceImpl:bincountReduceImplCPU,ceilImpl:ceilImplCPU,concatImpl:concatImplCPU,equalImpl:equalImplCPU,expImpl:expImplCPU,expm1Impl:expm1ImplCPU,floorImpl:floorImplCPU,gatherNdImpl:gatherNdImplCPU,gatherV2Impl:gatherV2ImplCPU,greaterImpl:greaterImplCPU,greaterEqualImpl:greaterEqualImplCPU,lessImpl:lessImplCPU,lessEqualImpl:lessEqualImplCPU,linSpaceImpl:linSpaceImplCPU,logImpl:logImplCPU,maxImpl:maxImplCPU,maximumImpl:maximumImplCPU,minimumImpl:minimumImplCPU,multiplyImpl:multiplyImplCPU,negImpl:negImplCPU,notEqualImpl:notEqualImplCPU,prodImpl:prodImplCPU,rangeImpl:rangeImplCPU,rsqrtImpl:rsqrtImplCPU,sigmoidImpl:sigmoidImplCPU,simpleAbsImpl:simpleAbsImplCPU,sliceImpl:sliceImplCPU,sparseFillEmptyRowsImpl:sparseFillEmptyRowsImplCPU,sparseReshapeImpl:sparseReshapeImplCPU,sparseSegmentReductionImpl:sparseSegmentReductionImplCPU,sqrtImpl:sqrtImplCPU,stridedSliceImpl:stridedSliceImplCPU,stringNGramsImpl:stringNGramsImplCPU,stringSplitImpl:stringSplitImplCPU,stringToHashBucketFastImpl:stringToHashBucketFastImplCPU,subImpl:subImplCPU,tileImpl:tileImplCPU,topKImpl:topKImplCPU,transposeImpl:transposeImplCPU,uniqueImpl:uniqueImplCPU}=shared_exports;function getVecChannels(e,t){return["x","y","z","w","u","v"].slice(0,t).map((t=>`${e}.${t}`))}function getChannels(e,t){return 1===t?[e]:getVecChannels(e,t)}function getSourceCoords(e,t){if(1===e)return"rc";let n="";for(let a=0;a<e;a++)n+=t[a],a<e-1&&(n+=",");return n}var PackProgram=class{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e;const t=e.length;if(0===t)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const n=getChannels("rc",t),a=getCoordsDataType(t),r=getOutOfBoundsCondition(t,e,n),s=getSetup(t,e[e.length-1],e[e.length-2],n),o=getOutput(e,n);this.userCode=`\n        void main() {\n          ${a} rc = getOutputCoords();\n\n          if(${r}) {\n            setOutput(vec4(0));\n          } else {\n            ${s}\n\n            setOutput(vec4(${o}));\n          }\n        }\n      `}}};function getSourceCoordsArr(e,t){const n=[];for(let a=0;a<=1;a++)for(let r=0;r<=1;r++){let s=`${0===a?"r":"rp1"}, ${0===r?"c":"cp1"}`;for(let n=2;n<e;n++)s=`${t[t.length-1-n]},`+s;n.push(s)}return n}function getOutOfBoundsCondition(e,t,n){if(1===e)return`rc > ${t[0]}`;let a="";for(let r=e-2;r<e;r++)a+=`${n[r]} >= ${t[r]}`,r<e-1&&(a+="||");return a}function getSetup(e,t,n,a){if(1===e)return"";const r=a.slice(-2);return`\n    int r = ${r[0]};\n    int c = ${r[1]};\n    int rp1 = r + 1;\n    int cp1 = c + 1;\n\n    bool cEdge = cp1 >= ${t};\n    bool rEdge = rp1 >= ${n};\n  `}function getOutput(e,t){const n=e.length,a=getSourceCoordsArr(n,t);return 1===n?`getA(rc),\n            rc + 1 >= ${e[0]} ? 0. : getA(rc + 1),\n            0, 0`:`getA(${a[0]}),\n          cEdge ? 0. : getA(${a[1]}),\n          rEdge ? 0. : getA(${a[2]}),\n          rEdge || cEdge ? 0. : getA(${a[3]})`}var ReshapePackedProgram=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=useShapeUniforms(this.outputShape.length);let n="";for(let e=0;e<4;e++){let t="thisRC = rc;";e%2==1&&(t+="thisRC.z += 1;"),e>1&&(t+="thisRC.y += 1;"),n+=`\n        ${t}\n        ${e>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${e}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${e>0?"}":""}\n      `}this.userCode=`\n      ${getReshapedInputCoords(t,this.enableShapeUniforms)}\n      ${this.enableShapeUniforms?getFlatIndexFrom3DOutput():getFlatIndexFrom3D(e)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};\n        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};\n\n        ${n}\n\n        setOutput(result);\n      }\n    `}};function getReshapedInputCoords(e,t){return`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${t?getLogicalCoordinatesFromFlatIndexByUniform(["r","c","d"],"inputShape"):getLogicalCoordinatesFromFlatIndex(["r","c","d"],e)}\n      return ivec3(r, c, d);\n    }\n  `}var TextureManager=class{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(e,t,n){const a=getPhysicalFromLogicalTextureType(t,n),r=getKeyFromTextureShape(e,a,n);r in this.freeTextures||(this.freeTextures[r]=[]),r in this.usedTextures||(this.usedTextures[r]=[]);const s=computeBytes(e,a,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[r].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=s,this.log();const e=this.freeTextures[r].shift();return this.usedTextures[r].push(e),e}let o;return a===PhysicalTextureType.PACKED_2X2_FLOAT32?o=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):a===PhysicalTextureType.PACKED_2X2_FLOAT16?o=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):a===PhysicalTextureType.UNPACKED_FLOAT32?o=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):a===PhysicalTextureType.UNPACKED_FLOAT16?o=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):a===PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE&&(o=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[r].push(o),this.numUsedTextures++,this._numBytesAllocated+=s,this.log(),o}releaseTexture(e,t,n,a){if(null==this.freeTextures)return;const r=getPhysicalFromLogicalTextureType(n,a),s=getKeyFromTextureShape(t,r,a);s in this.freeTextures||(this.freeTextures[s]=[]);const o=computeBytes(t,r,this.gpgpu.gl,this.gpgpu.textureConfig,a),i=env().get("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==i&&this._numBytesAllocated>i?(this.gpgpu.deleteMatrixTexture(e),this._numBytesAllocated-=o):(this.freeTextures[s].push(e),this.numFreeTextures++,this._numBytesFree+=o),this.numUsedTextures--;const l=this.usedTextures[s],u=l.indexOf(e);if(u<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l.splice(u,1),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const e in this.freeTextures)this.freeTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e)}));for(const e in this.usedTextures)this.usedTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e)}));this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}};function numBytesForInternalFormat(e,t){const n=e;if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F)return 16;if(t===e.RGBA)return 16;if(t===n.RGBA16F)return 8;throw new Error(`Unknown internal format ${t}`)}function computeBytes(e,t,n,a,r){const s=internalFormatForPhysicalTexType(t,a);let o;if(r){const[t,n]=getPackedMatrixTextureShapeWidthHeight(e[0],e[1]);o=t*n}else{const[t,n]=getUnpackedMatrixTextureShapeWidthHeight(e[0],e[1]);o=t*n}return o*numBytesForInternalFormat(n,s)}function internalFormatForPhysicalTexType(e,t){switch(e){case PhysicalTextureType.PACKED_2X2_FLOAT32:return getInternalFormatForPackedMatrixTexture(t);case PhysicalTextureType.PACKED_2X2_FLOAT16:return getInternalFormatForFloat16PackedMatrixTexture(t);case PhysicalTextureType.UNPACKED_FLOAT32:return getInternalFormatForFloat32MatrixTexture(t);case PhysicalTextureType.UNPACKED_FLOAT16:return getInternalFormatForFloat16MatrixTexture(t);case PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE:return getInternalFormatForUnsignedBytesMatrixTexture(t);default:throw new Error(`Unknown physical texture type ${e}`)}}function getPhysicalTextureForRendering(e){return env().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?PhysicalTextureType.PACKED_2X2_FLOAT32:PhysicalTextureType.UNPACKED_FLOAT32:e?PhysicalTextureType.PACKED_2X2_FLOAT16:PhysicalTextureType.UNPACKED_FLOAT16}function getPhysicalFromLogicalTextureType(e,t){if(e===TextureUsage.UPLOAD)return PhysicalTextureType.PACKED_2X2_FLOAT32;if(e===TextureUsage.RENDER||null==e)return getPhysicalTextureForRendering(t);if(e===TextureUsage.DOWNLOAD||e===TextureUsage.PIXELS)return PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${e}`)}function getKeyFromTextureShape(e,t,n){return`${e[0]}_${e[1]}_${t}_${n}`}var UnaryOpProgram=class{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=useShapeUniforms(this.outputShape.length),this.userCode=`\n      float unaryOperation(float x) {\n        ${t}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}},CHECK_NAN_SNIPPET="if (isnan(x)) return x;",LINEAR="return x;",ABS="return abs(x);",ELU2="return (x >= 0.0) ? x : (exp(x) - 1.0);",RELU=CHECK_NAN_SNIPPET+"\n  return (x < 0.0) ? 0.0 : x;\n",RELU6=CHECK_NAN_SNIPPET+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",CLONE="return x;",SIGMOID="return 1.0 / (1.0 + exp(-1.0 * x));",LINEAR2="return x;",ELU3="\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n",RELU2="\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",RELU62="\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",SIGMOID2="return 1.0 / (1.0 + exp(-1.0 * x));",UnaryOpPackedProgram=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=useShapeUniforms(this.outputShape.length),this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${t}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}},UnpackProgram=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e;const t=e.length,n=getChannels("rc",t),a=getCoordsDataType(t),r=getSourceCoords(t,n),s=n.slice(-2),o=t<=1?"rc":`vec2(${s.join(",")})`;this.userCode=`\n      void main() {\n        ${a} rc = getOutputCoords();\n        vec4 packedInput = getA(${r});\n\n        setOutput(getChannel(packedInput, ${o}));\n      }\n    `}},whereImpl3=kernel_impls_exports.whereImpl,EPSILON_FLOAT322=1e-7,EPSILON_FLOAT162=1e-4,binaryCaches={};function getBinaryCache(e){return e in binaryCaches||(binaryCaches[e]={}),binaryCaches[e]}var CPU_HANDOFF_SIZE_THRESHOLD=env().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),BEFORE_PAGING_CONSTANT=600;function numMBBeforeWarning(){return null==env().global.screen?1024:env().global.screen.height*env().global.screen.width*window.devicePixelRatio*BEFORE_PAGING_CONSTANT/1024/1024}var _MathBackendWebGL=class extends KernelBackend{constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!env().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");if(null==e){const e=getWebGLContext(env().getNumber("WEBGL_VERSION"));this.binaryCache=getBinaryCache(env().getNumber("WEBGL_VERSION")),this.gpgpu=new GPGPUContext(e),this.canvas=e.canvas,this.gpgpuCreatedLocally=!0}else this.gpgpu=e,this.binaryCache={},this.gpgpuCreatedLocally=!1,this.canvas=e.gl.canvas;this.textureManager=new TextureManager(this.gpgpu),this.numMBBeforeWarning=numMBBeforeWarning(),this.texData=new DataStorage(this,engine())}nextDataId(){return _MathBackendWebGL.nextDataId++}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}write(e,t,n){if((env().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||env().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===n&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const a={id:this.nextDataId()};return this.texData.set(a,{shape:t,dtype:n,values:e,usage:TextureUsage.UPLOAD,refCount:1}),a}refCount(e){if(this.texData.has(e)){return this.texData.get(e).refCount}return 0}incRef(e){this.texData.get(e).refCount++}decRef(e){if(this.texData.has(e)){this.texData.get(e).refCount--}}move(e,t,n,a,r){if(env().getBool("DEBUG")&&this.checkNumericalProblems(t),"complex64"===a)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:n,dtype:a,values:t,usage:TextureUsage.UPLOAD,refCount:r})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:n,dtype:a,complexTensorInfos:r,slice:s,shape:o,isPacked:i}=t;if(null!=s){let t;t=i?new UnaryOpPackedProgram(o,CLONE):new UnaryOpProgram(o,CLONE);const n=this.runWebGLProgram(t,[{dataId:e,shape:o,dtype:a}],a),r=this.readSync(n.dataId);return this.disposeIntermediateTensorInfo(n),r}if(null!=n)return this.convertAndCacheOnCPU(e);if("string"===a)return n;const l=null!=this.activeTimers;let u,c;if(l&&(u=util_exports.now()),"complex64"===a){const e=this.readSync(r.real.dataId),t=this.readSync(r.imag.dataId);c=backend_util_exports.mergeRealAndImagArrays(e,t)}else c=this.getValuesFromTexture(e);return l&&(this.downloadWaitMs+=util_exports.now()-u),this.convertAndCacheOnCPU(e,c)}async read(e){if(this.pendingRead.has(e)){const t=this.pendingRead.get(e);return new Promise((e=>t.push(e)))}const t=this.texData.get(e),{values:n,shape:a,slice:r,dtype:s,complexTensorInfos:o,isPacked:i}=t;if(null!=r){let t;t=i?new UnaryOpPackedProgram(a,CLONE):new UnaryOpProgram(a,CLONE);const n=this.runWebGLProgram(t,[{dataId:e,shape:a,dtype:s}],s),r=this.read(n.dataId);return this.disposeIntermediateTensorInfo(n),r}if(null!=n)return this.convertAndCacheOnCPU(e);if(env().getBool("DEBUG")&&!env().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===env().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let l,u,c=null;if("complex64"!==s&&env().get("WEBGL_BUFFER_SUPPORTED")){l=this.decode(e);const t=this.texData.get(l.dataId);c=this.gpgpu.createBufferFromTexture(t.texture,...getDenseTexShape(a))}if(this.pendingRead.set(e,[]),"complex64"!==s&&await this.gpgpu.createAndWaitForFence(),"complex64"===s){const e=await Promise.all([this.read(o.real.dataId),this.read(o.imag.dataId)]),t=e[0],n=e[1];u=backend_util_exports.mergeRealAndImagArrays(t,n)}else if(null==c)u=this.getValuesFromTexture(e);else{const e=util_exports.sizeFromShape(a);u=this.gpgpu.downloadFloat32MatrixFromBuffer(c,e)}if(null!=l&&this.disposeIntermediateTensorInfo(l),null!=c){const e=this.gpgpu.gl;callAndCheck(e,(()=>e.deleteBuffer(c)))}const d=this.convertAndCacheOnCPU(e,u),p=this.pendingRead.get(e);return this.pendingRead.delete(e),p.forEach((e=>e(d))),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&engine().removeDataId(e,this),this.pendingDeletes--),d}bufferSync(e){const t=this.readSync(e.dataId);let n=t;if("string"===e.dtype)try{n=t.map((e=>util_exports.decodeString(e)))}catch(e){throw new Error("Failed to decode encoded string bytes into utf-8")}return buffer(e.shape,e.dtype,n)}checkNumericalProblems(e){if(null!=e)for(let t=0;t<e.length;t++){const n=e[t];if(!canBeRepresented(n)){if(env().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error(`The value ${n} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`);throw Error(`The value ${n} cannot be represented on this device.`)}}}getValuesFromTexture(e){const{shape:t,dtype:n,isPacked:a}=this.texData.get(e),r=util_exports.sizeFromShape(t);if(env().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const n=this.decode(e),a=this.texData.get(n.dataId),s=this.gpgpu.downloadMatrixFromPackedTexture(a.texture,...getDenseTexShape(t)).subarray(0,r);return this.disposeIntermediateTensorInfo(n),s}const s=env().getBool("WEBGL_PACK")&&!0===a,o=s?getShapeAs3D(t):t,i=s?new EncodeFloatPackedProgram(o):new EncodeFloatProgram(o),l=this.runWebGLProgram(i,[{shape:o,dtype:n,dataId:e}],"float32"),u=this.texData.get(l.dataId),c=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(u.texture,u.texShape[0],u.texShape[1]).subarray(0,r);return this.disposeIntermediateTensorInfo(l),c}timerAvailable(){return env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}async time(e){const t=this.activeTimers,n=[];let a=!1;null==this.programTimersStack?(this.programTimersStack=n,a=!0):this.activeTimers.push(n),this.activeTimers=n,e();const r=util_exports.flatten(this.activeTimers.map((e=>e.query))).filter((e=>null!=e)),s=util_exports.flatten(this.activeTimers.map((e=>e.name))).filter((e=>null!=e));this.activeTimers=t,a&&(this.programTimersStack=null);const o={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};if(env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const e=await Promise.all(r);o.kernelMs=util_exports.sum(e),o.getExtraProfileInfo=()=>e.map(((e,t)=>({name:s[t],ms:e}))).map((e=>`${e.name}: ${e.ms}`)).join(", ")}else o.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,o}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:util_exports.now(),endMs:null}}endTimer(e){return env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=util_exports.now(),e)}async getQueryTime(e){if(env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const t=e;return t.endMs-t.startMs}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:n}=this.texData.get(e);return null!=n&&(this.disposeData(n.real.dataId,t),this.disposeData(n.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:n,texShape:a,usage:r,isPacked:s,slice:o}=this.texData.get(e),i=o&&o.origDataId||e,l=this.dataRefCount.get(i);l>1?this.dataRefCount.set(i,l-1):(this.dataRefCount.delete(i),null!=t&&(this.numBytesInGPU-=this.computeBytes(a,n),this.textureManager.releaseTexture(t,a,r,s)));const u=this.texData.get(e);u.texture=null,u.texShape=null,u.isPacked=!1,u.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=CPU_HANDOFF_SIZE_THRESHOLD){return env().getBool("WEBGL_CPU_FORWARD")&&e.every((e=>null==this.texData.get(e.dataId).texture&&util_exports.sizeFromShape(e.shape)<t))}getGPGPUContext(){return this.gpgpu}where(e){backend_util_exports.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return whereImpl3(e.shape,t)}packedUnaryOp(e,t,n){const a=new UnaryOpPackedProgram(e.shape,t),r=this.compileAndRun(a,[e],n);return engine().makeTensorFromDataId(r.dataId,r.shape,r.dtype)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){const t=simpleAbsImplCPU(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,t)}if(env().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,ABS,e.dtype);const t=new UnaryOpProgram(e.shape,ABS),n=this.compileAndRun(t,[e]);return engine().makeTensorFromDataId(n.dataId,n.shape,n.dtype)}makeTensorInfo(e,t,n){let a;if("string"===t&&null!=n&&n.length>0&&util_exports.isString(n[0])){const r=n.map((e=>util_exports.encodeString(e)));a=this.write(r,e,t)}else a=this.write(n,e,t);return this.texData.get(a).usage=null,{dataId:a,shape:e,dtype:t}}makeOutput(e,t,n){const{dataId:a}=this.makeTensorInfo(e,t,n);return engine().makeTensorFromDataId(a,e,t,this)}unpackTensor(e){const t=new UnpackProgram(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new PackProgram(e.shape);return this.runWebGLProgram(t,[e],e.dtype,null,!0)}packedReshape(e,t){const n=[getBatchDim(e.shape),...getRowsCols(e.shape)],a={dtype:e.dtype,shape:n,dataId:e.dataId},r=[getBatchDim(t),...getRowsCols(t)],s=new ReshapePackedProgram(r,n),o=[n],i=this.runWebGLProgram(s,[a],e.dtype,o,!0);return{dataId:i.dataId,shape:t,dtype:i.dtype}}decode(e){const t=this.texData.get(e),{isPacked:n,shape:a,dtype:r}=t,s=getShapeAs3D(a);let o;const i=getDenseTexShape(s);o=n?new DecodeMatrixPackedProgram(s):new DecodeMatrixProgram(s);const l=[i];return{dtype:r,shape:a,dataId:this.runWebGLProgram(o,[{shape:s,dtype:r,dataId:e}],r,l,!0).dataId}}runWebGLProgram(e,t,n,a,r=!1){const s=this.makeTensorInfo(e.outputShape,n),o=this.texData.get(s.dataId);if(e.packedOutput&&(o.isPacked=!0),e.outPackingScheme===PackingScheme.DENSE){const t=getDenseTexShape(e.outputShape);o.texShape=t.map((e=>2*e))}if(null!=e.outTexUsage&&(o.usage=e.outTexUsage),0===util_exports.sizeFromShape(s.shape))return o.values=util_exports.getTypedArrayFromDType(s.dtype,0),s;const i=[],l=t.map((t=>{if("complex64"===t.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let n=this.texData.get(t.dataId);if(null==n.texture){if(!e.packedInputs&&util_exports.sizeFromShape(t.shape)<=env().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:t.shape,texData:null,isUniform:!0,uniformValues:n.values};e.packedInputs&&(n.isPacked=!0,n.shape=t.shape)}else if(!!n.isPacked!=!!e.packedInputs)t=n.isPacked?this.unpackTensor(t):this.packTensor(t),i.push(t),n=this.texData.get(t.dataId);else if(n.isPacked&&!isReshapeFree(n.shape,t.shape)){const e=t,a=t.shape;t.shape=n.shape,t=this.packedReshape(t,a),i.push(t),n=this.texData.get(t.dataId),e.shape=a}return this.uploadToGPU(t.dataId),{shape:t.shape,texData:n,isUniform:!1}}));this.uploadToGPU(s.dataId);const u={shape:s.shape,texData:o,isUniform:!1},c=makeShaderKey(e,l,u),d=this.getAndSaveBinary(c,(()=>compileProgram(this.gpgpu,e,l,u))),p=null!=this.activeTimers;let h;p&&(h=this.startTimer()),runProgram(this.gpgpu,d,l,u,a),i.forEach((e=>this.disposeIntermediateTensorInfo(e))),p&&(h=this.endTimer(h),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(h)}));const m=env().get("WEBGL_FLUSH_THRESHOLD");if(m>0){const e=util_exports.now();e-this.lastGlFlushTime>m&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=e)}if(!env().getBool("WEBGL_LAZILY_UNPACK")&&o.isPacked&&!1===r){const e=this.unpackTensor(s);return this.disposeIntermediateTensorInfo(s),e}return s}compileAndRun(e,t,n,a,r=!1){n=n||t[0].dtype;return this.runWebGLProgram(e,t,n,a,r)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){if(!this.disposed){if(!env().getBool("IS_TEST")){Object.keys(this.binaryCache).forEach((e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]}))}this.textureManager.dispose(),null!=this.canvas&&"undefined"!=typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0}}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=tidy((()=>{if(!env().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=env().getBool("DEBUG");env().set("DEBUG",!1);const t=this.abs(scalar(1e-8)).dataSync()[0];if(env().set("DEBUG",e),t>0)return 32}return 16}))),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?EPSILON_FLOAT322:EPSILON_FLOAT162}uploadToGPU(e){const t=this.texData.get(e),{shape:n,dtype:a,values:r,texture:s,usage:o,isPacked:i}=t;if(null!=s)return;const l=null!=this.activeTimers;let u;l&&(u=util_exports.now());let c=t.texShape;if(null==c&&(c=getTextureShapeFromLogicalShape(n,i),t.texShape=c),null!=r){const e=getShapeAs3D(n);let s,o=c[1],d=c[0];const p=r instanceof Uint8Array||r instanceof Uint8ClampedArray;i?([o,d]=getPackedMatrixTextureShapeWidthHeight(c[0],c[1]),s=new EncodeMatrixPackedProgram(e,p)):s=new EncodeMatrixProgram(e,p);const h=this.makeTensorInfo([d,o],a);this.texData.get(h.dataId).usage=p?TextureUsage.PIXELS:TextureUsage.UPLOAD,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(h.dataId),o,d,r);const m=[[d,o]],f=!0,g=this.runWebGLProgram(s,[h],a,m,f),x=this.texData.get(g.dataId);t.texture=x.texture,t.texShape=x.texShape,t.isPacked=x.isPacked,t.usage=x.usage,this.disposeIntermediateTensorInfo(h),this.texData.delete(g.dataId),t.values=null,l&&(this.uploadWaitMs+=util_exports.now()-u)}else{const e=this.acquireTexture(c,o,a,i);t.texture=e}}convertAndCacheOnCPU(e,t){const n=this.texData.get(e),{dtype:a}=n;return this.releaseGPUData(e),null!=t&&(n.values=float32ToTypedArray(t,a)),n.values}acquireTexture(e,t,n,a){if(this.numBytesInGPU+=this.computeBytes(e,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const e=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${e} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,a)}computeBytes(e,t){return e[0]*e[1]*util_exports.bytesPerElement(t)}},MathBackendWebGL=_MathBackendWebGL;function float32ToTypedArray(e,t){if("float32"===t||"complex64"===t)return e;if("int32"===t||"bool"===t){const n="int32"===t?new Int32Array(e.length):new Uint8Array(e.length);for(let t=0;t<n.length;++t)n[t]=Math.round(e[t]);return n}throw new Error(`Unknown dtype ${t}`)}MathBackendWebGL.nextDataId=0;var version6="0.0.0";function forceHalfFloat(){env().set("WEBGL_FORCE_F16_TEXTURES",!0)}device_util_exports.isBrowser()&&registerBackend("webgl",(()=>new MathBackendWebGL),2);var webgl={forceHalfFloat:forceHalfFloat},CHECK_NAN_SNIPPET2="\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n",BinaryOpProgram=class{constructor(e,t,n){this.variableNames=["A","B"],this.outputShape=backend_util_exports.assertAndGetBroadcastShape(t,n),this.enableShapeUniforms=useShapeUniforms(this.outputShape.length),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${e}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}},CHECK_NAN_SNIPPET3="\n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n",BinaryOpPackedProgram=class{constructor(e,t,n,a=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=backend_util_exports.assertAndGetBroadcastShape(t,n);const r=this.outputShape.length;this.enableShapeUniforms=useShapeUniforms(r);let s="";if(a)if(0===r||1===util_exports.sizeFromShape(this.outputShape))s="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else{if(s=`\n          ${getCoordsDataType(r)} coords = getOutputCoords();\n        `,1===r)this.enableShapeUniforms?s+="\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":s+=`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{const e=getChannels("coords",r);this.enableShapeUniforms?s+=`\n            bool nextRowOutOfBounds =\n              (${e[r-2]} + 1) >= outShape[${r} - 2];\n            bool nextColOutOfBounds =\n              (${e[r-1]} + 1) >= outShape[${r} - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `:s+=`\n            bool nextRowOutOfBounds =\n              (${e[r-2]} + 1) >= ${this.outputShape[r-2]};\n            bool nextColOutOfBounds =\n              (${e[r-1]} + 1) >= ${this.outputShape[r-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${e}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${s}\n\n        setOutput(result);\n      }\n    `}};function identity3(e){const{inputs:t,backend:n}=e,{x:a}=t;return n.incRef(a.dataId),{dataId:a.dataId,shape:a.shape,dtype:a.dtype}}var identityConfig2={kernelName:Identity,backendName:"webgl",kernelFunc:identity3};function complex3(e){const{inputs:t,backend:n}=e,{real:a,imag:r}=t,s=n.makeTensorInfo(a.shape,"complex64"),o=n.texData.get(s.dataId),i=identity3({inputs:{x:a},backend:n}),l=identity3({inputs:{x:r},backend:n});return o.complexTensorInfos={real:i,imag:l},s}var complexConfig2={kernelName:Complex,backendName:"webgl",kernelFunc:complex3},LEAKYRELU="return (a < 0.) ? b * a : a;",LEAKYRELU_PACKED="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";function leakyRelu3(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{alpha:s}=a,o=n.makeTensorInfo([],"float32",util_exports.createScalarValue(s,"float32")),i=env().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new BinaryOpPackedProgram(LEAKYRELU_PACKED,r.shape,o.shape):new BinaryOpProgram(LEAKYRELU,r.shape,o.shape),l=n.runWebGLProgram(i,[r,o],"float32");return n.disposeIntermediateTensorInfo(o),l}var leakyReluConfig2={kernelName:LeakyRelu,backendName:"webgl",kernelFunc:leakyRelu3},PRELU="return (a < 0.) ? b * a : a;",PRELU_PACKED="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";function prelu4(e){const{inputs:t,backend:n}=e,{x:a,alpha:r}=t,s=env().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new BinaryOpPackedProgram(PRELU_PACKED,a.shape,r.shape):new BinaryOpProgram(PRELU,a.shape,r.shape);return n.runWebGLProgram(s,[a,r],"float32")}var preluConfig2={kernelName:Prelu,backendName:"webgl",kernelFunc:prelu4},CHECK_NAN_SNIPPET_UNARY="if (isnan(x)) return x;",CHECK_NAN_SNIPPET_BINARY="\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n",CHECK_NAN_SNIPPET_BINARY_PACKED="\n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n";function unaryKernelFunc2({opSnippet:e,packedOpSnippet:t,cpuKernelImpl:n,dtype:a}){return({inputs:r,backend:s})=>{const{x:o}=r,i=s,l=a||o.dtype;if(i.shouldExecuteOnCPU([o])&&null!=n){const e=i.texData.get(o.dataId),t=n(e.values,l);return i.makeTensorInfo(o.shape,l,t)}let u;return u=env().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=t?new UnaryOpPackedProgram(o.shape,t):new UnaryOpProgram(o.shape,e),i.runWebGLProgram(u,[o],l)}}function binaryKernelFunc2({opSnippet:e,packedOpSnippet:t,checkOutOfBounds:n=!1,supportsComplex:a=!1,cpuKernelImpl:r,dtype:s}){return({inputs:o,backend:i})=>{const{a:l,b:u}=o,c=i;if(a&&"complex64"===l.dtype){const t=c.texData.get(l.dataId),n=c.texData.get(u.dataId),[a,r]=[[t.complexTensorInfos.real,n.complexTensorInfos.real],[t.complexTensorInfos.imag,n.complexTensorInfos.imag]].map((t=>{const[n,a]=t,r={dataId:n.dataId,dtype:n.dtype,shape:l.shape},s={dataId:a.dataId,dtype:a.dtype,shape:u.shape},o=new BinaryOpProgram(e,l.shape,u.shape);return c.runWebGLProgram(o,[r,s],upcastType(n.dtype,a.dtype))})),s=complex3({inputs:{real:a,imag:r},backend:c});return c.disposeIntermediateTensorInfo(a),c.disposeIntermediateTensorInfo(r),s}const d=s||upcastType(l.dtype,u.dtype);if(("string"===l.dtype||"string"===u.dtype||c.shouldExecuteOnCPU([l,u]))&&null!=r){const e=c.texData.get(l.dataId).values,t=c.texData.get(u.dataId).values,n="string"===l.dtype?backend_util_exports.fromUint8ToStringArray(e):e,a="string"===l.dtype?backend_util_exports.fromUint8ToStringArray(t):t,[s,o]=r(l.shape,u.shape,n,a,d),i=c.makeTensorInfo(o,d);return c.texData.get(i.dataId).values=s,i}let p;return p=env().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=t?new BinaryOpPackedProgram(t,l.shape,u.shape,n):new BinaryOpProgram(e,l.shape,u.shape),c.runWebGLProgram(p,[l,u],d)}}function mapActivationToShaderProgram(e,t=!1){if("linear"===e)return t?LINEAR2:LINEAR;if("relu"===e)return t?RELU2:RELU;if("elu"===e)return t?ELU3:ELU2;if("relu6"===e)return t?RELU62:RELU6;if("prelu"===e)return t?PRELU_PACKED:PRELU;if("leakyrelu"===e)return t?LEAKYRELU_PACKED:LEAKYRELU;if("sigmoid"===e)return t?SIGMOID2:SIGMOID;throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`)}var MatMulPackedProgram=class{constructor(e,t,n,a=!1,r=!1,s=!1,o=null,i=!1,l=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=useShapeUniforms(this.outputShape.length);const u=a?e[1]:e[2],c=Math.ceil(u/2),d=a?"i * 2, rc.y":"rc.y, i * 2",p=r?"rc.z, i * 2":"i * 2, rc.z",h=a?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],m=r?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let f="",g="";o&&(f=i?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${o}\n        }`:l?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${o}\n        }`:`vec4 activation(vec4 x) {\n          ${o}\n        }`,g="result = activation(result);");const x=s?"result += getBiasAtOutCoords();":"";s&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),l&&this.variableNames.push("leakyreluAlpha");let y="rc.x",A="rc.x";e[0]<t[0]?y=`int(min(float(rc.x), ${e[0]-1}.))`:t[0]<e[0]&&(A=`int(min(float(rc.x), ${t[0]-1}.))`),this.userCode=`\n      ${f}\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ${c}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < ${c}; i++) {\n          int batchA = ${y};\n          int batchB = ${A};\n          vec4 a = getMatrixA(batchA, ${d});\n          vec4 b = getMatrixB(batchB, ${p});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${h[0]} * ${m[0]});\n          result += (${h[1]} * ${m[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${x}\n\n        ${g}\n\n        setOutput(result);\n      }\n    `}},COMPLEX_MULTIPLY={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"},BinaryOpComplexProgram=class{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=backend_util_exports.assertAndGetBroadcastShape(t,n),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${e}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}},MUL="return a * b;";function multiply3(e){const{inputs:t,backend:n}=e,{a:a,b:r}=t,s=backend_util_exports.upcastType(a.dtype,r.dtype);if("complex64"===a.dtype){const e=n.texData.get(a.dataId),t=n.texData.get(r.dataId),s=new BinaryOpComplexProgram(COMPLEX_MULTIPLY.REAL,a.shape,r.shape),o=new BinaryOpComplexProgram(COMPLEX_MULTIPLY.IMAG,a.shape,r.shape),i=[{dataId:e.complexTensorInfos.real.dataId,dtype:e.complexTensorInfos.real.dtype,shape:a.shape},{dataId:e.complexTensorInfos.imag.dataId,dtype:e.complexTensorInfos.imag.dtype,shape:a.shape},{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:r.shape},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:r.shape}],l=n.runWebGLProgram(s,i,"float32"),u=n.runWebGLProgram(o,i,"float32"),c=complex3({inputs:{real:l,imag:u},backend:n});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(u),c}if(n.shouldExecuteOnCPU([a,r])){const e=n.texData.get(a.dataId),t=n.texData.get(r.dataId),[o,i]=multiplyImplCPU(a.shape,r.shape,e.values,t.values,s),l=n.makeTensorInfo(i,s);return n.texData.get(l.dataId).values=o,l}let o;return o=env().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new BinaryOpPackedProgram(MUL,a.shape,r.shape):new BinaryOpProgram(MUL,a.shape,r.shape),n.runWebGLProgram(o,[a,r],s)}var multiplyConfig2={kernelName:Multiply,backendName:"webgl",kernelFunc:multiply3};function packedReshape(e,t,n){const a=[getBatchDim(e.shape),...getRowsCols(e.shape)],r={dtype:e.dtype,shape:a,dataId:e.dataId},s=[getBatchDim(t),...getRowsCols(t)],o=new ReshapePackedProgram(s,a),i=[a],l=n.runWebGLProgram(o,[r],e.dtype,i,!0);return{dataId:l.dataId,shape:t,dtype:l.dtype}}function reshape4(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{shape:s}=a,o=n,i=util_exports.sizeFromShape(r.shape),l=util_exports.inferFromImplicitShape(s,i),u=util_exports.sizeFromShape(l);util_exports.assert(i===u,(()=>`The new shape (${l}) has ${u} elements and the old shape (${r.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`));const c=o.texData.get(r.dataId);return!c.isPacked||isReshapeFree(r.shape,l)||null!==c.texture&&isReshapeFree(c.shape,l)?(o.incRef(r.dataId),{dataId:r.dataId,shape:l,dtype:r.dtype}):packedReshape(r,l,o)}var reshapeConfig2={kernelName:Reshape,backendName:"webgl",kernelFunc:reshape4},MeanProgram=class{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:a,inSize:r,outSize:s}=e;this.outputShape=[a,s];const o=4*Math.floor(n/4),i=n%4;let l="sumValue += dot(values, ones);";if(null!=t){const e=1/t;l=`sumValue += dot(values * ${util_exports.isInt(e)?e.toPrecision(2):e}, ones);`}let u="";r%n>0&&(u=`\n        if (inIdx < 0 || inIdx >= ${r}) {\n          return 0.0;\n        }\n      `),this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${u}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${o}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${l}\n        }\n\n        int inIdx = inOffset + ${o};\n        if (${1===i}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${l}\n        } else if (${2===i}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${l}\n        } else if (${3===i}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${l}\n        }\n        setOutput(sumValue);\n      }\n    `}},ReduceProgram=class{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:a,inSize:r,outSize:s}=e;this.outputShape=[a,s];let o="0.0",i="";"prod"===t?o="1.0":"min"===t?(o="1.0 / 1e-20",i="min"):"max"===t&&(o="-1.0 / 1e-20",i="max");let l=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===t?l="sumValue":"prod"===t?l="prodValue":"all"===t?l="allValue":"any"===t&&(l="anyValue");const u=4*Math.floor(n/4),c=n%4;let d=`\n      if (${"sum"===t}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===t}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${i}(values, minMaxValue);\n        if (${"min"===t} || ${"max"===t}) {\n          minMaxValue = ${i}(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    `,p="vec4";"all"===t?(o="1.0",d="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",p="bvec4"):"any"===t&&(o="0.0",d="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",p="bvec4");let h="";r%n>0&&(h=`\n        if (inIdx < 0 || inIdx >= ${r}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${o};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${h}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        vec4 minMaxValue = vec4(${o});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${u}; i += 4) {\n          int inIdx = inOffset + i;\n          ${p} values = ${p}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${d}\n        }\n\n        int inIdx = inOffset + ${u};\n        if (${1===c}) {\n          ${p} values = ${p}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${d}\n        } else if (${2===c}) {\n          ${p} values = ${p}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${d}\n        } else if (${3===c}) {\n          ${p} values = ${p}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${d}\n        }\n        setOutput(${l});\n      }\n    `}};function getReductionStages(e){const t=[];for(;0===t.length||1!==t[t.length-1].outSize;){const n=t.length?t[t.length-1].outSize:e[1],a=backend_util_exports.computeOptimalWindowSize(n);t.push({inSize:n,windowSize:a,outSize:Math.ceil(n/a)})}return t}function reduce(e,t,n,a){const r=getReductionStages(e.shape);let s=e;for(let o=0;o<r.length;o++){const{inSize:i,windowSize:l,outSize:u}=r[o];let c,d;c="mean"===n?0===o?new MeanProgram({windowSize:l,inSize:i,batchSize:e.shape[0],outSize:u},i):new MeanProgram({windowSize:l,inSize:i,batchSize:e.shape[0],outSize:u}):new ReduceProgram({windowSize:l,inSize:i,batchSize:e.shape[0],outSize:u},n),d=s,s=a.runWebGLProgram(c,[s],t),d.dataId!==e.dataId&&a.disposeIntermediateTensorInfo(d)}return s}var TransposeProgram=class{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let a=0;a<n.length;a++)n[a]=e[t[a]];this.outputShape=n,this.rank=n.length;const a=getCoordsDataType(this.rank),r=getSwitchedCoords(t);this.userCode=`\n    void main() {\n      ${a} resRC = getOutputCoords();\n      setOutput(getA(${r}));\n    }\n    `}};function getSwitchedCoords(e){const t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],a=new Array(t);for(let t=0;t<e.length;t++)a[e[t]]=n[t];return a.join()}var TransposePackedProgram=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const n=new Array(e.length);for(let a=0;a<n.length;a++)n[a]=e[t[a]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const a=getCoordsDataType(this.rank),r=getVecChannels("rc",this.rank),s=new Array(this.rank);for(let e=0;e<t.length;e++)s[t[e]]=r[e];const o=`vec2(${s.slice(-2).join()})`,i=`++${r[this.rank-1]} < ${n[this.rank-1]}`,l=`getChannel(getA(${s.join()}), ${o})`;this.userCode=`\n    void main() {\n      ${a} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${l};\n      if(${i}) {\n        result[1] = ${l};\n      }\n      --${r[this.rank-1]};\n      if(++${r[this.rank-2]} < ${n[this.rank-2]}) {\n        result[2] = ${l};\n        if(${i}) {\n          result[3] = ${l};\n        }\n      }\n      setOutput(result);\n    }\n    `}};function transposeImpl2(e,t,n){const a=env().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new TransposePackedProgram(e.shape,t):new TransposeProgram(e.shape,t);return n.runWebGLProgram(a,[e],e.dtype)}function sumImpl(e,t,n,a){const r=t,s=e.shape.length,o=util_exports.parseAxisParam(r,e.shape);let i=o;const l=backend_util_exports.getAxesPermutation(i,s),u=null!=l;let c=e;u&&(c=transposeImpl2(e,l,a),i=backend_util_exports.getInnerMostAxes(i.length,s)),backend_util_exports.assertAxesAreInnerMostDims("sum",i,s);const[d,p]=backend_util_exports.computeOutAndReduceShapes(c.shape,i);let h=d;n&&(h=backend_util_exports.expandShapeToKeepDim(d,o));const m=util_exports.sizeFromShape(p),f=reshape4({inputs:{x:c},attrs:{shape:[util_exports.sizeFromShape(e.shape)/m,m]},backend:a}),g=reduce(f,sumOutType(e.dtype),"sum",a),x=reshape4({inputs:{x:g},attrs:{shape:h},backend:a});return a.disposeIntermediateTensorInfo(f),a.disposeIntermediateTensorInfo(g),u&&a.disposeIntermediateTensorInfo(c),x}function sum4(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:o}=a;return sumImpl(r,s,o,n)}var sumConfig2={kernelName:Sum,backendName:"webgl",kernelFunc:sum4};function transpose3(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{perm:s}=a,o=n,i=r.shape.length,l=new Array(i);for(let e=0;e<l.length;e++)l[e]=r.shape[s[e]];let u;if(o.shouldExecuteOnCPU([r])){const e=o.texData.get(r.dataId).values,t=transposeImplCPU(e,r.shape,r.dtype,s,l);u=o.makeTensorInfo(l,r.dtype);o.texData.get(u.dataId).values=t}else u=transposeImpl2(r,s,o);return u}var transposeConfig2={kernelName:Transpose,backendName:"webgl",kernelFunc:transpose3},MATMUL_SHARED_DIM_THRESHOLD=1e3;function batchMatMulImpl({a:e,b:t,transposeA:n,transposeB:a,backend:r,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:l=null}){const u=e.shape.length,c=t.shape.length,d=n?e.shape[u-2]:e.shape[u-1],p=a?t.shape[c-1]:t.shape[c-2],h=n?e.shape[u-1]:e.shape[u-2],m=a?t.shape[c-2]:t.shape[c-1],f=e.shape.slice(0,-2),g=t.shape.slice(0,-2),x=util_exports.sizeFromShape(f),y=util_exports.sizeFromShape(g),A=broadcast_util_exports.assertAndGetBroadcastShape(e.shape.slice(0,-2),t.shape.slice(0,-2)).concat([h,m]);util_exports.assert(d===p,(()=>`Error in matMul: inner shapes (${d}) and (${p}) of Tensors with shapes ${e.shape} and ${t.shape} and transposeA=${n} and transposeB=${a} must match.`));const b=n?[x,d,h]:[x,h,d],v=a?[y,m,p]:[y,p,m],k=reshape4({inputs:{x:e},backend:r,attrs:{shape:b}}),S=reshape4({inputs:{x:t},backend:r,attrs:{shape:v}}),w=[k,S],C=Math.max(x,y),I=n?k.shape[1]:k.shape[2],T=null!=s,N=null!=o,_="leakyrelu"===l,E=null!=l?mapActivationToShaderProgram(l,!0):null;let P;if((1===h||1===m)&&I>MATMUL_SHARED_DIM_THRESHOLD&&!1===(T||N||_||null!=E)){let e=k,t=S;n&&(e=transpose3({inputs:{x:k},backend:r,attrs:{perm:[0,2,1]}}),w.push(e)),a&&(t=transpose3({inputs:{x:S},backend:r,attrs:{perm:[0,2,1]}}),w.push(t));const s=1===m;let o=e;1!==m&&(o=reshape4({inputs:{x:e},backend:r,attrs:{shape:[C,I,1]}}),w.push(o));const i=1===m?2:1;let l=t;s&&(l=reshape4({inputs:{x:t},backend:r,attrs:{shape:[C,1,I]}}),w.push(l));const u=multiply3({inputs:{a:o,b:l},backend:r});P=sum4({inputs:{x:u},backend:r,attrs:{axis:i,keepDims:!0}}),w.push(u)}else{const l=upcastType(e.dtype,t.dtype),u=new MatMulPackedProgram(b,v,[C,h,m],n,a,T,E,N,_),c=[k,S];if(null!=s&&c.push(s),N&&c.push(o),_){const e=r.makeTensorInfo([],"float32",util_exports.createScalarValue(i,"float32"));c.push(e),w.push(e)}P=r.runWebGLProgram(u,c,l)}const R=reshape4({inputs:{x:P},backend:r,attrs:{shape:A}});w.push(P);for(const e of w)r.disposeIntermediateTensorInfo(e);return R}function _fusedMatMul2(e){const{inputs:t,backend:n,attrs:a}=e,{a:r,b:s,bias:o,preluActivationWeights:i}=t,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:d}=a;return batchMatMulImpl({a:r,b:s,transposeA:l,transposeB:u,backend:n,bias:o,preluActivationWeights:i,leakyreluAlpha:d,activation:c})}var _fusedMatMulConfig2={kernelName:_FusedMatMul,backendName:"webgl",kernelFunc:_fusedMatMul2},ABS2="return abs(x);";function abs3(e){const{inputs:t,backend:n}=e,{x:a}=t;if(n.shouldExecuteOnCPU([a])&&"complex64"!==a.dtype){const e=n.texData.get(a.dataId),t=simpleAbsImplCPU(e.values);return n.makeTensorInfo(a.shape,a.dtype,t)}let r;return r=env().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new UnaryOpPackedProgram(a.shape,ABS2):new UnaryOpProgram(a.shape,ABS2),n.runWebGLProgram(r,[a],a.dtype)}var absConfig2={kernelName:Abs,backendName:"webgl",kernelFunc:abs3},ACOS=CHECK_NAN_SNIPPET+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n",acos3=unaryKernelFunc2({opSnippet:ACOS}),acosConfig2={kernelName:Acos,backendName:"webgl",kernelFunc:acos3},ACOSH=CHECK_NAN_SNIPPET+"\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));",acosh3=unaryKernelFunc2({opSnippet:ACOSH}),acoshConfig2={kernelName:Acosh,backendName:"webgl",kernelFunc:acosh3},ADD="return a + b;",addKernelFunc=binaryKernelFunc2({opSnippet:ADD,packedOpSnippet:ADD,supportsComplex:!0,cpuKernelImpl:addImplCPU}),addConfig2={kernelName:Add,backendName:"webgl",kernelFunc:addKernelFunc},AddNProgram=class{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map(((e,t)=>`T${t}`));const n=[];this.variableNames.forEach((e=>{n.push(`float v${e} = get${e}AtOutCoords();`)}));const a=this.variableNames.map((e=>`v${e}`)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        float result = ${a};\n        setOutput(result);\n      }\n    `}},AddNPackedProgram=class{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map(((e,t)=>`T${t}`));const n=[];this.variableNames.forEach((e=>{n.push(`vec4 v${e} = get${e}AtOutCoords();`)}));const a=this.variableNames.map((e=>`v${e}`)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        vec4 result = ${a};\n        setOutput(result);\n      }\n    `}};function addN3(e){const{inputs:t,backend:n}=e,a=t;if(1===a.length)return identity3({inputs:{x:a[0]},backend:n});if(a.length>env().get("WEBGL_MAX_TEXTURES_IN_SHADER")){const e=Math.floor(a.length/2),t=addN3({inputs:a.slice(0,e),backend:n}),r=addN3({inputs:a.slice(e),backend:n});return addN3({inputs:[t,r],backend:n})}const r=a.map((e=>e.dtype)).reduce(((e,t)=>upcastType(e,t))),s=a.map((e=>e.shape)),o=env().getBool("WEBGL_PACK")?new AddNPackedProgram(a[0].shape,s):new AddNProgram(a[0].shape,s);return n.runWebGLProgram(o,a,r)}var addNConfig2={kernelName:AddN,backendName:"webgl",kernelFunc:addN3};function all3(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:o}=a,i=r.shape.length,l=util_exports.parseAxisParam(s,r.shape);let u=l;const c=backend_util_exports.getAxesPermutation(u,i);let d=r;null!=c&&(d=transpose3({inputs:{x:r},backend:n,attrs:{perm:c}}),u=backend_util_exports.getInnerMostAxes(u.length,i)),backend_util_exports.assertAxesAreInnerMostDims("all",u,i);const[p,h]=backend_util_exports.computeOutAndReduceShapes(d.shape,u),m=reshape4({inputs:{x:d},backend:n,attrs:{shape:[-1,util_exports.sizeFromShape(h)]}}),f=reduce(m,m.dtype,"all",n);let g;if(o){g=reshape4({inputs:{x:f},backend:n,attrs:{shape:backend_util_exports.expandShapeToKeepDim(p,l)}})}else g=reshape4({inputs:{x:f},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(f),null!=c&&n.disposeIntermediateTensorInfo(d),g}var allConfig2={kernelName:All,backendName:"webgl",kernelFunc:all3};function any3(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:o}=a,i=r.shape.length,l=util_exports.parseAxisParam(s,r.shape);let u=l;const c=backend_util_exports.getAxesPermutation(u,i);let d=r;null!=c&&(d=transpose3({inputs:{x:r},backend:n,attrs:{perm:c}}),u=backend_util_exports.getInnerMostAxes(u.length,i)),backend_util_exports.assertAxesAreInnerMostDims("any",u,i);const[p,h]=backend_util_exports.computeOutAndReduceShapes(d.shape,u),m=reshape4({inputs:{x:d},backend:n,attrs:{shape:[-1,util_exports.sizeFromShape(h)]}}),f=reduce(m,m.dtype,"any",n);let g;if(o){g=reshape4({inputs:{x:f},backend:n,attrs:{shape:backend_util_exports.expandShapeToKeepDim(p,l)}})}else g=reshape4({inputs:{x:f},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(f),null!=c&&n.disposeIntermediateTensorInfo(d),g}var anyConfig2={kernelName:Any,backendName:"webgl",kernelFunc:any3},ArgMinMaxProgram=class{constructor(e,t,n){this.variableNames=["A"];const{windowSize:a,batchSize:r,outSize:s}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[r,s];const o="max"===t?">":"<",i=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${a};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${a}; i++) {\n          int inIdx = ${i};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${o} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}},ArgMinMaxPackedProgram=class{constructor(e,t,n,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,util_exports.assert(e.length>2,(()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`));const r=e[e.length-1],s=Math.ceil(r/t);this.outputShape=e.slice(0,-1),s>1&&this.outputShape.push(s),a||this.variableNames.push("bestIndicesA");const o=this.outputShape,i=o.length,l=getCoordsDataType(i),u=getChannels("coords",i);let c,d;if(1===s){d=i+1;const e=getCoordsDataType(d);c=`\n        ${e} sourceLocR = ${e}(${u.join()}, 0);\n        ++${u[i-1]};\n        ${e} sourceLocG = ${e}(${u.join()}, 0);\n        ++${u[i-2]};\n        ${e} sourceLocA = ${e}(${u.join()}, 0);\n        --${u[i-1]};\n        ${e} sourceLocB = ${e}(${u.join()}, 0);\n        --${u[i-2]};`}else d=i,c=`\n        ${l} sourceLocR = coords;\n        ++${u[i-1]};\n        ${l} sourceLocG = coords;\n        ++${u[i-2]};\n        ${l} sourceLocA = coords;\n        --${u[i-1]};\n        ${l} sourceLocB = coords;\n        --${u[i-2]};`;const p=["x","y","z","w","u","v"].slice(0,d),h="."+p[d-1],m=p.map((e=>"int "+e)),f=getChannels("sourceLocR",d-1).concat("inIdx.r"),g=getChannels("sourceLocG",d-1).concat("inIdx.g"),x=getChannels("sourceLocB",d-1).concat("inIdx.b"),y=getChannels("sourceLocA",d-1).concat("inIdx.a"),A="max"===n?"greaterThan":"lessThan",b=a?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${f.join()}),\n                             getBestIndicesAChannel(${g.join()}),\n                             getBestIndicesAChannel(${x.join()}),\n                             getBestIndicesAChannel(${y.join()})));`,v=`vec4(\n            getAChannel(${f.join()}),\n            hasNextCol ? getAChannel(${g.join()}) : 0.,\n            hasNextRow ? getAChannel(${x.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${y.join()}) : 0.)`,k=a?"":`\n      float getBestIndicesAChannel(${m.join()}) {\n        return getChannel(getBestIndicesA(${p.join()}),\n                                          vec2(${p.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${m.join()}) {\n        return getChannel(getA(${p.join()}),\n                               vec2(${p.slice(-2).join()}));\n      }\n      ${k}\n      void main() {\n        ${l} coords = getOutputCoords();\n        bool hasNextCol = ${u[i-1]} < ${o[i-1]-1};\n        bool hasNextRow = ${u[i-2]} < ${o[i-2]-1};\n        ${c}\n        ivec4 srcIdx = ivec4(sourceLocR${h}, sourceLocG${h},\n          sourceLocB${h}, sourceLocA${h}) * ${t};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${v};\n\n        for (int i = 0; i < ${t}; i++) {\n          inIdx = srcIdx;\n          ${b}\n          vec4 candidate = ${v};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${A}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}};function argReduce(e,t,n,a=null){let r=t.shape[0],s=t.shape[1];null!=a&&(r=a.shape[0],s=a.shape[1]);const o=backend_util_exports.computeOptimalWindowSize(s),i={windowSize:o,inSize:s,batchSize:r,outSize:Math.ceil(s/o)},l=new ArgMinMaxProgram(i,n,null==a),u=[t];null!=a&&u.push(a);const c=e.runWebGLProgram(l,u,"int32");if(1===c.shape[1])return c;const d=argReduce(e,t,n,c);return e.disposeIntermediateTensorInfo(c),d}function argReducePacked(e,t,n,a=null){const r=null!=a?a.shape:t.shape,s=r[r.length-1],o=backend_util_exports.computeOptimalWindowSize(s),i=new ArgMinMaxPackedProgram(r,o,n,null==a),l=null==a?[t]:[t,a],u=e.runWebGLProgram(i,l,"int32");if(u.shape.length===t.shape.length){const a=argReducePacked(e,t,n,u);return e.disposeIntermediateTensorInfo(u),a}return u}function argMinMaxReduce(e,t,n,a){const r=[n];if(backend_util_exports.assertAxesAreInnerMostDims("arg"+a.charAt(0).toUpperCase()+a.slice(1),r,t.shape.length),!env().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){const n=[],s=e.texData.get(t.dataId);let o=t;null!==s&&s.isPacked&&(o=e.unpackTensor(t),n.push(o));const[i,l]=backend_util_exports.computeOutAndReduceShapes(o.shape,r),u=util_exports.sizeFromShape(l),c=reshape4({inputs:{x:o},backend:e,attrs:{shape:[-1,u]}});n.push(c);const d=argReduce(e,c,a);n.push(d);const p=reshape4({inputs:{x:d},backend:e,attrs:{shape:i}});return n.forEach((t=>e.disposeIntermediateTensorInfo(t))),p}return argReducePacked(e,t,a)}function argMax3(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s}=a;let o=util_exports.parseAxisParam(s,r.shape);const i=backend_util_exports.getAxesPermutation(o,r.shape.length);let l=r;const u=[];null!=i&&(l=transpose3({inputs:{x:r},backend:n,attrs:{perm:i}}),u.push(l),o=backend_util_exports.getInnerMostAxes(o.length,l.shape.length)),backend_util_exports.assertAxesAreInnerMostDims("argMax",[o[0]],l.shape.length);const c=argMinMaxReduce(n,l,o[0],"max");return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),c}var argMaxConfig2={kernelName:ArgMax,backendName:"webgl",kernelFunc:argMax3};function argMin3(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s}=a;let o=util_exports.parseAxisParam(s,r.shape);const i=backend_util_exports.getAxesPermutation(o,r.shape.length);let l=r;const u=[];null!=i&&(l=transpose3({inputs:{x:r},backend:n,attrs:{perm:i}}),u.push(l),o=backend_util_exports.getInnerMostAxes(o.length,l.shape.length)),backend_util_exports.assertAxesAreInnerMostDims("argMin",[o[0]],l.shape.length);const c=argMinMaxReduce(n,l,o[0],"min");return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),c}var argMinConfig2={kernelName:ArgMin,backendName:"webgl",kernelFunc:argMin3},ASIN=CHECK_NAN_SNIPPET+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n",asin3=unaryKernelFunc2({opSnippet:ASIN}),asinConfig2={kernelName:Asin,backendName:"webgl",kernelFunc:asin3},ASINH=CHECK_NAN_SNIPPET+"return log(x + sqrt(x * x + 1.0));",asinh3=unaryKernelFunc2({opSnippet:ASINH}),asinhConfig2={kernelName:Asinh,backendName:"webgl",kernelFunc:asinh3},ATAN=CHECK_NAN_SNIPPET+"\n  return atan(x);\n",atan4=unaryKernelFunc2({opSnippet:ATAN}),atanConfig2={kernelName:Atan,backendName:"webgl",kernelFunc:atan4},ATAN2=CHECK_NAN_SNIPPET_BINARY+"\n  return atan(a, b);\n",ATAN2_PACKED="\n  vec4 result = atan(a, b);\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  "+CHECK_NAN_SNIPPET_BINARY_PACKED+"\n  return result;\n",atan23=binaryKernelFunc2({opSnippet:ATAN2,packedOpSnippet:ATAN2_PACKED}),atan2Config2={kernelName:Atan2,backendName:"webgl",kernelFunc:atan23},ATANH=CHECK_NAN_SNIPPET+"\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;",atanh3=unaryKernelFunc2({opSnippet:ATANH}),atanhConfig2={kernelName:Atanh,backendName:"webgl",kernelFunc:atanh3},Pool2DProgram=class{constructor(e,t,n,a=!1,r=!1){if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const s=e.filterWidth,o=e.strideHeight,i=e.strideWidth,l=e.dilationHeight,u=e.dilationWidth,c=e.effectiveFilterHeight,d=e.effectiveFilterWidth,p=e.padInfo.top,h=e.padInfo.left;this.outputShape=e.outShape;const m="avg"===t,f=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,g=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let x="0.0";if(m||(x="-1.0 / 1e-20"),n){const t=">=";return void(this.userCode=`\n        const ivec2 strides = ivec2(${o}, ${i});\n        const ivec2 pads = ivec2(${p}, ${h});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${c};\n              wR += ${l}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${d};\n                wC += ${u}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ${t} currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${a?r?f:g:`wR * ${d} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let y=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(y="avgValue / count");const A=4*Math.floor(s/4),b=s%4,v=`\n      if (${m}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${o}, ${i});\n      const ivec2 pads = ivec2(${p}, ${h});\n      const float initializationValue = ${x};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${x});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${c};\n            wR += ${l}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${A}; wC += 4) {\n            int xC = xCCorner + wC * ${u};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              getValue(batch, xR, xC + 3 * ${u}, d)\n            );\n\n            ${v}\n          }\n\n          int xC = xCCorner + ${A};\n          if (${1===b}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${v}\n          } else if (${2===b}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${v}\n          } else if (${3===b}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              initializationValue\n            );\n\n            ${v}\n          }\n        }\n        setOutput(${y});\n      }\n    `}},Pool3DProgram=class{constructor(e,t,n,a=!1,r=!1){if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const s=e.filterWidth,o=e.strideDepth,i=e.strideHeight,l=e.strideWidth,u=e.dilationDepth,c=e.dilationHeight,d=e.dilationWidth,p=e.effectiveFilterDepth,h=e.effectiveFilterHeight,m=e.effectiveFilterWidth,f=e.padInfo.front,g=e.padInfo.top,x=e.padInfo.left;this.outputShape=e.outShape;const y="avg"===t;let A="0.0";if(y||(A="-1.0 / 1e-20"),n){const t=">=";return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${o}, ${i}, ${l});\n        const ivec3 pads = ivec3(${f}, ${g}, ${x});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${p};\n              wD += ${u}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${h};\n                wR += ${c}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${m};\n                  wC += ${d}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ${t} currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${a?r?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${h} * ${m} +\n                      wR * ${m} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let b=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(b="avgValue / count");const v=4*Math.floor(s/4),k=s%4,S=`\n      if (${y}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${o}, ${i}, ${l});\n      const ivec3 pads = ivec3(${f}, ${g}, ${x});\n      const float initializationValue = ${A};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${A});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${p};\n            wD += ${u}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${h};\n            wR += ${c}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${v}; wC += 4) {\n              int xC = xCCorner + wC * ${d};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${d}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${d}, ch)\n              );\n\n              ${S}\n            }\n\n            int xC = xCCorner + ${v};\n            if (${1===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${S}\n            } else if (${2===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${S}\n            } else if (${3===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${d}, ch),\n                initializationValue\n              );\n\n              ${S}\n            }\n          }\n          setOutput(${b});\n        }\n      }\n    `}};function avgPool3(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t;assertNotComplex2(r,"avgPool");const{filterSize:s,strides:o,pad:i,dimRoundingMode:l}=a;util_exports.assert(backend_util_exports.eitherStridesOrDilationsAreOne(o,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`));const u=backend_util_exports.computePool2DInfo(r.shape,s,o,1,i,l);if(1===u.filterWidth&&1===u.filterHeight&&util_exports.arraysEqual(u.inShape,u.outShape))return identity3({inputs:{x:r},backend:n});const c=new Pool2DProgram(u,"avg",!1);return n.runWebGLProgram(c,[r],"float32")}var avgPoolConfig2={kernelName:AvgPool,backendName:"webgl",kernelFunc:avgPool3};function avgPool3D2(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:s,strides:o,pad:i,dimRoundingMode:l,dataFormat:u}=a,c=backend_util_exports.computePool3DInfo(r.shape,s,o,[1,1,1],i,l,u),d=new Pool3DProgram(c,"avg",!1);return n.runWebGLProgram(d,[r],"float32")}var avgPool3DConfig2={kernelName:AvgPool3D,backendName:"webgl",kernelFunc:avgPool3D2},AvgPool2DBackpropProgram=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,a=e.strideHeight,r=e.strideWidth,s=e.dilationHeight,o=e.dilationWidth,i=e.effectiveFilterHeight,l=e.effectiveFilterWidth,u=i-1-e.padInfo.top,c=l-1-e.padInfo.left,d=1/(t*n);this.userCode=`\n      const ivec2 pads = ivec2(${u}, ${c});\n      const float avgMultiplier = float(${d});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${i};\n            wR += ${s}) {\n          float dyR = float(dyRCorner + wR) / ${a}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${l};\n            wC+= ${o}) {\n            float dyC = float(dyCCorner + wC) / ${r}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},AvgPool3DBackpropProgram=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,a=e.filterWidth,r=e.strideDepth,s=e.strideHeight,o=e.strideWidth,i=e.dilationDepth,l=e.dilationHeight,u=e.dilationWidth,c=e.effectiveFilterDepth,d=e.effectiveFilterHeight,p=e.effectiveFilterWidth,h=c-1-e.padInfo.front,m=d-1-e.padInfo.top,f=p-1-e.padInfo.left,g=1/(t*n*a);this.userCode=`\n      const ivec3 pads = ivec3(${h}, ${m}, ${f});\n      const float avgMultiplier = float(${g});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${c};\n            wD += ${i}) {\n          float dyD = float(dyDCorner + wD) / ${r}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${d};\n              wR += ${l}) {\n            float dyR = float(dyRCorner + wR) / ${s}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${p};\n                wC += ${u}) {\n              float dyC = float(dyCCorner + wC) / ${o}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}};function avgPool3DGrad2(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,o=s,{filterSize:i,strides:l,pad:u,dimRoundingMode:c}=a,d=backend_util_exports.computePool3DInfo(o.shape,i,l,[1,1,1],u,c),p=new AvgPool3DBackpropProgram(d);return n.runWebGLProgram(p,[r],o.dtype)}var avgPoolGrad3DConfig={kernelName:AvgPool3DGrad,backendName:"webgl",kernelFunc:avgPool3DGrad2};function avgPoolGrad3(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,o=s;assertNotComplex2([r,s],"avgPoolGrad");const{filterSize:i,strides:l,pad:u}=a,c=backend_util_exports.computePool2DInfo(o.shape,i,l,1,u),d=new AvgPool2DBackpropProgram(c);return n.runWebGLProgram(d,[r],o.dtype)}var avgPoolGradConfig3={kernelName:AvgPoolGrad,backendName:"webgl",kernelFunc:avgPoolGrad3};function batchMatMul2(e){const{inputs:t,backend:n,attrs:a}=e,{a:r,b:s}=t,{transposeA:o,transposeB:i}=a;return batchMatMulImpl({a:r,b:s,transposeA:o,transposeB:i,backend:n})}var batchMatMulConfig2={kernelName:BatchMatMul,backendName:"webgl",kernelFunc:batchMatMul2},BatchNormProgram=class{constructor(e,t,n,a,r,s){this.outputShape=[],this.variableNames=["x","mean","variance"],backend_util_exports.assertAndGetBroadcastShape(e,t),backend_util_exports.assertAndGetBroadcastShape(e,n);let o="0.0";null!=a&&(backend_util_exports.assertAndGetBroadcastShape(e,a),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let i="1.0";null!=r&&(backend_util_exports.assertAndGetBroadcastShape(e,r),this.variableNames.push("scale"),i="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${o};\n        float scale = ${i};\n        float inv = scale * inversesqrt(variance + float(${s}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}},BatchNormPackedProgram=class{constructor(e,t,n,a,r,s){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],backend_util_exports.assertAndGetBroadcastShape(e,t),backend_util_exports.assertAndGetBroadcastShape(e,n);let o="vec4(0.0)";null!=a&&(backend_util_exports.assertAndGetBroadcastShape(e,a),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let i="vec4(1.0)";null!=r&&(backend_util_exports.assertAndGetBroadcastShape(e,r),this.variableNames.push("scale"),i="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        vec4 offset = ${o};\n        vec4 scale = ${i};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${s}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}},batchNorm3=({inputs:e,backend:t,attrs:n})=>{const{x:a,mean:r,variance:s,offset:o,scale:i}=e;util_exports.assert(r.shape.length===s.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),util_exports.assert(null==o||r.shape.length===o.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),util_exports.assert(null==i||r.shape.length===i.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));let{varianceEpsilon:l}=n;null==l&&(l=.001);const u=[a,r,s];let c=null;null!=o&&(c=o.shape,u.push(o));let d=null;null!=i&&(d=i.shape,u.push(i));const p=env().getBool("WEBGL_PACK_NORMALIZATION")?new BatchNormPackedProgram(a.shape,r.shape,s.shape,c,d,l):new BatchNormProgram(a.shape,r.shape,s.shape,c,d,l);return t.runWebGLProgram(p,u,u[0].dtype)},batchNormConfig2={kernelName:FusedBatchNorm,backendName:"webgl",kernelFunc:batchNorm3},SliceProgram=class{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=getCoordsDataType(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const n=getCoords(this.rank);let a;a=`\n        ${t} sourceLoc;\n        ${t} coords = getOutputCoords();\n        ${e.map(((e,t)=>`sourceLoc.${coords[t]} = start[${t}] + coords.${coords[t]};`)).join("\n")}\n      `,this.userCode=`\n      void main() {\n        ${a}\n        setOutput(getSource(${n}));\n      }\n    `}},coords=["x","y","z","w","u","v"];function getCoords(e){if(1===e)return"sourceLoc";if(e<=6)return coords.slice(0,e).map((e=>"sourceLoc."+e)).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}var SlicePackedProgram=class{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const t=getCoordsDataType(this.rank),n=getChannels("coords",this.rank),a=getChannels("sourceLoc",this.rank),r=1===this.rank?"sourceLoc":`vec2(${a.slice(-2).join()})`,s=`getChannel(getSource(${a.join()}), ${r})`,o=`\n      result.x = ${s};\n      if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n        ++${a[this.rank-1]};\n        result.y = ${s};\n        --${a[this.rank-1]};\n      }\n    `,i=1===this.rank?"":`\n      --${n[this.rank-1]};\n      if (++${n[this.rank-2]} < ${e[this.rank-2]}) {\n        ++${a[this.rank-2]};\n        result.z = ${s};\n        if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n          ++${a[this.rank-1]};\n          result.w = ${s};\n        }\n      }\n    `,l=this.rank<=4?`sourceLoc = coords +\n            ${t}(${e.map(((e,t)=>`start[${t}]`)).join()});`:e.map(((e,t)=>`${a[t]} = ${n[t]} + start[${t}];`)).join("\n");this.userCode=`\n      void main() {\n        ${t} coords = getOutputCoords();\n        ${t} sourceLoc;\n        ${l}\n        vec4 result = vec4(0.);\n        ${o}\n        ${i}\n        setOutput(result);\n      }\n    `}};function shallowSlice(e,t,n,a){const r=a.texData.get(e.dataId),s=a.makeTensorInfo(n,e.dtype),o=a.texData.get(s.dataId);Object.assign(o,r),o.refCount=1,o.shape=n,o.dtype=e.dtype;let i=slice_util_exports.computeFlatOffset(t,util_exports.computeStrides(e.shape));r.slice&&(i+=r.slice.flatOffset),o.slice={flatOffset:i,origDataId:r.slice&&r.slice.origDataId||e.dataId};const l=a.dataRefCount.get(o.slice.origDataId)||1;return a.dataRefCount.set(o.slice.origDataId,l+1),s}function slice3(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{begin:s,size:o}=a,[i,l]=slice_util_exports.parseSliceParams(r,s,o);if(slice_util_exports.assertParamsValid(r,i,l),0===util_exports.sizeFromShape(l))return n.makeTensorInfo(l,r.dtype,[]);if(n.shouldExecuteOnCPU([r])||"string"===r.dtype){const e=n.texData.get(r.dataId),t=sliceImplCPU(e.values,i,l,r.shape,r.dtype);return n.makeTensorInfo(l,r.dtype,t)}const{isPacked:u}=n.texData.get(r.dataId),c=slice_util_exports.isSliceContinous(r.shape,i,l);if(u||!c){const e=env().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new SlicePackedProgram(l):new SliceProgram(l),t=[i];return n.runWebGLProgram(e,[r],r.dtype,t)}return n.uploadToGPU(r.dataId),shallowSlice(r,i,l,n)}var sliceConfig2={kernelName:Slice,backendName:"webgl",kernelFunc:slice3},batchToSpaceND3=e=>{const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:s,crops:o}=a;util_exports.assert(r.shape.length<=4,(()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet"));const i=s.reduce(((e,t)=>e*t)),l=backend_util_exports.getReshaped(r.shape,s,i),u=backend_util_exports.getPermuted(l.length,s.length),c=backend_util_exports.getReshapedPermuted(r.shape,s,i),d=backend_util_exports.getSliceBeginCoords(o,s.length),p=backend_util_exports.getSliceSize(c,o,s.length),h=[],m=reshape4({inputs:{x:r},backend:n,attrs:{shape:l}}),f=transpose3({inputs:{x:m},backend:n,attrs:{perm:u}}),g=reshape4({inputs:{x:f},backend:n,attrs:{shape:c}}),x=slice3({inputs:{x:g},backend:n,attrs:{begin:d,size:p}});return h.push(m),h.push(f),h.push(g),h.forEach((e=>n.disposeIntermediateTensorInfo(e))),x},batchToSpaceNDConfig2={kernelName:BatchToSpaceND,backendName:"webgl",kernelFunc:batchToSpaceND3};function bincount3(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,weights:s}=t,{size:o}=a,i=n.readSync(r.dataId),l=n.readSync(s.dataId),u=bincountImplCPU(i,l,s.dtype,s.shape,o);return n.makeTensorInfo([o],s.dtype,u)}var bincountConfig2={kernelName:Bincount,backendName:"webgl",kernelFunc:bincount3};function broadcastArgs3(e){const{inputs:t,backend:n}=e,{s0:a,s1:r}=t,s=n.readSync(a.dataId),o=n.readSync(r.dataId),i=backend_util_exports.assertAndGetBroadcastShape(Array.from(s),Array.from(o));return n.makeTensorInfo([i.length],"int32",Int32Array.from(i))}var broadcastArgsConfig2={kernelName:BroadcastArgs,backendName:"webgl",kernelFunc:broadcastArgs3},NOT_EQUAL="return float(a != b);",notEqual3=binaryKernelFunc2({opSnippet:NOT_EQUAL,cpuKernelImpl:notEqualImplCPU,dtype:"bool"}),notEqualConfig2={kernelName:NotEqual,backendName:"webgl",kernelFunc:notEqual3};function real3(e){const{inputs:t,backend:n}=e,{input:a}=t;return identity3({inputs:{x:n.texData.get(a.dataId).complexTensorInfos.real},backend:n})}var realConfig2={kernelName:Real,backendName:"webgl",kernelFunc:real3},TO_INT="return float(int(x));";function int(e,t){const n=new UnaryOpProgram(e.shape,TO_INT),a=t.runWebGLProgram(n,[e],"int32");return{dataId:a.dataId,shape:a.shape,dtype:a.dtype}}function cast4(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{dtype:s}=a;if("complex64"===s){if("complex64"===r.dtype)return identity3({inputs:{x:r},backend:n});const e=zeros(r.shape),t=cast4({inputs:{x:r},backend:n,attrs:{dtype:"float32"}}),a=complex3({inputs:{real:t,imag:e},backend:n});return e.dispose(),n.disposeIntermediateTensorInfo(t),a}if("complex64"===r.dtype){const e=real3({inputs:{input:r},backend:n}),t=cast4({inputs:{x:e},backend:n,attrs:{dtype:s}});return n.disposeIntermediateTensorInfo(e),t}if(!util_exports.hasEncodingLoss(r.dtype,s)){const e=identity3({inputs:{x:r},backend:n});return{dataId:e.dataId,shape:e.shape,dtype:s}}if("int32"===s)return int(r,n);if("bool"===s){const e=n.makeTensorInfo([],"bool",util_exports.getTypedArrayFromDType("bool",1)),t=notEqual3({inputs:{a:r,b:e},backend:n});return n.disposeIntermediateTensorInfo(e),t}throw new Error(`Error in Cast: failed to cast ${r.dtype} to ${s}`)}var castConfig2={kernelName:Cast,backendName:"webgl",kernelFunc:cast4},CEIL="return ceil(x);",ceil3=unaryKernelFunc2({opSnippet:CEIL,packedOpSnippet:CEIL,cpuKernelImpl:ceilImplCPU}),ceilConfig2={kernelName:Ceil,backendName:"webgl",kernelFunc:ceil3},ClipProgram=class{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}},ClipPackedProgram=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}};function clipByValue2(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{clipValueMin:s,clipValueMax:o}=a;let i;i=env().getBool("WEBGL_PACK_CLIP")?new ClipPackedProgram(r.shape):new ClipProgram(r.shape);const l=[[s],[o]];return n.runWebGLProgram(i,[r],r.dtype,l)}var clipByValueConfig={kernelName:ClipByValue,backendName:"webgl",kernelFunc:clipByValue2},ComplexAbsProgram=class{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}};function makeComplexComponentTensorInfo(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}function complexAbs2(e){const{inputs:t,backend:n}=e,{x:a}=t,r=n.texData.get(a.dataId),s=new ComplexAbsProgram(a.shape),o=[makeComplexComponentTensorInfo(a,r.complexTensorInfos.real),makeComplexComponentTensorInfo(a,r.complexTensorInfos.imag)];return n.runWebGLProgram(s,o,o[0].dtype)}var complexAbsConfig2={kernelName:ComplexAbs,backendName:"webgl",kernelFunc:complexAbs2},ConcatProgram=class{constructor(e){this.outputShape=[],this.outputShape=backend_util_exports.computeOutShape(e,1),this.variableNames=e.map(((e,t)=>`T${t}`));const t=new Array(e.length-1);t[0]=e[0][1];for(let n=1;n<t.length;n++)t[n]=t[n-1]+e[n][1];const n=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let e=1;e<t.length;e++){const a=t[e-1];n.push(`else if (yC < ${t[e]}) setOutput(getT${e}(yR, yC-${a}));`)}const a=t.length,r=t[t.length-1];n.push(`else setOutput(getT${a}(yR, yC-${r}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${n.join("\n        ")}\n      }\n    `}},ConcatPackedProgram=class{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=backend_util_exports.computeOutShape(e,t);const n=this.outputShape,a=n.length,r=getCoordsDataType(a),s=getChannels("coords",a),o=["x","y","z","w","u","v"].slice(0,a);this.variableNames=e.map(((e,t)=>`T${t}`));const i=new Array(e.length-1);i[0]=e[0][t];for(let n=1;n<i.length;n++)i[n]=i[n-1]+e[n][t];const l=o[t],u=o.slice(-2),c=o.join();let d=`if (${l} < ${i[0]}) {\n        return getChannel(\n            getT0(${c}), vec2(${u.join()}));\n        }`;for(let e=1;e<i.length;e++){const t=i[e-1];d+=`\n        if (${l} < ${i[e]}  && ${l} >= ${i[e-1]}) {\n          return getChannel(\n            getT${e}(${shiftedChannels(o,l,t)}),\n            vec2(${shiftedChannels(u,l,t)}));\n        }`}const p=i.length,h=i[i.length-1];d+=`\n        return getChannel(\n          getT${p}(${shiftedChannels(o,l,h)}),\n          vec2(${shiftedChannels(u,l,h)}));`,this.userCode=`\n      float getValue(${o.map((e=>"int "+e))}) {\n        ${d}\n      }\n\n      void main() {\n        ${r} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${s}), 0., 0., 0.);\n\n        ${s[a-1]} = ${s[a-1]} + 1;\n        if (${s[a-1]} < ${n[a-1]}) {\n          result.g = getValue(${s});\n        }\n\n        ${s[a-2]} = ${s[a-2]} + 1;\n        if (${s[a-2]} < ${n[a-2]}) {\n          result.a = getValue(${s});\n        }\n\n        ${s[a-1]} = ${s[a-1]} - 1;\n        if (${s[a-2]} < ${n[a-2]} &&\n            ${s[a-1]} < ${n[a-1]}) {\n          result.b = getValue(${s});\n        }\n        setOutput(result);\n      }\n    `}};function shiftedChannels(e,t,n){const a=e.indexOf(t);return e.map(((e,t)=>t===a?`${e} - ${n}`:e)).join()}function imag3(e){const{inputs:t,backend:n}=e,{input:a}=t;return identity3({inputs:{x:n.texData.get(a.dataId).complexTensorInfos.imag},backend:n})}var imagConfig2={kernelName:Imag,backendName:"webgl",kernelFunc:imag3};function concatImpl2(e,t,n){const a=e[0].dtype;if("complex64"===a){const a=e.map((e=>real3({inputs:{input:e},backend:n}))),r=e.map((e=>imag3({inputs:{input:e},backend:n}))),s=concatImpl2(a,t,n),o=concatImpl2(r,t,n),i=complex3({inputs:{real:s,imag:o},backend:n});return a.forEach((e=>n.disposeIntermediateTensorInfo(e))),r.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(o),i}let r=n.shouldExecuteOnCPU(e);if("string"===a&&(r=!0),r){const r=e.map((e=>{const a=util_exports.sizeFromShape(e.shape.slice(t));return reshape4({inputs:{x:e},backend:n,attrs:{shape:[-1,a]}})})),s=r.map((e=>({vals:n.readSync(e.dataId),shape:e.shape}))),o=backend_util_exports.computeOutShape(r.map((e=>e.shape)),1),i=1===r[0].shape[0],l=concatImplCPU(s,o,a,i),u=backend_util_exports.computeOutShape(e.map((e=>e.shape)),t),c=n.makeTensorInfo(u,a,l);return r.forEach((e=>n.disposeIntermediateTensorInfo(e))),c}if(e.length>env().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const a=Math.floor(e.length/2),r=concatImpl2(e.slice(0,a),t,n),s=concatImpl2(e.slice(a),t,n),o=concatImpl2([r,s],t,n);return n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(s),o}if(env().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&e[0].shape.length>1){const r=new ConcatPackedProgram(e.map((e=>e.shape)),t);return n.runWebGLProgram(r,e,a)}const{tensors2D:s,outShape:o}=computeTensors2D(e,t,n),i=new ConcatProgram(s.map((e=>e.shape))),l=n.runWebGLProgram(i,s,a);s.forEach((e=>n.disposeIntermediateTensorInfo(e)));const u=reshape4({inputs:{x:l},attrs:{shape:o},backend:n});return n.disposeIntermediateTensorInfo(l),u}function computeTensors2D(e,t,n){const a=backend_util_exports.computeOutShape(e.map((e=>e.shape)),t);return{tensors2D:e.map((e=>reshape4({inputs:{x:e},attrs:{shape:[-1,util_exports.sizeFromShape(e.shape.slice(t))]},backend:n}))),outShape:a}}function concat3(e){const{inputs:t,backend:n,attrs:a}=e,{axis:r}=a,s=util_exports.parseAxisParam(r,t[0].shape)[0],o=backend_util_exports.computeOutShape(t.map((e=>e.shape)),s);if(0===util_exports.sizeFromShape(o))return n.makeTensorInfo(o,t[0].dtype,[]);const i=t.filter((e=>util_exports.sizeFromShape(e.shape)>0));if(1===i.length)return identity3({inputs:{x:i[0]},backend:n});const l=i.map((e=>e.shape));return backend_util_exports.assertParamsConsistent(l,s),concatImpl2(i,s,n)}var concatConfig2={kernelName:Concat,backendName:"webgl",kernelFunc:concat3},Conv2DProgram=class{constructor(e,t=!1,n=null,a=!1,r=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const s=e.padInfo.top,o=e.padInfo.left,i=e.strideHeight,l=e.strideWidth,u=e.dilationHeight,c=e.dilationWidth,d=e.filterHeight,p=e.filterWidth,h=4*Math.floor(e.inChannels/4),m=e.inChannels%4,f="channelsLast"===e.dataFormat,g=f?1:2,x=f?2:3,y=f?3:1;let A="",b="";n&&(A=a?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:r?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,b="result = activation(result);");const v=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${A}\n\n      const ivec2 strides = ivec2(${i}, ${l});\n      const ivec2 pads = ivec2(${s}, ${o});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${y}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${g}], coords[${x}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${d}; wR++) {\n          int xR = xRCorner + wR * ${u};\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${p}; wC++) {\n            int xC = xCCorner + wC * ${c};\n\n            if (xC < 0 || xC >= ${e.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${h}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${f}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===m}) {\n\n              if (${f}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${h}) *\n                    getW(wR, wC, ${h}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${h}, xR, xC) *\n                    getW(wR, wC, ${h}, d2);\n              }\n\n            } else if (${2===m}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${h}, d2),\n                getW(wR, wC, ${h} + 1, d2)\n              );\n\n              if (${f}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${h}),\n                  getX(batch, xR, xC, ${h} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${h}, xR, xC),\n                  getX(batch, ${h} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===m}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${h}, d2),\n                getW(wR, wC, ${h} + 1, d2),\n                getW(wR, wC, ${h} + 2, d2)\n              );\n\n              if (${f}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${h}),\n                  getX(batch, xR, xC, ${h} + 1),\n                  getX(batch, xR, xC, ${h} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${h}, xR, xC),\n                  getX(batch, ${h} + 1, xR, xC),\n                  getX(batch, ${h} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${v}\n        ${b}\n        setOutput(result);\n      }\n    `}},Conv3DProgram=class{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,n=e.padInfo.top,a=e.padInfo.left,r=e.strideDepth,s=e.strideHeight,o=e.strideWidth,i=e.dilationDepth,l=e.dilationHeight,u=e.dilationWidth,c=e.filterDepth,d=e.filterHeight,p=e.filterWidth,h=4*Math.floor(e.inChannels/4),m=e.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${r}, ${s}, ${o});\n      const ivec3 pads = ivec3(${t}, ${n}, ${a});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${c}; wF++) {\n          int xF = xFCorner + wF * ${i};\n\n          if (xF < 0 || xF >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${d}; wR++) {\n            int xR = xRCorner + wR * ${l};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${p}; wC++) {\n              int xC = xCCorner + wC * ${u};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${h}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===m}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${h}) *\n                  getW(wF, wR, wC, ${h}, d2);\n              } else if (${2===m}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${h}),\n                  getX(batch, xF, xR, xC, ${h} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${h}, d2),\n                  getW(wF, wR, wC, ${h} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===m}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${h}),\n                  getX(batch, xF, xR, xC, ${h} + 1),\n                  getX(batch, xF, xR, xC, ${h} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${h}, d2),\n                  getW(wF, wR, wC, ${h} + 1, d2),\n                  getW(wF, wR, wC, ${h} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},Im2ColPackedProgram=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=useShapeUniforms(this.outputShape.length);const{dataFormat:n}=t,a=getGlslDifferences(),r="channelsLast"===n,s=r?0:1,o=r?1:2,i=this.enableShapeUniforms?"if(blockIndex < outShape[1] && pos < outShape[0]) {":`if(blockIndex < ${e[1]} && pos < ${e[0]}) {`;let l="";for(let e=0;e<=1;e++)for(let t=0;t<=1;t++)l+=`\n          blockIndex = rc.y + ${t};\n          pos = rc.x + ${e};\n\n          ${i}\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[${s}] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[${o}] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (${r}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*e+t}] = getChannel(\n                    getA(d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*e+t}] = getChannel(\n                    getA(ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec2 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${l}\n\n        ${a.output} = result;\n      }\n    `}};function conv2dByMatMul({x:e,filter:t,convInfo:n,backend:a,bias:r=null,preluActivationWeights:s=null,leakyreluAlpha:o=0,activation:i=null}){const l=e.shape,u=a.texData.get(e.dataId),c=n.inChannels,d=l[0]*l[1]*l[2],p=n.outChannels,h="channelsLast"===n.dataFormat;let m;const f=[];if(!((1===d||1===p)&&c>MATMUL_SHARED_DIM_THRESHOLD)&&u.isPacked&&h&&null!=u.texture&&l[2]%2!=0&&util_exports.arraysEqual(u.shape.slice(-3),l.slice(-3))){const c=l[0]*l[1]*(l[2]+1),d={dataId:e.dataId,shape:[1,c,n.inChannels],dtype:e.dtype},p=u.shape;u.shape=u.shape.slice(),u.shape[u.shape.length-2]++,util_exports.assert(isReshapeFree(u.shape,d.shape),(()=>`packed reshape ${u.shape} to ${d.shape} isn't free`));const h=reshape4({inputs:{x:t},backend:a,attrs:{shape:[1,n.inChannels,n.outChannels]}});f.push(h);const g=batchMatMulImpl({a:d,b:h,backend:a,transposeA:false,transposeB:false,bias:r,activation:i,preluActivationWeights:s,leakyreluAlpha:o}),x=a.texData.get(g.dataId);util_exports.assert(x.isPacked,(()=>"batchMatMul result is expected to be packed")),u.shape=p,x.shape=n.outShape,m=identity3({inputs:{x:g},backend:a}),m.shape=n.outShape,f.push(g)}else{const u=reshape4({inputs:{x:e},backend:a,attrs:{shape:[1,h?l[0]*l[1]*l[2]:l[0]*l[2]*l[3],n.inChannels]}}),c=reshape4({inputs:{x:t},backend:a,attrs:{shape:[1,n.inChannels,n.outChannels]}}),d=batchMatMulImpl({a:u,b:c,transposeA:false,transposeB:false,backend:a,bias:r,activation:i,preluActivationWeights:s,leakyreluAlpha:o});m=reshape4({inputs:{x:d},backend:a,attrs:{shape:n.outShape}}),f.push(u),f.push(c),f.push(d)}for(const e of f)a.disposeIntermediateTensorInfo(e);return m}function conv2dWithIm2Row({x:e,filter:t,convInfo:n,backend:a,bias:r=null,preluActivationWeights:s=null,leakyreluAlpha:o=0,activation:i=null}){const{filterWidth:l,filterHeight:u,inChannels:c,outWidth:d,outHeight:p,dataFormat:h}=n,m="channelsLast"===h,f=l*u*c,g=p*d,x=[f,g],y=[],A=reshape4({inputs:{x:e},backend:a,attrs:{shape:e.shape.slice(1)}}),b=reshape4({inputs:{x:t},backend:a,attrs:{shape:[1,f,util_exports.sizeFromShape(t.shape)/f]}});y.push(A),y.push(b);const v=new Im2ColPackedProgram(x,n),k=[A.shape,[n.padInfo.top,n.padInfo.left],[n.strideHeight,n.strideWidth],[n.dilationHeight,n.dilationWidth],[n.inChannels],[n.filterWidth*n.inChannels],[n.outWidth]],S=a.runWebGLProgram(v,[A],"float32",k),w=reshape4({inputs:{x:S},backend:a,attrs:{shape:[1,x[0],x[1]]}});y.push(S),y.push(w);const C=null!=r,I=null!=s,T="leakyrelu"===i,N=i?mapActivationToShaderProgram(i,!0):null,_=new MatMulPackedProgram(w.shape,b.shape,[1,g,n.outChannels],!0,!1,C,N,I,T),E=[w,b];if(r&&E.push(r),I&&E.push(s),T){const e=a.makeTensorInfo([],"float32",util_exports.createScalarValue(o,"float32"));E.push(e),y.push(e)}const P=a.runWebGLProgram(_,E,"float32"),R=reshape4({inputs:{x:P},backend:a,attrs:{shape:m?[1,p,d,n.outChannels]:[1,n.outChannels,p,d]}});y.push(P);for(const e of y)a.disposeIntermediateTensorInfo(e);return R}function conv2d4(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:o,pad:i,dataFormat:l,dilations:u,dimRoundingMode:c}=a,d=backend_util_exports.convertConv2DDataFormat(l),p=backend_util_exports.computeConv2DInfo(r.shape,s.shape,o,u,i,c,!1,d);let h;if(1!==p.filterHeight||1!==p.filterWidth||1!==p.dilationHeight||1!==p.dilationWidth||1!==p.strideHeight||1!==p.strideWidth||"SAME"!==p.padInfo.type&&"VALID"!==p.padInfo.type)if(env().getBool("WEBGL_CONV_IM2COL")&&1===r.shape[0])h=conv2dWithIm2Row({x:r,filter:s,convInfo:p,backend:n});else{const e=new Conv2DProgram(p);h=n.runWebGLProgram(e,[r,s],"float32")}else h=conv2dByMatMul({x:r,filter:s,convInfo:p,backend:n});const m=reshape4({inputs:{x:h},backend:n,attrs:{shape:p.outShape}});return n.disposeIntermediateTensorInfo(h),m}var conv2DConfig2={kernelName:Conv2D,backendName:"webgl",kernelFunc:conv2d4},Conv2DDerFilterProgram=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,a=e.padInfo.top,r=e.padInfo.left,s="channelsLast"===e.dataFormat;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${a};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${r};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              if (${s}) {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},Conv2DDerInputProgram=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,a=e.strideHeight,r=e.strideWidth,s="channelsLast"===e.dataFormat,o=t-1-e.padInfo.top,i=n-1-e.padInfo.left,l=s?1:2,u=s?2:3,c=s?3:1;this.userCode=`\n      const ivec2 pads = ivec2(${o}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${c}];\n\n        ivec2 dyCorner = ivec2(coords[${l}], coords[${u}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${a}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${r}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n\n              if (${s}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},Conv3DDerFilterProgram=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideDepth,n=e.strideHeight,a=e.strideWidth,r=e.padInfo.front,s=e.padInfo.top,o=e.padInfo.left;this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yF = 0; yF < ${e.outDepth}; yF++) {\n            int xF = wF + yF * ${t} - ${r};\n\n            if (xF < 0 || xF >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${e.outHeight}; yR++) {\n              int xR = wR + yR * ${n} - ${s};\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${e.outWidth}; yC++) {\n                int xC = wC + yC * ${a} - ${o};\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},Conv3DDerInputProgram=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,a=e.filterWidth,r=e.strideDepth,s=e.strideHeight,o=e.strideWidth,i=t-1-e.padInfo.front,l=n-1-e.padInfo.top,u=a-1-e.padInfo.left;this.userCode=`\n      const ivec3 pads = ivec3(${i}, ${l}, ${u});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${t}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${r}.0;\n\n          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${t} - 1 - wF;\n\n          for (int wR = 0; wR < ${n}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${s}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${n} - 1 - wR;\n\n            for (int wC = 0; wC < ${a}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${o}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${a} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}};function conv2DBackpropFilter3(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,dy:s}=t,{strides:o,pad:i,dataFormat:l,dimRoundingMode:u,filterShape:c}=a,d=backend_util_exports.convertConv2DDataFormat(l),p=backend_util_exports.computeConv2DInfo(r.shape,c,o,1,i,u,!1,d),h=new Conv2DDerFilterProgram(p);return n.runWebGLProgram(h,[r,s],"float32")}var conv2DBackpropFilterConfig2={kernelName:Conv2DBackpropFilter,backendName:"webgl",kernelFunc:conv2DBackpropFilter3};function conv2DBackpropInput3(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:s}=t,{inputShape:o,strides:i,pad:l,dataFormat:u,dimRoundingMode:c}=a,d=backend_util_exports.convertConv2DDataFormat(u),p=backend_util_exports.computeConv2DInfo(o,s.shape,i,1,l,c,!1,d),h=new Conv2DDerInputProgram(p);return n.runWebGLProgram(h,[r,s],"float32")}var conv2DBackpropInputConfig2={kernelName:Conv2DBackpropInput,backendName:"webgl",kernelFunc:conv2DBackpropInput3};function conv3D2(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:o,pad:i,dilations:l}=a,u=backend_util_exports.computeConv3DInfo(r.shape,s.shape,o,l,i),c=new Conv3DProgram(u);return n.runWebGLProgram(c,[r,s],"float32")}var conv3DConfig2={kernelName:Conv3D,backendName:"webgl",kernelFunc:conv3D2};function conv3DBackpropFilterV22(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,dy:s}=t,{strides:o,pad:i,filterShape:l}=a,u=backend_util_exports.computeConv3DInfo(r.shape,l,o,1,i),c=new Conv3DDerFilterProgram(u);return n.runWebGLProgram(c,[r,s],"float32")}var conv3DBackpropFilterV2Config2={kernelName:Conv3DBackpropFilterV2,backendName:"webgl",kernelFunc:conv3DBackpropFilterV22};function conv3DBackpropInput2(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:s}=t,{pad:o,strides:i,inputShape:l}=a,u=backend_util_exports.computeConv3DInfo(l,s.shape,i,1,o),c=new Conv3DDerInputProgram(u);return n.runWebGLProgram(c,[r,s],"float32")}var conv3DBackpropInputConfig={kernelName:Conv3DBackpropInputV2,backendName:"webgl",kernelFunc:conv3DBackpropInput2},COS=CHECK_NAN_SNIPPET_UNARY+"\n  return cos(x);\n",cos3=unaryKernelFunc2({opSnippet:COS}),cosConfig2={kernelName:Cos,backendName:"webgl",kernelFunc:cos3},COSH="\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n",cosh3=unaryKernelFunc2({opSnippet:COSH}),coshConfig2={kernelName:Cosh,backendName:"webgl",kernelFunc:cosh3},CropAndResizeProgram=class{constructor(e,t,n,a,r){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[s,o,i,l]=e,[u]=t,[c,d]=n;this.outputShape=[u,c,d,l];const p="bilinear"===a?1:0,[h,m]=[o-1+".0",i-1+".0"],[f,g,x]=c>1?[""+(o-1)/(c-1),"(y2-y1) * height_ratio",`y1*${h} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${h}`],[y,A,b]=d>1?[""+(i-1)/(d-1),"(x2-x1) * width_ratio",`x1*${m} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${m}`];this.userCode=`\n      const float height_ratio = float(${f});\n      const float width_ratio = float(${y});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${s}) {\n          return;\n        }\n\n        float height_scale = ${g};\n        float width_scale = ${A};\n\n        float in_y = ${x};\n        if( in_y < 0.0 || in_y > ${h} ) {\n          setOutput(float(${r}));\n          return;\n        }\n        float in_x = ${b};\n        if( in_x < 0.0 || in_x > ${m} ) {\n          setOutput(float(${r}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${p} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}},cropAndResize3=e=>{const{inputs:t,backend:n,attrs:a}=e,{image:r,boxes:s,boxInd:o}=t,{cropSize:i,method:l,extrapolationValue:u}=a,c=new CropAndResizeProgram(r.shape,s.shape,i,l,u);return n.runWebGLProgram(c,[r,s,o],"float32")},cropAndResizeConfig2={kernelName:CropAndResize,backendName:"webgl",kernelFunc:cropAndResize3},CumSumProgram=class{constructor(e,t,n){this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}],this.outputShape=e;const a=e.length,r=t?"0.0":`getX(${getCoords2(a,"coords")})`,s=e[e.length-1];let o="",i="";t?(o=n?"end != "+(s-1):"end != 0",i=n?"end + 1":"end - 1"):(o=n?`end + pow2 < ${s}`:"end >= pow2",i=n?"end + pow2":"end - pow2"),this.userCode=`\n      void main() {\n        ${getCoordsDataType(a)} coords = getOutputCoords();\n        int end = ${getFinalCoord(a,"coords")};\n        float val = ${r};\n        int pow2 = int(pow(2.0, index));\n        if (${o}) {\n          int idx = ${i};\n          ${getFinalCoord(a,"coords")} = idx;\n          val += getX(${getCoords2(a,"coords")});\n        }\n        setOutput(val);\n      }\n    `}};function getCoords2(e,t){if(1===e)return`${t}`;if(2===e)return`${t}.x, ${t}.y`;if(3===e)return`${t}.x, ${t}.y, ${t}.z`;if(4===e)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw Error(`Cumulative sum for rank ${e} is not yet supported`)}function getFinalCoord(e,t){if(1===e)return`${t}`;if(2===e)return`${t}.y`;if(3===e)return`${t}.z`;if(4===e)return`${t}.w`;throw Error(`Cumulative sum for rank ${e} is not yet supported`)}function cumsum3(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,exclusive:o,reverse:i}=a,l=r.shape.length,u=backend_util_exports.getAxesPermutation([s],l);let c=r;null!=u&&(c=transpose3({inputs:{x:r},backend:n,attrs:{perm:u}}));const d=backend_util_exports.getInnerMostAxes(1,l)[0];if(d!==l-1)throw new Error(`WebGL cumsum shader expects an inner-most axis=${r.shape.length-1} but got axis=${s}`);const p=c.shape[d];let h=identity3({inputs:{x:c},backend:n});for(let e=0;e<=Math.ceil(Math.log2(p))-1;e++){const t=new CumSumProgram(c.shape,!1,i),a=[[e]],r=h;h=n.runWebGLProgram(t,[h],h.dtype,a),n.disposeIntermediateTensorInfo(r)}if(o){const e=new CumSumProgram(c.shape,o,i),t=h;h=n.runWebGLProgram(e,[h],h.dtype),n.disposeIntermediateTensorInfo(t)}if(null!=u){const e=transpose3({inputs:{x:h},backend:n,attrs:{perm:backend_util_exports.getUndoAxesPermutation(u)}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(c),e}return h}var cumsumConfig2={kernelName:Cumsum,backendName:"webgl",kernelFunc:cumsum3};function denseBincount3(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,weights:s}=t,{size:o,binaryOutput:i}=a;if(1===r.shape.length){const e=n.readSync(r.dataId),t=n.readSync(s.dataId),a=bincountImplCPU(e,t,s.dtype,s.shape,o);return n.makeTensorInfo([o],s.dtype,a)}if(2===r.shape.length){const e=n.bufferSync(r),t=n.bufferSync(s),a=bincountReduceImplCPU(e,t,o,i);return n.makeTensorInfo(a.shape,s.dtype,a.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}var denseBincountConfig2={kernelName:DenseBincount,backendName:"webgl",kernelFunc:denseBincount3},DepthToSpaceProgram=class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${t};\n      int offset_h = imod(h, ${t});\n      int in_w = w / ${t};\n      int offset_w = imod(w, ${t});\n      int offset_d = (offset_h * ${t} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}};function depthToSpace3(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockSize:s,dataFormat:o}=a,i=r.shape[0],l=("NHWC"===o?r.shape[1]:r.shape[2])*s,u=("NHWC"===o?r.shape[2]:r.shape[3])*s,c=("NHWC"===o?r.shape[3]:r.shape[1])/(s*s),d=new DepthToSpaceProgram("NHWC"===o?[i,l,u,c]:[i,c,l,u],s,o);return n.runWebGLProgram(d,[r],r.dtype)}var depthToSpaceConfig2={kernelName:DepthToSpace,backendName:"webgl",kernelFunc:depthToSpace3},DepthwiseConv2DProgram=class{constructor(e,t=!1,n=null,a=!1,r=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=useShapeUniforms(this.outputShape.length);const s=e.filterHeight,o=e.filterWidth,i=e.outChannels/e.inChannels;let l="",u="";n&&(l=a?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:r?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,u="result = activation(result);");const c=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${l}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${i};\n        int q = d2 - d1 * ${i};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${s}; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${o}; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${c}\n        ${u}\n        setOutput(result);\n      }\n    `}},DepthwiseConvPacked2DProgram=class{constructor(e,t=!1,n=null,a=!1,r=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=useShapeUniforms(this.outputShape.length);const s=e.outChannels/e.inChannels,o=e.padInfo.left,i=e.strideWidth,l=e.dilationWidth,u=e.filterHeight,c=e.filterWidth,d=c;let p="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let e=0;e<c;e++)p+=`\n          vec4 xTexelC${2*e};\n          int xTexelC${2*e}Ready;\n          vec4 xTexelC${2*e+1};\n          int xTexelC${2*e+1}Ready;\n          vec4 xC${e};`;p+=`\n    for (int r = 0; r < ${u}; r++) {\n      `;for(let e=0;e<c;e++)p+=`\n          xTexelC${2*e} = vec4(0.0);\n          xTexelC${2*e}Ready = 0;\n          xTexelC${2*e+1} = vec4(0.0);\n          xTexelC${2*e+1}Ready = 0;\n          xC${e} = vec4(0.0);`;p+="\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";for(let e=0;e<(d+1)/2;e++){const t=2*e;if(p+=`\n          xC = xCCorner + ${t*l};\n          `,1===i){if(t<c&&(o%2==1?(p+=`\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {\n                  xTexelC${t} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${t}.zw = vec2(0.0);\n                  }\n                  xTexelC${t}Ready = 1;\n                }\n              `,p+=1===l&&t>0?`\n                xC${t} = vec4(xTexelC${t-2}.zw, xTexelC${t}.xy);\n                `:`\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${t} = vec4(previous.zw, xTexelC${t}.xy);\n                  } else {\n                    xC${t} = vec4(0.0, 0.0, xTexelC${t}.xy);\n                  }\n                  `):p+=`\n                if (xC >= 0 && xC < inDims[1] && xTexelC${t}Ready == 0) {\n                  xTexelC${t} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${t}.zw = vec2(0.0);\n                  }\n                  xTexelC${t}Ready = 1;\n                }\n\n                xC${t} = xTexelC${t};\n                `,t+1<c)){const e=o%2==0?util_exports.nearestLargerEven(l):l;l%2==0&&o%2==1||l%2!=0&&o%2!=1?(p+=`\n                  xCOffset = xC + imod(pads[1], 2) + ${e};\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                    xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC${t+1}.zw = vec2(0.0);\n                    }\n                    xTexelC${t+1}Ready = 1;\n                  }\n                  `,l>1&&(p+=`\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {\n                      xTexelC${t} = getX(batch, xR, xCOffset, d1);\n                      xTexelC${t}Ready = 1;\n                    }\n                    `),p+=`\n                  xC${t+1} = vec4(xTexelC${t}.zw, xTexelC${t+1}.xy);\n                  `):p+=1===e?`\n                    xC${t+1} = xTexelC${t};\n                    `:`\n                    xCOffset = xC + ${e};\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                      xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC${t+1}.zw = vec2(0.0);\n                      }\n                      xTexelC${t+1}Ready = 1;\n                    }\n\n                    xC${t+1} = xTexelC${t+1};\n                    `}}else t<c&&(o%2==1?(p+=`\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {\n                  xTexelC${t} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${t}.zw = vec2(0.0);\n                  }\n                  xTexelC${t}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${t+1}Ready == 0) {\n                  xTexelC${t+1} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC${t+1}.zw = vec2(0.0);\n                  }\n                  xTexelC${t+1}Ready = 1;\n                }\n\n                xC${t} = vec4(xTexelC${t}.zw, xTexelC${t+1}.zw);\n              `,t+1<c&&(p+=`\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${t+1} = vec4(xTexelC${t+1}.xy, final.xy);\n                `)):(p+=`\n                if(xC >= 0 && xC < inDims[1] && xTexelC${t}Ready == 0) {\n                  xTexelC${t} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${t}.zw = vec2(0.0);\n                  }\n                  xTexelC${t}Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                  xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${t+1}.zw = vec2(0.);\n                  }\n                  xTexelC${t+1}Ready = 1;\n                }\n\n                xC${t} = vec4(\n                  xTexelC${t}.xy, xTexelC${t+1}.xy);\n              `,t+1<c&&(p+=`\n                  xC${t+1} = vec4(xTexelC${t}.zw, xTexelC${t+1}.zw);\n                `)));t<c&&(p+=`\n            wTexel = getW(r, ${t}, d1, q);\n            dotProd += xC${t} * vec4(wTexel.xz, wTexel.xz);\n          `,t+1<c&&(p+=`\n              wTexel = getW(r, ${t+1}, d1, q);\n              dotProd += xC${t+1} * vec4(wTexel.xz, wTexel.xz);\n            `))}p+="\n    }\n  ",p+="\n      }\n    ";let h="",m="";n&&(h=a?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:r?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`vec4 activation(vec4 x) {\n          ${n}\n        }`,m="result = activation(result);");const f=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${h}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${s};\n        int q = d2 - d1 * ${s};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${p}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${f}\n        ${m}\n        setOutput(result);\n      }\n    `}};function depthwiseConv2dNative2(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:o,pad:i,dilations:l,dimRoundingMode:u}=a;let c=l;null==c&&(c=[1,1]),util_exports.assert(backend_util_exports.eitherStridesOrDilationsAreOne(o,c),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`));const d=backend_util_exports.computeConv2DInfo(r.shape,s.shape,o,c,i,u,!0);let p;p=env().getBool("WEBGL_PACK_DEPTHWISECONV")&&d.strideWidth<=2&&d.outChannels/d.inChannels==1?new DepthwiseConvPacked2DProgram(d):new DepthwiseConv2DProgram(d);const h=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];return n.runWebGLProgram(p,[r,s],"float32",h)}var depthwiseConv2dNativeConfig2={kernelName:DepthwiseConv2dNative,backendName:"webgl",kernelFunc:depthwiseConv2dNative2},DepthwiseConv2DDerFilterProgram=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,a=e.padInfo.top,r=e.padInfo.left,s=e.outChannels/e.inChannels;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${s} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${a};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${r};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},DepthwiseConv2DDerInputProgram=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,a=e.strideHeight,r=e.strideWidth,s=t-1-e.padInfo.top,o=n-1-e.padInfo.left,i=e.outChannels/e.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${s}, ${o});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${a}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${r}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${i}; dm++) {\n              int d2 = d1 * ${i} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}};function depthwiseConv2dNativeBackpropFilter3(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,dy:s}=t,{strides:o,dilations:i,pad:l,dimRoundingMode:u,filterShape:c}=a,d=backend_util_exports.computeConv2DInfo(r.shape,c,o,i,l,u,!0),p=new DepthwiseConv2DDerFilterProgram(d);return n.runWebGLProgram(p,[r,s],"float32")}var depthwiseConv2dNativeBackpropFilterConfig2={kernelName:DepthwiseConv2dNativeBackpropFilter,backendName:"webgl",kernelFunc:depthwiseConv2dNativeBackpropFilter3};function depthwiseConv2dNativeBackpropInput3(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:s}=t,{strides:o,dilations:i,pad:l,dimRoundingMode:u,inputShape:c}=a,d=backend_util_exports.computeConv2DInfo(c,s.shape,o,i,l,u,!0),p=new DepthwiseConv2DDerInputProgram(d);return n.runWebGLProgram(p,[r,s],"float32")}var depthwiseConv2dNativeBackpropInputConfig2={kernelName:DepthwiseConv2dNativeBackpropInput,backendName:"webgl",kernelFunc:depthwiseConv2dNativeBackpropInput3},DiagProgram=class{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}};function diag3(e){const{inputs:t,backend:n}=e,{x:a}=t,r=[...a.shape,...a.shape],s=util_exports.sizeFromShape(a.shape),o=reshape4({inputs:{x:a},backend:n,attrs:{shape:[s]}}),i=new DiagProgram(s),l=n.runWebGLProgram(i,[o],o.dtype),u=reshape4({inputs:{x:l},backend:n,attrs:{shape:r}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),u}var diagConfig2={kernelName:Diag,backendName:"webgl",kernelFunc:diag3},Dilation2DProgram=class{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:n,padInfo:a,strideHeight:r,strideWidth:s,filterHeight:o,filterWidth:i,dilationHeight:l,dilationWidth:u}=e,{top:c,left:d}=a;this.userCode=`\n      const ivec2 strides = ivec2(${r}, ${s});\n      const ivec2 pads = ivec2(${c}, ${d});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${o}; h++) {\n          int hIn = hBeg + h * ${l};\n\n          if (hIn >= 0 && hIn < ${t}) {\n            for (int w = 0; w < ${i}; w++) {\n              int wIn = wBeg + w * ${u};\n\n              if (wIn >= 0 && wIn < ${n}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}};function dilation2D(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:o,pad:i,dilations:l}=a,u=backend_util_exports.computeDilation2DInfo(r.shape,s.shape,o,i,"NHWC",l);let c;const d=new Dilation2DProgram(u);c=n.runWebGLProgram(d,[r,s],"float32");const p=reshape4({inputs:{x:c},backend:n,attrs:{shape:u.outShape}});return n.disposeIntermediateTensorInfo(c),p}var dilation2DConfig={kernelName:Dilation2D,backendName:"webgl",kernelFunc:dilation2D};function einsum3(e){const{inputs:t,backend:n,attrs:a}=e,{equation:r}=a,s=t,{allDims:o,summedDims:i,idDims:l}=backend_util_exports.decodeEinsumEquation(r,s.length);backend_util_exports.checkEinsumDimSizes(o.length,l,s);const{path:u,steps:c}=backend_util_exports.getEinsumComputePath(i,l),d=c.length;let p=null,h=o.length;const m=[];for(let e=0;e<d;++e){for(const t of c[e]){const{permutationIndices:e,expandDims:a}=backend_util_exports.getEinsumPermutation(h,l[t]);let r;backend_util_exports.isIdentityPermutation(e)?r=s[t]:(r=transpose3({inputs:{x:s[t]},backend:n,attrs:{perm:e}}),m.push(r));const o=r.shape.slice();for(let e=0;e<a.length;++e)o.splice(a[e],0,1);util_exports.arraysEqual(r.shape,o)||(r=reshape4({inputs:{x:r},backend:n,attrs:{shape:o}}),m.push(r)),null===p?p=r:(p=multiply3({inputs:{a:r,b:p},backend:n}),m.push(p))}e<d-1&&(u[e]>=0&&(p=sum4({inputs:{x:p},backend:n,attrs:{axis:u[e]-(o.length-h),keepDims:!1}}),m.push(p)),h--)}for(const e of m)e!==p&&n.disposeIntermediateTensorInfo(e);return p}var einsumConfig2={kernelName:Einsum,backendName:"webgl",kernelFunc:einsum3},ELU4="return (x >= 0.0) ? x : (exp(x) - 1.0);",ELU_PACKED="\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n",elu5=unaryKernelFunc2({opSnippet:ELU4,packedOpSnippet:ELU_PACKED}),eluConfig2={kernelName:Elu,backendName:"webgl",kernelFunc:elu5},ELU_DER="return (b >= 1.0) ? a : a * (b + 1.0);",ELU_DER_PACKED="\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",eluGrad2=e=>{const{inputs:t,backend:n}=e,{dy:a,y:r}=t,s=env().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new BinaryOpPackedProgram(ELU_DER_PACKED,a.shape,r.shape):new BinaryOpProgram(ELU_DER,a.shape,r.shape);return n.runWebGLProgram(s,[a,r],a.dtype)},eluGradConfig3={kernelName:EluGrad,backendName:"webgl",kernelFunc:eluGrad2},PACKED_EQUAL="\n  return vec4(equal(a, b));\n",EQUAL="return float(a == b);",equal3=binaryKernelFunc2({opSnippet:EQUAL,packedOpSnippet:PACKED_EQUAL,dtype:"bool",cpuKernelImpl:equalImplCPU}),equalConfig2={kernelName:Equal,backendName:"webgl",kernelFunc:equal3},ERF=`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${backend_util_exports.ERF_P};\n  float a1 = ${backend_util_exports.ERF_A1};\n  float a2 = ${backend_util_exports.ERF_A2};\n  float a3 = ${backend_util_exports.ERF_A3};\n  float a4 = ${backend_util_exports.ERF_A4};\n  float a5 = ${backend_util_exports.ERF_A5};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`,erf3=unaryKernelFunc2({opSnippet:ERF}),erfConfig2={kernelName:Erf,backendName:"webgl",kernelFunc:erf3},EXP="return exp(x);",exp3=unaryKernelFunc2({opSnippet:EXP,packedOpSnippet:EXP,cpuKernelImpl:expImplCPU,dtype:"float32"}),expConfig2={kernelName:Exp,backendName:"webgl",kernelFunc:exp3};function expandDims4(e){const{inputs:t,attrs:n,backend:a}=e,{dim:r}=n,{input:s}=t,o=s.shape.length,i=s.shape.slice();let l=r;return r<0&&(util_exports.assert(-(o+1)<=r,(()=>`Axis must be in the interval [${-(o+1)}, ${o}]`)),l=o+r+1),i.splice(l,0,1),reshape4({inputs:{x:s},backend:a,attrs:{shape:i}})}var expandDimsConfig2={kernelName:ExpandDims,backendName:"webgl",kernelFunc:expandDims4},EXPM1="return exp(x) - 1.0;",expm13=unaryKernelFunc2({opSnippet:EXPM1,packedOpSnippet:EXPM1,cpuKernelImpl:expm1ImplCPU}),expm1Config2={kernelName:Expm1,backendName:"webgl",kernelFunc:expm13},FFTProgram=class{constructor(e,t,n){this.variableNames=["real","imag"];const a=t[1];this.outputShape=t;const r=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,s=n?`${a}.0`:"1.0";let o;if("real"===e)o="return real * expR - imag * expI;";else{if("imag"!==e)throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);o="return real * expI + imag * expR;"}this.userCode=`\n      const float exponentMultiplier = ${r};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${o}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${a});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${a}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${s};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}};function fftImpl2(e,t,n){const a=n.texData.get(e.dataId),r=util_exports.sizeFromShape(e.shape),s=e.shape[e.shape.length-1],o=reshape4({inputs:{x:e},backend:n,attrs:{shape:[r/s,s]}}),i=o.shape,l=new FFTProgram("real",i,t),u=new FFTProgram("imag",i,t),c=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:i},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:i}],d=n.runWebGLProgram(l,c,"float32"),p=n.runWebGLProgram(u,c,"float32"),h=complex3({inputs:{real:d,imag:p},backend:n});n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p);const m=reshape4({inputs:{x:h},backend:n,attrs:{shape:e.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(h),m}function fft3(e){const{inputs:t,backend:n}=e,{input:a}=t;return fftImpl2(a,!1,n)}var fftConfig2={kernelName:FFT,backendName:"webgl",kernelFunc:fft3},FillProgram=class{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode="\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}};function fill3(e){const{backend:t,attrs:n}=e,{shape:a,value:r}=n;let{dtype:s}=n;if(s=s||util_exports.inferDtype(r),"string"===s){const e=util_exports.getArrayFromDType(s,util_exports.sizeFromShape(a));return e.fill(r),t.makeTensorInfo(a,s,e)}{const e=new FillProgram(a,r),n=[[r]];return t.runWebGLProgram(e,[],s,n)}}var fromPixels2DContext2,fillConfig2={kernelName:Fill,backendName:"webgl",kernelFunc:fill3},FlipLeftRightProgram=class{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${t} - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${t}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}},flipLeftRightConfig2={kernelName:FlipLeftRight,backendName:"webgl",kernelFunc:({inputs:e,backend:t})=>{const{image:n}=e,a=t,r=new FlipLeftRightProgram(n.shape);return a.runWebGLProgram(r,[n],n.dtype)}},FLOOR="return floor(x);",floor3=unaryKernelFunc2({opSnippet:FLOOR,packedOpSnippet:FLOOR,cpuKernelImpl:floorImplCPU}),floorConfig2={kernelName:Floor,backendName:"webgl",kernelFunc:floor3},INT_DIV="\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",INT_DIV_PACKED="\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",floorDiv3=binaryKernelFunc2({opSnippet:INT_DIV,packedOpSnippet:INT_DIV_PACKED,dtype:"int32"}),floorDivConfig2={kernelName:FloorDiv,backendName:"webgl",kernelFunc:floorDiv3},FromPixelsProgram=class{constructor(e){this.variableNames=["A"];const t=getGlslDifferences(),[n,a]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${a}.0, ${n}.0);\n\n        vec4 values = ${t.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}},FromPixelsPackedProgram=class{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=getGlslDifferences(),[n,a]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${a}.0, ${n}.0);\n            vec4 values = ${t.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${t.output} = result;\n      }\n    `}},fromPixelsConfig={kernelName:FromPixels,backendName:"webgl",kernelFunc:fromPixels2};function fromPixels2(e){const{inputs:t,backend:n,attrs:a}=e;let{pixels:r}=t;const{numChannels:s}=a,o="undefined"!=typeof HTMLVideoElement&&r instanceof HTMLVideoElement,i="undefined"!=typeof HTMLImageElement&&r instanceof HTMLImageElement,[l,u]=o?[r.videoWidth,r.videoHeight]:[r.width,r.height],c=[u,l],d=[u,l,s];(i||o)&&(null==fromPixels2DContext2&&(fromPixels2DContext2=document.createElement("canvas").getContext("2d")),fromPixels2DContext2.canvas.width=l,fromPixels2DContext2.canvas.height=u,fromPixels2DContext2.drawImage(r,0,0,l,u),r=fromPixels2DContext2.canvas);const p=n.makeTensorInfo(c,"int32");n.texData.get(p.dataId).usage=TextureUsage.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(p.dataId),r);const h=env().getBool("WEBGL_PACK")?new FromPixelsPackedProgram(d):new FromPixelsProgram(d),m=n.runWebGLProgram(h,[p],"int32");return n.disposeData(p.dataId),m}function fusedConv2d(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s,bias:o,preluActivationWeights:i}=t,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:p,activation:h,leakyreluAlpha:m}=a,f=backend_util_exports.convertConv2DDataFormat(c),g=backend_util_exports.computeConv2DInfo(r.shape,s.shape,l,d,u,p,!1,f);let x;const y=[];if(1!==g.filterHeight||1!==g.filterWidth||1!==g.dilationHeight||1!==g.dilationWidth||1!==g.strideHeight||1!==g.strideWidth||"SAME"!==g.padInfo.type&&"VALID"!==g.padInfo.type)if(env().getBool("WEBGL_CONV_IM2COL")&&1===r.shape[0])x=conv2dWithIm2Row({x:r,filter:s,convInfo:g,backend:n,bias:o,activation:h,preluActivationWeights:i,leakyreluAlpha:m});else{const e=null!=o,t=null!=i,a="leakyrelu"===h,l=h?mapActivationToShaderProgram(h,!1):null,u=new Conv2DProgram(g,e,l,t,a),c=[r,s];if(o&&c.push(o),i&&c.push(i),a){const e=n.makeTensorInfo([],"float32",util_exports.createScalarValue(m,"float32"));c.push(e),y.push(e)}x=n.runWebGLProgram(u,c,"float32")}else x=conv2dByMatMul({x:r,filter:s,convInfo:g,backend:n,bias:o,activation:h,preluActivationWeights:i,leakyreluAlpha:m});const A=reshape4({inputs:{x:x},backend:n,attrs:{shape:g.outShape}});return y.push(x),y.forEach((e=>n.disposeIntermediateTensorInfo(e))),A}var fusedConv2DConfig2={kernelName:FusedConv2D,backendName:"webgl",kernelFunc:fusedConv2d};function fusedDepthwiseConv2D2(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s,bias:o,preluActivationWeights:i}=t,{strides:l,pad:u,dilations:c,dimRoundingMode:d,activation:p,leakyreluAlpha:h}=a,m=[];let f=c;null==f&&(f=[1,1]),util_exports.assert(backend_util_exports.eitherStridesOrDilationsAreOne(l,f),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${f}'`));const g=backend_util_exports.computeConv2DInfo(r.shape,s.shape,l,f,u,d,!0),x=env().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels==1,y=p?mapActivationToShaderProgram(p,x):null,A=[r,s],b=null!=o,v=null!=i,k="leakyrelu"===p;if(b&&A.push(o),v&&A.push(i),k){const e=n.makeTensorInfo([],"float32",util_exports.createScalarValue(h,"float32"));A.push(e),m.push(e)}let S;S=x?new DepthwiseConvPacked2DProgram(g,b,y,v,k):new DepthwiseConv2DProgram(g,b,y,v,k);const w=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],C=n.runWebGLProgram(S,A,"float32",w);return m.forEach((e=>n.disposeIntermediateTensorInfo(e))),C}var fusedDepthwiseConv2DConfig2={kernelName:FusedDepthwiseConv2D,backendName:"webgl",kernelFunc:fusedDepthwiseConv2D2},GatherNDProgram=class{constructor(e,t,n){this.sliceDim=e,this.strides=t,this.variableNames=["x","indices"],this.outputShape=n;const a=getCoordsDataType(t.length),r=getCoordsDataType(n.length),s=this.sliceDim>1?"strides[j]":"strides";this.userCode=`\n        ${a} strides = ${a}(${this.strides});\n         void main() {\n          ${r} coords = getOutputCoords();\n          int flattenIndex = 0;\n          for (int j = 0; j < ${this.sliceDim}; j++) {\n            int index = round(getIndices(coords[0], j));\n            flattenIndex += index * ${s};\n          }\n          setOutput(getX(flattenIndex, coords[1]));\n        }\n      `}};function gatherNd2(e){const{inputs:t,backend:n}=e,{params:a,indices:r}=t,s=r.shape,o=s[s.length-1],i=util_exports.sizeFromShape(a.shape),[l,u,c,d]=backend_util_exports.prepareAndValidate(a,r),p=reshape4({inputs:{x:r},backend:n,attrs:{shape:[u,o]}}),h=reshape4({inputs:{x:a},backend:n,attrs:{shape:[util_exports.sizeFromShape(a.shape)/c,c]}});if(n.shouldExecuteOnCPU([a,r])||"string"===a.dtype){const e=n.readSync(r.dataId),t=n.bufferSync(a),s=gatherNdImplCPU(e,t,a.dtype,u,o,c,d,a.shape,i);return n.makeTensorInfo(l,a.dtype,s.values)}const m=new GatherNDProgram(o,d,[u,c]),f=n.runWebGLProgram(m,[h,p],h.dtype),g=reshape4({inputs:{x:f},backend:n,attrs:{shape:l}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(f),g}var gatherNdConfig2={kernelName:GatherNd,backendName:"webgl",kernelFunc:gatherNd2},GatherProgram=class{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const n=getCoordsDataType(this.rank),a=getSourceCoords2(e,2);this.userCode=`\n      void main() {\n        ${n} resRC = getOutputCoords();\n        setOutput(getA(${a}));\n      }\n    `}};function getSourceCoords2(e,t){const n=["resRC.x","resRC.y","resRC.z","resRC.w"],a=[];for(let t=0;t<e.length;t++)2===t?a.push("int(getIndices(resRC.x, resRC.z))"):a.push(`${n[t]}`);return a.join()}function gatherV22(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,indices:s}=t,{axis:o,batchDims:i}=a,l=util_exports.parseAxisParam(o,r.shape)[0],u=n.readSync(s.dataId),c=r.shape[l];for(let e=0;e<u.length;++e){const t=u[e];util_exports.assert(t<=c-1&&t>=0,(()=>`GatherV2: the index value ${t} is not in [0, ${c-1}]`))}const d=backend_util_exports.segment_util.collectGatherOpShapeInfo(r,s,l,i),p=util_exports.sizeFromShape(s.shape),h=[],m=reshape4({inputs:{x:r},backend:n,attrs:{shape:[d.batchSize,d.outerSize,d.dimSize,d.sliceSize]}}),f=reshape4({inputs:{x:s},backend:n,attrs:{shape:[d.batchSize,p/d.batchSize]}});h.push(m),h.push(f);const g=[d.batchSize,d.outerSize,p/d.batchSize,d.sliceSize];if(n.shouldExecuteOnCPU([r,s])||"string"===r.dtype){const e=n.bufferSync(f),t=n.bufferSync(m),a=gatherV2ImplCPU(t,e,g);return h.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(d.outputShape,a.dtype,a.values)}const x=new GatherProgram(m.shape,g),y=n.runWebGLProgram(x,[m,f],m.dtype);h.push(y);const A=reshape4({inputs:{x:y},backend:n,attrs:{shape:d.outputShape}});return h.forEach((e=>n.disposeIntermediateTensorInfo(e))),A}var gatherV2Config2={kernelName:GatherV2,backendName:"webgl",kernelFunc:gatherV22},GREATER="return float(a > b);",GREATER_PACKED="\n  return vec4(greaterThan(a, b));\n",greater4=binaryKernelFunc2({opSnippet:GREATER,packedOpSnippet:GREATER_PACKED,cpuKernelImpl:greaterImplCPU,dtype:"bool"}),greaterConfig2={kernelName:Greater,backendName:"webgl",kernelFunc:greater4},GREATER_EQUAL="return float(a >= b);",GREATER_EQUAL_PACKED="\n  return vec4(greaterThanEqual(a, b));\n",greaterEqual3=binaryKernelFunc2({opSnippet:GREATER_EQUAL,packedOpSnippet:GREATER_EQUAL_PACKED,dtype:"bool",cpuKernelImpl:greaterEqualImplCPU}),greaterEqualConfig2={kernelName:GreaterEqual,backendName:"webgl",kernelFunc:greaterEqual3};function ifft3(e){const{inputs:t,backend:n}=e,{input:a}=t;return fftImpl2(a,!0,n)}var ifftConfig2={kernelName:IFFT,backendName:"webgl",kernelFunc:ifft3},IS_FINITE="return float(!isnan(x) && !isinf(x));",isFinite4=unaryKernelFunc2({opSnippet:IS_FINITE,dtype:"bool"}),isFiniteConfig2={kernelName:IsFinite,backendName:"webgl",kernelFunc:isFinite4},IS_INF="return float(isinf(x));",isInf3=unaryKernelFunc2({opSnippet:IS_INF,dtype:"bool"}),isInfConfig2={kernelName:IsInf,backendName:"webgl",kernelFunc:isInf3},IS_NAN="return float(isnan(x));",isNaN4=unaryKernelFunc2({opSnippet:IS_NAN,dtype:"bool"}),isNaNConfig2={kernelName:IsNan,backendName:"webgl",kernelFunc:isNaN4},LESS="return float(a < b);",LESS_PACKED="\n  return vec4(lessThan(a, b));\n",less4=binaryKernelFunc2({opSnippet:LESS,packedOpSnippet:LESS_PACKED,cpuKernelImpl:lessImplCPU,dtype:"bool"}),lessConfig2={kernelName:Less,backendName:"webgl",kernelFunc:less4},LESS_EQUAL="return float(a <= b);",LESS_EQUAL_PACKED="\n  return vec4(lessThanEqual(a, b));\n",lessEqual3=binaryKernelFunc2({opSnippet:LESS_EQUAL,packedOpSnippet:LESS_EQUAL_PACKED,cpuKernelImpl:lessEqualImplCPU,dtype:"bool"}),lessEqualConfig2={kernelName:LessEqual,backendName:"webgl",kernelFunc:lessEqual3};function linSpace2(e){const{backend:t,attrs:n}=e,{start:a,stop:r,num:s}=n,o=linSpaceImplCPU(a,r,s);return t.makeTensorInfo([o.length],"float32",o)}var linSpaceConfig2={kernelName:LinSpace,backendName:"webgl",kernelFunc:linSpace2},LOG="if (x < 0.0) return NAN;\n  return log(x);",LOG_PACKED="\n  vec4 result = log(x);\n  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));\n  result.r = isNaN.r == 1.0 ? NAN : result.r;\n  result.g = isNaN.g == 1.0 ? NAN : result.g;\n  result.b = isNaN.b == 1.0 ? NAN : result.b;\n  result.a = isNaN.a == 1.0 ? NAN : result.a;\n\n  return result;\n",log6=unaryKernelFunc2({opSnippet:LOG,packedOpSnippet:LOG_PACKED,cpuKernelImpl:logImplCPU}),logConfig2={kernelName:Log,backendName:"webgl",kernelFunc:log6},LOG1P="return log(1.0 + x);",log1p3=unaryKernelFunc2({opSnippet:LOG1P}),log1pConfig2={kernelName:Log1p,backendName:"webgl",kernelFunc:log1p3},LOGICAL_AND="return float(a >= 1.0 && b >= 1.0);",LOGICAL_AND_PACKED="\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",logicalAnd3=binaryKernelFunc2({opSnippet:LOGICAL_AND,packedOpSnippet:LOGICAL_AND_PACKED,dtype:"bool"}),logicalAndConfig2={kernelName:LogicalAnd,backendName:"webgl",kernelFunc:logicalAnd3},LOGICAL_NOT="return float(!(x >= 1.0));",logicalNot3=unaryKernelFunc2({opSnippet:LOGICAL_NOT}),logicalNotConfig2={kernelName:LogicalNot,backendName:"webgl",kernelFunc:logicalNot3},LOGICAL_OR="return float(a >= 1.0 || b >= 1.0);",LOGICAL_OR_PACKED="\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",logicalOr3=binaryKernelFunc2({opSnippet:LOGICAL_OR,packedOpSnippet:LOGICAL_OR_PACKED,dtype:"bool"}),logicalOrConfig2={kernelName:LogicalOr,backendName:"webgl",kernelFunc:logicalOr3},LRNProgram=class{constructor(e,t,n,a,r){this.variableNames=["x"],this.outputShape=[];const s=t,o=e[3]-1;let i;this.outputShape=e;const l=`float(${n}) + float(${a}) * sum`;i=.5===r?`inversesqrt(${l})`:1===r?`1.0/(${l})`:`exp(log(${l}) * float(-${r}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${s}; j <= ${s}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${o}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${i};\n        setOutput(val);\n      }\n    `}},LRNPackedProgram=class{constructor(e,t,n,a,r){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const s=t,o=e[3]-1;let i;this.outputShape=e;const l=`float(${n}) + float(${a}) * sum`;i=.5===r?`inversesqrt(${l})`:1===r?`1.0/(${l})`:`exp(log(${l}) * float(-${r}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${s};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${s}; j <= ${s}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${o}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${i};\n        setOutput(result);\n      }\n    `}},lrn=e=>{const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{depthRadius:s,bias:o,alpha:i,beta:l}=a,u=env().getBool("WEBGL_PACK_NORMALIZATION")?new LRNPackedProgram(r.shape,s,o,i,l):new LRNProgram(r.shape,s,o,i,l);return n.runWebGLProgram(u,[r],r.dtype)},LRNConfig={kernelName:LRN,backendName:"webgl",kernelFunc:lrn},LRNGradProgram=class{constructor(e,t,n,a,r){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=a,this.beta=r,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${t})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${t} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${a}) * norm + float(${n});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${a})\n                * float(${r})\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${r});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}},lrnGrad=e=>{const{inputs:t,backend:n,attrs:a}=e,{x:r,y:s,dy:o}=t,{depthRadius:i,bias:l,alpha:u,beta:c}=a,d=new LRNGradProgram(r.shape,i,l,u,c);return n.runWebGLProgram(d,[r,s,o],r.dtype)},LRNGradConfig={kernelName:LRNGrad,backendName:"webgl",kernelFunc:lrnGrad};function maxImpl2(e,t,n,a){const r=util_exports.sizeFromShape(t),s=reshape4({inputs:{x:e},attrs:{shape:[util_exports.sizeFromShape(e.shape)/r,r]},backend:a}),o=reduce(s,e.dtype,"max",a),i=reshape4({inputs:{x:o},attrs:{shape:n},backend:a});return a.disposeIntermediateTensorInfo(s),a.disposeIntermediateTensorInfo(o),i}function max4(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{reductionIndices:s,keepDims:o}=a,i=r.shape.length,l=util_exports.parseAxisParam(s,r.shape);let u=l;const c=backend_util_exports.getAxesPermutation(u,i),d=null!=c,p=n.shouldExecuteOnCPU([r]);let h=r;if(d){if(p){const e=n.texData.get(h.dataId).values,t=new Array(i);for(let e=0;e<t.length;e++)t[e]=r.shape[c[e]];const a=transposeImplCPU(e,r.shape,r.dtype,c,t);h=n.makeTensorInfo(t,r.dtype);n.texData.get(h.dataId).values=a}else h=transposeImpl2(r,c,n);u=backend_util_exports.getInnerMostAxes(u.length,i)}backend_util_exports.assertAxesAreInnerMostDims("max",u,i);const[m,f]=backend_util_exports.computeOutAndReduceShapes(h.shape,u);let g,x=m;if(o&&(x=backend_util_exports.expandShapeToKeepDim(m,l)),p){const e=n.texData.get(h.dataId).values,t=maxImplCPU(e,util_exports.sizeFromShape(f),x,r.dtype);g=n.makeTensorInfo(x,r.dtype);n.texData.get(g.dataId).values=t}else g=maxImpl2(h,f,x,n);return d&&n.disposeIntermediateTensorInfo(h),g}var maxConfig2={kernelName:Max,backendName:"webgl",kernelFunc:max4},MAXIMUM=CHECK_NAN_SNIPPET2+"\n  return max(a, b);\n",MAXIMUM_PACKED="\n  vec4 result = vec4(max(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  "+CHECK_NAN_SNIPPET3+"\n  return result;\n",maximum4=binaryKernelFunc2({opSnippet:MAXIMUM,packedOpSnippet:MAXIMUM_PACKED,cpuKernelImpl:maximumImplCPU}),maximumConfig2={kernelName:Maximum,backendName:"webgl",kernelFunc:maximum4};function maxPool3(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t;assertNotComplex2(r,"maxPool");const{filterSize:s,strides:o,pad:i,dimRoundingMode:l}=a;util_exports.assert(backend_util_exports.eitherStridesOrDilationsAreOne(o,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`));const u=backend_util_exports.computePool2DInfo(r.shape,s,o,1,i,l);if(1===u.filterWidth&&1===u.filterHeight&&util_exports.arraysEqual(u.inShape,u.outShape))return identity3({inputs:{x:r},backend:n});const c=new Pool2DProgram(u,"max",!1);return n.runWebGLProgram(c,[r],r.dtype)}var maxPoolConfig2={kernelName:MaxPool,backendName:"webgl",kernelFunc:maxPool3};function maxPool3d2(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:s,strides:o,pad:i,dataFormat:l,dimRoundingMode:u}=a,c=backend_util_exports.computePool3DInfo(r.shape,s,o,[1,1,1],i,u,l),d=new Pool3DProgram(c,"max",!1);return n.runWebGLProgram(d,[r],r.dtype)}var maxPool3DConfig2={kernelName:MaxPool3D,backendName:"webgl",kernelFunc:maxPool3d2},MaxPool2DBackpropProgram=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideHeight,n=e.strideWidth,a=e.dilationHeight,r=e.effectiveFilterHeight,s=e.effectiveFilterWidth,o=r-1-e.padInfo.top,i=s-1-e.padInfo.left,l=r*s-1;this.userCode=`\n      const ivec2 pads = ivec2(${o}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${r};\n          wR += ${a}) {\n          float dyR = float(dyRCorner + wR) / ${t}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${s}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${n}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${l} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${s} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},MaxPool3DBackpropProgram=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideDepth,n=e.strideHeight,a=e.strideWidth,r=e.dilationDepth,s=e.dilationHeight,o=e.dilationWidth,i=e.effectiveFilterDepth,l=e.effectiveFilterHeight,u=e.effectiveFilterWidth,c=i-1-e.padInfo.front,d=l-1-e.padInfo.top,p=u-1-e.padInfo.left,h=i*l*u-1;this.userCode=`\n      const ivec3 pads = ivec3(${c}, ${d}, ${p});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${i};\n           wD += ${r}) {\n          float dyD = float(dyDCorner + wD) / ${t}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${l};\n              wR += ${s}) {\n            float dyR = float(dyRCorner + wR) / ${n}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${u};\n                wC += ${o}) {\n              float dyC = float(dyCCorner + wC) / ${a}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${h} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${l} * ${u} +\n                  wR * ${u} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}};function maxPool3DGrad2(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,o=s,{filterSize:i,strides:l,pad:u,dimRoundingMode:c}=a,d=backend_util_exports.computePool3DInfo(o.shape,i,l,[1,1,1],u,c),p=new Pool3DProgram(d,"max",!0),h=n.runWebGLProgram(p,[o],o.dtype),m=new MaxPool3DBackpropProgram(d),f=n.runWebGLProgram(m,[r,h],o.dtype);return n.disposeIntermediateTensorInfo(h),f}var maxPoolGrad3DConfig={kernelName:MaxPool3DGrad,backendName:"webgl",kernelFunc:maxPool3DGrad2};function maxPoolGrad3(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s,output:o}=t,i=s;assertNotComplex2([s,o],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:d}=a,p=backend_util_exports.computePool2DInfo(i.shape,l,u,1,c,d),h=new Pool2DProgram(p,"max",!0),m=n.runWebGLProgram(h,[i],i.dtype),f=new MaxPool2DBackpropProgram(p),g=n.runWebGLProgram(f,[r,m],i.dtype);return n.disposeIntermediateTensorInfo(m),g}var maxPoolGradConfig3={kernelName:MaxPoolGrad,backendName:"webgl",kernelFunc:maxPoolGrad3};function maxPoolWithArgmaxImpl2(e,t,n,a){let r=new Pool2DProgram(n,"max",!1);const s=a.runWebGLProgram(r,[e],"float32");r=new Pool2DProgram(n,"max",!0,!0,t);return[s,a.runWebGLProgram(r,[e],"float32")]}var maxPoolWithArgmaxConfig2={kernelName:MaxPoolWithArgmax,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:a}=e,{filterSize:r,strides:s,pad:o,includeBatchInIndex:i}=t,l=n;util_exports.assert(4===a.shape.length,(()=>`Error in maxPool: input must be rank 4 but got rank ${a.shape.length}.`));const u=[1,1];util_exports.assert(backend_util_exports.eitherStridesOrDilationsAreOne(s,u),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${s} and dilations '${u}'`));const c=backend_util_exports.computePool2DInfo(a.shape,r,s,u,o),[d,p]=maxPoolWithArgmaxImpl2(a,i,c,l);return[d,p]}};function meanImpl(e,t,n,a){const r=util_exports.sizeFromShape(t),s=reshape4({inputs:{x:e},attrs:{shape:[util_exports.sizeFromShape(e.shape)/r,r]},backend:a}),o=reduce(s,"float32","mean",a),i=reshape4({inputs:{x:o},attrs:{shape:n},backend:a});return a.disposeIntermediateTensorInfo(s),a.disposeIntermediateTensorInfo(o),i}var meanConfig2={kernelName:Mean,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:a}=e,{keepDims:r,axis:s}=t,o=n,i=a.shape.length,l=util_exports.parseAxisParam(s,a.shape);let u=l;const c=backend_util_exports.getAxesPermutation(u,i),d=null!=c,p=o.shouldExecuteOnCPU([a]),h=[];let m=a;if(d){if(p){const e=o.texData.get(m.dataId).values,t=new Array(i);for(let e=0;e<t.length;e++)t[e]=a.shape[c[e]];const n=transposeImplCPU(e,a.shape,a.dtype,c,t);m=o.makeTensorInfo(t,a.dtype);o.texData.get(m.dataId).values=n}else m=transposeImpl2(a,c,o);h.push(m),u=backend_util_exports.getInnerMostAxes(u.length,i)}backend_util_exports.assertAxesAreInnerMostDims("sum",u,i);const[f,g]=backend_util_exports.computeOutAndReduceShapes(m.shape,u);let x=f;r&&(x=backend_util_exports.expandShapeToKeepDim(f,l));const y=meanImpl(m,g,x,o);for(const e of h)o.disposeIntermediateTensorInfo(e);return y}};function min4(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:o}=a,i=r.shape.length,l=util_exports.parseAxisParam(s,r.shape);let u=l;const c=backend_util_exports.getAxesPermutation(u,i);let d=r;null!=c&&(d=transpose3({inputs:{x:r},backend:n,attrs:{perm:c}}),u=backend_util_exports.getInnerMostAxes(u.length,r.shape.length)),backend_util_exports.assertAxesAreInnerMostDims("min",u,i);const[p,h]=backend_util_exports.computeOutAndReduceShapes(d.shape,u),m=reshape4({inputs:{x:d},backend:n,attrs:{shape:[-1,util_exports.sizeFromShape(h)]}}),f=reduce(m,m.dtype,"min",n);let g;if(o){g=reshape4({inputs:{x:f},backend:n,attrs:{shape:backend_util_exports.expandShapeToKeepDim(p,l)}})}else g=reshape4({inputs:{x:f},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(f),null!=c&&n.disposeIntermediateTensorInfo(d),g}var minConfig2={kernelName:Min,backendName:"webgl",kernelFunc:min4},MINIMUM=CHECK_NAN_SNIPPET2+"\n  return min(a, b);\n",MINIMUM_PACKED="\n  vec4 result = vec4(min(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  "+CHECK_NAN_SNIPPET3+"\n  return result;\n",minimum4=binaryKernelFunc2({opSnippet:MINIMUM,packedOpSnippet:MINIMUM_PACKED,cpuKernelImpl:minimumImplCPU}),minimumConfig2={kernelName:Minimum,backendName:"webgl",kernelFunc:minimum4},MirrorPadProgram=class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const a=e.length,r=getCoordsDataType(a),s=t.map((e=>e[0])).join(","),o=t.map(((t,n)=>t[0]+e[n])).join(","),i=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,a),l="reflect"===n?0:1;this.userCode=1!==a?`\n      ${r} start = ${r}(${s});\n      ${r} end = ${r}(${o});\n\n      void main() {\n        ${r} outC = getOutputCoords();\n        for (int i = 0; i < ${a}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${l};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${l};\n          }\n        }\n        ${r} coords = outC - start;\n        setOutput(getX(${i}));\n      }\n    `:`\n        int start = ${s};\n        int end = ${o};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${l};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${l};\n          }\n          setOutput(getX(outC - start));\n        }\n      `}},MirrorPadPackedProgram=class{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const a=e.length,r=getCoordsDataType(a),s=t.map((e=>e[0])).join(","),o=t.map(((t,n)=>t[0]+e[n])).join(","),i=getChannels("rc",a),l=getChannels("source",a),u=`${i[a-1]} < ${this.outputShape[a-1]}`,c=1===a?"source":`vec2(${l.slice(-2).join()})`,d="reflect"===n?0:1;let p="";if(1===a){const e=`\n        ${r} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${d};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${d};\n        }\n        source -= start;\n      `;p=`\n        ${r} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${l.join()}), ${c});\n        ${i[a-1]} += 1;\n        if(${u}) {\n          ${e}\n          result[1] = getChannel(getX(${l.join()}), ${c});\n        }\n      `}else{const e=`\n        ${r} source = rc;\n        ${r} lt = ${r}(lessThan(source, start));\n        ${r} gte = ${r}(greaterThanEqual(source, end));\n        ${r} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${d}) +\n                gte * ((end - 1) * 2 - source + ${d});\n        source -= start;\n      `;p=`\n        ${r} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${l.join()}), ${c});\n        ${i[a-1]} += 1;\n        if(${u}) {\n          ${e}\n          result[1] = getChannel(getX(${l.join()}), ${c});\n        }\n        rc = outputLoc;\n        ${i[a-2]} += 1;\n        if(${i[a-2]} < ${this.outputShape[a-2]}) {\n          ${e}\n          result[2] = getChannel(getX(${l.join()}), ${c});\n          ${i[a-1]} += 1;\n          if(${u}) {\n            ${e}\n            result[3] = getChannel(getX(${l.join()}), ${c});\n          }\n        }\n      `}this.userCode=`\n      const ${r} start = ${r}(${s});\n      const ${r} end = ${r}(${o});\n\n      void main() {\n        ${r} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${p}\n        setOutput(result);\n      }\n    `}},mirrorPadKernelFunc=({inputs:e,backend:t,attrs:n})=>{const{x:a}=e,{paddings:r,mode:s}=n,o=env().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new MirrorPadPackedProgram(a.shape,r,s):new MirrorPadProgram(a.shape,r,s);return t.runWebGLProgram(o,[a],a.dtype)},mirrorPadConfig2={kernelName:MirrorPad,backendName:"webgl",kernelFunc:mirrorPadKernelFunc},MOD="if (b == 0.0) return NAN;\n  return mod(a, b);",MOD_PACKED="\n  vec4 result = mod(a, b);\n  vec4 isNaN = vec4(equal(b, vec4(0.0)));\n  "+CHECK_NAN_SNIPPET3+"\n  return result;\n",mod3=binaryKernelFunc2({opSnippet:MOD,packedOpSnippet:MOD_PACKED}),modConfig2={kernelName:Mod,backendName:"webgl",kernelFunc:mod3},MultinomialProgram=class{constructor(e,t,n){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,n],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${t-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${t-1}));\n      }\n    `}},DIV="\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",DIV_PACKED="\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",realDiv=binaryKernelFunc2({opSnippet:DIV,packedOpSnippet:DIV_PACKED,checkOutOfBounds:!0}),realDivConfig2={kernelName:RealDiv,backendName:"webgl",kernelFunc:realDiv},SUB="return a - b;",sub3=binaryKernelFunc2({opSnippet:SUB,packedOpSnippet:SUB,supportsComplex:!0,cpuKernelImpl:subImplCPU}),subConfig2={kernelName:Sub,backendName:"webgl",kernelFunc:sub3};function softmax4(e){const{inputs:t,backend:n,attrs:a}=e,{logits:r}=t,{dim:s}=a,o=util_exports.parseAxisParam([s],r.shape),i=max4({inputs:{x:r},backend:n,attrs:{reductionIndices:o,keepDims:!1}}),l=backend_util_exports.expandShapeToKeepDim(i.shape,o),u=reshape4({inputs:{x:i},backend:n,attrs:{shape:l}}),c=sub3({inputs:{a:r,b:u},backend:n}),d=exp3({inputs:{x:c},backend:n}),p=sum4({inputs:{x:d},backend:n,attrs:{axis:o,keepDims:!1}}),h=reshape4({inputs:{x:p},backend:n,attrs:{shape:l}}),m=realDiv({inputs:{a:d,b:h},backend:n});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(h),m}var softmaxConfig2={kernelName:Softmax,backendName:"webgl",kernelFunc:softmax4};function multinomial3(e){const{inputs:t,backend:n,attrs:a}=e,{logits:r}=t,{numSamples:s,seed:o,normalized:i}=a,l=i?r:softmax4({inputs:{logits:r},backend:n,attrs:{dim:r.shape.length-1}}),u=l.shape[0],c=l.shape[1],d=new MultinomialProgram(u,c,s),p=[[o]],h=n.runWebGLProgram(d,[l],"int32",p);return i||n.disposeIntermediateTensorInfo(l),h}var multinomialConfig2={kernelName:Multinomial,backendName:"webgl",kernelFunc:multinomial3},NEG="return -x;";function neg3(e){const{inputs:t,backend:n}=e,{x:a}=t;if(n.shouldExecuteOnCPU([a])){const e=n.texData.get(a.dataId),[t,r]=negImplCPU(e.values,a.shape,a.dtype);return n.makeTensorInfo(r,a.dtype,t)}let r;return r=env().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new UnaryOpPackedProgram(a.shape,NEG):new UnaryOpProgram(a.shape,NEG),n.runWebGLProgram(r,[a],a.dtype)}var negConfig2={kernelName:Neg,backendName:"webgl",kernelFunc:neg3},nonMaxSuppressionV3Impl3=kernel_impls_exports.nonMaxSuppressionV3Impl;function nonMaxSuppressionV32(e){backend_util_exports.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:s}=t,{maxOutputSize:o,iouThreshold:i,scoreThreshold:l}=a,u=n.readSync(r.dataId),c=n.readSync(s.dataId),{selectedIndices:d}=nonMaxSuppressionV3Impl3(u,c,o,i,l);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}var nonMaxSuppressionV3Config2={kernelName:NonMaxSuppressionV3,backendName:"webgl",kernelFunc:nonMaxSuppressionV32},nonMaxSuppressionV4Impl3=kernel_impls_exports.nonMaxSuppressionV4Impl;function nonMaxSuppressionV42(e){backend_util_exports.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:s}=t,{maxOutputSize:o,iouThreshold:i,scoreThreshold:l,padToMaxOutputSize:u}=a,c=n.readSync(r.dataId),d=n.readSync(s.dataId),{selectedIndices:p,validOutputs:h}=nonMaxSuppressionV4Impl3(c,d,o,i,l,u);return[n.makeTensorInfo([p.length],"int32",new Int32Array(p)),n.makeTensorInfo([],"int32",new Int32Array([h]))]}var nonMaxSuppressionV4Config2={kernelName:NonMaxSuppressionV4,backendName:"webgl",kernelFunc:nonMaxSuppressionV42},nonMaxSuppressionV5Impl3=kernel_impls_exports.nonMaxSuppressionV5Impl;function nonMaxSuppressionV52(e){backend_util_exports.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:s}=t,{maxOutputSize:o,iouThreshold:i,scoreThreshold:l,softNmsSigma:u}=a,c=n.readSync(r.dataId),d=n.readSync(s.dataId),p=o,h=i,m=l,f=u,{selectedIndices:g,selectedScores:x}=nonMaxSuppressionV5Impl3(c,d,p,h,m,f);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([x.length],"float32",new Float32Array(x))]}var nonMaxSuppressionV5Config2={kernelName:NonMaxSuppressionV5,backendName:"webgl",kernelFunc:nonMaxSuppressionV52},OneHotProgram=class{constructor(e,t,n,a){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${a}), float(${n}),\n                      float(index == coords.y)));\n      }\n    `}},oneHot3=e=>{const{inputs:t,backend:n,attrs:a}=e,{indices:r}=t,{depth:s,onValue:o,offValue:i}=a,l=util_exports.sizeFromShape(r.shape),u=new OneHotProgram(l,s,o,i),c=reshape4({inputs:{x:r},backend:n,attrs:{shape:[l]}}),d=n.runWebGLProgram(u,[c],r.dtype);n.disposeIntermediateTensorInfo(c);const p=reshape4({inputs:{x:d},backend:n,attrs:{shape:[...r.shape,s]}});return n.disposeIntermediateTensorInfo(d),p},oneHotConfig2={kernelName:OneHot,backendName:"webgl",kernelFunc:oneHot3};function zerosLike3(e){const{inputs:t,backend:n}=e,{x:a}=t;if("complex64"===a.dtype){const e=real3({inputs:{input:a},backend:n}),t=zerosLike3({inputs:{x:e},backend:n}),r=imag3({inputs:{input:a},backend:n}),s=zerosLike3({inputs:{x:r},backend:n}),o=complex3({inputs:{real:t,imag:s},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(s),o}return fill3({attrs:{shape:a.shape,dtype:a.dtype,value:"string"===a.dtype?"":0},backend:n})}var zerosLikeConfig2={kernelName:ZerosLike,backendName:"webgl",kernelFunc:zerosLike3};function onesLike3(e){const{inputs:t,backend:n}=e,{x:a}=t;if("string"===a.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===a.dtype){const e=real3({inputs:{input:a},backend:n}),t=onesLike3({inputs:{x:e},backend:n}),r=imag3({inputs:{input:a},backend:n}),s=zerosLike3({inputs:{x:r},backend:n}),o=complex3({inputs:{real:t,imag:s},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(s),o}return fill3({attrs:{shape:a.shape,dtype:a.dtype,value:1},backend:n})}var onesLikeConfig2={kernelName:OnesLike,backendName:"webgl",kernelFunc:onesLike3};function pack2(e){const{inputs:t,backend:n,attrs:a}=e,{axis:r}=a;if(1===t.length)return expandDims4({inputs:{input:t[0]},backend:n,attrs:{dim:r}});const s=t[0].shape,o=t[0].dtype;t.forEach((e=>{util_exports.assertShapesMatch(s,e.shape,"All tensors passed to stack must have matching shapes"),util_exports.assert(o===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const i=[],l=concat3({inputs:t.map((e=>{const t=expandDims4({inputs:{input:e},backend:n,attrs:{dim:r}});return i.push(t),t})),backend:n,attrs:{axis:r}});return i.forEach((e=>n.disposeIntermediateTensorInfo(e))),l}var packConfig2={kernelName:Pack,backendName:"webgl",kernelFunc:pack2},PadProgram=class{constructor(e,t,n){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const a=e.length,r=getCoordsDataType(a),s=t.map((e=>e[0])).join(","),o=t.map(((t,n)=>t[0]+e[n])).join(","),i=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,a);this.userCode=1!==a?`\n      ${r} start = ${r}(${s});\n      ${r} end = ${r}(${o});\n\n      void main() {\n        ${r} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${r} coords = outC - start;\n          setOutput(getX(${i}));\n        }\n      }\n    `:`\n        int start = ${s};\n        int end = ${o};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}},PadPackedProgram=class{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const a=e.length,r=getCoordsDataType(a),s=t.map((e=>e[0])).join(","),o=t.map(((t,n)=>t[0]+e[n])).join(","),i=getChannels("rc",a),l=getChannels("source",a),u=`${i[a-1]} < ${this.outputShape[a-1]}`,c=1===a?"source":`vec2(${l.slice(-2).join()})`,d=[`${r} rc = outputLoc;`,`${i[a-1]} += 1;\n       if(${u}) {\n      `,1===a?"":`}\n       rc = outputLoc;\n       ${i[a-2]} += 1;\n       if(${i[a-2]} < ${this.outputShape[a-2]}) {`,1===a?"":`  ${i[a-1]} += 1;\n         if(${u}) {`],p=1===a?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let h="";for(let e=0,t=1===a?2:4;e<t;e++)h+=`\n        ${d[e]}\n        if (${p}) {\n          result[${e}] = float(value);\n        } else {\n          ${r} source = rc - start;\n          result[${e}] = getChannel(getX(${l.join()}), ${c});\n        }\n      `;h+=1===a?"} ":"}}",this.userCode=`\n      const ${r} start = ${r}(${s});\n      const ${r} end = ${r}(${o});\n\n      void main() {\n        ${r} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${h}\n        setOutput(result);\n      }\n    `}},padV22=e=>{const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{paddings:s,constantValue:o}=a;if(0===util_exports.sizeFromShape(r.shape)){return fill3({backend:n,attrs:{shape:s.map(((e,t)=>e[0]+r.shape[t]+e[1])),value:o,dtype:r.dtype}})}const i=env().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new PadPackedProgram(r.shape,s,o):new PadProgram(r.shape,s,o),l=[[o]];return n.runWebGLProgram(i,[r],r.dtype,l)},padV2Config2={kernelName:PadV2,backendName:"webgl",kernelFunc:padV22},POW="\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",POW_PACKED="\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));\n  "+CHECK_NAN_SNIPPET3+"\n  return result;\n",pow3=binaryKernelFunc2({opSnippet:POW,packedOpSnippet:POW_PACKED}),powConfig2={kernelName:Pow,backendName:"webgl",kernelFunc:pow3};function prod3(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:o}=a,i=r.shape.length,l=[],u=util_exports.parseAxisParam(s,r.shape);let c=u;const d=backend_util_exports.getAxesPermutation(c,i);let p,h=r;if(null!=d&&(h=transpose3({inputs:{x:r},backend:n,attrs:{perm:d}}),c=backend_util_exports.getInnerMostAxes(c.length,i),l.push(h)),backend_util_exports.assertAxesAreInnerMostDims("prod",c,i),n.shouldExecuteOnCPU([h])){const e=n.texData.get(h.dataId).values,{outVals:t,outShape:a,outDtype:r}=prodImplCPU(h.shape,h.dtype,e,c);p=n.makeTensorInfo(a,r,t)}else{const[e,t]=backend_util_exports.computeOutAndReduceShapes(h.shape,c),a=util_exports.sizeFromShape(t),s=reshape4({inputs:{x:h},backend:n,attrs:{shape:[-1,a]}}),o=reduce(s,sumOutType(r.dtype),"prod",n);p=reshape4({inputs:{x:o},backend:n,attrs:{shape:e}}),l.push(s),l.push(o)}if(o){l.push(p);const e=backend_util_exports.expandShapeToKeepDim(p.shape,u);p=reshape4({inputs:{x:p},backend:n,attrs:{shape:e}})}return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),p}var prodConfig2={kernelName:Prod,backendName:"webgl",kernelFunc:prod3},range4=e=>{const{backend:t,attrs:n}=e,{start:a,stop:r,step:s,dtype:o}=n,i=rangeImplCPU(a,r,s,o);return t.makeTensorInfo([i.length],o,i)},rangeConfig2={kernelName:Range,backendName:"webgl",kernelFunc:range4},RECIPROCAL="return 1.0 / x;",reciprocal3=unaryKernelFunc2({opSnippet:RECIPROCAL}),reciprocalConfig2={kernelName:Reciprocal,backendName:"webgl",kernelFunc:reciprocal3},RELU3=CHECK_NAN_SNIPPET+"\n  return (x < 0.0) ? 0.0 : x;\n",RELU_PACKED="\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",relu3=unaryKernelFunc2({opSnippet:RELU3,packedOpSnippet:RELU_PACKED}),reluConfig2={kernelName:Relu,backendName:"webgl",kernelFunc:relu3},RELU63=CHECK_NAN_SNIPPET+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",RELU6_PACKED="\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",relu63=unaryKernelFunc2({opSnippet:RELU63,packedOpSnippet:RELU6_PACKED}),relu6Config2={kernelName:Relu6,backendName:"webgl",kernelFunc:relu63},ResizeBilinearProgram=class{constructor(e,t,n,a,r){this.variableNames=["A"],this.outputShape=[];const[s,o,i,l]=e;this.outputShape=[s,t,n,l];const u=[a&&t>1?o-1:o,a&&n>1?i-1:i],c=[a&&t>1?t-1:t,a&&n>1?n-1:n];let d;d=r?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]});\n      const vec2 inputShapeRC = vec2(${o}.0, ${i}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${d};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}},ResizeBilinearPackedProgram=class{constructor(e,t,n,a,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[s,o,i,l]=e;this.outputShape=[s,t,n,l];const u=[a&&t>1?o-1:o,a&&n>1?i-1:i],c=[a&&t>1?t-1:t,a&&n>1?n-1:n];let d;d=r?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]},\n          ${u[1]/c[1]});\n      const vec3 inputShapeRC = vec3(${o}.0, ${i}.0,\n                                     ${i}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${d};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${l-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}};function resizeBilinear3(e){const{inputs:t,backend:n,attrs:a}=e,{images:r}=t,{alignCorners:s,halfPixelCenters:o,size:i}=a,[l,u]=i,c=env().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new ResizeBilinearPackedProgram(r.shape,l,u,s,o):new ResizeBilinearProgram(r.shape,l,u,s,o);return n.runWebGLProgram(c,[r],"float32")}var resizeBilinearConfig2={kernelName:ResizeBilinear,backendName:"webgl",kernelFunc:resizeBilinear3},ResizeBilinearBackpropProgram=class{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,a,r]=t,[,s,o]=e,i=[n&&s>1?a-1:a,n&&o>1?r-1:r],l=[n&&s>1?s-1:s,n&&o>1?o-1:o],u=i[0]/l[0],c=i[1]/l[1],d=1/u,p=1/c,h=2*Math.ceil(d)+2,m=2*Math.ceil(p)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${d});\n        const float invWidthScale = float(${p});\n\n        const int winHeight = int(${h});\n        const int winWidth = int(${m});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${s}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${o}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${a-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${r-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}};function resizeBilinearGrad2(e){const{inputs:t,backend:n,attrs:a}=e,{images:r,dy:s}=t,{alignCorners:o}=a,i=new ResizeBilinearBackpropProgram(s.shape,r.shape,o);return n.runWebGLProgram(i,[s],s.dtype)}var resizeBilinearGradConfig3={kernelName:ResizeBilinearGrad,backendName:"webgl",kernelFunc:resizeBilinearGrad2},ResizeNearestNeighborProgram=class{constructor(e,t,n,a,r){this.variableNames=["A"],this.outputShape=[];const[s,o,i,l]=e;this.outputShape=[s,t,n,l];const u=[a&&t>1?o-1:o,a&&n>1?i-1:i],c=[a&&t>1?t-1:t,a&&n>1?n-1:n],d=a?"0.5":"0.0";let p;p=r?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]});\n      const vec2 inputShapeRC = vec2(${o}.0, ${i}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${p};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}},ResizeNearestNeighborPackedProgram=class{constructor(e,t,n,a,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[s,o,i,l]=e;this.outputShape=[s,t,n,l];const u=[a&&t>1?o-1:o,a&&n>1?i-1:i],c=[a&&t>1?t-1:t,a&&n>1?n-1:n],d=a?"0.5":"0.0";let p;p=r?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]},\n          ${u[1]/c[1]});\n      const vec3 inputShapeRC = vec3(${o}.0, ${i}.0,\n                                     ${i}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${p};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${l-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    `}};function resizeNearestNeighbor3(e){const{inputs:t,backend:n,attrs:a}=e,{images:r}=t,{alignCorners:s,halfPixelCenters:o,size:i}=a,[l,u]=i,c=env().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new ResizeNearestNeighborPackedProgram(r.shape,l,u,s,o):new ResizeNearestNeighborProgram(r.shape,l,u,s,o);return n.runWebGLProgram(c,[r],r.dtype)}var resizeNearestNeighborConfig2={kernelName:ResizeNearestNeighbor,backendName:"webgl",kernelFunc:resizeNearestNeighbor3},ResizeNearestNeigborBackpropProgram=class{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,a,r]=t,[,s,o]=e,i=[n&&s>1?a-1:a,n&&o>1?r-1:r],l=[n&&s>1?s-1:s,n&&o>1?o-1:o],u=i[0]/l[0],c=i[1]/l[1],d=1/u,p=1/c,h=2*Math.ceil(d)+2,m=2*Math.ceil(p)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${d});\n        const float invWidthScale = float(${p});\n\n        const int winHeight = int(${h});\n        const int winWidth = int(${m});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${s}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${o}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${i[0]}) *\n                (float(dyR) / float(${l[0]}));\n\n            float sourceFracCol =\n                float(${i[1]}) *\n                  (float(dyC) / float(${l[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${a}) - 1),\n                ${n} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${r}) - 1),\n                ${n} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}};function resizeNearestNeighborGrad2(e){const{inputs:t,backend:n,attrs:a}=e,{images:r,dy:s}=t,{alignCorners:o}=a,i=new ResizeNearestNeigborBackpropProgram(s.shape,r.shape,o);return n.runWebGLProgram(i,[s],s.dtype)}var resizeNearestNeighborGradConfig3={kernelName:ResizeNearestNeighborGrad,backendName:"webgl",kernelFunc:resizeNearestNeighborGrad2},ReverseProgram=class{constructor(e,t){this.variableNames=["x"];const n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=e,1===n)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${e[0]} - coord - 1));\n        }\n      `);const a=e.map(((n,a)=>(n=>-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - coords[${n}] - 1`:`coords[${n}]`)(a))).join(","),r=getCoordsDataType(n);this.userCode=`\n      void main() {\n        ${r} coords = getOutputCoords();\n        setOutput(getX(${a}));\n      }\n    `}},ReversePackedProgram=class{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=e;const a=getChannels("rc",n),r=`${a[n-1]} + 1 < ${this.outputShape[n-1]}`,s=`${a[n-2]} + 1 < ${this.outputShape[n-2]}`,o=getCoordsDataType(n);var i;function l(n){const a=e.map(((a,r)=>function(n,a){return-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - ${a[n]} - 1`:`${a[n]}`}(r,n)));return`getChannel(getX(${a.join(",")}), vec2(${a.slice(-2).join(",")}))`}this.userCode=1===n?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${e[0]} - rc - 1),\n            ${e[0]} - rc - 1);\n          if(${r}){\n              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),\n                ${e[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${o} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${i=a.slice(),l(i)};\n          if(${r}){\n            result.g = ${function(e){return e[n-1]="("+e[n-1]+" + 1)",l(e)}(a.slice())};\n          }\n          if(${s}) {\n            result.b = ${function(e){return e[n-2]="("+e[n-2]+" + 1)",l(e)}(a.slice())};\n            if(${r}) {\n              result.a = ${function(e){return e[n-1]="("+e[n-1]+" + 1)",e[n-2]="("+e[n-2]+" + 1)",l(e)}(a.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}};function reverse3(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{dims:s}=a,o=r.shape.length,i=util_exports.parseAxisParam(s,r.shape);if(0===o)return identity3({inputs:{x:r},backend:n});const l=env().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new ReversePackedProgram(r.shape,i):new ReverseProgram(r.shape,i);return n.runWebGLProgram(l,[r],r.dtype)}var reverseConfig2={kernelName:Reverse,backendName:"webgl",kernelFunc:reverse3},RotateProgram=class{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const n=e[1],a=e[2];this.outputShape=e;let r="";r="number"==typeof t?`float outputValue = ${t.toFixed(2)};`:`\n        vec3 fill = vec3(${t.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${r}\n          if(coordX >= 0 && coordX < ${a} && coordY >= 0 && coordY < ${n}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}},rotateWithOffsetConfig2={kernelName:RotateWithOffset,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:a}=e,{radians:r,fillValue:s,center:o}=t,i=n,l=new RotateProgram(a.shape,s),[u,c]=backend_util_exports.getImageCenter(o,a.shape[1],a.shape[2]),d=[[u,c,Math.sin(r),Math.cos(r)]];return i.runWebGLProgram(l,[a],a.dtype,d)}},ROUND="\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n",round4=unaryKernelFunc2({opSnippet:ROUND}),roundConfig2={kernelName:Round,backendName:"webgl",kernelFunc:round4},RSQRT="return inversesqrt(x);",rsqrt3=unaryKernelFunc2({opSnippet:RSQRT,cpuKernelImpl:rsqrtImplCPU}),rsqrtConfig2={kernelName:Rsqrt,backendName:"webgl",kernelFunc:rsqrt3},ScatterProgram=class{constructor(e,t,n,a,r,s,o=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=s;const i=getCoordsDataType(r.length),l=getCoordsDataType(s.length);let u="";1===n?u="i":2===n&&(u="i, j");const c=`getIndices(${u})`;let d="";1===a?d="i":2===a&&(d="i, coords[1]");const p=`getUpdates(${d})`,h=t>1?"strides[j]":"strides";this.userCode=`\n        ${i} strides = ${i}(${r});\n\n        void main() {\n          ${l} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${e}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${t}; j++) {\n              int index = round(${c});\n              flattenedIndex += index * ${h};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ${p};\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      `}};function scatterNd2(e){const{inputs:t,backend:n,attrs:a}=e,{indices:r,updates:s}=t,{shape:o}=a,{sliceRank:i,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=backend_util_exports.calculateShapes(s,r,o),p=[d/u,u];if(0===d)return n.makeTensorInfo(o,r.dtype);const h=reshape4({inputs:{x:r},backend:n,attrs:{shape:[l,i]}}),m=reshape4({inputs:{x:s},backend:n,attrs:{shape:[l,u]}}),f=n.makeTensorInfo([],"float32",new Float32Array([0])),g=new ScatterProgram(l,i,h.shape.length,m.shape.length,c,p),x=n.runWebGLProgram(g,[m,h,f],m.dtype),y=reshape4({inputs:{x:x},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(f),y}var scatterNdConfig2={kernelName:ScatterNd,backendName:"webgl",kernelFunc:scatterNd2},SelectProgram=class{constructor(e,t,n){let a,r;if(this.variableNames=["c","a","b"],this.outputShape=t,n>4)throw Error(`Where for rank ${n} is not yet supported`);if(1===n)r="resRC",a="resRC";else{const n=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[],o=[];for(let a=0;a<t.length;a++)o.push(`${n[a]}`),a<e&&s.push(`${n[a]}`);a=s.join(),r=o.join()}const s=getCoordsDataType(n);this.userCode=`\n      void main() {\n        ${s} resRC = getOutputCoords();\n        float cVal = getC(${a});\n        if (cVal >= 1.0) {\n          setOutput(getA(${r}));\n        } else {\n          setOutput(getB(${r}));\n        }\n      }\n    `}};function select3(e){const{inputs:t,backend:n}=e,{condition:a,t:r,e:s}=t,o=new SelectProgram(a.shape.length,r.shape,r.shape.length);return n.runWebGLProgram(o,[a,r,s],upcastType(r.dtype,s.dtype))}var selectConfig2={kernelName:Select,backendName:"webgl",kernelFunc:select3},SELU=`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${backend_util_exports.SELU_SCALEALPHA};\n  float scale = ${backend_util_exports.SELU_SCALE};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`,selu3=unaryKernelFunc2({opSnippet:SELU}),seluConfig2={kernelName:Selu,backendName:"webgl",kernelFunc:selu3},SIGMOID3="return 1.0 / (1.0 + exp(-1.0 * x));",sigmoid3=unaryKernelFunc2({opSnippet:SIGMOID3,packedOpSnippet:SIGMOID3,cpuKernelImpl:sigmoidImplCPU}),sigmoidConfig2={kernelName:Sigmoid,backendName:"webgl",kernelFunc:sigmoid3},SIGN="\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n",sign3=unaryKernelFunc2({opSnippet:SIGN}),signConfig2={kernelName:Sign,backendName:"webgl",kernelFunc:sign3},SIN=CHECK_NAN_SNIPPET_UNARY+"\n  return sin(x);\n",sin3=unaryKernelFunc2({opSnippet:SIN}),sinConfig2={kernelName:Sin,backendName:"webgl",kernelFunc:sin3},SINH="\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n",sinh3=unaryKernelFunc2({opSnippet:SINH}),sinhConfig2={kernelName:Sinh,backendName:"webgl",kernelFunc:sinh3},SOFTPLUS="\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n",softplus3=unaryKernelFunc2({opSnippet:SOFTPLUS}),softplusConfig2={kernelName:Softplus,backendName:"webgl",kernelFunc:softplus3},spaceToBatchND3=e=>{const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:s,paddings:o}=a;util_exports.assert(r.shape.length<=4,(()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet"));const i=s.reduce(((e,t)=>e*t)),l=[[0,0]];l.push(...o);for(let e=1+s.length;e<r.shape.length;++e)l.push([0,0]);const u=[],c=padV22({inputs:{x:r},backend:n,attrs:{paddings:l,constantValue:0}}),d=backend_util_exports.getReshaped(c.shape,s,i,!1),p=backend_util_exports.getPermuted(d.length,s.length,!1),h=backend_util_exports.getReshapedPermuted(c.shape,s,i,!1),m=reshape4({inputs:{x:c},backend:n,attrs:{shape:d}}),f=transpose3({inputs:{x:m},backend:n,attrs:{perm:p}}),g=reshape4({inputs:{x:f},backend:n,attrs:{shape:h}});return u.push(c),u.push(m),u.push(f),u.forEach((e=>n.disposeIntermediateTensorInfo(e))),g},spaceToBatchNDConfig2={kernelName:SpaceToBatchND,backendName:"webgl",kernelFunc:spaceToBatchND3};function sparseFillEmptyRows3(e){const{inputs:t,backend:n}=e,{indices:a,values:r,denseShape:s,defaultValue:o}=t;if(1!==s.shape.length)throw new Error(`Dense shape must be a vector, saw:\n         ${s.shape}`);if(2!==a.shape.length)throw new Error(`Indices must be a matrix, saw:\n         ${a.shape}`);if(1!==r.shape.length)throw new Error(`Values must be a vector, saw:\n         ${r.shape}`);if(0!==o.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${o.shape}`);const i=n.readSync(a.dataId),l=n.readSync(r.dataId),u=n.readSync(s.dataId),c=n.readSync(o.dataId)[0],[d,p,h,m,f]=sparseFillEmptyRowsImplCPU(i,a.shape,a.dtype,l,r.dtype,u,c);return[n.makeTensorInfo(p,a.dtype,d),n.makeTensorInfo([p[0]],r.dtype,h),n.makeTensorInfo([m.length],"bool",new Uint8Array(m.map((e=>Number(e))))),n.makeTensorInfo([f.length],a.dtype,new Int32Array(f))]}var sparseFillEmptyRowsConfig2={kernelName:SparseFillEmptyRows,backendName:"webgl",kernelFunc:sparseFillEmptyRows3};function sparseReshape3(e){const{inputs:t,backend:n}=e,{inputIndices:a,inputShape:r,newShape:s}=t;if(2!==a.shape.length)throw new Error(`Input indices should be a matrix but received shape ${a.shape}`);if(1!==r.shape.length)throw new Error(`Input shape should be a vector but received shape ${r.shape}`);if(1!==s.shape.length)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);const o=Array.from(n.readSync(r.dataId)),i=n.readSync(a.dataId),l=Array.from(n.readSync(s.dataId)),[u,c,d]=sparseReshapeImplCPU(i,a.shape,a.dtype,o,l);return[n.makeTensorInfo(c,a.dtype,u),n.makeTensorInfo([d.length],s.dtype,new Int32Array(d))]}var sparseReshapeConfig2={kernelName:SparseReshape,backendName:"webgl",kernelFunc:sparseReshape3};function sparseSegmentMean3(e){const{inputs:t,backend:n}=e,{data:a,indices:r,segmentIds:s}=t;if(a.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error(`Indices should be a vector but received shape\n              ${r.shape}`);if(1!==s.shape.length)throw new Error(`Segment ids should be a vector but received shape\n              ${s.shape}`);const o=n.readSync(a.dataId),i=n.readSync(r.dataId),l=n.readSync(s.dataId),[u,c]=sparseSegmentReductionImplCPU(o,a.shape,a.dtype,i,l,!0);return n.makeTensorInfo(c,a.dtype,u)}var sparseSegmentMeanConfig2={kernelName:SparseSegmentMean,backendName:"webgl",kernelFunc:sparseSegmentMean3};function sparseSegmentSum3(e){const{inputs:t,backend:n}=e,{data:a,indices:r,segmentIds:s}=t;if(a.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error(`Indices should be a vector but received shape\n             ${r.shape}`);if(1!==s.shape.length)throw new Error(`Segment ids should be a vector but received shape\n             ${s.shape}`);const o=n.readSync(a.dataId),i=n.readSync(r.dataId),l=n.readSync(s.dataId),[u,c]=sparseSegmentReductionImplCPU(o,a.shape,a.dtype,i,l);return n.makeTensorInfo(c,a.dtype,u)}var sparseSegmentSumConfig2={kernelName:SparseSegmentSum,backendName:"webgl",kernelFunc:sparseSegmentSum3};function sparseToDense3(e){const{inputs:t,backend:n,attrs:a}=e,{sparseIndices:r,sparseValues:s,defaultValue:o}=t,{outputShape:i}=a,{sliceRank:l,numUpdates:u,strides:c,outputSize:d}=backend_util_exports.calculateShapes(s,r,i),p=new ScatterProgram(u,l,r.shape.length,s.shape.length,c,[d,1],!1),h=n.runWebGLProgram(p,[s,r,o],s.dtype),m=reshape4({inputs:{x:h},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(h),m}var sparseToDenseConfig2={kernelName:SparseToDense,backendName:"webgl",kernelFunc:sparseToDense3};function splitV2(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{numOrSizeSplits:s,axis:o}=a,i=util_exports.parseAxisParam(o,r.shape)[0],l=backend_util_exports.prepareSplitSize(r,s,i),u=r.shape.length,c=new Array(u).fill(0),d=r.shape.slice();return l.map((e=>{const t=[...d];t[i]=e;const a=slice3({inputs:{x:r},backend:n,attrs:{begin:c,size:t}});return c[i]+=e,a}))}var splitVConfig2={kernelName:SplitV,backendName:"webgl",kernelFunc:splitV2},SQRT="return sqrt(x);",sqrt3=unaryKernelFunc2({opSnippet:SQRT,packedOpSnippet:SQRT,cpuKernelImpl:sqrtImplCPU}),sqrtConfig2={kernelName:Sqrt,backendName:"webgl",kernelFunc:sqrt3},SQUARE="return x * x;",square3=unaryKernelFunc2({opSnippet:SQUARE}),squareConfig2={kernelName:Square,backendName:"webgl",kernelFunc:square3},SQUARED_DIFFERENCE="return (a - b) * (a - b);",squaredDifference3=binaryKernelFunc2({opSnippet:SQUARED_DIFFERENCE,packedOpSnippet:SQUARED_DIFFERENCE}),squaredDifferenceConfig2={kernelName:SquaredDifference,backendName:"webgl",kernelFunc:squaredDifference3};function step3({inputs:e,attrs:t,backend:n}){const{x:a}=e,r=CHECK_NAN_SNIPPET+`\n    return x > 0.0 ? 1.0 : float(${t.alpha});\n  `,s=new UnaryOpProgram(a.shape,r);return n.runWebGLProgram(s,[a],a.dtype)}var stepConfig2={kernelName:Step,backendName:"webgl",kernelFunc:step3},StridedSliceProgram=class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=n;const a=n.length,r=getCoordsDataType(n.length),s=getCoordsDataType(n.length);let o="";if(1===a)o="coords * strides + begin";else{let e=0;o=n.map(((t,a)=>(e++,1===n.length?`coords * strides[${a}] + begin[${a}]`:`coords[${e-1}] * strides[${a}] + begin[${a}]`))).join(",")}this.userCode=`\n      ${r} begin = ${r}(${e});\n      ${r} strides = ${r}(${t});\n\n      void main() {\n        ${s} coords = getOutputCoords();\n        setOutput(getX(${o}));\n      }\n    `}};function stridedSlice3(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{begin:s,end:o,strides:i,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:d,shrinkAxisMask:p}=a,{finalShapeSparse:h,finalShape:m,isIdentity:f,sliceDim0:g,isSimpleSlice:x,begin:y,end:A,strides:b}=slice_util_exports.sliceInfo(r.shape,s,o,i,l,u,c,d,p);let v;if(f)v=reshape4({inputs:{x:r},backend:n,attrs:{shape:m}});else if(g||x){util_exports.assert(r.shape.length>=1,(()=>`Input must have rank at least 1, got: ${r.shape.length}`));const e=slice_util_exports.computeOutShape(y,A,b),t=slice3({inputs:{x:r},backend:n,attrs:{begin:y,size:e}});v=reshape4({inputs:{x:t},backend:n,attrs:{shape:m}}),n.disposeIntermediateTensorInfo(t)}else{if(n.shouldExecuteOnCPU([r])){const e=n.readSync(r.dataId),t=buffer(r.shape,r.dtype,e),a=stridedSliceImplCPU(h,t,b,y);v=n.makeTensorInfo(m,r.dtype,a.values)}else{const e=new StridedSliceProgram(y,b,h);v=n.runWebGLProgram(e,[r],r.dtype)}}const k=reshape4({inputs:{x:v},backend:n,attrs:{shape:m}});return n.disposeIntermediateTensorInfo(v),k}var stridedSliceConfig2={kernelName:StridedSlice,backendName:"webgl",kernelFunc:stridedSlice3};function stringNGrams3(e){const{inputs:t,backend:n,attrs:a}=e,{separator:r,nGramWidths:s,leftPad:o,rightPad:i,padWidth:l,preserveShortSequences:u}=a,{data:c,dataSplits:d}=t,p=n.readSync(c.dataId),h=n.readSync(d.dataId),[m,f]=stringNGramsImplCPU(p,h,r,s,o,i,l,u);return[n.makeTensorInfo([m.length],"string",m),n.makeTensorInfo(d.shape,"int32",f)]}var stringNGramsConfig2={kernelName:StringNGrams,backendName:"webgl",kernelFunc:stringNGrams3};function stringSplit3(e){const{inputs:t,backend:n,attrs:a}=e,{skipEmpty:r}=a,{input:s,delimiter:o}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(1!==s.shape.length)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(0!==o.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const i=n.readSync(s.dataId),l=n.readSync(o.dataId)[0],[u,c,d]=stringSplitImplCPU(i,l,r),p=c.length;return[n.makeTensorInfo([p,2],"int32",u),n.makeTensorInfo([p],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(d))]}var stringSplitConfig2={kernelName:StringSplit,backendName:"webgl",kernelFunc:stringSplit3};function stringToHashBucketFast3(e){const{inputs:t,backend:n,attrs:a}=e,{numBuckets:r}=a,{input:s}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const o=n.readSync(s.dataId),i=stringToHashBucketFastImplCPU(o,r);return n.makeTensorInfo(s.shape,"int32",i)}var stringToHashBucketFastConfig2={kernelName:StringToHashBucketFast,backendName:"webgl",kernelFunc:stringToHashBucketFast3},TAN="return tan(x);",tan3=unaryKernelFunc2({opSnippet:TAN}),tanConfig2={kernelName:Tan,backendName:"webgl",kernelFunc:tan3},TANH="\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n",tanh4=unaryKernelFunc2({opSnippet:TANH}),tanhConfig2={kernelName:Tanh,backendName:"webgl",kernelFunc:tanh4},TileProgram=class{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let a=0;a<n.length;a++)n[a]=e[a]*t[a];this.outputShape=n,this.rank=n.length;const a=getCoordsDataType(this.rank),r=getSourceCoords3(e);this.userCode=`\n      void main() {\n        ${a} resRC = getOutputCoords();\n        setOutput(getA(${r}));\n      }\n    `}};function getSourceCoords3(e){const t=e.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(1===t)return`imod(resRC, ${e[0]})`;const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],a=[];for(let t=0;t<e.length;t++)a.push(`imod(${n[t]}, ${e[t]})`);return a.join()}function tile4(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{reps:s}=a;if("string"===r.dtype||r.shape.length>5){const e=n.readSync(r.dataId),t="string"===r.dtype?e.map((e=>util_exports.decodeString(e))):e,a=buffer(r.shape,r.dtype,t),o=tileImplCPU(a,s);return n.makeTensorInfo(o.shape,o.dtype,o.values)}const o=new TileProgram(r.shape,s);return n.runWebGLProgram(o,[r],r.dtype)}var tileConfig2={kernelName:Tile,backendName:"webgl",kernelFunc:tile4},SwapProgram=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}},MergeProgram=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}};function disposeIntermediateTensorInfoOrNull(e,t){null!==t&&e.disposeIntermediateTensorInfo(t)}function roundUpToPow2(e){let t=1;for(;t<e;)t*=2;return t}function topK2(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{k:s,sorted:o}=a,i=env().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=env().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),u=r.shape,c=u[u.length-1];if(n.shouldExecuteOnCPU([r])||c<i||s>l){const e=n.readSync(r.dataId),[t,a]=topKImplCPU(e,u,r.dtype,s,o);return[n.makeTensorInfo(t.shape,t.dtype,t.values),n.makeTensorInfo(a.shape,a.dtype,a.values)]}if(0===s)return u[u.length-1]=0,[n.makeTensorInfo(u,r.dtype,[]),n.makeTensorInfo(u,"int32",[])];if(1===c)return[r,fill3({attrs:{shape:u,dtype:"int32",value:0},backend:n})];const d=n.texData.get(r.dataId),p=null!==d&&d.isPacked,h=p?n.unpackTensor(r):r,m=util_exports.sizeFromShape(u)/c,f=reshape4({inputs:{x:h},attrs:{shape:[m,c]},backend:n});p&&disposeIntermediateTensorInfoOrNull(n,h);const g=roundUpToPow2(s),x=roundUpToPow2(c);let y=null;const A=()=>null===y?[f,f]:[f,y],b=(e,t,a)=>{const r=A(),s=new SwapProgram(a),o=[[c],[null===y?1:0],[Number.NEGATIVE_INFINITY],[e],[t]],i=y;y=n.runWebGLProgram(s,r,"int32",o),disposeIntermediateTensorInfoOrNull(n,i)};for(let e=1;e<g;e*=2){const t=2*e;for(let n=e;n>=1;n/=2)b(t,n,[m,x])}for(let e=x;e>g;e/=2){const t=A(),a=new MergeProgram([m,e/2]),r=[[c],[null===y?1:0],[g]],s=y;y=n.runWebGLProgram(a,t,"int32",r),disposeIntermediateTensorInfoOrNull(n,s);const o=g/2,i=2*o;for(let e=o;e>=1;e/=2)b(i,e,y.shape)}let v=y;y=slice3({inputs:{x:y},backend:n,attrs:{begin:0,size:[m,s]}}),disposeIntermediateTensorInfoOrNull(n,v);let k=gatherV22({inputs:{x:f,indices:y},backend:n,attrs:{axis:1,batchDims:1}});disposeIntermediateTensorInfoOrNull(n,f);const S=u.slice(0,-1);S.push(s),v=y,y=reshape4({inputs:{x:y},attrs:{shape:S},backend:n}),disposeIntermediateTensorInfoOrNull(n,v);const w=k;return k=reshape4({inputs:{x:k},attrs:{shape:S},backend:n}),disposeIntermediateTensorInfoOrNull(n,w),[k,y]}var topKConfig2={kernelName:TopK,backendName:"webgl",kernelFunc:topK2},TransformProgram=class{constructor(e,t,n,a,r,s){this.variableNames=["Image","Transforms"],this.outputShape=s;const o="nearest"===n?1:2;let i;switch(a){case"constant":default:i=1;break;case"reflect":i=2;break;case"wrap":i=3;break;case"nearest":i=4}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${i} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${i} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${i} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${r});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${r});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${t}));\n                float mapY = mapCoord(inY, float(${e}));\n\n                if (${o} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}};function transform3(e){const{inputs:t,backend:n,attrs:a}=e,{image:r,transforms:s}=t,{interpolation:o,fillMode:i,fillValue:l,outputShape:u}=a,[c,d,p,h]=r.shape,[m,f]=null!=u?u:[d,p],g=new TransformProgram(d,p,o,i,l,[c,m,f,h]);return n.runWebGLProgram(g,[r,s],"float32")}var transformConfig2={kernelName:Transform,backendName:"webgl",kernelFunc:transform3};function unique4(e){const{inputs:t,attrs:n,backend:a}=e,{axis:r}=n,{x:s}=t;assertNotComplex2(s,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const o=a.readSync(s.dataId),{outputValues:i,outputShape:l,indices:u}=uniqueImplCPU(o,r,s.shape,s.dtype);return[a.makeTensorInfo(l,s.dtype,i),a.makeTensorInfo([u.length],"int32",u)]}var uniqueConfig2={kernelName:Unique,backendName:"webgl",kernelFunc:unique4};function unpack2(e){const{inputs:t,backend:n,attrs:a}=e,{value:r}=t;let{axis:s}=a;s<0&&(s+=r.shape.length);const o=r,i=o.shape.length,l=r.shape[s],u=new Array(i-1);let c=0;for(let e=0;e<i;e++)e!==s&&(u[c++]=o.shape[e]);const d=[],p=new Array(i).fill(0),h=o.shape.slice();h[s]=1;const m=new Array(l);for(let e=0;e<m.length;e++){p[s]=e;const t=slice3({inputs:{x:o},backend:n,attrs:{begin:p,size:h}}),a=reshape4({inputs:{x:t},backend:n,attrs:{shape:u}});m[e]=a,d.push(t)}return d.forEach((e=>n.disposeIntermediateTensorInfo(e))),m}var unpackConfig2={kernelName:Unpack,backendName:"webgl",kernelFunc:unpack2},SegmentOpProgram=class{constructor(e,t){this.variableNames=["x","segmentIds"];const n=e.windowSize,a=e.batchSize,r=e.inSize,s=e.numSegments,o=s*Math.ceil(r/n);this.outputShape=[a,o];const i=4*Math.floor(n/4),l=n%4,u="\n        sumValue += dot(values, segFilter);\n    ";let c="";r%n>0&&(c=`\n        if (inIdx < 0 || inIdx >= ${r}) {\n          return initializationValue;\n        }\n      `);let d="";r%n>0&&(d=`\n        if (inIdx < 0 || inIdx >= ${r}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${c}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${d}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${s})) * float(${n}));\n        int currentSeg = int(mod(float(outIdx), float(${s})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${i}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${u}\n        }\n\n        int inIdx = inOffset + ${i};\n        if (${1===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${u}\n        } else if (${2===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${u}\n        } else if (${3===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${u}\n        }\n        setOutput(sumValue);\n      }\n    `}};function unsortedSegmentSum3(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,segmentIds:s}=t,{numSegments:o}=a,i=r.shape.length,l=[];let u=0;const c=backend_util_exports.getAxesPermutation([u],i);let d=r;null!=c&&(d=transpose3({inputs:{x:r},backend:n,attrs:{perm:c}}),l.push(d),u=backend_util_exports.getInnerMostAxes(1,i)[0]);const p=backend_util_exports.segment_util.computeOutShape(d.shape,u,o),h=util_exports.sizeFromShape([d.shape[u]]),m=reshape4({inputs:{x:d},backend:n,attrs:{shape:[-1,h]}});l.push(m);const f=sumOutType(r.dtype),g=(e,t,a,r,s)=>{const o=e.shape[0],i=e.shape[1],u=backend_util_exports.segment_util.segOpComputeOptimalWindowSize(i,s),c=new SegmentOpProgram({windowSize:u,inSize:i,batchSize:o,numSegments:s},t),d=n.compileAndRun(c,[e,a],r);if(l.push(d),d.shape[1]===s)return d;const p=range4({backend:n,attrs:{start:0,stop:s,step:1,dtype:"float32"}}),h=tile4({inputs:{x:p},backend:n,attrs:{reps:[i/u]}});l.push(p),l.push(h);return g(d,t,h,r,s)},x=reshape4({inputs:{x:g(m,"unsortedSegmentSum",s,f,o)},backend:n,attrs:{shape:p}});let y=x;if(null!=c){l.push(x);const e=backend_util_exports.getUndoAxesPermutation(c);y=transpose3({inputs:{x:y},backend:n,attrs:{perm:e}})}return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),y}var unsortedSegmentSumConfig2={kernelName:UnsortedSegmentSum,backendName:"webgl",kernelFunc:unsortedSegmentSum3},kernelConfigs2=[LRNConfig,LRNGradConfig,_fusedMatMulConfig2,absConfig2,acosConfig2,acoshConfig2,addConfig2,addNConfig2,allConfig2,anyConfig2,argMaxConfig2,argMinConfig2,asinConfig2,asinhConfig2,atan2Config2,atanConfig2,atanhConfig2,avgPool3DConfig2,avgPoolConfig2,avgPoolGrad3DConfig,avgPoolGradConfig3,batchMatMulConfig2,batchNormConfig2,batchToSpaceNDConfig2,bincountConfig2,broadcastArgsConfig2,castConfig2,ceilConfig2,clipByValueConfig,complexAbsConfig2,complexConfig2,concatConfig2,conv2DBackpropFilterConfig2,conv2DBackpropInputConfig2,conv2DConfig2,conv3DBackpropFilterV2Config2,conv3DBackpropInputConfig,conv3DConfig2,cosConfig2,coshConfig2,cropAndResizeConfig2,cumsumConfig2,denseBincountConfig2,depthToSpaceConfig2,depthwiseConv2dNativeBackpropFilterConfig2,depthwiseConv2dNativeBackpropInputConfig2,depthwiseConv2dNativeConfig2,diagConfig2,dilation2DConfig,einsumConfig2,eluConfig2,eluGradConfig3,equalConfig2,erfConfig2,expConfig2,expandDimsConfig2,expm1Config2,fftConfig2,fillConfig2,flipLeftRightConfig2,floorConfig2,floorDivConfig2,fromPixelsConfig,fusedConv2DConfig2,fusedDepthwiseConv2DConfig2,gatherNdConfig2,gatherV2Config2,greaterConfig2,greaterEqualConfig2,identityConfig2,ifftConfig2,imagConfig2,isFiniteConfig2,isInfConfig2,isNaNConfig2,leakyReluConfig2,lessConfig2,lessEqualConfig2,linSpaceConfig2,log1pConfig2,logConfig2,logicalAndConfig2,logicalNotConfig2,logicalOrConfig2,maxConfig2,maxPool3DConfig2,maxPoolConfig2,maxPoolGrad3DConfig,maxPoolGradConfig3,maxPoolWithArgmaxConfig2,maximumConfig2,meanConfig2,minConfig2,minimumConfig2,mirrorPadConfig2,modConfig2,multinomialConfig2,multiplyConfig2,negConfig2,nonMaxSuppressionV3Config2,nonMaxSuppressionV4Config2,nonMaxSuppressionV5Config2,notEqualConfig2,oneHotConfig2,onesLikeConfig2,packConfig2,padV2Config2,powConfig2,preluConfig2,prodConfig2,rangeConfig2,realConfig2,realDivConfig2,reciprocalConfig2,relu6Config2,reluConfig2,reshapeConfig2,resizeBilinearConfig2,resizeBilinearGradConfig3,resizeNearestNeighborConfig2,resizeNearestNeighborGradConfig3,reverseConfig2,rotateWithOffsetConfig2,roundConfig2,rsqrtConfig2,scatterNdConfig2,selectConfig2,seluConfig2,sigmoidConfig2,signConfig2,sinConfig2,sinhConfig2,sliceConfig2,softmaxConfig2,softplusConfig2,spaceToBatchNDConfig2,sparseFillEmptyRowsConfig2,sparseReshapeConfig2,sparseSegmentMeanConfig2,sparseSegmentSumConfig2,sparseToDenseConfig2,splitVConfig2,sqrtConfig2,squareConfig2,squaredDifferenceConfig2,stepConfig2,stridedSliceConfig2,stringNGramsConfig2,stringSplitConfig2,stringToHashBucketFastConfig2,subConfig2,sumConfig2,tanConfig2,tanhConfig2,tileConfig2,topKConfig2,transformConfig2,transposeConfig2,uniqueConfig2,unpackConfig2,unsortedSegmentSumConfig2,zerosLikeConfig2];for(const e of kernelConfigs2)registerKernel(e);var ENV5=env();function symbolicallyComputeStrides2(e,t){if(Math.max(...e)>3)throw new Error("Cannot symbolically compute strides for rank > 4 tensor.");const n=e.length,a=e.map((e=>`${t}[${e}]`)),r=new Array(n-1);r[n-2]=a[n-1];for(let e=n-3;e>=0;--e)r[e]=`(${r[e+1]} * ${a[e+1]})`;return r}function getCoordsDataType2(e){if(e<=1)return"i32";if(2===e)return"vec2<i32>";if(3===e)return"vec3<i32>";if(4===e)return"vec4<i32>";throw Error(`GPU for rank ${e} is not yet supported`)}function mapToWgslTypes(e,t){return"float32"===e?t?"vec4<f32>":"f32":"int32"===e||"bool"===e?t?"vec4<i32>":"i32":e}function getWorkGroupSizeString(){return"\n  [[stage(compute), workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)]]\n"}function getFlatDispatchLayoutMainHeaderString(){return`\n  ${getWorkGroupSizeString()}\n  fn main([[builtin(local_invocation_id)]] localId : vec3<u32>,\n          [[builtin(global_invocation_id)]] globalId : vec3<u32>,\n          [[builtin(num_workgroups)]] numWorkgroups: vec3<u32>)\n`}function getNonFlatDispatchLayoutMainHeaderString(){return`\n  ${getWorkGroupSizeString()}\n  fn main([[builtin(local_invocation_id)]] localId : vec3<u32>,\n          [[builtin(global_invocation_id)]] globalId : vec3<u32>)\n`}function getMainHeaderAndGlobalIndexString(){return`\n    ${getFlatDispatchLayoutMainHeaderString()} {\n      let index = getGlobalIndex(globalId, localId, numWorkgroups);\n`}function makeShader2(e,t,n,a=!1){const r=`\n    let workGroupSizeX = ${n.workGroupSize[0]}u;\n    let workGroupSizeY = ${n.workGroupSize[1]}u;\n    let workGroupSizeZ = ${n.workGroupSize[2]}u;`;if(!0===a){const e=generateGetCoordsFromFlatIndex(t.shape),a=`\n      [[block]] struct Matrix0 {\n        numbers: array<${mapToWgslTypes(t.dtype,n.isVec4)}>;\n      };\n      [[block]] struct Uniform {\n        size            : i32;\n        numChannels     : i32;\n        outShapeStrides : vec2<i32>;\n        dispatchSize    : vec3<u32>;\n      };\n\n      [[group(0), binding(0)]] var<storage, write> result : Matrix0;\n      [[group(0), binding(2)]] var<uniform> uniforms: Uniform;\n    `;return[SHADER_PREFIX,a,r,SAMPLING_SNIPPETS,e,n.getUserCode()].join("\n")}const s=[];let o="[[block]] struct Uniforms { NAN : f32; ";n.variableNames.forEach(((t,n)=>{o+=`${t.charAt(0).toLowerCase()+t.slice(1)}Shape : ${getCoordsDataType2(e[n].shape.length)}; `})),o+=`outShape : ${getCoordsDataType2(t.shape.length)} ; `;const i=t.shape.length-1;o+=`\n       outShapeStrides: ${getCoordsDataType2(i)}; `,n.size&&(o+="size : i32; "),n.uniforms&&(o+=n.uniforms),o+="};",s.push(o),n.atomic?s.push("\n    [[block]] struct Matrix0 {\n        numbers: array<atomic<i32>>;\n    };\n\n    [[group(0), binding(0)]] var<storage, read_write> result : Matrix0;\n  "):s.push(`\n    [[block]] struct Matrix0 {\n        numbers: array<${mapToWgslTypes(t.dtype,n.isVec4)}>;\n    };\n\n    [[group(0), binding(0)]] var<storage, write> result : Matrix0;\n  `),n.variableNames.forEach(((t,a)=>{s.push(`\n    [[block]] struct Matrix${1+a} {\n      numbers: array<${mapToWgslTypes(e[a].dtype,n.isVec4)}>;\n    };\n    [[group(0), binding(${1+a})]] var<storage, read> ${t} : Matrix${1+a};\n    `)})),""!==o&&s.push(`\n    [[group(0), binding(${1+n.variableNames.length})]] var<uniform> uniforms : Uniforms;\n    `),s.push(r);const[l,u]=generateGetOutputCoords(t.shape,n.dispatchLayout),c=generateGetCoordsFromFlatIndex(t.shape),d=[SHADER_PREFIX,s.join("\n"),SAMPLING_SNIPPETS,c,l,getOutputFlatIndexSnippet(t.shape.length)];if(n.atomic||d.push(getSetOutputSnippet(t.shape,t.dtype,n.isVec4)),u===t.shape.length){const a=e.map((e=>getInputSamplingSnippet2(e,t.shape,n.isVec4,n.dispatchLayout.x.length===t.shape.length))).join("\n");d.push(a)}d.push(n.getUserCode());return d.join("\n")}ENV5.registerFlag("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE",(()=>15)),ENV5.registerFlag("WEBGPU_CPU_FORWARD",(()=>!0)),ENV5.registerFlag("WEBGPU_MATMUL_WORK_PER_THREAD",(()=>4)),ENV5.registerFlag("WEBGPU_USE_NAIVE_CONV2D",(()=>!1)),ENV5.registerFlag("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE",(()=>!1)),ENV5.registerFlag("WEBGPU_CONV_SEPARATE_IM2COL_SHADER",(()=>!1)),ENV5.registerFlag("WEBGPU_USE_LOW_POWER_GPU",(()=>!1)),ENV5.registerFlag("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD",(()=>1e3)),ENV5.registerFlag("WEBGPU_USE_PROFILE_TOOL",(()=>!1)),ENV5.registerFlag("WEBGPU_USE_IMPORT",(()=>!1));var SHADER_PREFIX="\n  fn idiv(a: i32, b: i32, sign: f32) -> i32 {\n    var res: i32 = a / b;\n    let mod: i32 = a % b;\n    if (sign < 0. && mod != 0) {\n      res = res - 1;\n    }\n    return res;\n  }\n\n  fn isNanCustom(val : f32) -> bool {\n    if (val > 0.0) {\n      return false;\n    }\n    if (val < 0.0) {\n      return false;\n    }\n    if (val == 0.0) {\n      return false;\n    }\n    return true;\n  }\n\n  fn isNanCustomVec4F32(val : vec4<f32>) -> vec4<f32> {\n    var res = vec4<f32> (0.0);\n    for (var i = 0u; i < 4u; i = i + 1u) {\n      if (isNanCustom(val[i])) {\n        res[i] = 1.0;\n      } else {\n        res[i] = 0.0;\n      }\n    }\n    return res;\n  }\n\n  // Checks whether coordinates lie within the bounds of the shape.\n  fn coordsInBounds4D(coord : vec4<i32>, shape : vec4<i32>) -> bool {\n    return all(coord >= vec4<i32>(0)) &&\n        all(coord < shape);\n  }\n\n  fn coordsInBounds3D(coord : vec3<i32>, shape : vec3<i32>) -> bool {\n    return all(coord >= vec3<i32>(0)) &&\n        all(coord < shape);\n  }\n\n  fn coordsInBounds2D(coord : vec2<i32>, shape : vec2<i32>) -> bool {\n    return all(coord >= vec2<i32>(0)) &&\n        all(coord < shape);\n  }\n  ",SAMPLING_SNIPPETS="\n  fn getFlatIndex1D(coord : i32, shape : i32) -> i32 {\n    return coord;\n  }\n\n  fn getFlatIndex2D(coords : vec2<i32>, shape : vec2<i32>) -> i32 {\n    return i32(dot(vec2<f32>(coords), vec2<f32>(f32(shape.y), 1.0)));\n  }\n\n  fn getFlatIndex3D(coords : vec3<i32>, shape : vec3<i32>) -> i32 {\n    return i32(dot(vec3<f32>(coords), vec3<f32>(f32(shape.y) * f32(shape.z), f32(shape.z), 1.0)));\n  }\n\n  fn getFlatIndex4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {\n    return i32(dot(vec4<f32>(coords), vec4<f32>(\n        f32(shape.y) * f32(shape.z) * f32(shape.w), f32(shape.z) * f32(shape.w), f32(shape.w), 1.0)));\n  }\n\n  // Only used when the y/z dimension of workgroup size is 1.\n  fn getGlobalIndex(globalId : vec3<u32>, localId : vec3<u32>, numWorkgroups: vec3<u32>) -> i32 {\n    if (numWorkgroups.y == 1u && numWorkgroups.z == 1u) {\n      return i32(globalId.x);\n    }\n\n    let localInvocationIndex = localId.z * workGroupSizeX * workGroupSizeY +\n        localId.y * workGroupSizeX + localId.x;\n    let workGroupID = (globalId - localId)/vec3<u32>(\n        workGroupSizeX, workGroupSizeY, workGroupSizeZ);\n\n    return i32((workGroupID.z * numWorkgroups.x * numWorkgroups.y +\n      workGroupID.y * numWorkgroups.x + workGroupID.x) *\n      (workGroupSizeX * workGroupSizeY * workGroupSizeZ) +\n      localInvocationIndex);\n  }\n";function getOutputFlatIndexSnippet(e){let t="";switch(e){case 0:case 1:t+="\n        fn getOutputFlatIndex(coords : i32) -> i32 {\n          return coords;\n        }\n        ";break;case 2:t+="\n        fn getOutputFlatIndex(coords : vec2<i32>) -> i32 {\n          return i32(dot(vec2<f32>(coords), vec2<f32>(f32(uniforms.outShapeStrides), 1.0)));\n        }\n        ";break;case 3:t+="\n        fn getOutputFlatIndex(coords : vec3<i32>) -> i32 {\n          return i32(dot(vec3<f32>(coords), vec3<f32>(f32(uniforms.outShapeStrides.x), f32(uniforms.outShapeStrides.y), 1.0)));\n        }\n        ";break;case 4:t+="\n        fn getOutputFlatIndex(coords : vec4<i32>) -> i32 {\n          return i32(dot(vec4<f32>(coords), vec4<f32>(\n            f32(uniforms.outShapeStrides.x), f32(uniforms.outShapeStrides.y), f32(uniforms.outShapeStrides.z), 1.0)));\n        }\n        ";break;default:util_exports.assert(!1,(()=>`Unsupported ${e}D shape`))}return t}function getSetOutputSnippet(e,t,n){const a=e.length,r=mapToWgslTypes(t,n);let s;if(s=n?`fn setOutputFlat(flatIndex : i32, value : vec4<f32>) {\n      result.numbers[flatIndex] = ${r}(value);\n    }\n    fn setOutputFlatI32(flatIndex : i32, value : vec4<i32>) {\n      result.numbers[flatIndex] = ${r}(value);\n    }`:`fn setOutputFlat(flatIndex : i32, value : f32) {\n      result.numbers[flatIndex] = ${r}(value);\n    }\n    fn setOutputFlatI32(flatIndex : i32, value : i32) {\n      result.numbers[flatIndex] = ${r}(value);\n    }`,a>=2){const e=["d0","d1","d2","d3"].slice(0,a),t=getCoordsDataType2(a);s+=n?`\n      fn setOutput(${e.map((e=>`${e} : i32`)).join(", ")}, value : vec4<f32>) {\n        let flatIndex = getOutputFlatIndex(${t}(${e.join(", ")}));\n        setOutputFlat(flatIndex / 4, value);\n      }\n      fn setOutputI32(${e.map((e=>`${e} : i32`)).join(", ")}, value : vec4<i32>) {\n        let flatIndex = getOutputFlatIndex(${t}(${e.join(", ")}));\n        setOutputFlatI32(flatIndex / 4, value);\n      }\n    `:`\n      fn setOutput(${e.map((e=>`${e} : i32`)).join(", ")}, value : f32) {\n        let flatIndex = getOutputFlatIndex(${t}(${e.join(", ")}));\n        setOutputFlat(flatIndex, value);\n      }\n      fn setOutputI32(${e.map((e=>`${e} : i32`)).join(", ")}, value : i32) {\n        let flatIndex = getOutputFlatIndex(${t}(${e.join(", ")}));\n        setOutputFlatI32(flatIndex, value);\n      }\n    `}return s}function getInputSamplingSnippet2(e,t,n,a){let r=getSamplerFromInInfo2(e,n);return e.shape.length<=t.length&&(r+=getSamplerAtOutputCoords2(e,t,n,a)),r}function getSamplerFromInInfo2(e,t){const n=e.name,a=e.shape.length,r=getCoordsDataType2(a),s="get"+n.charAt(0).toUpperCase()+n.slice(1),o=["d0","d1","d2","d3"].slice(0,a),i=o.map((e=>`${e} : i32`)).join(", ");if(a<1)return t?`\n        fn ${s}() -> vec4<f32> {\n          return vec4<f32>(${n}.numbers[0]);\n        }\n      `:`\n      fn ${s}() ->f32 {\n        return f32(${n}.numbers[0]);\n      }\n    `;const l=`uniforms.${n.charAt(0).toLowerCase()+n.slice(1)}Shape`;let u=`${a}D`;return 0===a&&(u="1D"),t?`\n      fn ${s}(${i}) -> vec4<f32> {\n        return vec4<f32>(${n}.numbers[getFlatIndex${u}(${r}(${o.join(",")}),\n          ${l}) / 4]);\n      }\n      `:`\n    fn ${s}(${i}) -> f32 {\n      return f32(${n}.numbers[getFlatIndex${u}(${r}(${o.join(",")}),\n        ${l})]);\n    }\n   `}function getSamplerAtOutputCoords2(e,t,n,a){const r=e.name,s=r.charAt(0).toUpperCase()+r.slice(1),o="get"+s+"AtOutCoords",i=e.shape.length,l=t.length,u=getCoordsDataType2(l);if(util_exports.arraysEqual(e.shape,t)&&a)return n?`\n        fn ${o}ByGlobalIndex(globalIndex : i32) -> vec4<f32> {\n          return vec4<f32>(${r}.numbers[globalIndex]);\n        }\n\n        fn ${o}ByCoords(coords : ${u}) -> vec4<f32> {\n          return vec4<f32>(${r}.numbers[${l>1?"getOutputFlatIndex(coords)":"coords"} / 4]);\n        }\n        `:`\n      fn ${o}ByGlobalIndex(globalIndex : i32) -> f32 {\n        return f32(${r}.numbers[globalIndex]);\n      }\n\n      fn ${o}ByCoords(coords : ${u}) -> f32 {\n        return f32(${r}.numbers[${l>1?"getOutputFlatIndex(coords)":"coords"}]);\n      }\n      `;const c=backend_util_exports.getBroadcastDims(e.shape,t),d=l-i;let p="";if(0===i)return n?`\n      fn ${o}ByGlobalIndex(globalIndex : i32) -> vec4<f32> {\n        return get${s}();\n      }\n\n      fn ${o}ByCoords(coords : ${u}) -> vec4<f32> {\n        return get${s}();\n      }\n    `:`\n      fn ${o}ByGlobalIndex(globalIndex : i32) -> f32{\n        return get${s}();\n      }\n\n      fn ${o}ByCoords(coords : ${u}) -> f32{\n        return get${s}();\n      }\n    `;p=l<2&&c.length>=1?"coords = 0;":c.map((e=>`coords[${e+d}] = 0;`)).join("\n");let h="";if(l<2&&i>0)h="coords";else if(l>1){h=`${getCoordsDataType2(i)}(${e.shape.map(((e,t)=>`coords[${t+d}]`)).join(", ")})`}else h="coords";const m=`uniforms.${r.charAt(0).toLowerCase()+r.slice(1)}Shape`,f=`${i}D`;return n?`\n      fn ${o}ByGlobalIndex(globalIndex : i32) -> vec4<f32> {\n        var coords = getCoordsFromFlatIndex(globalIndex);\n        ${p}\n        return ${r}.numbers[getFlatIndex${f}(${h}, ${m}) / 4];\n      }\n\n      fn ${o}ByCoords(coordsIn : ${u}) -> vec4<f32> {\n        var coords = coordsIn;\n        ${p}\n        return ${r}.numbers[getFlatIndex${f}(${h}, ${m}) / 4];\n      }\n    `:`\n    fn ${o}ByGlobalIndex(globalIndex : i32) -> f32 {\n      var coords = getCoordsFromFlatIndex(globalIndex);\n      ${p}\n      return f32(${r}.numbers[getFlatIndex${f}(${h}, ${m})]);\n    }\n\n    fn ${o}ByCoords(coordsIn : ${u}) -> f32 {\n      var coords = coordsIn;\n      ${p}\n      return f32(${r}.numbers[getFlatIndex${f}(${h}, ${m})]);\n    }\n  `}function generateGetOutputCoords(e,t){const{x:n,y:a=[],z:r=[]}=t,s=e.length;if(n.length===s){return[`fn getOutputCoordsWithFlatDispatchLayout(globalId : vec3<u32>, localId : vec3<u32>, numWorkgroups: vec3<u32>) -> ${getCoordsDataType2(s)}{\n      let globalIndex = getGlobalIndex(globalId, localId, numWorkgroups);\n      return getCoordsFromFlatIndex(globalIndex);\n    }\n    `,s]}let o="";const i=[n,a,r];let l=0;for(let e=0;e<i.length;e++){const t=i[e];if(0!==t.length)if(l+=t.length,1===t.length)o+=`let d${t[0]} = i32(globalId[${e}]);`;else{const n=symbolicallyComputeStrides2(t,"uniforms.outShape");o+=`var index${e} = i32(globalId[${e}]);`;for(let a=0;a<n.length;a++)o+=`let d${t[a]} = index${e} / ${n[a]};`,a===n.length-1?o+=`let d${t[a+1]} = index${e} - d${t[a]} * ${n[a]};`:o+=`index${e} = index${e} - d${t[a]} * ${n[a]};`}}const u=[];for(let e=0;e<l;e++)u.push(`d${e}`);const c=getCoordsDataType2(l);let d=`fn getOutputCoordsWithNonFlatDispatchLayout(globalId : vec3<u32>) -> ${c} {\n    ${o}\n  `;return 0===u.length?d+=`return ${c}(0); }`:d+=`return ${c}(${u.join(",")}); }`,[d,l]}function generateGetCoordsFromFlatIndex(e){const t=e.length;if(t<=1)return"fn getCoordsFromFlatIndex(index : i32) -> i32 { return index; }";const n=util_exports.computeStrides(e),a=getCoordsDataType2(t),r=[];for(let e=0;e<t;e++)r.push(`d${e}`);if(1===n.length)return"    fn getCoordsFromFlatIndex(index : i32) -> vec2<i32> {\n      let d0 = index / uniforms.outShapeStrides; let d1 = index - d0 * uniforms.outShapeStrides;\n      return vec2<i32>(d0, d1);\n    }";return`\n    fn getCoordsFromFlatIndex(index : i32) -> ${a} {\n      ${"var index2 = index;"+n.map(((e,t)=>`${`let ${r[t]} = index2 / uniforms.outShapeStrides[${t}]`}; ${t===n.length-1?`let ${r[t+1]} = index2 - ${r[t]} * uniforms.outShapeStrides[${t}]`:`index2 = index2 - ${r[t]} * uniforms.outShapeStrides[${t}]`};`)).join("")}\n      return ${a}(${r.join(",")});\n    }\n  `}var webgpu_util_exports={};__export2(webgpu_util_exports,{ArrayBufferToTypedArray:()=>ArrayBufferToTypedArray,GPUBytesPerElement:()=>GPUBytesPerElement,computeDispatch:()=>computeDispatch,computeWorkGroupSizeForConv2d:()=>computeWorkGroupSizeForConv2d,computeWorkGroupSizeForMatMul:()=>computeWorkGroupSizeForMatMul,computeWorkPerThreadForConv2d:()=>computeWorkPerThreadForConv2d,flatDispatchLayout:()=>flatDispatchLayout,isWebGPUSupported:()=>isWebGPUSupported,tilesFitEvenlyIntoShape:()=>tilesFitEvenlyIntoShape});var BinaryOpType,MAX_COMPUTE_PER_DIMENSION_DISPATCH_SIZE=65535,arrayProduct=e=>{let t=1;for(let n=0;n<e.length;n++)t*=e[n];return t};function tilesFitEvenlyIntoShape(e,t){if(e.length!==t.length)throw new Error(`Cannot compute whether rank ${e.length} tiles fit evenly into rank ${t.length} shape - ranks must match.`);return t.every(((t,n)=>t%e[n]==0))}function computeDispatch(e,t,n=[1,1,1],a=[1,1,1]){const[r,s,o]=[Math.ceil(arrayProduct(e.x.map((e=>t[e])))/(n[0]*a[0])),e.y?Math.ceil(arrayProduct(e.y.map((e=>t[e])))/(n[1]*a[1])):1,e.z?Math.ceil(arrayProduct(e.z.map((e=>t[e])))/(n[2]*a[2])):1];if(r<=MAX_COMPUTE_PER_DIMENSION_DISPATCH_SIZE&&s<=MAX_COMPUTE_PER_DIMENSION_DISPATCH_SIZE&&o<=MAX_COMPUTE_PER_DIMENSION_DISPATCH_SIZE)return[r,s,o];util_exports.assert(r>MAX_COMPUTE_PER_DIMENSION_DISPATCH_SIZE&&void 0===e.y&&void 0===e.z,(()=>"Dispatch size exceeds WebGPU limits in Y or Z dimension."));let i=Math.ceil(Math.sqrt(r));return i>MAX_COMPUTE_PER_DIMENSION_DISPATCH_SIZE?(i=Math.ceil(Math.cbrt(r)),util_exports.assert(i<=MAX_COMPUTE_PER_DIMENSION_DISPATCH_SIZE,(()=>"Total dispatch size exceeds WebGPU maximum.")),[i,i,i]):[i,i,1]}function computeWorkGroupSizeForConv2d(e,t){const n=arrayProduct(e.x.map((e=>t[e]))),a=arrayProduct(e.y.map((e=>t[e])));return n<=4?[4,16,1]:a<=4?[16,4,1]:[16,16,1]}function computeWorkGroupSizeForMatMul(e,t,n){return 1===e?[32,1,1]:1===n?[1,32,1]:[8,8,1]}function computeWorkPerThreadForConv2d(e,t){const n=arrayProduct(e.x.map((e=>t[e]))),a=arrayProduct(e.y.map((e=>t[e])));return n<=4?[1,2,1]:a<=4?[2,1,1]:[2,2,1]}function flatDispatchLayout(e){return{x:e.map(((e,t)=>t))}}function GPUBytesPerElement(e){if("float32"===e||"int32"===e||"bool"===e||"string"===e)return 4;if("complex64"===e)return 8;throw new Error(`Unknown dtype ${e}`)}function ArrayBufferToTypedArray(e,t){if("float32"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t||"string"===t){const t=new Int32Array(e),n=new ArrayBuffer(t.length),a=new Uint8Array(n);for(let e=0;e<t.length;e++)a[e]=t[e];return a}throw new Error(`Unknown dtype ${t}`)}function isWebGPUSupported(){return!!navigator.gpu}!function(e){e[e.MUL=0]="MUL",e[e.ADD=1]="ADD",e[e.SUB=2]="SUB",e[e.DIV=3]="DIV",e[e.EQUAL=4]="EQUAL",e[e.GREATER=5]="GREATER",e[e.GREATER_EQUAL=6]="GREATER_EQUAL",e[e.LESS=7]="LESS",e[e.LESS_EQUAL=8]="LESS_EQUAL",e[e.LOGICAL_AND=9]="LOGICAL_AND",e[e.NOT_EQUAL=10]="NOT_EQUAL",e[e.SQUARED_DIFFERENCE=11]="SQUARED_DIFFERENCE",e[e.INT_DIV=12]="INT_DIV",e[e.POW=13]="POW",e[e.PRELU=14]="PRELU",e[e.MAX=15]="MAX",e[e.MIN=16]="MIN",e[e.COMPLEX_MULTIPLY_REAL=17]="COMPLEX_MULTIPLY_REAL",e[e.COMPLEX_MULTIPLY_IMAG=18]="COMPLEX_MULTIPLY_IMAG"}(BinaryOpType||(BinaryOpType={}));var UnaryOpType,ADD2="return a + b;",COMPLEX_MULTIPLY_REAL="return areal * breal - aimag * bimag;",COMPLEX_MULTIPLY_IMAG="return areal * bimag + aimag * breal;",DIV2="return a / b;",MUL2="return a * b;",SQUARED_DIFFERENCE2="return (a - b) * (a - b);",SUB2="return a - b;",EQUAL2="return f32(a == b);",EQUAL_VEC4="return vec4<f32>(a == b);",GREATER2="return f32(a > b);",GREATER_VEC4="return vec4<f32>(a > b);",GREATER_EQUAL2="return f32(a >= b);",GREATER_EQUAL_VEC4="return vec4<f32>(a >= b);",LESS2="return f32(a < b);",LESS_VEC4="return vec4<f32>(a < b);",LESS_EQUAL2="return f32(a <= b);",LESS_EQUAL_VEC4="return vec4<f32>(a <= b);",LOGICAL_AND2="return f32(f32(a) >= 1.0 && f32(b) >= 1.0);",LOGICAL_AND_VEC4="return (vec4<f32>(a >= vec4<f32>(1.0)) *\n  vec4<f32>(b >= vec4<f32>(1.0)));",CHECK_NAN_SNIPPET4="\n  if (isNanCustom(a)) { return a; }\n  if (isNanCustom(b)) { return b; }\n  ",CHECK_NAN_SNIPPET_VEC4="\n  if (isNaN.r > 0.) {\n    resultTemp.r = uniforms.NAN;\n  }\n  if (isNaN.g > 0.) {\n    resultTemp.g = uniforms.NAN;\n  }\n  if (isNaN.b > 0.) {\n    resultTemp.b = uniforms.NAN;\n  }\n  if (isNaN.a > 0.) {\n    resultTemp.a = uniforms.NAN;\n  }\n  ",INT_DIV2="\n  let s = sign(a) * sign(b);\n  let ia = i32(round(a));\n  let ib = i32(round(b));\n  return f32(idiv(ia, ib, s));\n  ",INT_DIV_VEC4="\n  let ia = vec4<i32>(round(a));\n  let ib = vec4<i32>(round(b));\n  let cond = ib != vec4<i32>(0);\n  var resultTemp = vec4<i32>(0);\n  let s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    resultTemp[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    resultTemp[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    resultTemp[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    resultTemp[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4<f32>(resultTemp);\n  ",NOT_EQUAL2="return f32(a != b);",NOT_EQUAL_VEC4="return vec4<f32>(a != b);",POW2="\n  if(a < 0.0 && floor(b) < b) {\n    return uniforms.NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  if (round(abs(b) % 2.0) != 1.0) {\n    return pow(abs(a), b);\n  }\n  return sign(a) * pow(abs(a), b);\n  ",POW_VEC4=`\n  let isModRound1Bool = vec4<i32>(round(abs(b) % vec4<f32>(2.0))) == vec4<i32>(1);\n  let isModRound1 = vec4<f32>(isModRound1Bool);\n  let multiplier = sign(a) * isModRound1 + (vec4<f32>(1.0) - isModRound1);\n  var resultTemp = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  let isExpZero = b == vec4<f32>(0.0);\n  if (isExpZero.r) {\n    resultTemp.r = 1.0;\n  }\n  if (isExpZero.g) {\n    resultTemp.g = 1.0;\n  }\n  if (isExpZero.b) {\n    resultTemp.b = 1.0;\n  }\n  if (isExpZero.a) {\n    resultTemp.a = 1.0;\n  }\n  let isNaN = vec4<f32>(a < vec4<f32>(0.0)) * vec4<f32>(floor(b) < b);\n  ${CHECK_NAN_SNIPPET_VEC4}\n  return resultTemp;\n  `,PRELU2="if (a < 0.0) { return b * a; }  return a;",PRELU_VEC4="\n  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));\n  return (aLessThanZero * (b * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);\n  ";function getMinMaxString(e,t){const n=t?CHECK_NAN_SNIPPET_VEC4:CHECK_NAN_SNIPPET4;return t?`\n    var resultTemp = vec4<f32>(${e}(a, b));\n    let isNaN = min(vec4<f32>(isNanCustomVec4F32(a)) + vec4<f32>(isNanCustomVec4F32(b)), vec4<f32>(1.0));\n    `+n+"\n    return resultTemp;\n  ":n+`\n    return ${e}(a, b);\n  `}function getBinaryOpString(e,t){switch(e){case 0:return MUL2;case 1:return ADD2;case 2:return SUB2;case 3:return DIV2;case 4:return t?EQUAL_VEC4:EQUAL2;case 5:return t?GREATER_VEC4:GREATER2;case 6:return t?GREATER_EQUAL_VEC4:GREATER_EQUAL2;case 7:return t?LESS_VEC4:LESS2;case 8:return t?LESS_EQUAL_VEC4:LESS_EQUAL2;case 9:return t?LOGICAL_AND_VEC4:LOGICAL_AND2;case 10:return t?NOT_EQUAL_VEC4:NOT_EQUAL2;case 11:return SQUARED_DIFFERENCE2;case 12:return t?INT_DIV_VEC4:INT_DIV2;case 14:return t?PRELU_VEC4:PRELU2;case 15:return getMinMaxString("max",t);case 16:return getMinMaxString("min",t);case 13:return t?POW_VEC4:POW2;case 17:return COMPLEX_MULTIPLY_REAL;case 18:return COMPLEX_MULTIPLY_IMAG;default:throw new Error(`BinaryType ${e} is not implemented!`)}}!function(e){e[e.ABS=0]="ABS",e[e.CEIL=1]="CEIL",e[e.COS=2]="COS",e[e.COSH=3]="COSH",e[e.ELU=4]="ELU",e[e.EXP=5]="EXP",e[e.EXPM1=6]="EXPM1",e[e.FLOOR=7]="FLOOR",e[e.LINEAR=8]="LINEAR",e[e.LOG=9]="LOG",e[e.LOGICAL_NOT=10]="LOGICAL_NOT",e[e.NEG=11]="NEG",e[e.PRELU=12]="PRELU",e[e.RELU=13]="RELU",e[e.RELU6=14]="RELU6",e[e.RSQRT=15]="RSQRT",e[e.SIN=16]="SIN",e[e.SINH=17]="SINH",e[e.SIGMOID=18]="SIGMOID",e[e.SQRT=19]="SQRT",e[e.SQUARE=20]="SQUARE",e[e.TANH=21]="TANH",e[e.TO_INT=22]="TO_INT"}(UnaryOpType||(UnaryOpType={}));var ABS3="return abs(a);",CEIL2="return ceil(a);",COS2="return cos(a);",COSH2="\n  let e2x = exp(-a);\n  return (e2x + 1.0 / e2x) / 2.0;\n",EXPM12="return exp(a) - 1.0;",ELU5="if (a >= 0.0) { return a; }  return (exp(a) - 1.0);",ELU_VEC4="\n  var resFloat = exp(a) - vec4<f32>(1.0);\n  if (a.r >= 0.0) {\n    resFloat.r = a.r;\n  }\n  if (a.g >= 0.0) {\n    resFloat.g = a.g;\n  }\n  if (a.b >= 0.0) {\n    resFloat.b = a.b;\n  }\n  if (a.a >= 0.0) {\n    resFloat.a = a.a;\n  }\n  return resFloat;\n",EXP2="return exp(a);",FLOOR2="return floor(a);",LINEAR3="return a;",LOG2="if (a < 0.0) { return 1.0/0.0; }\n  return log(a);",LOGICAL_NOT2="return f32(!(a >= 1.0));",NEG2="return -a;",PRELU3="return (a < 0.0) ? b * a : a;",RELU4="return max(a, 0.0);",RELU64="return clamp(a, 0.0, 6.0);",RELU6_VEC4="return clamp(a, vec4<f32>(0.0, 0.0, 0.0, 0.0), vec4<f32>(6.0, 6.0, 6.0, 6.0));",RELU_VEC4="\n  var resFloat = a * vec4<f32>(a >= vec4<f32>(0.0));\n  let isNaN = isNan(a);\n\n  if (isNaN.r) {\n    resFloat.r = a.r;\n  }\n  if (isNaN.g) {\n    resFloat.g = a.g;\n  }\n  if (isNaN.b) {\n    resFloat.b = a.b;\n  }\n  if (isNaN.a) {\n    resFloat.a = a.a;\n  }\n  return resFloat;\n",RSQRT2="return 1.0/sqrt(a);",SIGMOID4="return 1.0 / (1.0 + exp(-1.0 * a));",SIN2="return sin(a);",SINH2="\n  let e2x = exp(a);\n  return (e2x - 1.0 / e2x) / 2.0;\n",SQRT2="return sqrt(a);",SQUARE2="return a * a;",TANH2="\n  let e2x = exp(-2.0 * abs(a));\n  return sign(a) * (1.0 - e2x) / (1.0 + e2x);\n",TO_INT2="return f32(i32((a)));";function getUnaryOpString(e,t){switch(e){case 0:return ABS3;case 2:return COS2;case 3:return COSH2;case 1:return CEIL2;case 4:return t?ELU_VEC4:ELU5;case 5:return EXP2;case 6:return EXPM12;case 7:return FLOOR2;case 8:return LINEAR3;case 9:return LOG2;case 10:return LOGICAL_NOT2;case 11:return NEG2;case 12:return PRELU3;case 13:return t?RELU_VEC4:RELU4;case 14:return t?RELU6_VEC4:RELU64;case 15:return RSQRT2;case 18:return SIGMOID4;case 16:return SIN2;case 17:return SINH2;case 19:return SQRT2;case 20:return SQUARE2;case 21:return TANH2;case 22:return TO_INT2;default:throw new Error(`BinaryType ${e} is not implemented!`)}}function mapActivationToShaderProgram2(e,t=!1){if(null===e)return null;if("linear"===e)return getUnaryOpString(UnaryOpType.LINEAR);if("relu"===e)return getUnaryOpString(UnaryOpType.RELU,t);if("elu"===e)return getUnaryOpString(UnaryOpType.ELU,t);if("relu6"===e)return getUnaryOpString(UnaryOpType.RELU6,t);if("prelu"===e)return getBinaryOpString(BinaryOpType.PRELU,t);if("sigmoid"===e)return getUnaryOpString(UnaryOpType.SIGMOID);throw new Error(`Activation ${e} has not been implemented for the WebGPU backend.`)}function makeMatMulPackedVec4Source(e,t){const n=e[1],a=e[0],r=t[1]*e[1],s=t[0]*e[0],o=t[0]*e[0];return`\n  var<workgroup> mm_Asub : array<array<vec4<f32>, ${o/a}>, ${r}>;\n  var<workgroup> mm_Bsub : array<array<vec4<f32>, ${s/a}>, ${o}>;\n\n  let RowPerThread = ${n};\n  let ColPerThread = ${a}; // only support ColPerThread = 4\n  let TileAOuter = ${r};\n  let TileBOuter = ${s};\n  let TileInner = ${o};\n\n  ${getNonFlatDispatchLayoutMainHeaderString()} {\n\n    let tileRow = i32(localId.y) * RowPerThread;\n    let tileCol = i32(localId.x);\n\n    let globalRow = i32(globalId.y) * RowPerThread;\n    let globalCol = i32(globalId.x);\n    let numTiles = (uniforms.dimInner - 1) / TileInner + 1;\n\n    var acc: array<vec4<f32>, ${n}>;\n    var ACached : vec4<f32>;\n    var BCached : array<vec4<f32>, 4>;\n\n    // Loop over shared dimension.\n    var globalColA = tileCol;\n    let RowPerThreadB = TileInner / ${t[1]};\n    let tileRowB = i32(localId.y) * RowPerThreadB;\n    for (var t = 0; t < numTiles; t = t + 1) {\n        // Load one tile of A into local memory.\n        for (var innerRow = 0; innerRow < RowPerThread; innerRow = innerRow + 1) {\n            let inputRow = tileRow + innerRow;\n            let inputCol = tileCol;\n            mm_Asub[inputRow][inputCol] = mm_readA(globalRow + innerRow, globalColA, globalId);\n        }\n        globalColA = globalColA + TileInner / ColPerThread;\n\n        // Load one tile of B into local memory.\n        for (var innerRow = 0; innerRow < RowPerThreadB; innerRow = innerRow + 1) {\n            let inputRow = tileRowB + innerRow;\n            let inputCol = tileCol;\n            mm_Bsub[inputRow][inputCol] = mm_readB(t * TileInner + inputRow, globalCol, globalId);\n        }\n\n        workgroupBarrier();\n\n        // Compute acc values for a single thread.\n        for (var k = 0; k < TileInner / ColPerThread; k = k + 1) {\n            BCached[0] = mm_Bsub[k * ColPerThread][tileCol];\n            BCached[1] = mm_Bsub[k * ColPerThread + 1][tileCol];\n            BCached[2] = mm_Bsub[k * ColPerThread + 2][tileCol];\n            BCached[3] = mm_Bsub[k * ColPerThread + 3][tileCol];\n\n            for (var i = 0; i < RowPerThread; i = i + 1) {\n                ACached = mm_Asub[tileRow + i][k];\n                acc[i] = BCached[0] * ACached.x + acc[i];\n                acc[i] = BCached[1] * ACached.y + acc[i];\n                acc[i] = BCached[2] * ACached.z + acc[i];\n                acc[i] = BCached[3] * ACached.w + acc[i];\n            }\n        }\n\n        workgroupBarrier();\n    }\n\n    for (var innerRow = 0; innerRow < RowPerThread; innerRow = innerRow + 1) {\n        mm_write(globalRow + innerRow,\n                 globalCol,\n                 acc[innerRow], globalId);\n    }\n}`}function makeMatMulVectorVec4Source(e){return`\n  var<workgroup> mm_Asub : array<vec4<f32>, ${e[0]}>;\n  let tileSize = ${4*e[0]};\n  ${getNonFlatDispatchLayoutMainHeaderString()} {\n    let tileCol = i32(localId.x);\n    let globalCol = i32(globalId.x);\n    let globalRow = i32(globalId.y);\n\n    let numTiles = (uniforms.dimInner - 1) / tileSize + 1;\n\n    // Without this initialization strange values show up in acc.\n    var acc = vec4<f32>(0.0);\n\n    // Loop over shared dimension.\n    for (var t = 0; t < numTiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      let colA = t * tileSize / 4 + tileCol;\n      mm_Asub[tileCol] = mm_readA(globalRow, colA, globalId);\n\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      for (var k = 0; k < tileSize / 4; k = k + 1) {\n        let rowB = t * tileSize + k * 4;\n        let BCached0 = mm_readB(rowB, globalCol, globalId);\n        let BCached1 = mm_readB(rowB + 1, globalCol, globalId);\n        let BCached2 = mm_readB(rowB + 2, globalCol, globalId);\n        let BCached3 = mm_readB(rowB + 3, globalCol, globalId);\n\n        let ACached = mm_Asub[k];\n        acc = acc + BCached0 * ACached.x;\n        acc = acc + BCached1 * ACached.y;\n        acc = acc + BCached2 * ACached.z;\n        acc = acc + BCached3 * ACached.w;\n      }\n\n      workgroupBarrier();\n    }\n\n    if (globalRow < uniforms.dimAOuter && globalCol < uniforms.dimBOuter) {\n      mm_write(globalRow, globalCol, acc, globalId);\n    }\n  }\n`}var MatMulPackedVec4Program=class{constructor(e,t,n,a=null,r=null,s=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32; dimBOuter : i32; dimInner : i32;",this.workGroupSize=[16,16,1],this.isVec4=!0,this.vecSize=4,this.outputShape=t,this.workGroupSize=computeWorkGroupSizeForMatMul(t[1],e[2],t[2]),this.dispatchLayout={x:[2],y:[1],z:[0]},1===t[1]&&(n=1),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.vecSize,n,1]);const o=null!=a,i=null!=s;o&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),this.workPerThread=n,this.aShape=e,this.addBias=o,this.activation=r,this.hasPreluActivationWeights=i,[this.fitA,this.fitB]=this.getShapeFit(),this.shaderKey=`matMulPackedVec4_${n}_${this.activation}_${this.fitA}_${this.fitB}_${this.outputShape[1]>1}`}getShapeFit(){const e=this.aShape[2],t=this.outputShape[2],n=[this.outputShape[0],e,t],a=this.workGroupSize[1]*this.workPerThread,r=this.workGroupSize[0]*this.vecSize,s=[r,r];return[tilesFitEvenlyIntoShape([a,r],this.aShape.slice(1)),tilesFitEvenlyIntoShape(s,n.slice(1))]}getUserCode(){const e=this.fitA?"return A.numbers[batch * batchASize + row * uniforms.dimInner / 4 + col]":"if (coordsInBounds2D(vec2<i32>(row, col * 4), vec2<i32>(uniforms.dimAOuter, uniforms.dimInner))) {\n            return A.numbers[batch * batchASize + row * uniforms.dimInner / 4 + col];\n        }\n        return vec4<f32>(0.0)",t=this.fitB?"return B.numbers[batch * batchBSize + row * uniforms.dimBOuter / 4 + col]":"if(coordsInBounds2D(vec2<i32>(row, col * 4), vec2<i32>(uniforms.dimInner, uniforms.dimBOuter))) {\n             return B.numbers[batch * batchBSize + row * uniforms.dimBOuter / 4 + col];\n        }\n        return vec4<f32>(0.0)";let n="",a="";if(this.activation){const e=mapActivationToShaderProgram2(this.activation,this.isVec4);n=this.hasPreluActivationWeights?`fn activation(a : vec4<f32>, outCoord : vec3<i32>) -> vec4<f32> {\n                  let b = getPreluActivationWeightsAtOutCoordsByCoords(outCoord);\n                  ${e}\n                }`:`\n            fn activation(a : vec4<f32>, outCoord : vec3<i32>) -> vec4<f32> {\n              ${e}\n            }`,a="value = activation(value, outCoord);"}const r=this.addBias?"value = value + getBiasAtOutCoordsByCoords(outCoord);":"";return`\n      ${n}\n      fn mm_readA(row : i32, col : i32,  globalId : vec3<u32>) -> vec4<f32> {\n        let batchASize = uniforms.aShape[1] * uniforms.aShape[2] / ${this.vecSize};\n        let batch = i32(globalId.z);\n        ${e};\n      }\n\n      fn mm_readB(row : i32, col : i32,  globalId : vec3<u32>) -> vec4<f32> {\n        let batchBSize = uniforms.bShape[1] * uniforms.bShape[2] / ${this.vecSize};\n        let batch = i32(globalId.z);\n        ${t};\n      }\n\n      fn mm_write(row : i32, col : i32, valueIn : vec4<f32>, globalId : vec3<u32>) {\n        if (row < uniforms.aShape[1] && col * 4 < uniforms.bShape[2])\n        {\n          var value = valueIn;\n          let batch = i32(globalId.z);\n          let outCoord = vec3<i32>(batch, row, col * 4);\n          ${r}\n          ${a}\n          setOutput(outCoord[0], outCoord[1], outCoord[2], value);\n        }\n      }\n      ${this.outputShape[1]>1?makeMatMulPackedVec4Source([this.vecSize,this.workPerThread,1],this.workGroupSize):makeMatMulVectorVec4Source(this.workGroupSize)}\n\n    `}};function makeMatMulPackedSource(e,t){const n=t[1]*e[1],a=t[0]*e[0],r=n>a?n:a;return`\n    var<workgroup> mm_Asub : array<array<f32, ${r}>, ${n}>;\n    var<workgroup> mm_Bsub : array<array<f32, ${a}>, ${r}>;\n    ${getNonFlatDispatchLayoutMainHeaderString()} {\n      let tileRow = i32(localId.y) * ${e[1]};\n      let tileCol = i32(localId.x) * ${e[0]};\n\n      let globalRow = i32(globalId.y) * ${e[1]};\n      let globalCol = i32(globalId.x) * ${e[0]};\n\n      let numTiles = (uniforms.dimInner - 1) / ${r} + 1;\n\n      var acc : array<array<f32, ${e[0]}>, ${e[1]}>;\n      var ACached : f32;\n      var BCached : array<f32, ${e[0]}>;\n\n      // Without this initialization strange values show up in acc.\n      for (var innerRow = 0; innerRow < ${e[1]}; innerRow = innerRow + 1) {\n        for (var innerCol = 0; innerCol < ${e[0]}; innerCol = innerCol + 1) {\n          acc[innerRow][innerCol] = 0.0;\n        }\n      }\n\n      let ColPerThreadA = ${r} / ${t[0]};\n      let tileColA = i32(localId.x) * ColPerThreadA;\n      let RowPerThreadB = ${r} / ${t[1]};\n      let tileRowB = i32(localId.y) * RowPerThreadB;\n\n      // Loop over shared dimension.\n      for (var t = 0; t < numTiles; t = t + 1) {\n        // Load one tile of A into local memory.\n        for (var innerRow = 0; innerRow < ${e[1]}; innerRow = innerRow + 1) {\n          for (var innerCol = 0; innerCol < ColPerThreadA; innerCol = innerCol + 1) {\n            let inputRow = tileRow + innerRow;\n            let inputCol = tileColA + innerCol;\n\n            mm_Asub[inputRow][inputCol] = mm_readA(\n                globalRow + innerRow,\n                t * ${r} + inputCol, globalId);\n          }\n        }\n        // Load one tile of B into local memory.\n        for (var innerRow = 0; innerRow < RowPerThreadB; innerRow = innerRow + 1) {\n          for (var innerCol = 0; innerCol < ${e[0]}; innerCol = innerCol + 1) {\n            let inputRow = tileRowB + innerRow;\n            let inputCol = tileCol + innerCol;\n\n            mm_Bsub[inputRow][inputCol] = mm_readB(\n              t * ${r} + inputRow,\n              globalCol + innerCol, globalId);\n          }\n        }\n\n        workgroupBarrier();\n\n        // Compute acc values for a single thread.\n        for (var k = 0; k < ${r}; k = k + 1) {\n          for (var inner = 0; inner < ${e[0]}; inner = inner + 1) {\n            BCached[inner] = mm_Bsub[k][tileCol + inner];\n          }\n\n          for (var innerRow = 0; innerRow < ${e[1]}; innerRow = innerRow + 1) {\n            ACached = mm_Asub[tileRow + innerRow][k];\n            for (var innerCol = 0; innerCol < ${e[0]}; innerCol = innerCol + 1) {\n              acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];\n            }\n          }\n        }\n\n        workgroupBarrier();\n      }\n\n      for (var innerRow = 0; innerRow < ${e[1]}; innerRow = innerRow + 1) {\n        for (var innerCol = 0; innerCol < ${e[0]}; innerCol = innerCol + 1) {\n\n          if ((globalCol + innerCol) < uniforms.dimBOuter &&\n              (globalRow + innerRow) < uniforms.dimAOuter) {\n            mm_write(globalRow + innerRow,\n                     globalCol + innerCol,\n                     acc[innerRow][innerCol], globalId);\n          }\n        }\n      }\n    }\n  `}function makeMatMulVectorSource(e){return`\n    let TileSize = ${4*e[0]};\n    var<workgroup> mm_Asub : array<vec4<f32>, ${e[0]}>;\n\n    ${getNonFlatDispatchLayoutMainHeaderString()} {\n      let tileCol = i32(localId.x);\n      let globalCol = i32(globalId.x);\n      let globalRow = i32(globalId.y);\n\n      let numTiles = (uniforms.dimInner - 1) / TileSize + 1;\n\n      // Without this initialization strange values show up in acc.\n      var acc = 0.0;\n\n      // Loop over shared dimension.\n      for (var t = 0; t < numTiles; t = t + 1) {\n        // Load one tile of A into local memory.\n        let colA = t * TileSize + tileCol * 4;\n        mm_Asub[tileCol] = vec4<f32>(mm_readA(globalRow, colA, globalId),\n                                mm_readA(globalRow, colA + 1, globalId),\n                                mm_readA(globalRow, colA + 2, globalId),\n                                mm_readA(globalRow, colA + 3, globalId));\n        workgroupBarrier();\n\n        // Compute acc values for a single thread.\n        for (var k = 0; k < TileSize / 4; k = k + 1) {\n          let rowB = t * TileSize + k * 4;\n          let BCached = vec4<f32>(mm_readB(rowB, globalCol, globalId),\n                              mm_readB(rowB + 1, globalCol, globalId),\n                              mm_readB(rowB + 2, globalCol, globalId),\n                              mm_readB(rowB + 3, globalCol, globalId));\n\n          let ACached = mm_Asub[k];\n          acc = acc + dot(ACached, BCached);\n        }\n\n        workgroupBarrier();\n      }\n\n      if (globalRow < uniforms.dimAOuter && globalCol < uniforms.dimBOuter) {\n        mm_write(globalRow, globalCol, acc, globalId);\n      }\n    }\n  `}var MatMulPackedProgram2=class{constructor(e,t,n,a=!1,r=!1,s=null,o=null,i=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32; dimBOuter : i32; dimInner : i32;",this.workGroupSize=[16,16,1],this.outputShape=t,this.dispatchLayout={x:[2],y:[1],z:[0]};const l=a?e[1]:e[2];this.workGroupSize=computeWorkGroupSizeForMatMul(t[1],l,t[2]),1!==t[1]&&1!==t[2]||(n=1),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workGroupSize,[n,n,1]),util_exports.arraysEqual(this.dispatch,[1,1,1])&&(n=1,this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workGroupSize,[n,n,1]));const u=null!=s,c=null!=i;u&&this.variableNames.push("bias"),c&&this.variableNames.push("preluActivationWeights"),this.workPerThread=n,this.aShape=e,this.transposeA=a,this.transposeB=r,this.addBias=u,this.activation=o,this.hasPreluActivationWeights=c;const d=this.outputShape[2],p=this.transposeB?[this.outputShape[0],d,l]:[this.outputShape[0],l,d];[this.fitA,this.fitB]=this.getShapeFit(p),this.shaderKey=`matMulPacked_${this.workPerThread}_${a}_${r}_${this.activation}_${this.fitA}_${this.fitB}_${this.outputShape[1]>1}`}getShapeFit(e){const t=this.workGroupSize[1]*this.workPerThread,n=this.workGroupSize[0]*this.workPerThread;let a=t>n?t:n;1===this.outputShape[1]&&(a*=4),util_exports.assert(a%this.workGroupSize[0]==0&&a%this.workGroupSize[1]==0,(()=>"tileInner must be multiple of workgroupsize.x and workgroupsize.y"));const r=[a,n];return[tilesFitEvenlyIntoShape([t,a],this.aShape.slice(1)),tilesFitEvenlyIntoShape(r,e.slice(1))]}getUserCode(){let e,t;e=!1===this.transposeA?this.fitA?"return A.numbers[batch * batchASize + row * uniforms.dimInner + col];":"if(coordsInBounds2D(vec2<i32>(row, col), vec2<i32>(uniforms.dimAOuter, uniforms.dimInner))) {\n             return A.numbers[batch * batchASize + row * uniforms.dimInner + col];\n           }\n           return 0.0;":this.fitA?"return A.numbers[batch * batchASize + col * uniforms.dimAOuter + row];":"if(coordsInBounds2D(vec2<i32>(row, col), vec2<i32>(uniforms.dimAOuter, uniforms.dimInner))) {\n             return A.numbers[batch* batchASize + col * uniforms.dimAOuter + row];\n           }\n           return 0.0;",t=!1===this.transposeB?this.fitB?"return B.numbers[batch * batchBSize + row * uniforms.dimBOuter + col];":"if(coordsInBounds2D(vec2<i32>(row, col), vec2<i32>(uniforms.dimInner, uniforms.dimBOuter))) {\n             return B.numbers[batch * batchBSize + row * uniforms.dimBOuter + col];\n           }\n           return 0.0;":this.fitB?"return B.numbers[batch * batchBSize + col * uniforms.dimInner + row];":"if(coordsInBounds2D(vec2<i32>(row, col), vec2<i32>(uniforms.dimInner, uniforms.dimBOuter))) {\n             return B.numbers[batch * batchBSize + col * uniforms.dimInner + row];\n           }\n           return 0.0;";let n="",a="";if(this.activation){const e=mapActivationToShaderProgram2(this.activation,!1);n=this.hasPreluActivationWeights?`fn activation(a : f32, outCoord : vec3<i32>) -> f32 {\n               let b = getPreluActivationWeightsAtOutCoordsByCoords(outCoord);\n               ${e}\n            }`:`\n              fn activation(a : f32, outCoord : vec3<i32>) -> f32 {\n                ${e}\n              }\n            `,a="value = activation(value, outCoord);"}return`\n      ${n}\n\n      fn mm_readA(row : i32, col : i32,  globalId : vec3<u32>) -> f32 {\n        let batchASize = uniforms.aShape[1] * uniforms.aShape[2];\n        let batch = i32(globalId.z);\n        ${e}\n      }\n\n      fn mm_readB(row : i32, col : i32,  globalId : vec3<u32>) -> f32 {\n        let batch = i32(globalId.z);\n        let batchBSize = uniforms.bShape[1] * uniforms.bShape[2];\n        ${t}\n      }\n\n      fn mm_write(row : i32, col : i32, valueIn : f32, globalId : vec3<u32>) {\n        var value = valueIn;\n        let batch = i32(globalId.z);\n        let outCoord = vec3<i32>(batch, row, col);\n        ${this.addBias?"value = value + getBiasAtOutCoordsByCoords(outCoord);":""}\n        ${a}\n        setOutput(batch, row, col, value);\n      }\n      ${this.outputShape[1]>1?makeMatMulPackedSource([this.workPerThread,this.workPerThread,1],this.workGroupSize):makeMatMulVectorSource(this.workGroupSize)}\n    `}};function makeMatMulReduceSource(){return`\n    var<workgroup> sumValues : array<f32, workGroupSizeX>;\n    ${getNonFlatDispatchLayoutMainHeaderString()} {\n      let coords = getOutputCoordsWithNonFlatDispatchLayout(globalId);\n      let batch = coords[0];\n      let row = coords[1];\n      let col = coords[2];\n      var sum = 0.0;\n      let Length = uniforms.dimInner;\n      for (var k = i32(localId.x); k < Length; k = k + i32(workGroupSizeX)) {\n        let dataA = mm_readA(batch, row, k);\n        let dataB = mm_readB(batch, k, col);\n        sum = sum + dataA * dataB;\n      }\n      sumValues[localId.x] = sum;\n      workgroupBarrier();\n\n      for(var currentSize = workGroupSizeX / 2u; currentSize > 1u;\n          currentSize = currentSize / 2u) {\n        if (localId.x < currentSize)\n        {\n          sumValues[localId.x] = sumValues[localId.x] + sumValues[localId.x + currentSize];\n        }\n        workgroupBarrier();\n      }\n\n      if (localId.x == 0u) {\n        sum = sumValues[0] + sumValues[1];\n        mm_write(batch, row, col, sum);\n      }\n    }\n  `}var MatMulReduceProgram=class{constructor(e,t=!1,n=!1,a=null,r=null,s=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32; dimBOuter : i32; dimInner : i32;",this.workGroupSize=[256,1,1],this.outputShape=e,this.dispatchLayout={x:[],y:[1,2],z:[0]},this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workGroupSize);const o=null!=a,i=null!=s;o&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),this.transposeA=t,this.transposeB=n,this.addBias=o,this.activation=r,this.hasPreluActivationWeights=i,this.shaderKey=`matMulReduce_${this.activation}_${t}_${n}`}getUserCode(){let e,t;e=!1===this.transposeA?"return A.numbers[batch * batchASize + row * uniforms.dimInner + col];":"return A.numbers[batch * batchASize + col * uniforms.dimAOuter + row];",t=!1===this.transposeB?"return B.numbers[batch * batchBSize + row * uniforms.dimBOuter + col];":"return B.numbers[batch * batchBSize + col * uniforms.dimInner + row];";let n="",a="";if(this.activation){const e=mapActivationToShaderProgram2(this.activation,!1);n=this.hasPreluActivationWeights?`fn activation(a : f32, outCoord : vec3<i32>) -> f32 {\n               let b = getPreluActivationWeightsAtOutCoordsByCoords(outCoord);\n               ${e}\n            }`:`\n              fn activation(a : f32, outCoord : vec3<i32>) -> f32 {\n                ${e}\n              }\n            `,a="value = activation(value, outCoord);"}return`\n      ${n}\n\n      fn mm_readA(batch: i32, row : i32, col : i32) -> f32 {\n        let batchASize = uniforms.aShape[1] * uniforms.aShape[2];\n        ${e}\n      }\n\n      fn mm_readB(batch: i32, row : i32, col : i32) -> f32 {\n        let batchBSize = uniforms.bShape[1] * uniforms.bShape[2];\n        ${t}\n      }\n\n      fn mm_write(batch: i32, row : i32, col : i32, valueIn : f32) {\n        var value = valueIn;\n        let outCoord = vec3<i32>(batch, row, col);\n        ${this.addBias?"value = value + getBiasAtOutCoordsByCoords(outCoord);":""}\n        ${a}\n        setOutput(batch, row, col, value);\n      }\n      ${makeMatMulReduceSource()}\n    `}};function makeMatMulSmallOutputSizeSource(e){const t=e[1]/2,n=e[0],a=t>n?t:n;return`\n  var<workgroup> mm_Asub1 : array<array<f32, ${a}>, ${t}>;\n  var<workgroup> mm_Bsub1 : array<array<f32, ${n}>, ${a}>;\n  var<workgroup> mm_Asub2 : array<array<f32, ${a}>, ${t}>;\n  var<workgroup> mm_Bsub2 : array<array<f32, ${n}>, ${a}>;\n\n  // If the output size is small for matrix multiplication, avoid to use vec4\n  // and handle some elements per thread to optimally utilize the ALU.\n  // Introduces two shared memory buffers, some logical threads could handle\n  // arithmetic operations and others handle IO operations between barrier api,\n  // makes ALUs and load/store units work simultaneously, could improves\n  // the performance.\n  ${getNonFlatDispatchLayoutMainHeaderString()} {\n    let tileRow = i32(localId.y);\n    let tileCol = i32(localId.x);\n    let globalRow = i32(globalId.y);\n    let globalCol = i32(globalId.x);\n\n    // uniforms.dimInner should be greater than 0.\n    let numTiles = (uniforms.dimInner - 1) / ${a} + 1;\n    var acc = 0.0;\n\n    var globalColA = tileCol;\n    var globalRowB = tileRow;\n    for (var t = 0; t < numTiles; t = t + 1) {\n      if (t == 0) {\n        if (tileRow < ${t}) {\n          // Load one tile of A and B into local memory.\n          // globalRow is always greater than or equal tileRow.\n          mm_Asub1[tileRow][tileCol] =\n              mm_readA((globalRow - tileRow) / 2 + tileRow, globalColA, globalId);\n          globalColA = globalColA + ${a};\n          mm_Bsub1[tileRow][tileCol] = mm_readB(globalRowB, globalCol, globalId);\n          globalRowB = globalRowB + ${a};\n        }\n      } else {\n        if (tileRow < ${t}) {\n          // Load one tile of A and B into local memory.\n          // globalRow is always greater than or equal tileRow.\n          mm_Asub1[tileRow][tileCol] =\n              mm_readA((globalRow - tileRow) / 2 + tileRow, globalColA, globalId);\n          globalColA = globalColA + ${a};\n          mm_Bsub1[tileRow][tileCol] = mm_readB(globalRowB, globalCol, globalId);\n          globalRowB = globalRowB + ${a};\n        } else {\n          // Compute acc values for a single thread.\n          for (var k = 0; k < ${a}; k = k + 1) {\n            let subRow = tileRow - ${t};\n            if (subRow < 0) {\n              continue;\n            }\n            acc = acc + mm_Asub2[subRow][k] * mm_Bsub2[k][tileCol];\n          }\n        }\n      }\n      workgroupBarrier();\n      if (t != 0) {\n        t = t + 1;\n      }\n\n      if (t < numTiles) {\n        if (tileRow < ${t}) {\n          // Load one tile of A and B into local memory.\n          // globalRow is always greater than or equal tileRow.\n          mm_Asub2[tileRow][tileCol] =\n              mm_readA((globalRow - tileRow) / 2 + tileRow, globalColA, globalId);\n          globalColA = globalColA + ${a};\n          mm_Bsub2[tileRow][tileCol] = mm_readB(globalRowB, globalCol, globalId);\n          globalRowB = globalRowB + ${a};\n        } else {\n          // Compute acc values for a single thread.\n          for (var k = 0; k < ${a}; k = k + 1) {\n            let subRow = tileRow - ${t};\n            if (subRow < 0) {\n              continue;\n            }\n            acc = acc + mm_Asub1[subRow][k] * mm_Bsub1[k][tileCol];\n          }\n        }\n      }\n      workgroupBarrier();\n    }\n    let writeCol = (globalRow - tileRow) / 2 + tileRow - ${t};\n    if (tileRow >= ${t} && writeCol >= 0) {\n      mm_write(writeCol, globalCol, acc, globalId);\n    }\n  }\n  `}var MatMulSmallOutputSizeProgram=class{constructor(e,t,n,a=null,r=null,s=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32; dimBOuter : i32; dimInner : i32;",this.workGroupSize=[8,16,1],util_exports.assert(e[1]<=16||t[2]<=16,(()=>"This program can be only used when A width or B Height are small")),this.outputShape=n,this.dispatchLayout={x:[2],y:[1],z:[0]},this.dispatch=[Math.ceil(n[2]/this.workGroupSize[0]),Math.ceil(2*n[1]/this.workGroupSize[1]),n[0]];const o=null!=a;o&&this.variableNames.push("bias");const i=null!=s;i&&this.variableNames.push("preluActivationWeights"),this.addBias=o,this.activation=r,this.hasPreluActivationWeights=i,this.shaderKey=`matMulSmallOutputSize_${this.activation}`}getUserCode(){let e="",t="";if(this.activation){const n=mapActivationToShaderProgram2(this.activation,!1);e=this.hasPreluActivationWeights?`fn activation(a : f32, outCoord : vec3<i32>) -> f32 {\n            let b = getPreluActivationWeightsAtOutCoordsByCoords(outCoord);\n            ${n}\n            }`:`fn activation(a : f32, outCoord : vec3<i32>) -> f32 {\n            ${n}\n        }`,t="value = activation(value, outCoord);"}return`\n      ${e}\n\n      fn mm_readA(row : i32, col : i32,  globalId : vec3<u32>) -> f32 {\n        let batchASize = uniforms.aShape[1] * uniforms.aShape[2];\n        let batch = i32(globalId.z);\n        if (coordsInBounds2D(vec2<i32>(row, col), vec2<i32>(uniforms.dimAOuter, uniforms.dimInner))) {\n          return A.numbers[batch * batchASize + row * uniforms.dimInner + col];\n        }\n        return 0.0;\n      }\n      fn mm_readB(row : i32, col : i32,  globalId : vec3<u32>) -> f32 {\n        let batch = i32(globalId.z);\n        let batchBSize = uniforms.bShape[1] * uniforms.bShape[2];\n        if (coordsInBounds2D(vec2<i32>(row, col), vec2<i32>(uniforms.dimInner, uniforms.dimBOuter))) {\n           return B.numbers[batch * batchBSize + row * uniforms.dimBOuter + col];\n         }\n         return 0.0;\n      }\n      fn mm_write(row : i32, col : i32, valueIn : f32, globalId : vec3<u32>) {\n        if (coordsInBounds2D(vec2<i32>(row, col), vec2<i32>(uniforms.dimAOuter, uniforms.dimBOuter))) {\n          let batch = i32(globalId.z);\n          let outCoord = vec3<i32>(batch, row, col);\n          var value = valueIn;\n          ${this.addBias?"value = value + getBiasAtOutCoordsByCoords(outCoord);":""}\n          ${t}\n          setOutput(batch, row, col, value);\n        }\n      }\n      ${makeMatMulSmallOutputSizeSource(this.workGroupSize)}\n    `}};function reshape5(e){const{inputs:t,attrs:n}=e,{x:a}=t,{shape:r}=n,s=util_exports.sizeFromShape(a.shape),o=util_exports.inferFromImplicitShape(r,s),i=util_exports.sizeFromShape(o);return util_exports.assert(s===i,(()=>`The new shape (${o}) has ${i} elements and the old shape (${a.shape}) has ${s} elements. The new shape and old shape must have the same number of elements.`)),e.backend.incRef(a.dataId),{dataId:a.dataId,shape:o,dtype:a.dtype}}var reshapeConfig3={kernelName:Reshape,backendName:"webgpu",kernelFunc:reshape5};function batchMatMulImpl2({a:e,b:t,transposeA:n,transposeB:a,backend:r,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:l=null}){const u=e.shape.length,c=t.shape.length,d=n?e.shape[u-2]:e.shape[u-1],p=a?t.shape[c-1]:t.shape[c-2],h=n?e.shape[u-1]:e.shape[u-2],m=a?t.shape[c-2]:t.shape[c-1],f=e.shape.slice(0,-2),g=t.shape.slice(0,-2),x=util_exports.sizeFromShape(f),y=util_exports.sizeFromShape(g),A=broadcast_util_exports.assertAndGetBroadcastShape(e.shape.slice(0,-2),t.shape.slice(0,-2)).concat([h,m]);util_exports.assert(d===p,(()=>`Error in matMul: inner shapes (${d}) and (${p}) of Tensors with shapes ${e.shape} and ${t.shape} and transposeA=${n} and transposeB=${a} must match.`));const b=n?[x,d,h]:[x,h,d],v=a?[y,m,p]:[y,p,m],k=reshape5({inputs:{x:e},backend:r,attrs:{shape:b}}),S=reshape5({inputs:{x:t},backend:r,attrs:{shape:v}}),w=[k,S],C=Math.max(x,y),I=d%4==0&&m%4==0&&!n&&!a&&m>=32;let T;T=h*m<=32?new MatMulReduceProgram([C,h,m],n,a,s,l,o):n||a||!(h<=16&&(m<=512||p>=2*m)||m<=16&&(h<=512||d>=2*h))?I?new MatMulPackedVec4Program(b,[C,h,m],env().get("WEBGPU_MATMUL_WORK_PER_THREAD"),s,l,o):new MatMulPackedProgram2(b,[C,h,m],env().get("WEBGPU_MATMUL_WORK_PER_THREAD"),n,a,s,l,o):new MatMulSmallOutputSizeProgram(b,v,[C,h,m],s,l,o);const N=[k,S];s&&N.push(s),o&&N.push(o);const _=[{type:"int32",data:[h]},{type:"int32",data:[m]},{type:"int32",data:[d]}],E=r.runWebGPUProgram(T,N,e.dtype,_),P=reshape5({inputs:{x:E},backend:r,attrs:{shape:A}});w.push(E);for(const e of w)r.disposeData(e.dataId);return P}function _fusedMatMul3(e){const{inputs:t,backend:n,attrs:a}=e,{a:r,b:s,bias:o,preluActivationWeights:i}=t,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:d}=a;return batchMatMulImpl2({a:r,b:s,transposeA:l,transposeB:u,backend:n,bias:o,preluActivationWeights:i,leakyreluAlpha:d,activation:c})}var _fusedMatMulConfig3={kernelName:_FusedMatMul,backendName:"webgpu",kernelFunc:_fusedMatMul3},BinaryOpComplexProgram2=class{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.workGroupSize=[128,1,1],this.size=!0,this.outputShape=backend_util_exports.assertAndGetBroadcastShape(t,n),this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey=`binaryOpComplex_${e}`,this.op=e}getUserCode(){return`\n      fn binaryOpComplex(\n          areal : f32, aimag : f32, breal : f32, bimag : f32) -> f32 {\n        ${getBinaryOpString(this.op,!1)}\n      }\n\n      ${getMainHeaderAndGlobalIndexString()}\n        if(index < uniforms.size) {\n          let areal = getARealAtOutCoordsByGlobalIndex(index);\n          let aimag = getAImagAtOutCoordsByGlobalIndex(index);\n          let breal = getBRealAtOutCoordsByGlobalIndex(index);\n          let bimag = getBImagAtOutCoordsByGlobalIndex(index);\n          setOutputFlat(index, binaryOpComplex(areal, aimag, breal, bimag));\n        }\n      }\n    `}},BinaryOpSharedProgram=class{constructor(e,t,n,a){this.variableNames=["A","B"],this.size=!0;this.workGroupSize=[256,1,1],this.outputShape=backend_util_exports.assertAndGetBroadcastShape(t,n),this.dispatchLayout=flatDispatchLayout(this.outputShape),this.lastDimensionSize=a?n[0]:t[0],this.lastDimensionSize<256?this.workPerThread=1:this.lastDimensionSize<512?this.workPerThread=2:this.workPerThread=4,this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]),this.useSharedMemoryWithB=a,this.op=e,this.shaderKey=`binaryShared_${e}_${this.lastDimensionSize}_${this.useSharedMemoryWithB}`}getUserCode(){const e=this.lastDimensionSize>1?`coords[${this.outputShape.length-1}]`:"0",t=this.useSharedMemoryWithB?`let a = getAAtOutCoordsByCoords(coords);\n         let b = sharedBuf[${e}];`:`let a = sharedBuf[${e}];\n         let b = getBAtOutCoordsByCoords(coords);`;return`\n        fn binaryOperation(a : f32, b : f32) -> f32 {\n          ${getBinaryOpString(this.op,!1)}\n        }\n        var<workgroup> sharedBuf : array<f32, ${this.lastDimensionSize}>;\n        ${getMainHeaderAndGlobalIndexString()}\n\n          // Fill in the shared memory buffer. Here we need a loop to make sure\n          // that all data in A|B are uploaded when |sharedMemorySize| is larger\n          // than work group size.\n          for(var localIndex = i32(localId.x); localIndex < ${this.lastDimensionSize}; localIndex = localIndex + ${this.workGroupSize[0]}) {\n            sharedBuf[localIndex] = f32(${this.useSharedMemoryWithB?"B":"A"}.numbers[localIndex]);\n          }\n          workgroupBarrier();\n\n          for(var i = 0; i < ${this.workPerThread}; i = i + 1) {\n            let flatIndex = index * ${this.workPerThread} + i;\n            if(flatIndex < uniforms.size) {\n              let coords = getCoordsFromFlatIndex(flatIndex);\n\n              ${t}\n              setOutputFlat(flatIndex, binaryOperation(a, b));\n            }\n          }\n        }\n        `}},BinaryOpVec4Program=class{constructor(e,t,n){this.variableNames=["A","B"],this.workPerThread=4,this.isVec4=!0,this.size=!0;this.workGroupSize=[128,1,1],this.outputShape=backend_util_exports.assertAndGetBroadcastShape(t,n),this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]),this.op=e,this.shaderKey=`binaryVec4_${e}`}getUserCode(){return`\n      fn binaryOperation(a : vec4<f32>, b : vec4<f32>) -> vec4<f32> {\n        ${getBinaryOpString(this.op,this.isVec4)}\n      }\n      ${getMainHeaderAndGlobalIndexString()}\n        if (index < uniforms.size) {\n          let a = getAAtOutCoordsByGlobalIndex(index);\n          let b = getBAtOutCoordsByGlobalIndex(index);\n          setOutputFlat(index, binaryOperation(a, b));\n        }\n      }\n    `}},BinaryOpProgram2=class{constructor(e,t,n){this.variableNames=["A","B"],this.size=!0;this.workGroupSize=[128,1,1],this.outputShape=backend_util_exports.assertAndGetBroadcastShape(t,n),this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey=`binary_${e}`,this.op=e}getUserCode(){return`\n      fn binaryOperation(a : f32, b : f32) -> f32 {\n        ${getBinaryOpString(this.op,!1)}\n      }\n      ${getMainHeaderAndGlobalIndexString()}\n        if (index < uniforms.size) {\n          let a = getAAtOutCoordsByGlobalIndex(index);\n          let b = getBAtOutCoordsByGlobalIndex(index);\n          setOutputFlat(index, binaryOperation(a, b));\n        }\n      }\n      `}};function getBinaryProgram(e,t,n){if(util_exports.arraysEqual(t,n)&&util_exports.sizeFromShape(t)%4==0)return new BinaryOpVec4Program(e,t,n);const a=1===t.length&&n.length>1&&t[0]<1024,r=1===n.length&&t.length>1&&n[0]<1024;return a||r?new BinaryOpSharedProgram(e,t,n,r):new BinaryOpProgram2(e,t,n)}function identity4(e){const{inputs:t}=e,{x:n}=t;return e.backend.incRef(n.dataId),{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}var identityConfig3={kernelName:Identity,backendName:"webgpu",kernelFunc:identity4};function complex4(e){const{inputs:t,backend:n}=e,{real:a,imag:r}=t,s=n.makeTensorInfo(a.shape,"complex64"),o=n.tensorMap.get(s.dataId),i=identity4({inputs:{x:a},backend:n}),l=identity4({inputs:{x:r},backend:n});return o.complexTensorInfos={real:i,imag:l},s}var complexConfig3={kernelName:Complex,backendName:"webgpu",kernelFunc:complex4},UnaryOpProgram2=class{constructor(e,t){this.variableNames=["A"],this.size=!0;this.workGroupSize=[128,1,1],this.outputShape=e,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workGroupSize),this.op=t,this.shaderKey=`unary_${t}`}getUserCode(){return`\n      fn unaryOperation(a : f32) -> f32 {\n        ${getUnaryOpString(this.op,!1)}\n      }\n      ${getMainHeaderAndGlobalIndexString()}\n        if (index < uniforms.size) {\n          let a = getAAtOutCoordsByGlobalIndex(index);\n          setOutputFlat(index, unaryOperation(a));\n        }\n      }\n      `}};function unaryKernelFunc3({opType:e,cpuKernelImpl:t,dtype:n}){return({inputs:a,backend:r})=>{const{x:s}=a,o=r,i=n||s.dtype;if(o.shouldExecuteOnCPU([s])&&null!=t){const e=o.tensorMap.get(s.dataId),n=t(e.values,i);return o.makeTensorInfo(s.shape,i,n)}const l=new UnaryOpProgram2(s.shape,e);return o.runWebGPUProgram(l,[s],i)}}function binaryKernelFunc3({opSnippet:e,cpuKernelImpl:t,supportsComplex:n=!1,dtype:a}){return({inputs:r,backend:s})=>{const{a:o,b:i}=r,l=s;if(n&&"complex64"===o.dtype){const t=l.tensorMap.get(o.dataId),n=l.tensorMap.get(i.dataId);let a,r;if(e!==BinaryOpType.MUL)[a,r]=[[t.complexTensorInfos.real,n.complexTensorInfos.real],[t.complexTensorInfos.imag,n.complexTensorInfos.imag]].map((t=>{const[n,a]=t,r={dataId:n.dataId,dtype:n.dtype,shape:o.shape},s={dataId:a.dataId,dtype:a.dtype,shape:i.shape},u=getBinaryProgram(e,o.shape,i.shape);return l.runWebGPUProgram(u,[r,s],upcastType(n.dtype,a.dtype))}));else{const e=new BinaryOpComplexProgram2(BinaryOpType.COMPLEX_MULTIPLY_REAL,o.shape,i.shape),s=new BinaryOpComplexProgram2(BinaryOpType.COMPLEX_MULTIPLY_IMAG,o.shape,i.shape),u=[{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:o.shape},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:o.shape},{dataId:n.complexTensorInfos.real.dataId,dtype:n.complexTensorInfos.real.dtype,shape:i.shape},{dataId:n.complexTensorInfos.imag.dataId,dtype:n.complexTensorInfos.imag.dtype,shape:i.shape}];a=l.runWebGPUProgram(e,u,"float32"),r=l.runWebGPUProgram(s,u,"float32")}const s=complex4({inputs:{real:a,imag:r},backend:l});return l.disposeData(a.dataId),l.disposeData(r.dataId),s}const u=a||upcastType(o.dtype,i.dtype);if(("string"===o.dtype||"string"===i.dtype||l.shouldExecuteOnCPU([o,i]))&&null!=t){const e=l.tensorMap.get(o.dataId).values,n=l.tensorMap.get(i.dataId).values,a="string"===o.dtype?backend_util_exports.fromUint8ToStringArray(e):e,r="string"===o.dtype?backend_util_exports.fromUint8ToStringArray(n):n,[s,c]=t(o.shape,i.shape,a,r,u);return l.makeTensorInfo(c,u,s)}const c=getBinaryProgram(e,o.shape,i.shape);return l.runWebGPUProgram(c,[o,i],u)}}var{addImpl:addImplCPU2,ceilImpl:ceilImplCPU2,concatImpl:concatImplCPU2,equalImpl:equalImplCPU2,expImpl:expImplCPU2,expm1Impl:expm1ImplCPU2,floorImpl:floorImplCPU2,gatherNdImpl:gatherNdImplCPU2,gatherV2Impl:gatherV2ImplCPU2,greaterEqualImpl:greaterEqualImplCPU2,greaterImpl:greaterImplCPU2,lessEqualImpl:lessEqualImplCPU2,lessImpl:lessImplCPU2,logImpl:logImplCPU2,maxImpl:maxImplCPU2,maximumImpl:maximumImplCPU2,minimumImpl:minimumImplCPU2,multiplyImpl:multiplyImplCPU2,negImpl:negImplCPU2,notEqualImpl:notEqualImplCPU2,prodImpl:prodImplCPU2,rangeImpl:rangeImplCPU2,rsqrtImpl:rsqrtImplCPU2,simpleAbsImpl:simpleAbsImplCPU2,sliceImpl:sliceImplCPU2,stridedSliceImpl:stridedSliceImplCPU2,stringNGramsImpl:stringNGramsImplCPU2,subImpl:subImplCPU2,tileImpl:tileImplCPU2,topKImpl:topKImplCPU2,transposeImpl:transposeImplCPU2,uniqueImpl:uniqueImplCPU2}=shared_exports,abs4=unaryKernelFunc3({opType:UnaryOpType.ABS,cpuKernelImpl:simpleAbsImplCPU2}),absConfig3={kernelName:Abs,backendName:"webgpu",kernelFunc:abs4},addKernelFunc2=binaryKernelFunc3({opSnippet:BinaryOpType.ADD,cpuKernelImpl:addImplCPU2,supportsComplex:!0}),addConfig3={kernelName:Add,backendName:"webgpu",kernelFunc:addKernelFunc2},AddNPackedProgram2=class{constructor(e){this.workPerThread=4,this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=e[0],this.variableNames=e.map(((e,t)=>`T${t}`)),this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]),this.shaderKey="addN"}getUserCode(){const e=[];this.variableNames.forEach((t=>{e.push(`let v${t} = get${t}AtOutCoordsByCoords(coords);`)}));const t=this.variableNames.map((e=>`v${e}`)).join(" + ");return`\n      ${getMainHeaderAndGlobalIndexString()}\n        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {\n          let flatIndex = index * ${this.workPerThread} + i;\n          if (flatIndex < uniforms.size) {\n            let coords = getCoordsFromFlatIndex(flatIndex);\n            ${e.join("\n        ")}\n            setOutputFlat(flatIndex, ${t});\n          }\n        }\n      }\n    `}};function addN4(e){const{inputs:t,backend:n}=e,a=t;if(1===a.length)return identity4({inputs:{x:a[0]},backend:n});const r=a.map((e=>e.dtype)).reduce(((e,t)=>upcastType(e,t))),s=a.map((e=>e.shape)),o=new AddNPackedProgram2(s);return n.runWebGPUProgram(o,a,r)}var addNConfig3={kernelName:AddN,backendName:"webgpu",kernelFunc:addN4},ArgMinMaxProgram2=class{constructor(e,t,n){this.variableNames=["x"],this.uniforms="axis : i32;";const a=[t];backend_util_exports.assertAxesAreInnerMostDims("arg"+n.charAt(0).toUpperCase()+n.slice(1),a,e.length),this.op="min"===n?"<":">";const[r,s]=backend_util_exports.computeOutAndReduceShapes(e,a);this.outputShape=0===r.length?[1]:r;const o=util_exports.sizeFromShape(s);this.reductionFactor=2;const i=Math.min(Math.ceil(o/this.reductionFactor),256);this.workGroupSize=[i,1,1],this.dispatchLayout={x:[],y:this.outputShape.map(((e,t)=>t))},this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workGroupSize),this.inputShape=e,this.shaderKey=`argMinMax${this.op}`}getUserCode(){const e=this.workGroupSize[0]>1,t=`\n      var<workgroup> xBestIndices : array<i32, ${this.workGroupSize[0]}>;\n      var<workgroup> xBestValues : array<f32, ${this.workGroupSize[0]}>;\n    `,n=`\n      xBestIndices[localId.x] = bestIndex;\n      xBestValues[localId.x] = bestValue;\n\n      for(var currentSize = WorkGroupSize; currentSize > 1; currentSize = DIV_CEIL(currentSize, ${this.reductionFactor})) {\n        workgroupBarrier();\n\n        for (var w = 0; w < ${this.reductionFactor}; w = w + 1) {\n          let i = i32(localId.x) * ${this.reductionFactor} + w;\n          if (i < currentSize) {\n            let candidateIndex = xBestIndices[i];\n            let candidate = xBestValues[i];\n            if(candidate ${this.op} bestValue && !isNanCustom(candidate)) {\n              bestValue = candidate;\n              bestIndex = candidateIndex;\n            }\n          }\n        }\n\n        xBestIndices[localId.x] = bestIndex;\n        xBestValues[localId.x] = bestValue;\n      }\n\n      if (localId.x == 0u) {\n        setOutputFlatI32(flatOutputIndex, i32(bestIndex));\n      }\n    `,a=e=>1===this.inputShape.length?"uniforms.xShape":`uniforms.xShape[${e}]`;return`\n      fn DIV_CEIL(a : i32, b : i32) -> i32 {\n        return ((a - 1) / b + 1);\n      }\n\n      let WorkGroupSize = ${this.workGroupSize[0]};\n\n      ${e?t:""}\n\n      // In order to get a flattened index into the input tensor, we need to\n      // add back the index along the reduced dimension to |outputCoords|.\n      // This function outputs the offset to the first value along\n      // |axis| and the stride to get the next value of the input along |axis|.\n      fn getInputCoordInfo(globalId : vec3<u32>) -> vec2<i32>{\n        let outputCoords = getOutputCoordsWithNonFlatDispatchLayout(globalId);\n        var i = ${this.outputShape.length-1};\n\n        var stride = 1;\n        var inputStride = 1;\n        var offset = 0;\n\n        for (var r = 1; r <= ${this.inputShape.length}; r = r + 1) {\n          let length = ${a(`${this.inputShape.length} - r`)};\n          if (${this.inputShape.length} - r == uniforms.axis) {\n            inputStride = stride;\n          } else {\n            offset = offset + ${((e,t)=>1===this.outputShape.length?e:`${e}[${t}]`)("outputCoords","i")} * stride;\n            i = i - 1;\n          }\n          stride = stride * length;\n        }\n\n        return vec2<i32>(offset, inputStride);\n      }\n\n      fn getInputIndex(coordInfo : vec2<i32>, index : i32) -> i32{\n        return coordInfo[0] + coordInfo[1] * index;\n      }\n\n      ${getNonFlatDispatchLayoutMainHeaderString()} {\n        let coordInfo = getInputCoordInfo(globalId);\n\n        var bestIndex = 0;\n        var bestValue = f32(x.numbers[getInputIndex(coordInfo, bestIndex)]);\n\n        let Length = ${a("uniforms.axis")};\n        let WorkPerThread = DIV_CEIL(Length, WorkGroupSize);\n\n        for (var w = 0; w < WorkPerThread; w = w + 1) {\n          let i = i32(globalId.x) * WorkPerThread + w;\n          if (i < Length) {\n            let candidate = f32(x.numbers[getInputIndex(coordInfo, i)]);\n            if (candidate ${this.op} bestValue && !isNanCustom(f32(candidate))) {\n              bestValue = candidate;\n              bestIndex = i;\n            }\n          }\n        }\n\n        let flatOutputIndex = i32(globalId.y);\n        ${e?n:"setOutputFlatI32(flatOutputIndex, bestIndex);"}\n      }\n    `}},TransposeSharedProgram=class{constructor(e,t){this.variableNames=["A"],this.workGroupSize=[16,16,1];const n=new Array(e.length);for(let a=0;a<n.length;a++)n[a]=e[t[a]];this.outputShape=n,this.dispatchLayout={x:[0],y:[1]},this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workGroupSize,[1,1,1]),this.shaderKey="transposeShared"}getUserCode(){return`\n      let TILE_DIM = ${this.workGroupSize[0]};\n      var<workgroup> tile : array<array<f32, ${this.workGroupSize[0]+1}>, ${this.workGroupSize[0]}>;\n      ${getWorkGroupSizeString()}\n      fn main([[builtin(local_invocation_id)]] localId : vec3<u32>,\n              [[builtin(workgroup_id)]] workgroupId : vec3<u32>) {\n        var x = i32(workgroupId.x) * TILE_DIM + i32(localId.x);\n        var y = i32(workgroupId.y) * TILE_DIM + i32(localId.y);\n        let width = uniforms.outShape[0];\n        let height = uniforms.outShape[1];\n        if (x < width && y < height) {\n          tile[localId.y][localId.x] =\n              A.numbers[y * width + x];\n        }\n        workgroupBarrier();\n\n        x = i32(workgroupId.y) * TILE_DIM + i32(localId.x);\n        y = i32(workgroupId.x) * TILE_DIM + i32(localId.y);\n        if (x < height && y < width) {\n          setOutputFlat((y * height + x), tile[localId.x]\n            [localId.y]);\n        }\n      }\n    `}},TransposeProgram2=class{constructor(e,t){this.variableNames=["A"],this.workPerThread=4,this.workGroupSize=[64,1,1],this.size=!0;const n=new Array(e.length);for(let a=0;a<n.length;a++)n[a]=e[t[a]];this.outputShape=n,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]),this.newDim=t,this.shaderKey=`transpose_${t}`}getUserCode(){const e=getCoordsDataType2(this.outputShape.length),t=getSwitchedCoords2(this.newDim);return`\n      ${getMainHeaderAndGlobalIndexString()}\n\n        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {\n          let flatIndex = index * ${this.workPerThread} + i;\n          if(flatIndex < uniforms.size) {\n            let resRC = getCoordsFromFlatIndex(flatIndex);\n            setOutputFlat(flatIndex, A.numbers[getFlatIndex${this.outputShape.length}D(\n              ${e}(${t}), uniforms.aShape)]);\n          }\n        }\n      }\n    `}};function getSwitchedCoords2(e){const t=e.length;if(t>4)throw Error(`Transpose for rank ${t} is not yet supported`);const n=new Array(t);for(let t=0;t<e.length;t++)n[e[t]]=`resRC[${t}]`;return n.join()}function transpose4(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{perm:s}=a,o=n,i=r.shape.length,l=new Array(i);for(let e=0;e<l.length;e++)l[e]=r.shape[s[e]];if(n.shouldExecuteOnCPU([r])){const e=o.tensorMap.get(r.dataId).values,t=transposeImplCPU2(e,r.shape,r.dtype,s,l);return n.makeTensorInfo(l,r.dtype,t)}if(2===r.shape.length&&util_exports.arraysEqual(s,[1,0])){const e=new TransposeSharedProgram(r.shape,s);return o.runWebGPUProgram(e,[r],r.dtype)}const u=new TransposeProgram2(r.shape,s);return o.runWebGPUProgram(u,[r],r.dtype)}var transposeConfig3={kernelName:Transpose,backendName:"webgpu",kernelFunc:transpose4};function argMax4(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s}=a;let o=util_exports.parseAxisParam(s,r.shape);const i=backend_util_exports.getAxesPermutation(o,r.shape.length);let l=r;const u=[];null!=i&&(l=transpose4({inputs:{x:r},backend:n,attrs:{perm:i}}),u.push(l),o=backend_util_exports.getInnerMostAxes(o.length,l.shape.length)),backend_util_exports.assertAxesAreInnerMostDims("argMax",[o[0]],l.shape.length);const c=new ArgMinMaxProgram2(l.shape,o[0],"max"),d=[{type:"int32",data:[o[0]]}],p=n.runWebGPUProgram(c,[l],"int32",d);return u.forEach((e=>n.disposeData(e.dataId))),p}var argMaxConfig3={kernelName:ArgMax,backendName:"webgpu",kernelFunc:argMax4};function argMin4(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s}=a;let o=util_exports.parseAxisParam(s,r.shape);const i=backend_util_exports.getAxesPermutation(o,r.shape.length);let l=r;const u=[];null!=i&&(l=transpose4({inputs:{x:r},backend:n,attrs:{perm:i}}),u.push(l),o=backend_util_exports.getInnerMostAxes(o.length,l.shape.length)),backend_util_exports.assertAxesAreInnerMostDims("argMin",[o[0]],l.shape.length);const c=new ArgMinMaxProgram2(l.shape,o[0],"min"),d=[{type:"int32",data:[o[0]]}],p=n.runWebGPUProgram(c,[l],"int32",d);return u.forEach((e=>n.disposeData(e.dataId))),p}var argMinConfig3={kernelName:ArgMin,backendName:"webgpu",kernelFunc:argMin4},Pool2DProgram2=class{constructor(e,t){this.variableNames=["x"],this.uniforms="stride : vec2<i32>; pad : vec2<i32>; dilation : vec2<i32>; convDims : vec2<i32>; filterDims : vec2<i32>;",this.workGroupSize=[128,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey=`pool2D_${t}`,this.poolType=t}getUserCode(){let e="resultValue = max(value, resultValue);";"avg"===this.poolType&&(e="resultValue = resultValue + value; count = count + 1.0;");let t="resultValue";"avg"===this.poolType&&(t="resultValue / count");return`\n      ${getMainHeaderAndGlobalIndexString()}\n      if (index < uniforms.size) {\n        let coords = getCoordsFromFlatIndex(index);\n          let batch = coords[0];\n          let xRCCorner = vec2<i32>(coords.yz) * uniforms.stride - uniforms.pad;\n          let xRCorner = xRCCorner.x;\n          let xCCorner = xRCCorner.y;\n\n          var resultValue = ${"avg"===this.poolType?"0.0":"-1.0 / pow(10.0, -20.0)"};\n          var count = 0.0;\n\n          for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + uniforms.dilation.x) {\n            let xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= uniforms.convDims.x) {\n              continue;\n            }\n\n            for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + uniforms.dilation.y) {\n              let xC = xCCorner + wC;\n              if (xC < 0 || xC >= uniforms.convDims.y) {\n                continue;\n              }\n\n              let value = getX(batch, xR, xC, coords[3]);\n              ${e}\n            }\n          }\n\n          setOutputFlat(index, ${t});\n        }\n      }\n    `}},PoolWithFilterSizeEqualsOneProgram=class{constructor(e){this.variableNames=["x"],this.uniforms="stride : vec2<i32>;",this.workGroupSize=[256,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="poolWithFilterSizeEqualsOne"}getUserCode(){return`\n      ${getMainHeaderAndGlobalIndexString()}\n        if (index < uniforms.size) {\n          let coords = getCoordsFromFlatIndex(index);\n          let batch = coords[0];\n          let d = coords[3];\n\n          let xRCCorner = coords.yz * uniforms.stride;\n          let xRCorner = xRCCorner.x;\n          let xCCorner = xRCCorner.y;\n\n          let value = getX(batch, xRCorner, xCCorner, d);\n          setOutputFlat(index, value);\n        }\n      }\n    `}};function avgPool4(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:s,strides:o,pad:i,dimRoundingMode:l}=a,u=backend_util_exports.computePool2DInfo(r.shape,s,o,1,i,l);if(1===u.filterWidth&&1===u.filterHeight&&util_exports.arraysEqual(u.inShape,u.outShape))return identity4({inputs:{x:r},backend:n});let c;const d=[{type:"int32",data:[u.strideHeight,u.strideWidth]}];return 1===u.filterHeight&&1===u.filterWidth?c=new PoolWithFilterSizeEqualsOneProgram(u):(c=new Pool2DProgram2(u,"avg"),d.push({type:"int32",data:[u.padInfo.top,u.padInfo.left]},{type:"int32",data:[u.dilationHeight,u.dilationWidth]},{type:"int32",data:[u.inHeight,u.inWidth]},{type:"int32",data:[u.effectiveFilterHeight,u.effectiveFilterWidth]})),n.runWebGPUProgram(c,[r],r.dtype,d)}var avgPoolConfig3={kernelName:AvgPool,backendName:"webgpu",kernelFunc:avgPool4};function batchMatMul3(e){const{inputs:t,backend:n,attrs:a}=e,{a:r,b:s}=t,{transposeA:o,transposeB:i}=a;return batchMatMulImpl2({a:r,b:s,transposeA:o,transposeB:i,backend:n})}var batchMatMulConfig3={kernelName:BatchMatMul,backendName:"webgpu",kernelFunc:batchMatMul3},SliceProgram2=class{constructor(e,t){this.variableNames=["source"],this.workPerThread=1,this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.rank=t.length,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]),this.start=e,this.uniforms=`start : ${getCoordsDataType2(e.length)}; `,this.shaderKey="slice"}getUserCode(){const e=getCoordsDataType2(this.rank),t=getCoords3(this.rank);let n;n=1===this.start.length?this.outputShape.map(((e,t)=>"sourceLoc = uniforms.start + coords;")):this.outputShape.map(((e,t)=>`sourceLoc.${coords2[t]} = uniforms.start[${t}] + coords.${coords2[t]};`));return`\n      ${getMainHeaderAndGlobalIndexString()}\n        if (index < uniforms.size) {\n          var sourceLoc : ${e};\n          let coords = getCoordsFromFlatIndex(index);\n          ${n.join("\n")}\n          setOutputFlat(index, getSource(${t}));\n        }\n      }\n    `}},coords2=["x","y","z","w","u","v"];function getCoords3(e){if(1===e)return"sourceLoc";if(e<=6)return coords2.slice(0,e).map((e=>`sourceLoc.${e}`)).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}function slice4(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{begin:s,size:o}=a,[i,l]=slice_util_exports.parseSliceParams(r,s,o);if(slice_util_exports.assertParamsValid(r,i,l),n.shouldExecuteOnCPU([r])||"string"===r.dtype){const e=n.tensorMap.get(r.dataId),t=sliceImplCPU2(e.values,i,l,r.shape,r.dtype);return n.makeTensorInfo(l,r.dtype,t)}if(0===util_exports.sizeFromShape(l))return n.makeTensorInfo(l,r.dtype,[]);const u=new SliceProgram2(i,l),c=[{type:"int32",data:i}];return n.runWebGPUProgram(u,[r],r.dtype,c)}var sliceConfig3={kernelName:Slice,backendName:"webgpu",kernelFunc:slice4},batchToSpaceND4=e=>{const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:s,crops:o}=a;util_exports.assert(r.shape.length<=4,(()=>"batchToSpaceND for rank > 4 with a WebGPU backend not implemented yet"));const i=s.reduce(((e,t)=>e*t)),l=backend_util_exports.getReshaped(r.shape,s,i),u=backend_util_exports.getPermuted(l.length,s.length),c=backend_util_exports.getReshapedPermuted(r.shape,s,i),d=backend_util_exports.getSliceBeginCoords(o,s.length),p=backend_util_exports.getSliceSize(c,o,s.length),h=[],m=reshape5({inputs:{x:r},backend:n,attrs:{shape:l}}),f=transpose4({inputs:{x:m},backend:n,attrs:{perm:u}}),g=reshape5({inputs:{x:f},backend:n,attrs:{shape:c}}),x=slice4({inputs:{x:g},backend:n,attrs:{begin:d,size:p}});return h.push(m),h.push(f),h.push(g),h.forEach((e=>n.disposeData(e.dataId))),x},batchToSpaceNDConfig3={kernelName:BatchToSpaceND,backendName:"webgpu",kernelFunc:batchToSpaceND4},notEqual4=binaryKernelFunc3({opSnippet:BinaryOpType.NOT_EQUAL,dtype:"bool",cpuKernelImpl:notEqualImplCPU2}),notEqualConfig3={kernelName:NotEqual,backendName:"webgpu",kernelFunc:notEqual4};function real4(e){const{inputs:t,backend:n}=e,{input:a}=t;return identity4({inputs:{x:n.tensorMap.get(a.dataId).complexTensorInfos.real},backend:n})}var realConfig3={kernelName:Real,backendName:"webgpu",kernelFunc:real4};function int2(e,t){const n=new UnaryOpProgram2(e.shape,UnaryOpType.TO_INT),a=t.runWebGPUProgram(n,[e],"int32");return{dataId:a.dataId,shape:a.shape,dtype:a.dtype}}function cast5(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{dtype:s}=a;if("complex64"===s){if("complex64"===r.dtype)return identity4({inputs:{x:r},backend:n});const e=zeros(r.shape),t=cast5({inputs:{x:r},backend:n,attrs:{dtype:"float32"}}),a=complex4({inputs:{real:t,imag:e},backend:n});return e.dispose(),n.disposeData(t.dataId),a}if("complex64"===r.dtype){const e=real4({inputs:{input:r},backend:n}),t=cast5({inputs:{x:e},backend:n,attrs:{dtype:s}});return n.disposeData(e.dataId),t}if(!util_exports.hasEncodingLoss(r.dtype,s)){const e=identity4({inputs:{x:r},backend:n});return{dataId:e.dataId,shape:e.shape,dtype:s}}if("int32"===s)return int2(r,n);if("bool"===s){const e=n.makeTensorInfo([],"bool",util_exports.getTypedArrayFromDType("bool",1)),t=notEqual4({inputs:{a:r,b:e},backend:n});return n.disposeData(e.dataId),t}throw new Error(`Error in Cast: failed to cast ${r.dtype} to ${s}`)}var castConfig3={kernelName:Cast,backendName:"webgpu",kernelFunc:cast5},ceil4=unaryKernelFunc3({opType:UnaryOpType.CEIL,cpuKernelImpl:ceilImplCPU2}),ceilConfig3={kernelName:Ceil,backendName:"webgpu",kernelFunc:ceil4},ClipVec4Program=class{constructor(e){this.variableNames=["A"],this.uniforms="minVal : f32; maxVal : f32;",this.workPerThread=4,this.workGroupSize=[64,1,1],this.isVec4=!0,this.size=!0,this.outputShape=e,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]),this.shaderKey="clipVec4"}getUserCode(){return`\n      ${getMainHeaderAndGlobalIndexString()}\n        if(index < uniforms.size) {\n          let value = getAAtOutCoordsByGlobalIndex(index);\n          var clampedValue : vec4<f32>;\n          for (var i = 0; i < 4; i = i + 1) {\n            if (isNanCustom(value[i])) {\n              clampedValue[i] = value[i];\n            } else {\n              clampedValue[i] = clamp(value[i], uniforms.minVal, uniforms.maxVal);\n            }\n          }\n\n          setOutputFlat(index, clampedValue);\n        }\n      }\n    `}},ClipProgram2=class{constructor(e){this.variableNames=["A"],this.uniforms="minVal : f32; maxVal : f32;",this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="clip"}getUserCode(){return`\n      ${getMainHeaderAndGlobalIndexString()}\n        if(index < uniforms.size) {\n          let value = getAAtOutCoordsByGlobalIndex(index);\n          if (isNanCustom(value)) {\n            setOutputFlat(index, value);\n            return;\n          }\n          setOutputFlat(index, clamp(value, uniforms.minVal, uniforms.maxVal));\n        }\n      }\n    `}};function clipByValue3(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{clipValueMin:s,clipValueMax:o}=a;let i;const l=[{type:"float32",data:[s]},{type:"float32",data:[o]}];return i=util_exports.sizeFromShape(r.shape)%4==0?new ClipVec4Program(r.shape):new ClipProgram2(r.shape),n.runWebGPUProgram(i,[r],r.dtype,l)}var clipByValueConfig2={kernelName:ClipByValue,backendName:"webgpu",kernelFunc:clipByValue3},ConcatProgram2=class{constructor(e){this.workPerThread=4,this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=backend_util_exports.computeOutShape(e,1),this.variableNames=e.map(((e,t)=>`T${t}`)),this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]),this.shapes=e,this.shaderKey=`concat${e}`}getUserCode(){const e=new Array(this.shapes.length-1),t=[];if(e.length>0){e[0]=this.shapes[0][1];for(let t=1;t<e.length;t++)e[t]=e[t-1]+this.shapes[t][1];t.push(`if (yC < ${e[0]}){ setOutput(coords.x, coords.y, getT0(yR, yC)); }`);for(let n=1;n<e.length;n++){const a=e[n-1];t.push(`elseif (yC < ${e[n]}){ setOutput(coords.x, coords.y, getT${n}(yR, yC - ${a})); }`)}const n=e.length,a=e[e.length-1];t.push(`else { setOutput(coords.x, coords.y, getT${n}(yR, yC - ${a})); }`)}else t.push("setOutput(coords.x, coords.y, getT0(yR, yC));");return`\n      ${getMainHeaderAndGlobalIndexString()}\n        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {\n          let flatIndex = index * ${this.workPerThread} + i;\n          if(flatIndex < uniforms.size) {\n            let coords = getCoordsFromFlatIndex(flatIndex);\n            let yR = coords.x;\n            let yC = coords.y;\n\n            ${t.join("\n        ")}\n          }\n        }\n      }\n    `}};function imag4(e){const{inputs:t,backend:n}=e,{input:a}=t;return identity4({inputs:{x:n.tensorMap.get(a.dataId).complexTensorInfos.imag},backend:n})}var imagConfig3={kernelName:Imag,backendName:"webgpu",kernelFunc:imag4};function concatImpl3(e,t,n){const a=e[0].dtype;if("complex64"===a){const a=e.map((e=>real4({inputs:{input:e},backend:n}))),r=e.map((e=>imag4({inputs:{input:e},backend:n}))),s=concatImpl3(a,t,n),o=concatImpl3(r,t,n),i=complex4({inputs:{real:s,imag:o},backend:n});return a.forEach((e=>n.disposeData(e.dataId))),r.forEach((e=>n.disposeData(e.dataId))),n.disposeData(s.dataId),n.disposeData(o.dataId),i}let r=n.shouldExecuteOnCPU(e);if("string"===a&&(r=!0),r){const r=e.map((e=>{const a=util_exports.sizeFromShape(e.shape.slice(t));return reshape5({inputs:{x:e},backend:n,attrs:{shape:[-1,a]}})})),s=r.map((e=>({vals:n.readSync(e.dataId),shape:e.shape}))),o=backend_util_exports.computeOutShape(r.map((e=>e.shape)),1),i=1===r[0].shape[0],l=concatImplCPU2(s,o,a,i),u=backend_util_exports.computeOutShape(e.map((e=>e.shape)),t),c=n.makeTensorInfo(u,a,l);return r.forEach((e=>n.disposeData(e.dataId))),c}const{tensors2D:s,outShape:o}=computeTensors2D2(e,t,n),i=new ConcatProgram2(s.map((e=>e.shape))),l=n.runWebGPUProgram(i,s,s[0].dtype);s.forEach((e=>n.disposeData(e.dataId)));const u=reshape5({inputs:{x:l},backend:n,attrs:{shape:o}});return n.disposeData(l.dataId),u}function computeTensors2D2(e,t,n){const a=backend_util_exports.computeOutShape(e.map((e=>e.shape)),t);return{tensors2D:e.map((e=>reshape5({inputs:{x:e},backend:n,attrs:{shape:[util_exports.sizeFromShape(e.shape.slice(0,t)),util_exports.sizeFromShape(e.shape.slice(t))]}}))),outShape:a}}function concat4(e){const{inputs:t,backend:n,attrs:a}=e,{axis:r}=a,s=util_exports.parseAxisParam(r,t[0].shape)[0],o=backend_util_exports.computeOutShape(t.map((e=>e.shape)),s);if(0===util_exports.sizeFromShape(o))return n.makeTensorInfo(o,t[0].dtype,[]);const i=t.filter((e=>util_exports.sizeFromShape(e.shape)>0));if(1===i.length)return identity4({inputs:{x:i[0]},backend:n});const l=i.map((e=>e.shape));return backend_util_exports.assertParamsConsistent(l,s),concatImpl3(i,s,n)}var concatConfig3={kernelName:Concat,backendName:"webgpu",kernelFunc:concat4},Im2ColProgram=class{constructor(e,t){this.variableNames=["A"],this.uniforms="pad : vec2<i32>; stride : vec2<i32>; dilation : vec2<i32>; outWidth : i32; itemsPerBlockRow : i32;\n      inChannels : i32;",this.workPerThread=4,this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]),this.isChannelsLast=t,this.shaderKey=`im2col_${this.isChannelsLast}`}getUserCode(){const e=this.isChannelsLast?0:1,t=this.isChannelsLast?1:2;return`\n    ${getMainHeaderAndGlobalIndexString()}\n\n      for(var i = 0; i<${this.workPerThread}; i = i + 1) {\n        let flatIndex = index * ${this.workPerThread} + i;\n\n        let rc = getCoordsFromFlatIndex(flatIndex);\n\n        if(flatIndex < uniforms.size) {\n          let blockIndex = rc[0];\n          let pos = rc[1];\n\n          let offsetY = blockIndex / uniforms.outWidth * uniforms.stride[1] - uniforms.pad[1];\n          let d0 = offsetY + uniforms.dilation[1] * pos / uniforms.itemsPerBlockRow;\n          var value = 0.0;\n          if(d0 < uniforms.aShape[${e}] && d0 >= 0) {\n            let offsetX = (blockIndex % uniforms.outWidth) * uniforms.stride[0] -\n              uniforms.pad[0];\n            let d1 = offsetX + uniforms.dilation[0] * ((pos %\n              uniforms.itemsPerBlockRow) / uniforms.inChannels);\n            let ch = pos % uniforms.inChannels;\n            if(d1 < uniforms.aShape[${t}] && d1 >= 0) {\n              value = getA(d0, d1, ch);\n            }\n          }\n          setOutputFlat(flatIndex, value);\n        }\n      }\n    }\n  `}};function conv2dByMatMul2({x:e,filter:t,convInfo:n,backend:a,bias:r=null,preluActivationWeights:s=null,leakyreluAlpha:o=0,activation:i=null}){const l=e.shape,u=reshape5({inputs:{x:e},backend:a,attrs:{shape:[1,"channelsLast"===n.dataFormat?l[0]*l[1]*l[2]:l[0]*l[2]*l[3],n.inChannels]}}),c=reshape5({inputs:{x:t},backend:a,attrs:{shape:[1,n.inChannels,n.outChannels]}}),d=batchMatMulImpl2({a:u,b:c,transposeA:!1,transposeB:!1,backend:a,bias:r,activation:i,preluActivationWeights:s,leakyreluAlpha:o}),p=reshape5({inputs:{x:d},backend:a,attrs:{shape:n.outShape}});return a.disposeData(u.dataId),a.disposeData(c.dataId),a.disposeData(d.dataId),p}function conv2dWithIm2Col({x:e,filter:t,convInfo:n,backend:a,bias:r=null,preluActivationWeights:s=null,leakyreluAlpha:o=0,activation:i=null}){const{filterWidth:l,filterHeight:u,inChannels:c,strideWidth:d,strideHeight:p,padInfo:h,outWidth:m,outHeight:f,dilationWidth:g,dilationHeight:x,dataFormat:y}=n,A="channelsLast"===y,b=l*u*c,v=f*m,k=[v,b],S=[],w=reshape5({inputs:{x:e},backend:a,attrs:{shape:e.shape.slice(1)}}),C=reshape5({inputs:{x:t},backend:a,attrs:{shape:[1,b,-1]}});S.push(w),S.push(C);const I=new Im2ColProgram(k,A),T=[{type:"int32",data:[h.left,h.top]},{type:"int32",data:[d,p]},{type:"int32",data:[g,x]},{type:"int32",data:[m]},{type:"int32",data:[c*l]},{type:"int32",data:[c]}],N=a.runWebGPUProgram(I,[w],w.dtype,T),_=reshape5({inputs:{x:N},backend:a,attrs:{shape:[1,k[0],k[1]]}});S.push(N),S.push(_);const E=[1,k[0],k[1]],P=new MatMulPackedProgram2(E,[1,v,n.outChannels],env().get("WEBGPU_MATMUL_WORK_PER_THREAD"),!1,!1),R=E[2],M=[{type:"int32",data:[E[1]]},{type:"int32",data:[n.outChannels]},{type:"int32",data:[R]}],F=a.runWebGPUProgram(P,[_,C],_.dtype,M),D=reshape5({inputs:{x:F},backend:a,attrs:{shape:A?[1,f,m,n.outChannels]:[1,n.outChannels,f,m]}});S.push(F);for(const e of S)a.disposeData(e.dataId);return D}var Conv2DMMVec4Program=class{constructor(e,t=!1,n=null,a=!1,r=!1){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>; pad : vec2<i32>; stride : vec2<i32>; dilation : vec2<i32>;\n      dimAOuter : i32; dimBOuter : i32; dimInner : i32;",this.isVec4=!0,this.outputShape=e.outShape,util_exports.assert("channelsLast"===e.dataFormat,(()=>"TODO: NCHW is unimplemented")),this.dispatchLayout={x:[3],y:[1,2],z:[0]},this.workGroupSize=[8,8,1];const s=[4,4,1];this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workGroupSize,s),this.convInfo=e,this.addBias=t,this.activation=n,this.hasPreluActivationWeights=a,this.hasLeakyreluAlpha=r,this.addBias&&this.variableNames.push("bias"),this.hasPreluActivationWeights&&this.variableNames.push("preluActivationWeights"),this.hasLeakyreluAlpha&&this.variableNames.push("leakyreluAlpha"),[this.fitA,this.fitB]=this.getShapeFit(s),this.shaderKey=`conv2DMMVec4_${this.activation}_${this.fitA}_${this.fitB}`}getShapeFit(e){const t=this.workGroupSize[1]*e[1],n=this.workGroupSize[0]*e[0],a=[t,n],r=[n,n],s=this.outputShape[1]*this.outputShape[2],o=this.outputShape[3],i=this.convInfo.filterHeight*this.convInfo.filterWidth*this.convInfo.inChannels;return[tilesFitEvenlyIntoShape(a,[s,i]),tilesFitEvenlyIntoShape(r,[i,o])]}getSampleAWithRemainder(e){return`let flatIndex${e} = getFlatIndex4D(coord, uniforms.xShape);\n    let divBy4Remainder${e} = flatIndex${e} % 4;\n    let divBy4Index${e} = flatIndex${e} / 4;\n    let curData${e} = x.numbers[divBy4Index${e}];\n    if (divBy4Remainder${e} == 0) {\n      temp = curData${e};\n    } else {\n      // TODO: This could end up being a redundant load with another one in\n      // the same shader invocation. Perhaps there's an opportunity for\n      // optimization\n      let nextData${e} = x.numbers[divBy4Index${e} + 1];\n      if (divBy4Remainder${e} == 1) {\n        temp = vec4<f32>(curData${e}.yzw, nextData${e}.x);\n      } elseif (divBy4Remainder${e} == 2) {\n        temp = vec4<f32>(curData${e}.zw, nextData${e}.xy);\n      } elseif (divBy4Remainder${e} == 3) {\n        temp = vec4<f32>(curData${e}.w, nextData${e}.xyz);\n      }\n    }\n    `}getUserCode(){const e=makeMatMulPackedVec4Source([4,4,1],this.workGroupSize),t=`let outRow = r / uniforms.outShape[2];\n        let outCol = r % uniforms.outShape[2];\n        let WRow = c / (uniforms.filterDims[1] * uniforms.xShape[3]);\n        let WCol = c / uniforms.xShape[3] % uniforms.filterDims[1];\n        let inChCoord = c % uniforms.xShape[3];\n        var coord = vec4<i32>(\n            batch,\n            outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0],\n            outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1],\n            inChCoord);\n        var resData = vec4<f32>(0.0);\n        ${0===this.convInfo.inChannels%4?"// The bounds checking is always needed since we use it to pad zero for\n          // the 'same' padding type.\n          if (coordsInBounds4D(coord, uniforms.xShape)) {\n            resData = x.numbers[getFlatIndex4D(coord, uniforms.xShape) / 4];\n          } else {\n            resData = vec4<f32>(0.0); }":`var temp = vec4<f32>(0.0);\n          ${this.getSampleAWithRemainder(1)}\n          resData = temp;\n          if (WCol == (uniforms.filterDims[1] - 1)) {\n            coord = vec4<i32>(\n              coord.x, coord.y + 1, coord.z + 1 - uniforms.filterDims[1], 0);\n              ${this.getSampleAWithRemainder(2)}\n            if (inChCoord == 0) {\n              resData = vec4<f32>(resData.xyz, temp.x);\n            } elseif (inChCoord == 1) {\n              resData = vec4<f32>(resData.xy, temp.xy);\n            } else {\n              resData = vec4<f32>(resData.x, temp.xyz);\n            }\n          }\n          `}\n        return resData;`,n=this.fitA?`${t}`:`if (r < uniforms.dimAOuter && c < uniforms.dimInner) {\n          ${t}\n         }\n         return vec4<f32>(0.0);\n        `,a=this.fitB?"return W.numbers[row * uniforms.dimBOuter / 4 + col];":"if(coordsInBounds2D(vec2<i32>(row, col * 4), vec2<i32>(uniforms.dimInner, uniforms.dimBOuter))) {\n           return W.numbers[row * uniforms.dimBOuter / 4 + col];\n         }\n         return vec4<f32>(0.0);\n        ";let r="",s="";if(this.activation){const e=mapActivationToShaderProgram2(this.activation,this.isVec4);if(this.hasPreluActivationWeights)r=`fn activation(a : vec4<f32>, outCoord : vec4<i32>) -> vec4<f32> {\n          let b = getPreluActivationWeightsAtOutCoordsByCoords(outCoord);\n          ${e}\n        }`;else{if(this.hasLeakyreluAlpha)throw r=`fn activation(a: vec4<f32>) -> vec4<f32> {\n          let b = getLeakyreluAlphaAtOutCoords();\n          ${e}\n        }`,new Error("Leakyrelu is not supported.");r=`\n        fn activation(a : vec4<f32>, outCoord : vec4<i32>) -> vec4<f32> {\n          ${e}\n        }`}s="value = activation(value, outCoord);"}return`\n        ${r}\n        fn mm_readA(row : i32, col : i32, globalId : vec3<u32>) -> vec4<f32> {\n          let r = row;\n          let c = col * 4;\n          var batch = i32(globalId.z);\n          ${n}\n        }\n\n        fn mm_readB(row : i32, col : i32, globalId : vec3<u32>) -> vec4<f32> {\n          ${a}\n        }\n\n        fn mm_write(row : i32, col : i32, valueInput : vec4<f32>, globalId : vec3<u32>) {\n          var batch = i32(globalId.z);\n          var value = valueInput;\n          if (row < uniforms.dimAOuter && col * 4 < uniforms.dimBOuter)\n          {\n            let outCoord = vec4<i32>(\n              batch,\n              row / uniforms.outShape[2],\n              row % uniforms.outShape[2],\n              col * 4);\n            ${this.addBias?"value = value + getBiasAtOutCoordsByCoords(outCoord);":""}\n            ${s}\n            setOutput(outCoord[0], outCoord[1], outCoord[2], outCoord[3],\n              value);\n          }\n        }\n        ${e}\n      `}},Conv2DMMProgram=class{constructor(e,t=!1,n=null,a=!1){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>; pad : vec2<i32>; stride : vec2<i32>; dilation : vec2<i32>; dimAOuter : i32; dimBOuter : i32; dimInner : i32;",this.outputShape=e.outShape,util_exports.assert("channelsLast"===e.dataFormat,(()=>"TODO: NCHW is unimplemented")),this.dispatchLayout={x:[3],y:[1,2],z:[0]},this.workGroupSize=computeWorkGroupSizeForConv2d(this.dispatchLayout,this.outputShape),this.elementsPerThread=computeWorkPerThreadForConv2d(this.dispatchLayout,this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workGroupSize,this.elementsPerThread),t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=t,this.activation=n,this.hasPreluActivationWeights=a,[this.fitA,this.fitB]=this.getShapeFit(),this.shaderKey=`conv2DMM_${this.elementsPerThread}_${this.activation}_${this.fitA}_${this.fitB}`}getShapeFit(){const e=this.workGroupSize[1]*this.elementsPerThread[1],t=this.workGroupSize[0]*this.elementsPerThread[0],n=e>t?e:t;util_exports.assert(n%this.workGroupSize[0]==0&&n%this.workGroupSize[1]==0,(()=>"tileInner must be multiple of workgroupsize.x and workgroupsize.y"));const a=[e,n],r=[n,t],s=this.outputShape[1]*this.outputShape[2],o=this.outputShape[3],i=this.convInfo.filterHeight*this.convInfo.filterWidth*this.convInfo.inChannels;return[tilesFitEvenlyIntoShape(a,[s,i]),tilesFitEvenlyIntoShape(r,[i,o])]}getUserCode(){const e=makeMatMulPackedSource(this.elementsPerThread,this.workGroupSize),t="\n    let outRow = row / uniforms.outShape[2];\n    let outCol = row % uniforms.outShape[2];\n\n    let WRow = col / (uniforms.filterDims[1] * uniforms.xShape[3]);\n    let WCol = col / uniforms.xShape[3] % uniforms.filterDims[1];\n    let coord = vec4<i32>(\n        batch,\n        outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0],\n        outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1],\n        col % uniforms.xShape[3]);\n    // The bounds checking is always needed since we use it to pad zero for the\n    // 'same' padding type.\n    if(coordsInBounds4D(coord, uniforms.xShape)) {\n      return x.numbers[getFlatIndex4D(coord, uniforms.xShape)];\n    }\n    return 0.0;",n=this.fitA?`${t}`:`if (row < uniforms.dimAOuter && col < uniforms.dimInner) {\n      ${t}\n    }\n    return 0.0;\n    `,a=this.fitB?"return W.numbers[row * uniforms.dimBOuter + col];":"if(coordsInBounds2D(vec2<i32>(row, col), vec2<i32>(uniforms.dimInner, uniforms.dimBOuter))) {\n           return W.numbers[row * uniforms.dimBOuter + col];\n\t }\n\t return 0.0;\n\t ";let r="",s="";if(this.activation){const e=mapActivationToShaderProgram2(this.activation,!1);r=this.hasPreluActivationWeights?`fn activation(a: f32, outCoord : vec4<i32>) -> f32 {\n                  let b = getPreluActivationWeightsAtOutCoordsByCoords(outCoord);\n                  ${e}\n                }`:`\n                  fn activation(a : f32, outCoord : vec4<i32>) -> f32 {\n                    ${e}\n                  }\n                `,s="value = activation(value, outCoord);"}return`\n    ${r}\n    fn mm_readA(row : i32, col : i32, globalId : vec3<u32>) -> f32 {\n      var batch = i32(globalId.z);\n      ${n}\n    }\n\n    fn mm_readB(row : i32, col : i32, globalId : vec3<u32>) -> f32 {\n      ${a}\n    }\n\n    fn mm_write(row : i32, col : i32, valueInput : f32, globalId : vec3<u32>) {\n      var batch = i32(globalId.z);\n      var value = valueInput;\n      let outCoord = vec4<i32>(\n          batch,\n          row / uniforms.outShape[2],\n          row % uniforms.outShape[2],\n          col);\n      ${this.addBias?"value = value + getBiasAtOutCoordsByCoords(outCoord);":""}\n      ${s}\n      result.numbers[getFlatIndex4D(outCoord, uniforms.outShape)] = value;\n    }\n    ${e}\n  `}},Conv2DNaiveProgram=class{constructor(e,t=!1,n=null,a=!1){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>; pad : vec2<i32>; stride : vec2<i32>; dilation : vec2<i32>;",this.workGroupSize=[128,1,1],this.outputShape=e.outShape,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workGroupSize),util_exports.assert("channelsLast"===e.dataFormat,(()=>"TODO: NCHW is unimplemented")),t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=t,this.activation=n,this.hasPreluActivationWeights=a,this.shaderKey=`conv2DNaive_${this.activation}`}getUserCode(){let e="",t="";if(this.activation){const n=mapActivationToShaderProgram2(this.activation);e=this.hasPreluActivationWeights?`fn activation(a : f32, outCoord : vec4<i32>) -> f32{\n               let b = getPreluActivationWeightsAtOutCoordsByCoords(outCoord);\n               ${n}\n             }`:`\n                  fn activation(a : f32, outCoord : vec4<i32>) -> f32{\n                    ${n}\n                  }\n                `,t="value = activation(value, outCoord);"}return`\n      ${e}\n      fn readInp(batch : i32, row : i32, col : i32, chan : i32) -> f32 {\n        let coord = vec4<i32>(batch, row, col, chan);\n        if(coordsInBounds4D(coord, uniforms.xShape)) {\n          return getX(batch, row, col, chan);\n        }\n        return 0.0;\n      }\n\n      fn readFilt(row : i32, col : i32, xChannel : i32, outChannel : i32) -> f32{\n        let coord = vec4<i32>(row, col, xChannel, outChannel);\n        if(coordsInBounds4D(coord, uniforms.wShape)) {\n          return getW(row, col, xChannel, outChannel);\n        }\n        return 0.0;\n      }\n\n      fn writeResult(batch : i32, row : i32, col : i32, chan : i32, value : f32) {\n        let coord = vec4<i32>(batch, row, col, chan);\n        if (coordsInBounds4D(coord, uniforms.outShape)) {\n          ${this.addBias?"value = value + getBiasAtOutCoordsByCoords(outCoord);":""}\n          ${t}\n          setOutput(batch, row, col, chan, value);\n        }\n      }\n\n      ${getFlatDispatchLayoutMainHeaderString()} {\n        let coords = getOutputCoordsWithFlatDispatchLayout(globalId, localId, numWorkgroups);\n        let batch = coords[0];\n        let outChannel = coords[3];\n\n        var acc = 0.0;\n\n        for (var row = 0; row < uniforms.filterDims[0]; row = row + 1) {\n          for (var col = 0; col < uniforms.filterDims[1]; col = col + 1) {\n            for (var xChannel = 0; xChannel < uniforms.xShape[3]; xChannel = xChannel + 1) {\n              let coordRow = coords[1] * uniforms.stride[0] + uniforms.dilation[0] * row - uniforms.pad[0];\n              let coordCol = coords[2] * uniforms.stride[1] + uniforms.dilation[1] * col - uniforms.pad[1];\n              let v = readInp(batch, coordRow, coordCol, xChannel);\n              let f = readFilt(row, col, xChannel, outChannel);\n              acc = acc + v * f;\n            }\n          }\n        }\n\n        writeResult(batch, coords[1], coords[2], outChannel, acc);\n      }\n    `}};function conv2d5(e){const{inputs:t,attrs:n,backend:a}=e,{x:r,filter:s}=t,{strides:o,pad:i,dataFormat:l,dilations:u,dimRoundingMode:c}=n,d=backend_util_exports.convertConv2DDataFormat(l),p=backend_util_exports.computeConv2DInfo(r.shape,s.shape,o,u,i,c,!1,d);if(1===p.filterHeight&&1===p.filterWidth&&1===p.dilationHeight&&1===p.dilationWidth&&1===p.strideHeight&&1===p.strideWidth&&("SAME"===p.padInfo.type||"VALID"===p.padInfo.type))return conv2dByMatMul2({x:r,filter:s,convInfo:p,backend:a});if(env().getBool("WEBGPU_CONV_SEPARATE_IM2COL_SHADER")&&1===r.shape[0])return conv2dWithIm2Col({x:r,filter:s,convInfo:p,backend:a});let h;const m=[p.padInfo.top,p.padInfo.left],f=[{type:"int32",data:[p.filterHeight,p.filterWidth]},{type:"int32",data:[...m]},{type:"int32",data:[p.strideHeight,p.strideWidth]},{type:"int32",data:[p.dilationHeight,p.dilationWidth]}],g=env().getBool("WEBGPU_USE_NAIVE_CONV2D");if(h=g?new Conv2DNaiveProgram(p):(p.inChannels%4==0||3===p.inChannels&&"VALID"===p.padInfo.type)&&p.outChannels%4==0&&p.outChannels>=64?new Conv2DMMVec4Program(p):new Conv2DMMProgram(p),!g){const e=p.outShape[1]*p.outShape[2],t=p.outShape[3],n=p.filterHeight*p.filterWidth*p.inShape[3];f.push({type:"int32",data:[e]},{type:"int32",data:[t]},{type:"int32",data:[n]})}return a.runWebGPUProgram(h,[r,s],r.dtype,f)}var conv2DConfig3={kernelName:Conv2D,backendName:"webgpu",kernelFunc:conv2d5},Conv2DDerInputMMProgram=class{constructor(e){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>; pads : vec2<i32>; stride : vec2<i32>; outBackprop : vec4<i32>; dimAOuter : i32; dimBOuter : i32; dimInner : i32;",this.outputShape=e.inShape,util_exports.assert("channelsLast"===e.dataFormat,(()=>"TODO: NCHW is unimplemented")),this.dispatchLayout={x:[3],y:[1,2],z:[0]},this.workGroupSize=computeWorkGroupSizeForConv2d(this.dispatchLayout,this.outputShape),this.elementsPerThread=computeWorkPerThreadForConv2d(this.dispatchLayout,this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workGroupSize,this.elementsPerThread),this.shaderKey=`conv2DDerInputMM_${this.elementsPerThread}`}getUserCode(){return`\n    fn mm_readA(row : i32, col : i32, globalId : vec3<u32>) -> f32 {\n      var batch = i32(globalId.z);\n      if (row < uniforms.dimAOuter && col < uniforms.dimInner) {\n      \n    let outRow = row / uniforms.outShape[2];\n    let outCol = row % uniforms.outShape[2];\n\n    let WRow = col / (uniforms.filterDims[1] * uniforms.outBackprop[3]);\n    let WCol = col / uniforms.outBackprop[3] % uniforms.filterDims[1];\n    let xR = f32(outRow - uniforms.pads[0] + WRow) / f32(uniforms.stride[0]);\n    let xC = f32(outCol - uniforms.pads[1] + WCol) / f32(uniforms.stride[1]);\n    if (xR < 0.0 || xR >= f32(uniforms.outBackprop[1]) || fract(xR) > 0.0) {\n      return 0.0;\n    }\n    if (xC < 0.0 || xC >= f32(uniforms.outBackprop[2]) || fract(xC) > 0.0) {\n      return 0.0;\n    }\n    let coord = vec4<i32>(\n        batch,\n        i32(xR),\n        i32(xC),\n        col % uniforms.outBackprop[3]);\n    return x.numbers[getFlatIndex4D(coord, uniforms.xShape)];\n    }\n    return 0.0;\n    }\n\n    fn mm_readB(row : i32, col : i32, globalId : vec3<u32>) -> f32 {\n      let coordX = uniforms.filterDims.x - 1 -\n          row / (uniforms.filterDims[1] * uniforms.outBackprop[3]);\n      let coordY = uniforms.filterDims.y - 1 -\n          (row / uniforms.outBackprop[3]) % uniforms.filterDims[1];\n      if (row < uniforms.dimInner && col < uniforms.dimBOuter &&\n          coordX >= 0 && coordY >= 0) {\n        let coord = vec4<i32>(coordX, coordY, col,\n            row % uniforms.outBackprop[3]);\n        return W.numbers[getFlatIndex4D(coord, uniforms.wShape)];\n      }\n      return 0.0;\n    }\n\n    fn mm_write(row : i32, col : i32, valueInput : f32, globalId : vec3<u32>) {\n      var batch = i32(globalId.z);\n      var value = valueInput;\n      let outCoord = vec4<i32>(\n          batch,\n          row / uniforms.outShape[2],\n          row % uniforms.outShape[2],\n          col);\n      result.numbers[getFlatIndex4D(outCoord, uniforms.outShape)] = value;\n    }\n\n    ${makeMatMulPackedSource(this.elementsPerThread,this.workGroupSize)}\n  `}},Conv2DDerInputProgram2=class{constructor(e){this.variableNames=["dy","W"],this.uniforms="filterDims : vec2<i32>; pads : vec2<i32>; stride : vec2<i32>; outBackprop : vec4<i32>;",this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workGroupSize),this.isChannelsLast="channelsLast"===e.dataFormat,this.shaderKey=`conv2DDerInput_${this.isChannelsLast}`}getUserCode(){const e=this.isChannelsLast?1:2,t=this.isChannelsLast?2:3,n=this.isChannelsLast?3:1;return`\n    ${getMainHeaderAndGlobalIndexString()} {\n      if(index < uniforms.size) {\n        let coords = getCoordsFromFlatIndex(index);\n        let batch = coords[0];\n        let d1 = coords[${n}];\n\n        let dyCorner = vec2<i32>(coords[${e}]), coords[${t}]) - uniforms.pads;\n        let dyRCorner = dyCorner.x;\n        let dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd = 0.0;\n        for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {\n          let dyR = (f32(dyRCorner) + f32(wR)) / f32(uniforms.stride.x);\n          let wRPerm = uniforms.filterDims.x - 1 - wR;\n          if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) || fract(dyR) > 0.0 ||\n              wRPerm < 0) {\n            continue;\n          }\n          let idyR = dyR;\n\n          for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {\n            let dyC = (f32(dyCCorner) + f32(wC)) / f32(uniforms.stride.y);\n            let wCPerm = uniforms.filterDims.y - 1 - wC;\n            if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||\n                fract(dyC) > 0.0 || wCPerm < 0) {\n              continue;\n            }\n            let idyC = dyC;\n\n            for (var d2 = 0; d2 < uniforms.outBackprop[3]; d2 = d2 + 1) {\n              if (${this.isChannelsLast}) {\n                let xValue = getDy(batch, idyR, idyC, d2);\n                let wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd = dotProd + xValue * wValue;\n              } else {\n                let xValue = getDy(batch, d2, idyR, idyC);\n                let wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd = dotProd + xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutputFlat(index, dotProd);\n      }\n    }\n  `}};function conv2DBackpropInput4(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:s}=t,{inputShape:o,strides:i,pad:l,dataFormat:u,dimRoundingMode:c}=a,d=backend_util_exports.convertConv2DDataFormat(u),p=backend_util_exports.computeConv2DInfo(o,s.shape,i,1,l,c,!1,d),h=[{type:"int32",data:[p.filterHeight,p.filterWidth]},{type:"int32",data:[p.filterHeight-1-p.padInfo.top,p.filterWidth-1-p.padInfo.left]},{type:"int32",data:[p.strideHeight,p.strideWidth]},{type:"int32",data:[p.batchSize,p.outHeight,p.outWidth,p.outChannels]}];let m;if(env().getBool("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE"))m=new Conv2DDerInputProgram2(p);else{m=new Conv2DDerInputMMProgram(p);const e=p.inShape[1]*p.inShape[2],t=p.inShape[3],n=p.filterHeight*p.filterWidth*p.outChannels;h.push({type:"uint32",data:[e]},{type:"uint32",data:[t]},{type:"uint32",data:[n]})}return n.runWebGPUProgram(m,[r,s],"float32",h)}var conv2DBackpropInputConfig3={kernelName:Conv2DBackpropInput,backendName:"webgpu",kernelFunc:conv2DBackpropInput4},cos4=unaryKernelFunc3({opType:UnaryOpType.COS}),cosConfig3={kernelName:Cos,backendName:"webgpu",kernelFunc:cos4},cosh4=unaryKernelFunc3({opType:UnaryOpType.COSH}),coshConfig3={kernelName:Cosh,backendName:"webgpu",kernelFunc:cosh4},CropAndResizeProgram2=class{constructor(e,t,n,a){this.variableNames=["Image","Boxes","BoxInd"],this.uniforms="extrapolationValue : f32;",this.workGroupSize=[64,1,1],this.size=!0;const[r]=t;this.outputShape=[r,n[0],n[1],e],this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workGroupSize),this.methodId="bilinear"===a?1:0,this.cropHeightBiggerThan1=this.outputShape[1]>1,this.cropWidthBiggerThan1=this.outputShape[2]>1,this.shaderKey=`cropAndResize_${this.methodId}_${this.cropHeightBiggerThan1}_${this.cropWidthBiggerThan1}`}getUserCode(){const[e,t]=["f32(uniforms.imageShape[1] - 1)","f32(uniforms.imageShape[2] - 1)"],[n,a,r]=this.cropHeightBiggerThan1?[`(${e} / f32(uniforms.outShape[1] - 1))`,"(y2-y1) * height_ratio",`y1*${e} + f32(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${e}`],[s,o,i]=this.cropWidthBiggerThan1?[`(${t} / f32(uniforms.outShape[2] - 1))`,"(x2-x1) * width_ratio",`x1*${t} + f32(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${t}`];return`\n      ${getMainHeaderAndGlobalIndexString()}\n      if (index < uniforms.size) {\n        let coords = getCoordsFromFlatIndex(index);\n        let height_ratio = f32(${n});\n        let width_ratio = f32(${s});\n        let b = coords[0];\n        let y = coords[1];\n        let x = coords[2];\n        let d = coords[3];\n        // get box vals\n        let y1 = getBoxes(b, 0);\n        let x1 = getBoxes(b, 1);\n        let y2 = getBoxes(b, 2);\n        let x2 = getBoxes(b, 3);\n        // get image in batch index\n        let bInd = i32(round(getBoxInd(b)));\n        if(bInd < 0 || bInd >= uniforms.outShape[0]) {\n          return;\n        }\n        let height_scale = ${a};\n        let width_scale = ${o};\n        let in_y = ${r};\n        if( in_y < 0.0 || in_y > ${e} ) {\n          setOutputFlat(index, uniforms.extrapolationValue);\n          return;\n        }\n        let in_x = ${i};\n        if( in_x < 0.0 || in_x > ${t} ) {\n          setOutputFlat(index, uniforms.extrapolationValue);\n          return;\n        }\n        let sourceFracIndexCR = vec2<f32>(in_x,in_y);\n        if(${this.methodId} == 1) {\n          // Compute the four integer indices.\n          let sourceFloorCR = vec2<i32>(sourceFracIndexCR);\n          let sourceCeilCR = vec2<i32>(ceil(sourceFracIndexCR));\n          let topLeft = getImage(bInd, sourceFloorCR.y, sourceFloorCR.x, d);\n          let bottomLeft = getImage(bInd, sourceCeilCR.y, sourceFloorCR.x, d);\n          let topRight = getImage(bInd, sourceFloorCR.y, sourceCeilCR.x, d);\n          let bottomRight = getImage(bInd, sourceCeilCR.y, sourceCeilCR.x, d);\n          let fracCR = sourceFracIndexCR - vec2<f32>(sourceFloorCR);\n          let top = topLeft + (topRight - topLeft) * fracCR.x;\n          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          let newValue = top + (bottom - top) * fracCR.y;\n          setOutputFlat(index, newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          let sourceNearestCR = vec2<i32>(floor(\n            sourceFracIndexCR + vec2<f32>(0.5,0.5)));\n          let newValue = getImage(\n            bInd, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutputFlat(index, newValue);\n        }\n      }\n    }\n    `}},cropAndResize4=e=>{const{inputs:t,backend:n,attrs:a}=e,{image:r,boxes:s,boxInd:o}=t,{cropSize:i,method:l,extrapolationValue:u}=a,c=new CropAndResizeProgram2(r.shape[3],s.shape,i,l),d=[{type:"float32",data:[u]}];return n.runWebGPUProgram(c,[r,s,o],"float32",d)},cropAndResizeConfig3={kernelName:CropAndResize,backendName:"webgpu",kernelFunc:cropAndResize4},DepthToSpaceProgram2=class{constructor(e,t){this.variableNames=["x"],this.workGroupSize=[64,1,1],this.size=!0,this.uniforms="blockSize : i32;",this.outputShape=e,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey=`depthToSpace_${t}`,this.dataFormat=t}getUserCode(){return`\n      ${getMainHeaderAndGlobalIndexString()}\n        if (index < uniforms.size) {\n          let coords = getCoordsFromFlatIndex(index);\n          let b = coords[0];\n          let h = ${this.getHeightCoordString()};\n          let w = ${this.getWidthCoordString()};\n          let d = ${this.getDepthCoordString()};\n\n          let in_h = h / uniforms.blockSize;\n          let offset_h = h % uniforms.blockSize;\n          let in_w = w / uniforms.blockSize;\n          let offset_w = w % uniforms.blockSize;\n          let offset_d = (offset_h * uniforms.blockSize + offset_w) *\n            ${this.getOutputDepthSize()};\n          let in_d = d + offset_d;\n\n          let rlt = ${this.getInputSamplingString()};\n          setOutputFlat(index, rlt);\n        }\n      }`}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?"uniforms.outShape[3]":"uniforms.outShape[1]"}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}};function depthToSpace4(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockSize:s,dataFormat:o}=a,i=r.shape[0],l=("NHWC"===o?r.shape[1]:r.shape[2])*s,u=("NHWC"===o?r.shape[2]:r.shape[3])*s,c=("NHWC"===o?r.shape[3]:r.shape[1])/(s*s),d=[{type:"int32",data:[s]}],p=new DepthToSpaceProgram2("NHWC"===o?[i,l,u,c]:[i,c,l,u],o);return n.runWebGPUProgram(p,[r],r.dtype,d)}var depthToSpaceConfig3={kernelName:DepthToSpace,backendName:"webgpu",kernelFunc:depthToSpace4},DepthwiseConv2D3x3Program=class{constructor(e,t=!1,n=null,a=!1){this.variableNames=["x","W"],this.uniforms="pad : vec2<i32>; stride : vec2<i32>; dilation : vec2<i32>; inDims : vec2<i32>;",this.workGroupSize=[4,4,4],this.isVec4=!0,this.outputShape=e.outShape,this.dispatchLayout={x:[0,1],y:[2],z:[3]},this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workGroupSize,[1,4,4]),util_exports.assert("channelsLast"===e.dataFormat,(()=>"TODO: NCHW is unimplemented")),t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=t,this.activation=n,this.hasPreluActivation=a,this.shaderKey=`depthwise3x3_${n}`}getUserCode(){let e="",t="";if(this.activation){const n=mapActivationToShaderProgram2(this.activation,this.isVec4);e=this.hasPreluActivation?`fn activation(a : vec4<f32>, outCoord : vec4<i32>) -> vec4<f32> {\n          let b = getPreluActivationWeightsAtOutCoordsByCoords(outCoord);\n          ${n}\n        }`:`\n        fn activation(a : vec4<f32>, outCoord : vec4<i32>) -> vec4<f32> {\n            ${n}\n          }\n        `,t="dotProd[i] = activation(dotProd[i], coords);"}const n=this.addBias?"dotProd[i] = dotProd[i] + getBiasAtOutCoordsByCoords(coords);":"";return`\n      ${e}\n\n      ${getWorkGroupSizeString()}\n      fn main([[builtin(global_invocation_id)]] globalId: vec3<u32>) {\n        let batch = 0;\n        let r = i32(globalId.x);\n        let c = i32(globalId.y) * 4;\n        let d2 = i32(globalId.z) * 4;\n        let xRCCorner = vec2<i32>(r, c) * uniforms.stride - uniforms.pad;\n        let d1 = d2;\n        let q = 0;\n\n        let xRCorner = xRCCorner.x;\n        let xCCorner = xRCCorner.y;\n\n        var wVals : array<vec4<f32>, 9>;\n        wVals[0] = getW(0, 0, d1, q);\n        wVals[1] = getW(0, 1, d1, q);\n        wVals[2] = getW(0, 2, d1, q);\n        wVals[3] = getW(1, 0, d1, q);\n        wVals[4] = getW(1, 1, d1, q);\n        wVals[5] = getW(1, 2, d1, q);\n        wVals[6] = getW(2, 0, d1, q);\n        wVals[7] = getW(2, 1, d1, q);\n        wVals[8] = getW(2, 2, d1, q);\n\n        var xVals : array<array<vec4<f32>, 6>, 3>;\n        for (var wR = 0; wR < 3; wR = wR + 1) {\n          let xR = xRCorner + wR * uniforms.dilation[0];\n          for (var wC = 0; wC < 6; wC = wC + 1) {\n            let xC = xCCorner + wC * uniforms.dilation[1];\n            if (xR < 0 || xR >= uniforms.inDims[0] || xC < 0 || xC >= uniforms.inDims[1]) {\n              xVals[wR][wC] = vec4<f32>(0.0);\n            } else {\n              xVals[wR][wC] = getX(batch, xR, xC, d1);\n            }\n          }\n        }\n\n        var dotProd : array<vec4<f32>, 4>;\n        dotProd[0] = vec4<f32>(0.0);\n        dotProd[1] = vec4<f32>(0.0);\n        dotProd[2] = vec4<f32>(0.0);\n        dotProd[3] = vec4<f32>(0.0);\n\n        for (var wR = 0; wR < 3; wR = wR + 1) {\n          for (var wC = 0; wC < 3; wC = wC + 1) {\n            let indexW = wR * 3 + wC;\n            dotProd[0] = dotProd[0] + xVals[wR][0 + wC] * wVals[indexW];\n            dotProd[1] = dotProd[1] + xVals[wR][1 + wC] * wVals[indexW];\n            dotProd[2] = dotProd[2] + xVals[wR][2 + wC] * wVals[indexW];\n            dotProd[3] = dotProd[3] + xVals[wR][3 + wC] * wVals[indexW];\n          }\n        }\n\n        for (var i = 0; i < 4; i = i + 1) {\n          let coords = vec4<i32>(batch, r, c + i, d2);\n          if (coordsInBounds4D(coords, uniforms.outShape)) {\n            ${n}\n            ${t}\n            setOutput(coords[0], coords[1], coords[2], coords[3], dotProd[i]);\n          }\n        }\n      }\n    `}},DepthwiseConv2DProgram2=class{constructor(e,t=!1,n=null,a=!1){this.variableNames=["x","W"],this.uniforms="pad : vec2<i32>; stride : vec2<i32>; dilation : vec2<i32>; inDims : vec2<i32>;",this.workGroupSize=[256,1,1],this.outputShape=e.outShape,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workGroupSize),util_exports.assert("channelsLast"===e.dataFormat,(()=>"TODO: NCHW is unimplemented")),t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=t,this.activation=n,this.hasPreluActivation=a,this.shaderKey=`depthwise_${this.convInfo.filterHeight}_${this.convInfo.filterWidth}_${this.activation}_${this.convInfo.outChannels/this.convInfo.inChannels}`}getUserCode(){const e=this.convInfo.outChannels/this.convInfo.inChannels;let t="",n="";if(this.activation){const e=mapActivationToShaderProgram2(this.activation,!1);t=this.hasPreluActivation?`fn activation(a : f32, outCoord : vec4<i32>) -> f32 {\n          let b = getPreluActivationWeightsAtOutCoordsByCoords(outCoord);\n          ${e}\n        }`:`\n          fn activation(a : f32, outCoord : vec4<i32>) -> f32 {\n            ${e}\n          }\n        `,n="dotProd = activation(dotProd, coords);"}const a=this.addBias?"dotProd = dotProd + getBiasAtOutCoordsByCoords(coords);":"";return`\n      ${t}\n\n      fn writeResult(batch : i32, row : i32, col : i32, chan : i32, value : f32) {\n        let coord = vec4<i32>(batch, row, col, chan);\n        if (coordsInBounds4D(coord, uniforms.outShape)) {\n          setOutput(batch, row, col, chan, value);\n        }\n      }\n\n      ${getFlatDispatchLayoutMainHeaderString()} {\n        let coords = getOutputCoordsWithFlatDispatchLayout(globalId, localId, numWorkgroups);\n        let batch = coords[0];\n        let xRCCorner = vec2<i32>(coords.yz) * uniforms.stride - uniforms.pad;\n        let d2 = coords[3];\n        let d1 = d2 / ${e};\n        let q = d2 - d1 * ${e};\n\n        let inputRowStart = xRCCorner.x;\n        let inputColStart = xRCCorner.y;\n        let inputRowEnd = inputRowStart + ${this.convInfo.filterHeight} * uniforms.dilation[0];\n        let inputColEnd = inputColStart + ${this.convInfo.filterWidth} * uniforms.dilation[1];\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd = 0.0;\n\n        // Extract if checking out of for loop for performance.\n        if (inputRowStart >= 0 && inputColStart >= 0 &&\n          inputRowEnd < uniforms.inDims[0] && inputColEnd < uniforms.inDims[1]) {\n            // Here using a constant value |this.convInfo.filterHeight| instead\n            // of uniform value is in order to loop unrolling.\n            for (var wR = 0; wR < ${this.convInfo.filterHeight}; wR = wR + 1) {\n              let xR = inputRowStart + wR * uniforms.dilation[0];\n\n              for (var wC = 0; wC < ${this.convInfo.filterWidth}; wC = wC + 1) {\n                let xC = inputColStart + wC * uniforms.dilation[1];\n\n                let xVal = getX(batch, xR, xC, d1);\n                let wVal = getW(wR, wC, d1, q);\n                dotProd = dotProd + xVal * wVal;\n              }\n            }\n          } else {\n            for (var wR = 0; wR < ${this.convInfo.filterHeight}; wR = wR + 1) {\n              let xR = inputRowStart + wR * uniforms.dilation[0];\n\n              if (xR < 0 || xR >= uniforms.inDims[0]) {\n                continue;\n              }\n\n              for (var wC = 0; wC < ${this.convInfo.filterWidth}; wC = wC + 1) {\n                let xC = inputColStart + wC * uniforms.dilation[1];\n\n                if (xC < 0 || xC >= uniforms.inDims[1]) {\n                  continue;\n                }\n\n                let xVal = getX(batch, xR, xC, d1);\n                let wVal = getW(wR, wC, d1, q);\n                dotProd = dotProd + xVal * wVal;\n              }\n            }\n          }\n\n        ${a}\n        ${n}\n        writeResult(batch, coords[1], coords[2], d2, dotProd);\n      }\n    `}};function depthwiseConv2dNative3(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:o,pad:i,dilations:l,dimRoundingMode:u}=a;let c=l;null==c&&(c=[1,1]);const d=backend_util_exports.computeConv2DInfo(r.shape,s.shape,o,c,i,u,!0);let p;p=1===d.batchSize&&d.inHeight===d.outHeight&&d.inWidth===d.outWidth&&1===d.strideHeight&&1===d.strideWidth&&d.filterHeight===d.filterWidth&&d.inChannels===d.outChannels&&3===d.filterHeight&&d.inChannels%4==0?new DepthwiseConv2D3x3Program(d):new DepthwiseConv2DProgram2(d);const h=[{type:"int32",data:[d.padInfo.top,d.padInfo.left]},{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.dilationHeight,d.dilationWidth]},{type:"int32",data:[d.inHeight,d.inWidth]}];return n.runWebGPUProgram(p,[r,s],r.dtype,h)}var depthwiseConv2dNativeConfig3={kernelName:DepthwiseConv2dNative,backendName:"webgpu",kernelFunc:depthwiseConv2dNative3},multiplyKernelFunc=binaryKernelFunc3({opSnippet:BinaryOpType.MUL,cpuKernelImpl:multiplyImplCPU2,supportsComplex:!0}),multiplyConfig3={kernelName:Multiply,backendName:"webgpu",kernelFunc:multiplyKernelFunc},ReduceProgram2=class{constructor(e,t,n){this.variableNames=["x"],this.uniforms="reduceSize : i32;",this.inputShape=[e.batchSize,e.inSize];const[a]=backend_util_exports.computeOutAndReduceShapes(this.inputShape,[1]);this.outputShape=0===a.length?[1]:a,this.reductionFactor=2;const r=Math.min(Math.ceil(e.inSize/this.reductionFactor),256);this.workGroupSize=[r,1,1],this.dispatchLayout={x:[],y:this.outputShape.map(((e,t)=>t))},this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workGroupSize),this.reduceType=t,this.shaderKey=`reduce_${t}_${n}`}getUserCode(){const e=this.workGroupSize[0]>1;let t="",n="0.0";"min"===this.reduceType||"max"===this.reduceType?(t=`\n         if (isNanCustom(candidate)) {\n          bestValue = uniforms.NAN;\n         } elseif (candidate ${"min"===this.reduceType?"<":">"}\n           bestValue)\n           {  bestValue = candidate; }`,n="f32(x.numbers[offset])"):"sum"===this.reduceType||"mean"===this.reduceType?t=" bestValue = bestValue + candidate; ":"prod"===this.reduceType&&(t=" bestValue = bestValue * candidate; ",n="1.0");const a="mean"===this.reduceType?"setOutputFlat(flatOutputIndex, bestValue / f32(uniforms.reduceSize));":"setOutputFlat(flatOutputIndex, bestValue);",r=`\n         var<workgroup> xBestValues : array<f32, ${this.workGroupSize[0]}>;\n       `,s=`\n       xBestValues[localId.x] = bestValue;\n       ${"sum"===this.reduceType||"mean"===this.reduceType||"prod"===this.reduceType?`bestValue = ${n};`:" "}\n       var currentSize = WorkGroupSize;\n       for(; currentSize > 1;) {\n         workgroupBarrier();\n         for (var w = 0; w < ${this.reductionFactor}; w = w + 1) {\n           let i = i32(localId.x) * ${this.reductionFactor} + w;\n           if (i < currentSize) {\n             let candidate = xBestValues[i];\n             ${t}\n           }\n         }\n         workgroupBarrier();\n         xBestValues[localId.x] = bestValue;\n         currentSize = DIV_CEIL(currentSize, ${this.reductionFactor});\n         ${"sum"===this.reduceType||"mean"===this.reduceType||"prod"===this.reduceType?`if(currentSize > 1) { bestValue = ${n}; }`:""}\n       }\n       if (localId.x == 0u) {\n         ${a}\n       }\n     `;return`\n       fn DIV_CEIL(a : i32, b : i32) -> i32 {\n        return ((a - 1) / b + 1);\n       }\n       let WorkGroupSize = ${this.workGroupSize[0]};\n       ${e?r:""}\n       fn getOffset(globalId : vec3<u32>) -> i32 {\n         let outputCoords = getOutputCoordsWithNonFlatDispatchLayout(globalId);\n         let offset = ${1===this.outputShape.length?"outputCoords":"outputCoords[0]"} * uniforms.reduceSize;\n         return offset;\n       }\n       ${getNonFlatDispatchLayoutMainHeaderString()} {\n         let offset = getOffset(globalId);\n         var bestValue = ${n};\n         let Length = uniforms.reduceSize;\n         let WorkPerThread = DIV_CEIL(Length, WorkGroupSize);\n         for (var w = 0; w < WorkPerThread; w = w + 1) {\n           let i = i32(globalId.x) * WorkPerThread + w;\n           if (i < Length) {\n             let candidate = f32(x.numbers[offset + i]);\n             ${t}\n           }\n         }\n         let flatOutputIndex = i32(globalId.y);\n         ${e?s:a}\n       }\n     `}};function reduce2(e,t,n,a,r){const s=e.shape.length,o=[],i=util_exports.parseAxisParam(t,e.shape);let l=i;const u=backend_util_exports.getAxesPermutation(l,s);let c=e;null!=u&&(c=transpose4({inputs:{x:e},attrs:{perm:u},backend:r}),l=backend_util_exports.getInnerMostAxes(l.length,s),o.push(c)),backend_util_exports.assertAxesAreInnerMostDims(a,l,s);const[d,p]=backend_util_exports.computeOutAndReduceShapes(c.shape,l);let h,m=d;if(n&&(m=backend_util_exports.expandShapeToKeepDim(d,i)),"max"!==a&&"prod"!==a||!r.shouldExecuteOnCPU([c])){const t=util_exports.sizeFromShape(p),n={windowSize:t,inSize:t,batchSize:util_exports.sizeFromShape(c.shape)/t,outSize:1},s="mean"===a?"float32":sumOutType(e.dtype),i=[{type:"int32",data:[t]}],l=new ReduceProgram2(n,a,s),u=r.runWebGPUProgram(l,[c],s,i);o.push(u),h=reshape5({inputs:{x:u},attrs:{shape:m},backend:r})}else{const t=r.tensorMap.get(c.dataId).values;switch(a){case"max":const n=maxImplCPU2(t,util_exports.sizeFromShape(p),m,e.dtype);h=r.makeTensorInfo(m,e.dtype,n);break;case"prod":const{outVals:s,outShape:o,outDtype:i}=prodImplCPU2(c.shape,c.dtype,t,l);h=r.makeTensorInfo(o,i,s);break;default:throw new Error(`${a} CPU implementation is not yet supported.`)}}return o.forEach((e=>r.disposeData(e.dataId))),h}function sum5(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:o}=a;return reduce2(r,s,o,"sum",n)}var sumConfig3={kernelName:Sum,backendName:"webgpu",kernelFunc:sum5};function einsum4(e){const{inputs:t,backend:n,attrs:a}=e,{equation:r}=a,s=t,{allDims:o,summedDims:i,idDims:l}=backend_util_exports.decodeEinsumEquation(r,s.length);backend_util_exports.checkEinsumDimSizes(o.length,l,s);const{path:u,steps:c}=backend_util_exports.getEinsumComputePath(i,l),d=c.length;let p=null,h=o.length;const m=[];for(let e=0;e<d;++e){for(const t of c[e]){const{permutationIndices:e,expandDims:a}=backend_util_exports.getEinsumPermutation(h,l[t]);let r;backend_util_exports.isIdentityPermutation(e)?r=s[t]:(r=transpose4({inputs:{x:s[t]},backend:n,attrs:{perm:e}}),m.push(r));const o=r.shape.slice();for(let e=0;e<a.length;++e)o.splice(a[e],0,1);util_exports.arraysEqual(r.shape,o)||(r=reshape5({inputs:{x:r},backend:n,attrs:{shape:o}}),m.push(r)),null===p?p=r:(p=multiplyKernelFunc({inputs:{a:r,b:p},backend:n}),m.push(p))}e<d-1&&(u[e]>=0&&(p=sum5({inputs:{x:p},backend:n,attrs:{axis:u[e]-(o.length-h),keepDims:!1}}),m.push(p)),h--)}for(const e of m)e!==p&&n.disposeData(e.dataId);return p}var einsumConfig3={kernelName:Einsum,backendName:"webgpu",kernelFunc:einsum4},elu6=unaryKernelFunc3({opType:UnaryOpType.ELU}),eluConfig3={kernelName:Elu,backendName:"webgpu",kernelFunc:elu6},equal4=binaryKernelFunc3({opSnippet:BinaryOpType.EQUAL,dtype:"bool",cpuKernelImpl:equalImplCPU2}),equalConfig3={kernelName:Equal,backendName:"webgpu",kernelFunc:equal4},exp4=unaryKernelFunc3({opType:UnaryOpType.EXP,cpuKernelImpl:expImplCPU2,dtype:"float32"}),expConfig3={kernelName:Exp,backendName:"webgpu",kernelFunc:exp4};function expandDims5(e){const{inputs:t,attrs:n,backend:a}=e,{dim:r}=n,{input:s}=t,o=s.shape.length,i=s.shape.slice();let l=r;return r<0&&(util_exports.assert(-(o+1)<=r,(()=>`Axis must be in the interval [${-(o+1)}, ${o}]`)),l=o+r+1),i.splice(l,0,1),reshape5({inputs:{x:s},backend:a,attrs:{shape:i}})}var expandDimsConfig3={kernelName:ExpandDims,backendName:"webgpu",kernelFunc:expandDims5},expm14=unaryKernelFunc3({opType:UnaryOpType.EXPM1,cpuKernelImpl:expm1ImplCPU2}),expm1Config3={kernelName:Expm1,backendName:"webgpu",kernelFunc:expm14},FillProgram2=class{constructor(e){this.variableNames=[],this.outputShape=[],this.uniforms="value : f32;",this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="fill"}getUserCode(){return`\n    ${getMainHeaderAndGlobalIndexString()}\n      if (index < uniforms.size) {\n        setOutputFlat(index, uniforms.value);\n      }\n    }\n  `}};function fill4(e){const{backend:t,attrs:n}=e,{shape:a,value:r}=n;let{dtype:s}=n;if(s=s||util_exports.inferDtype(r),"string"===s){const e=util_exports.getArrayFromDType(s,util_exports.sizeFromShape(a));return e.fill(r),t.makeTensorInfo(a,s,e)}{const e=new FillProgram2(a),n=[{type:"float32",data:[r]}];return t.runWebGPUProgram(e,[],s,n)}}var fillConfig3={kernelName:Fill,backendName:"webgpu",kernelFunc:fill4},FlipLeftRightProgram2=class{constructor(e){this.outputShape=[],this.variableNames=["x"],this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="flipLeftRight"}getUserCode(){return`\n      ${getMainHeaderAndGlobalIndexString()}\n        if (index < uniforms.size) {\n          let coords = getCoordsFromFlatIndex(index);\n          let coordX = uniforms.xShape[2] - coords[2] - 1;\n          let outputValue = getX(coords[0], coords[1], coordX, coords[3]);\n          setOutputFlat(index, outputValue);\n        }\n      }\n    `}},flipLeftRightConfig3={kernelName:FlipLeftRight,backendName:"webgpu",kernelFunc:({inputs:e,backend:t})=>{const{image:n}=e,a=t,r=new FlipLeftRightProgram2(n.shape);return a.runWebGPUProgram(r,[n],n.dtype)}},floor4=unaryKernelFunc3({opType:UnaryOpType.FLOOR,cpuKernelImpl:floorImplCPU2}),floorConfig3={kernelName:Floor,backendName:"webgpu",kernelFunc:floor4},floorDiv4=binaryKernelFunc3({opSnippet:BinaryOpType.INT_DIV,dtype:"int32"}),floorDivConfig3={kernelName:FloorDiv,backendName:"webgpu",kernelFunc:floorDiv4},makeBindGroup=(e,t,n,a,r)=>{const s=[a,...n];return r&&s.push(r),e.createBindGroup({layout:t,entries:s.map(((e,t)=>({binding:t,resource:e})))})},compileProgram2=(e,t,n,a,r,s=!1)=>{const o=makeShader2(a,{dtype:r.dtype,shape:r.shape},t,s),i=e.createShaderModule({code:o});return e.createComputePipeline({layout:n,compute:{module:i,entryPoint:"main"}})};function makeShaderKey2(e,t,n,a="",r=""){return e.shaderKey+"_"+(e.workGroupSize?e.workGroupSize.join(","):"")+t.map((e=>e.length)).join(",")+n.join(",")+e.variableNames.join(",")+a+r}function fromPixelsExternalImage(e){const{externalImage:t,backend:n,attrs:a,outShape:r,useImport:s}=e,{numChannels:o}=a,i=util_exports.sizeFromShape(r),l=util_exports.computeStrides(r),u=n.makeTensorInfo(r,"int32"),c=n.getFromPixelsProgram(s?"import":"copyExternal");c.updateOutputShape(r);const d=[u.shape],p=[u.dtype,s?"import":"copyExternal"],h=makeShaderKey2(c,d,p),m=c.getLayout(n.device),f=n.getAndSavePipeline(h,(()=>compileProgram2(n.device,c,m.pipelineLayout,[],u,!0)));c.setPipeline(f),s||n.queue.copyExternalImageToTexture({source:t,origin:{x:0,y:0}},{texture:c.makeInputTexture(n.device,r[1],r[0])},[r[1],r[0]]);const g=n.tensorMap.get(u.dataId);g.bufferInfo.buffer=n.acquireBuffer(g.bufferInfo.byteSize);const x=[i,o,...l,...c.dispatch];let y;if(c.setUniform(n.device,x),s){const e={source:t};y=n.device.importExternalTexture(e)}else y=c.inputTexture.createView();return n.runFromPixelsProgram(c,g.bufferInfo.buffer,m,y,u.dataId),u}var fromPixels2DContext3,fromPixelsConfig2={kernelName:FromPixels,backendName:"webgpu",kernelFunc:fromPixels3};function fromPixels3(e){const{inputs:t,backend:n,attrs:a}=e;let{pixels:r}=t;const{numChannels:s}=a;if(null==r)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");const o="undefined"!=typeof HTMLVideoElement&&r instanceof HTMLVideoElement,i="undefined"!=typeof HTMLImageElement&&r instanceof HTMLImageElement,l="undefined"!=typeof HTMLCanvasElement&&r instanceof HTMLCanvasElement||"undefined"!=typeof OffscreenCanvas&&r instanceof OffscreenCanvas,u="undefined"!=typeof ImageBitmap&&r instanceof ImageBitmap,[c,d]=o?[r.videoWidth,r.videoHeight]:[r.width,r.height],p=[d,c,s];if(env().getBool("WEBGPU_USE_IMPORT")&&o)return fromPixelsExternalImage({externalImage:r,backend:n,attrs:a,outShape:p,useImport:!0});if((o||i)&&(null==fromPixels2DContext3&&(fromPixels2DContext3=document.createElement("canvas").getContext("2d")),fromPixels2DContext3.canvas.width=c,fromPixels2DContext3.canvas.height=d,fromPixels2DContext3.drawImage(r,0,0,c,d),r=fromPixels2DContext3.canvas),u||l||o||i)return fromPixelsExternalImage({externalImage:r,backend:n,attrs:a,outShape:p,useImport:!1});const h=r.data;let m=h;if(null!=s&&4!==s){m=new Uint8Array(r.width*r.height*s);const e=h.length;let t=0;for(let n=0;n<e;n++)n%4<s&&(m[t++]=h[n])}const f=n.makeTensorInfo(p,"int32");return n.tensorMap.get(f.dataId).values=new Int32Array(m),n.maybeReleaseBuffer(f.dataId),n.uploadToGPU(f.dataId),f}var BatchNormProgram2=class{constructor(e,t,n,a,r){this.uniforms="varianceEpsilon : f32;",this.workGroupSize=[128,1,1],this.size=!0,this.variableNames=["x","mean","variance"],backend_util_exports.assertAndGetBroadcastShape(e,t),backend_util_exports.assertAndGetBroadcastShape(e,n),this.outputShape=e,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workGroupSize),null!=a&&(backend_util_exports.assertAndGetBroadcastShape(e,a),this.variableNames.push("offset")),null!=r&&(backend_util_exports.assertAndGetBroadcastShape(e,r),this.variableNames.push("scale")),this.offsetShape=a,this.scaleShape=r,this.shaderKey="batchNorm"}getUserCode(){let e="0.0";null!=this.offsetShape&&(e="getOffsetAtOutCoordsByGlobalIndex(index)");let t="1.0";null!=this.scaleShape&&(t="getScaleAtOutCoordsByGlobalIndex(index)");return`\n      ${getMainHeaderAndGlobalIndexString()}\n        if (index < uniforms.size)\n        {\n          let xValue = getXAtOutCoordsByGlobalIndex(index);\n          let meanValue = getMeanAtOutCoordsByGlobalIndex(index);\n          let varianValue = getVarianceAtOutCoordsByGlobalIndex(index);\n          let offsetValue = ${e};\n          let scaleValue = ${t};\n          let inv = scaleValue * inverseSqrt(varianValue + f32(uniforms.varianceEpsilon));\n          setOutputFlat(index,dot(vec3<f32>(xValue, -meanValue, offsetValue), vec3<f32>(inv, inv, 1.0)));\n        }\n      }\n  `}},fusedBatchNormConfig={kernelName:FusedBatchNorm,backendName:"webgpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:a,scale:r,offset:s,mean:o,variance:i}=e,{varianceEpsilon:l}=t,u=n,c=[a,o,i];let d=null;null!=s&&(d=s.shape,c.push(s));let p=null;null!=r&&(p=r.shape,c.push(r));const h=new BatchNormProgram2(a.shape,o.shape,i.shape,d,p),m=[{type:"float32",data:[l]}];return u.runWebGPUProgram(h,c,a.dtype,m)}};function fusedConv2d2(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s,bias:o,preluActivationWeights:i}=t,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:p,activation:h,leakyreluAlpha:m}=a,f=backend_util_exports.convertConv2DDataFormat(c),g=backend_util_exports.computeConv2DInfo(r.shape,s.shape,l,d,u,p,!1,f),x=null!=o,y=null!=i;let A;if(1===g.filterHeight&&1===g.filterWidth&&1===g.dilationHeight&&1===g.dilationWidth&&1===g.strideHeight&&1===g.strideWidth&&("SAME"===g.padInfo.type||"VALID"===g.padInfo.type))return conv2dByMatMul2({x:r,filter:s,convInfo:g,backend:n,bias:o,activation:h,preluActivationWeights:i,leakyreluAlpha:m});const b=env().getBool("WEBGPU_USE_NAIVE_CONV2D"),v=g.inChannels%4==0&&g.outChannels%4==0,k=[g.padInfo.top,g.padInfo.left],S=[{type:"int32",data:[g.filterHeight,g.filterWidth]},{type:"int32",data:[...k]},{type:"int32",data:[g.strideHeight,g.strideWidth]},{type:"int32",data:[g.dilationHeight,g.dilationWidth]}];if(b)A=new Conv2DNaiveProgram(g,x,h,y);else{A=v?new Conv2DMMVec4Program(g,x,h,y):new Conv2DMMProgram(g,x,h,y);const e=g.outShape[1]*g.outShape[2],t=g.outShape[3],n=g.filterHeight*g.filterWidth*g.inShape[3];S.push({type:"int32",data:[e]},{type:"int32",data:[t]},{type:"int32",data:[n]})}const w=[r,s];return x&&w.push(o),y&&w.push(i),n.runWebGPUProgram(A,w,r.dtype,S)}var fusedConv2DConfig3={kernelName:FusedConv2D,backendName:"webgpu",kernelFunc:fusedConv2d2};function fusedDepthwiseConv2D3(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s,bias:o,preluActivationWeights:i}=t,{strides:l,pad:u,dilations:c,dimRoundingMode:d,activation:p}=a;let h=c;null==h&&(h=[1,1]),util_exports.assert(backend_util_exports.eitherStridesOrDilationsAreOne(l,h),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${h}'`));const m=backend_util_exports.computeConv2DInfo(r.shape,s.shape,l,h,u,d,!0),f=[r,s],g=null!=o,x=null!=i;let y;g&&f.push(o),x&&f.push(i),y=1===m.batchSize&&m.inHeight===m.outHeight&&m.inWidth===m.outWidth&&1===m.strideHeight&&1===m.strideWidth&&m.filterHeight===m.filterWidth&&m.inChannels===m.outChannels&&3===m.filterHeight&&m.inChannels%4==0?new DepthwiseConv2D3x3Program(m,g,p,x):new DepthwiseConv2DProgram2(m,g,p,x);const A=[{type:"int32",data:[m.padInfo.top,m.padInfo.left]},{type:"int32",data:[m.strideHeight,m.strideWidth]},{type:"int32",data:[m.dilationHeight,m.dilationWidth]},{type:"int32",data:[m.inHeight,m.inWidth]}];return n.runWebGPUProgram(y,f,"float32",A)}var fusedDepthwiseConv2DConfig3={kernelName:FusedDepthwiseConv2D,backendName:"webgpu",kernelFunc:fusedDepthwiseConv2D3},GatherNDProgram2=class{constructor(e,t){this.variableNames=["A","indices"],this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey=`gathernd_${e}`,this.sliceDim=e,this.uniforms=`sliceDim : i32; strides : ${getCoordsDataType2(e)};`}getUserCode(){let e;e=this.sliceDim>1?"uniforms.strides[j]":"uniforms.strides";return`\n        ${getMainHeaderAndGlobalIndexString()}\n        if (index < uniforms.size) {\n          let coords = getCoordsFromFlatIndex(index);\n          var flattenIndex = 0;\n          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {\n            let indexTemp = i32(round(getIndices(coords[0], j)));\n            let strideNum = ${e};\n            flattenIndex = flattenIndex + indexTemp * strideNum;\n          }\n\n          setOutputFlat(index, getA(flattenIndex, coords[1]));\n        }\n      }\n      `}};function gatherNd3(e){const{inputs:t,backend:n}=e,{params:a,indices:r}=t,s=r.shape,o=s[s.length-1],i=util_exports.sizeFromShape(a.shape),[l,u,c,d]=backend_util_exports.prepareAndValidate(a,r),p=reshape5({inputs:{x:r},backend:n,attrs:{shape:[u,o]}}),h=reshape5({inputs:{x:a},backend:n,attrs:{shape:[util_exports.sizeFromShape(a.shape)/c,c]}});if(n.shouldExecuteOnCPU([a,r])||"string"===a.dtype){const e=n.readSync(r.dataId),t=n.bufferSync(a),s=gatherNdImplCPU2(e,t,a.dtype,u,o,c,d,a.shape,i);return n.makeTensorInfo(l,a.dtype,s.values)}const m=new GatherNDProgram2(o,[u,c]),f=[{type:"int32",data:[o]},{type:"int32",data:d}],g=n.runWebGPUProgram(m,[h,p],h.dtype,f),x=reshape5({inputs:{x:g},backend:n,attrs:{shape:l}});return n.disposeData(p.dataId),n.disposeData(h.dataId),n.disposeData(g.dataId),x}var gatherNdConfig3={kernelName:GatherNd,backendName:"webgpu",kernelFunc:gatherNd3},GatherProgram2=class{constructor(e,t){this.variableNames=["A","indices"],this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=e.slice(),this.aShape=e,this.outputShape=t,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="gather"}getUserCode(){const e=getSourceCoords4(this.aShape,"i32");return`\n      ${getMainHeaderAndGlobalIndexString()}\n        if (index < uniforms.size) {\n          let resRC = getCoordsFromFlatIndex(index);\n          setOutputFlat(index, getA(${e}));\n        }\n      }\n    `}};function getSourceCoords4(e,t="int"){const n=["resRC.x","resRC.y","resRC.z","resRC.w"],a=[];for(let r=0;r<e.length;r++)2===r?a.push(`${t}(getIndices(resRC.x, resRC.z))`):a.push(`${n[r]}`);return a.join()}function gatherV23(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,indices:s}=t,{axis:o,batchDims:i}=a,l=util_exports.parseAxisParam(o,r.shape)[0],u=backend_util_exports.segment_util.collectGatherOpShapeInfo(r,s,l,i),c=util_exports.sizeFromShape(s.shape),d=[],p=reshape5({inputs:{x:r},backend:n,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),h=reshape5({inputs:{x:s},backend:n,attrs:{shape:[u.batchSize,c/u.batchSize]}});d.push(p),d.push(h);const m=[u.batchSize,u.outerSize,c/u.batchSize,u.sliceSize];if(n.shouldExecuteOnCPU([r,s])){const e=n.tensorMap.get(h.dataId).values,t=buffer(h.shape,h.dtype,e),a=n.tensorMap.get(p.dataId).values,r=buffer(p.shape,p.dtype,a),s=gatherV2ImplCPU2(r,t,m);return d.forEach((e=>n.disposeData(e.dataId))),n.makeTensorInfo(u.outputShape,s.dtype,s.values)}const f=new GatherProgram2(p.shape,m),g=n.runWebGPUProgram(f,[p,h],p.dtype);d.push(g);const x=reshape5({inputs:{x:g},backend:n,attrs:{shape:u.outputShape}});return d.forEach((e=>n.disposeData(e.dataId))),x}var gatherV2Config3={kernelName:GatherV2,backendName:"webgpu",kernelFunc:gatherV23},greater5=binaryKernelFunc3({opSnippet:BinaryOpType.GREATER,cpuKernelImpl:greaterImplCPU2,dtype:"bool"}),greaterConfig3={kernelName:Greater,backendName:"webgpu",kernelFunc:greater5},greaterEqual4=binaryKernelFunc3({opSnippet:BinaryOpType.GREATER_EQUAL,dtype:"bool",cpuKernelImpl:greaterEqualImplCPU2}),greaterEqualConfig3={kernelName:GreaterEqual,backendName:"webgpu",kernelFunc:greaterEqual4},less5=binaryKernelFunc3({opSnippet:BinaryOpType.LESS,dtype:"bool",cpuKernelImpl:lessImplCPU2}),lessConfig3={kernelName:Less,backendName:"webgpu",kernelFunc:less5},lessEqual4=binaryKernelFunc3({opSnippet:BinaryOpType.LESS_EQUAL,dtype:"bool",cpuKernelImpl:lessEqualImplCPU2}),lessEqualConfig3={kernelName:LessEqual,backendName:"webgpu",kernelFunc:lessEqual4},log7=unaryKernelFunc3({opType:UnaryOpType.LOG,cpuKernelImpl:logImplCPU2}),logConfig3={kernelName:Log,backendName:"webgpu",kernelFunc:log7},logicalAnd4=binaryKernelFunc3({opSnippet:BinaryOpType.LOGICAL_AND,dtype:"bool"}),logicalAndConfig3={kernelName:LogicalAnd,backendName:"webgpu",kernelFunc:logicalAnd4},logicalNot4=unaryKernelFunc3({opType:UnaryOpType.LOGICAL_NOT}),logicalNotConfig3={kernelName:LogicalNot,backendName:"webgpu",kernelFunc:logicalNot4};function max5(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{reductionIndices:s,keepDims:o}=a;return reduce2(r,s,o,"max",n)}var maxConfig3={kernelName:Max,backendName:"webgpu",kernelFunc:max5},maximum5=binaryKernelFunc3({opSnippet:BinaryOpType.MAX,cpuKernelImpl:maximumImplCPU2}),maximumConfig3={kernelName:Maximum,backendName:"webgpu",kernelFunc:maximum5};function maxPool4(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:s,strides:o,pad:i,dimRoundingMode:l}=a,u=backend_util_exports.computePool2DInfo(r.shape,s,o,1,i,l);let c;const d=[];if(1===u.filterHeight&&1===u.filterWidth){if(util_exports.arraysEqual(u.inShape,u.outShape))return identity4({inputs:{x:r},backend:n});c=new PoolWithFilterSizeEqualsOneProgram(u),d.push({type:"int32",data:[u.strideHeight,u.strideWidth]})}else c=new Pool2DProgram2(u,"max"),d.push({type:"int32",data:[u.strideHeight,u.strideWidth]},{type:"int32",data:[u.padInfo.top,u.padInfo.left]},{type:"int32",data:[u.dilationHeight,u.dilationWidth]},{type:"int32",data:[u.inHeight,u.inWidth]},{type:"int32",data:[u.effectiveFilterHeight,u.effectiveFilterWidth]});return n.runWebGPUProgram(c,[r],r.dtype,d)}var maxPoolConfig3={kernelName:MaxPool,backendName:"webgpu",kernelFunc:maxPool4};function mean3(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{keepDims:s,axis:o}=a;return reduce2(r,o,s,"mean",n)}var meanConfig3={kernelName:Mean,backendName:"webgpu",kernelFunc:mean3};function min5(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:o}=a;return reduce2(r,s,o,"min",n)}var minConfig3={kernelName:Min,backendName:"webgpu",kernelFunc:min5},minimum5=binaryKernelFunc3({opSnippet:BinaryOpType.MIN,cpuKernelImpl:minimumImplCPU2}),minimumConfig3={kernelName:Minimum,backendName:"webgpu",kernelFunc:minimum5},MirrorPadProgram2=class{constructor(e,t,n){this.uniforms="",this.variableNames=["x"],this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1])),this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workGroupSize),this.xShape=e,t.map(((e,t)=>{this.uniforms+=` pad${t} : vec2<i32>;`})),this.offset="reflect"===n?0:1,this.shaderKey=`mirrorPad_${n}`}getUserCode(){const e=this.xShape.length,t=this.xShape.map(((e,t)=>`uniforms.pad${t}[0]`)).join(","),n=this.xShape.map(((t,n)=>`uniforms.pad${n}[0] + uniforms.xShape${e>1?`[${n}]`:""}`)).join(","),a=1===e?"start":"start[i]",r=1===e?"end":"end[i]",s=1===e?"outC":"outC[i]",o=getCoordsDataType2(e),i=e>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,e):"coords";return`\n      ${getMainHeaderAndGlobalIndexString()}\n        if (index < uniforms.size) {\n          let start = ${o}(${t});\n          let end = ${o}(${n});\n          var outC = getCoordsFromFlatIndex(index);\n          for (var i = 0; i < ${e}; i = i + 1) {\n            if (${s} < ${a}) {\n              ${s} = ${a} * 2 - ${s} - ${this.offset};\n            } elseif(${s} >= ${r}) {\n              ${s} = (${r} - 1) * 2 - ${s} + ${this.offset};\n            }\n          }\n          let coords = outC - start;\n          setOutputFlat(index, getX(${i}));\n        }\n      }\n    `}},mirrorPadConfig3={kernelName:MirrorPad,backendName:"webgpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:a}=e,{paddings:r,mode:s}=t,o=n,i=r.map((e=>({type:"int32",data:[e[0],e[1]]}))),l=new MirrorPadProgram2(a.shape,r,s);return o.runWebGPUProgram(l,[a],a.dtype,i)}};function neg4(e){const{inputs:t,backend:n}=e,{x:a}=t;if(n.shouldExecuteOnCPU([a])){const e=n.tensorMap.get(a.dataId),[t,r]=negImplCPU2(e.values,a.shape,a.dtype);return n.makeTensorInfo(r,a.dtype,t)}const r=new UnaryOpProgram2(a.shape,UnaryOpType.NEG);return n.runWebGPUProgram(r,[a],a.dtype)}var negConfig3={kernelName:Neg,backendName:"webgpu",kernelFunc:neg4};function nonMaxSuppressionV33(e){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:s}=t,{maxOutputSize:o,iouThreshold:i,scoreThreshold:l}=a,u=n.readSync(r.dataId),c=n.readSync(s.dataId),{selectedIndices:d}=kernel_impls_exports.nonMaxSuppressionV3Impl(u,c,o,i,l);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}var nonMaxSuppressionV3Config3={kernelName:NonMaxSuppressionV3,backendName:"webgpu",kernelFunc:nonMaxSuppressionV33};function nonMaxSuppressionV53(e){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:s}=t,{maxOutputSize:o,iouThreshold:i,scoreThreshold:l,softNmsSigma:u}=a,c=n.readSync(r.dataId),d=n.readSync(s.dataId),p=o,h=i,m=l,f=u,{selectedIndices:g,selectedScores:x}=kernel_impls_exports.nonMaxSuppressionV5Impl(c,d,p,h,m,f);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([x.length],"float32",new Float32Array(x))]}var nonMaxSuppressionV5Config3={kernelName:NonMaxSuppressionV5,backendName:"webgpu",kernelFunc:nonMaxSuppressionV53};function zerosLike4(e){const{inputs:t,backend:n}=e,{x:a}=t;if("complex64"===a.dtype){const e=real4({inputs:{input:a},backend:n}),t=zerosLike4({inputs:{x:e},backend:n}),r=imag4({inputs:{input:a},backend:n}),s=zerosLike4({inputs:{x:r},backend:n}),o=complex4({inputs:{real:t,imag:s},backend:n});return n.disposeData(e.dataId),n.disposeData(t.dataId),n.disposeData(r.dataId),n.disposeData(s.dataId),o}return fill4({attrs:{shape:a.shape,dtype:a.dtype,value:"string"===a.dtype?"":0},backend:n})}var zerosLikeConfig3={kernelName:ZerosLike,backendName:"webgpu",kernelFunc:zerosLike4};function onesLike4(e){const{inputs:t,backend:n}=e,{x:a}=t;if("string"===a.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===a.dtype){const e=real4({inputs:{input:a},backend:n}),t=onesLike4({inputs:{x:e},backend:n}),r=imag4({inputs:{input:a},backend:n}),s=zerosLike4({inputs:{x:r},backend:n}),o=complex4({inputs:{real:t,imag:s},backend:n});return n.disposeData(e.dataId),n.disposeData(t.dataId),n.disposeData(r.dataId),n.disposeData(s.dataId),o}return fill4({attrs:{shape:a.shape,dtype:a.dtype,value:1},backend:n})}var onesLikeConfig3={kernelName:OnesLike,backendName:"webgpu",kernelFunc:onesLike4};function pack3(e){const{inputs:t,backend:n,attrs:a}=e,{axis:r}=a;if(1===t.length)return expandDims5({inputs:{input:t[0]},backend:n,attrs:{dim:r}});const s=t[0].shape,o=t[0].dtype;t.forEach((e=>{util_exports.assertShapesMatch(s,e.shape,"All tensors passed to stack must have matching shapes"),util_exports.assert(o===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const i=[],l=concat4({inputs:t.map((e=>{const t=expandDims5({inputs:{input:e},backend:n,attrs:{dim:r}});return i.push(t),t})),backend:n,attrs:{axis:r}});return i.forEach((e=>n.disposeData(e.dataId))),l}var packConfig3={kernelName:Pack,backendName:"webgpu",kernelFunc:pack3},PadProgram2=class{constructor(e,t){this.variableNames=["x"],this.uniforms="constantValue : f32;",this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1])),this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workGroupSize),t.map(((e,t)=>{this.uniforms+=` pad${t} : vec2<i32>;`})),this.xShape=e,this.shaderKey="pad"}getUserCode(){const e=this.xShape.length,t=getCoordsDataType2(e),n=this.xShape.map(((e,t)=>`uniforms.pad${t}[0]`)).join(","),a=this.xShape.map(((t,n)=>`uniforms.pad${n}[0] + uniforms.xShape${e>1?`[${n}]`:""}`)).join(","),r=e>1?`${t}(${n})`:`${n}`,s=e>1?`${t}(${a})`:`${a}`,o=e>1?"any(outC < start)":"outC < start",i=e>1?"any(outC >= end)":"outC >= end",l=e>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,e):"coords";return`\n      ${getMainHeaderAndGlobalIndexString()}\n        if (index < uniforms.size) {\n          let start = ${r};\n          let end = ${s};\n          let outC = getCoordsFromFlatIndex(index);\n\n          if (${o} || ${i}) {\n            setOutputFlat(index, uniforms.constantValue);\n          } else {\n            let coords = outC - start;\n            setOutputFlat(index, getX(${l}));\n          }\n        }\n      }\n    `}},padV23=e=>{const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{paddings:s,constantValue:o}=a;if(s.every((e=>util_exports.arraysEqual(e,[0,0]))))return identity4({inputs:{x:r},backend:n});if(0===util_exports.sizeFromShape(r.shape)){return fill4({backend:n,attrs:{shape:s.map(((e,t)=>e[0]+r.shape[t]+e[1])),value:o,dtype:r.dtype}})}const i=[{type:"float32",data:[o]}];s.map((e=>i.push({type:"int32",data:[e[0],e[1]]})));const l=new PadProgram2(r.shape,s);return n.runWebGPUProgram(l,[r],r.dtype,i)},padV2Config3={kernelName:PadV2,backendName:"webgpu",kernelFunc:padV23},pow4=binaryKernelFunc3({opSnippet:BinaryOpType.POW}),powConfig3={kernelName:Pow,backendName:"webgpu",kernelFunc:pow4};function prelu5(e){const{inputs:t,backend:n}=e,{x:a,alpha:r}=t,s=new BinaryOpProgram2(BinaryOpType.PRELU,a.shape,r.shape);return n.runWebGPUProgram(s,[a,r],"float32")}var preluConfig3={kernelName:Prelu,backendName:"webgpu",kernelFunc:prelu5};function prod4(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:o}=a;return reduce2(r,s,o,"prod",n)}var prodConfig3={kernelName:Prod,backendName:"webgpu",kernelFunc:prod4},range5=e=>{const{backend:t,attrs:n}=e,{start:a,stop:r,step:s,dtype:o}=n,i=rangeImplCPU2(a,r,s,o);return t.makeTensorInfo([i.length],o,i)},rangeConfig3={kernelName:Range,backendName:"webgpu",kernelFunc:range5},realDiv2=binaryKernelFunc3({opSnippet:BinaryOpType.DIV}),realDivConfig3={kernelName:RealDiv,backendName:"webgpu",kernelFunc:realDiv2},relu4=unaryKernelFunc3({opType:UnaryOpType.RELU}),reluConfig3={kernelName:Relu,backendName:"webgpu",kernelFunc:relu4},relu64=unaryKernelFunc3({opType:UnaryOpType.RELU6}),relu6Config3={kernelName:Relu6,backendName:"webgpu",kernelFunc:relu64},ResizeBilinearProgram2=class{constructor(e,t,n,a,r){this.variableNames=["x"],this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=[e[0],t,n,e[3]],this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workGroupSize),this.alignCorners=a,this.halfPixelCenters=r,this.shaderKey=`resizeBilinear_${a}_${r}_${this.outputShape[1]>1}_${this.outputShape[2]>1}`}getUserCode(){const e=this.alignCorners&&this.outputShape[1]>1,t=this.alignCorners&&this.outputShape[2]>1;return`\n      ${getMainHeaderAndGlobalIndexString()}\n        if (index < uniforms.size) {\n        let coords = getCoordsFromFlatIndex(index);\n          let b = coords[0];\n          let d = coords[3];\n          let rc = coords.yz;\n\n          let effectiveInSize = vec2<f32>(\n            ${e?"f32(uniforms.xShape.y) - 1.0":"f32(uniforms.xShape.y)"},\n            ${t?"f32(uniforms.xShape.z) - 1.0":"f32(uniforms.xShape.z)"});\n\n          let effectiveOutSize = vec2<f32>(\n            ${e?"f32(uniforms.outShape.y) - 1.0":"f32(uniforms.outShape.y)"},\n            ${t?"f32(uniforms.outShape.z) - 1.0":"f32(uniforms.outShape.z)"});\n\n          let effectiveInputOverOutputRatioRC =\n              effectiveInSize / effectiveOutSize;\n\n          // Fractional source index\n          let sourceFracIndexRC = ${this.halfPixelCenters?"(vec2<f32>(rc) + vec2<f32>(0.5)) * effectiveInputOverOutputRatioRC - vec2<f32>(0.5)":"vec2<f32>(rc) * effectiveInputOverOutputRatioRC"};\n\n          // Compute the four integer indices.\n          let sourceFloorRC = vec2<i32>(sourceFracIndexRC);\n          let sourceCeilRC = vec2<i32>(\n            min(vec2<f32>(uniforms.xShape.yz) - vec2<f32>(1.0), ceil(sourceFracIndexRC)));\n\n          let topLeft = getX(b, sourceFloorRC.x, sourceFloorRC.y, d);\n          let bottomLeft = getX(b, sourceCeilRC.x, sourceFloorRC.y, d);\n          let topRight = getX(b, sourceFloorRC.x, sourceCeilRC.y, d);\n          let bottomRight = getX(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n          let fracRC = sourceFracIndexRC - vec2<f32>(sourceFloorRC);\n\n          let top = topLeft + (topRight - topLeft) * fracRC.y;\n          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n          let newValue = top + (bottom - top) * fracRC.x;\n\n          setOutputFlat(index, newValue);\n        }\n      }\n    `}};function resizeBilinear4(e){const{inputs:t,backend:n,attrs:a}=e,{images:r}=t,{alignCorners:s,size:o,halfPixelCenters:i}=a,[l,u]=o,c=new ResizeBilinearProgram2(r.shape,l,u,s,i);return n.runWebGPUProgram(c,[r],"float32")}var resizeBilinearConfig3={kernelName:ResizeBilinear,backendName:"webgpu",kernelFunc:resizeBilinear4},ResizeNearestNeighborProgram2=class{constructor(e,t,n,a,r){this.variableNames=["x"],this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=[e[0],t,n,e[3]],this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workGroupSize),this.alignCorners=a,this.halfPixelCenters=r,this.shaderKey=`resizeNearest_${a}_${this.outputShape[1]>1}_${this.outputShape[2]>1}_${r}`}getUserCode(){const e=this.alignCorners?"0.5":"0.0";let t;t=this.halfPixelCenters?"max((vec2<f32>(rc) + vec2<f32>(0.5)) * effectiveInputOverOutputRatioRC, vec2<f32>(0.0))":"vec2<f32>(rc) * effectiveInputOverOutputRatioRC";const n=this.alignCorners&&this.outputShape[1]>1,a=this.alignCorners&&this.outputShape[2]>1;return`\n      ${getMainHeaderAndGlobalIndexString()}\n        if (index < uniforms.size) {\n          let coords = getCoordsFromFlatIndex(index);\n          let b = coords[0];\n          let d = coords[3];\n          let rc = coords.yz;\n\n          let effectiveInSize = vec2<f32>(\n            ${n?"f32(uniforms.xShape.y) - 1.0":"f32(uniforms.xShape.y)"},\n            ${a?"f32(uniforms.xShape.z) - 1.0":"f32(uniforms.xShape.z)"});\n\n          let effectiveOutSize = vec2<f32>(\n            ${n?"f32(uniforms.outShape.y) - 1.0":"f32(uniforms.outShape.y)"},\n            ${a?"f32(uniforms.outShape.z) - 1.0":"f32(uniforms.outShape.z)"});\n\n          let effectiveInputOverOutputRatioRC =\n              effectiveInSize / effectiveOutSize;\n\n          // Fractional source index\n          let sourceFracIndexRC = ${t};\n\n          // Compute the coordinators of nearest neighbor point.\n          let inputShapeRC = vec2<f32>(f32(uniforms.xShape.y), f32(uniforms.xShape.z));\n          let sourceNearestRC = vec2<i32>(\n            min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${e})));\n          let newValue = getX(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n          setOutputFlat(index, newValue);\n        }\n      }\n    `}};function resizeNearestNeighbor4(e){const{inputs:t,backend:n,attrs:a}=e,{images:r}=t,{alignCorners:s,halfPixelCenters:o,size:i}=a,[l,u]=i,c=new ResizeNearestNeighborProgram2(r.shape,l,u,s,o);return n.runWebGPUProgram(c,[r],r.dtype)}var resizeNearestNeighborConfig3={kernelName:ResizeNearestNeighbor,backendName:"webgpu",kernelFunc:resizeNearestNeighbor4},RotateProgram2=class{constructor(e,t){this.outputShape=[],this.variableNames=["x"],this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workGroupSize),this.uniforms="centerX : f32; centerY : f32; sinRadians : f32;\n          cosRadians : f32;",this.shaderKey="rotate",this.outputShape=e,"number"==typeof t?(this.uniforms+=" fillValue : f32;",this.fillSnippet="var outputValue = uniforms.fillValue;",this.shaderKey+="_float"):(this.uniforms+=" fillValue : vec3<f32>;",this.fillSnippet="var outputValue = uniforms.fillValue[coords[3]];",this.shaderKey+="_vec3")}getUserCode(){return`\n        ${getMainHeaderAndGlobalIndexString()}\n\n          if (index < uniforms.size) {\n            let coords = getCoordsFromFlatIndex(index);\n            let coordXFloat = (f32(coords[2]) - uniforms.centerX) *\n                uniforms.cosRadians - (f32(coords[1]) - uniforms.centerY) *\n                uniforms.sinRadians;\n            let coordYFloat = (f32(coords[2]) - uniforms.centerX) *\n                uniforms.sinRadians + (f32(coords[1]) - uniforms.centerY) *\n                uniforms.cosRadians;\n            let coordX = i32(round(coordXFloat + uniforms.centerX));\n            let coordY = i32(round(coordYFloat + uniforms.centerY));\n            ${this.fillSnippet}\n            if(coordX >= 0 && coordX < uniforms.xShape[2] && coordY >= 0 &&\n                coordY < uniforms.xShape[1]) {\n              outputValue = getX(coords[0], coordY, coordX, coords[3]);\n            }\n            setOutputFlat(index, outputValue);\n          }\n        }\n      `}},rotateWithOffsetConfig3={kernelName:RotateWithOffset,backendName:"webgpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:a}=e,{radians:r,fillValue:s,center:o}=t,i=n,l=new RotateProgram2(a.shape,s),[u,c]=backend_util_exports.getImageCenter(o,a.shape[1],a.shape[2]),d=[{type:"float32",data:[u]},{type:"float32",data:[c]},{type:"float32",data:[Math.sin(r)]},{type:"float32",data:[Math.cos(r)]}];"number"==typeof s?d.push({type:"float32",data:[Number.parseFloat(s.toFixed(2))]}):d.push({type:"float32",data:s});return i.runWebGPUProgram(l,[a],a.dtype,d)}},rsqrt4=unaryKernelFunc3({opType:UnaryOpType.RSQRT,cpuKernelImpl:rsqrtImplCPU2}),rsqrtConfig3={kernelName:Rsqrt,backendName:"webgpu",kernelFunc:rsqrt4},ScatterOptimizedProgram=class{constructor(e,t,n,a,r,s,o){this.variableNames=["updates","indices"],this.workGroupSize=[64,1,1],this.atomic=!0,this.outputShape=s,this.type=o,this.dispatchLayout=flatDispatchLayout(e),this.dispatch=computeDispatch(this.dispatchLayout,e,this.workGroupSize),this.sliceDimGreaterThanOne=t>1,this.shaderKey=`scatter_${n}_${a}_${this.sliceDimGreaterThanOne}_${o}`;const i=getCoordsDataType2(r.length);this.uniforms=`sliceDim : i32; strides: ${i}; size: i32;`,this.updatesRank=a,this.indicesRank=n}getUserCode(){let e="";1===this.indicesRank?e="coords[0]":2===this.indicesRank&&(e="coords[0], j");const t=`getIndices(${e})`,n=this.sliceDimGreaterThanOne?"uniforms.strides[j]":"uniforms.strides";let a="",r="",s="";1===this.updatesRank?(a="coords[0]",r="flattenedIndex",s="\n      fn getUpdatesCoordsFromFlatIndex(index : i32) -> i32 {\n        return index;\n      }\n      "):2===this.updatesRank&&(a="coords[0], coords[1]",r="vec2<i32>(flattenedIndex, coords[1])",s="\n      fn getUpdatesCoordsFromFlatIndex(index : i32) -> vec2<i32> {\n        let d0 = index / uniforms.updatesShape[1];\n        let d1 = index - d0 * uniforms.updatesShape[1];\n        return vec2<i32>(d0, d1);\n      }\n      ");const o=`getUpdates(${a})`,i="int32"===this.type?"ignore(atomicAdd(&(result.numbers[flatIndex]), i32(updateValue)));":"\n     var assumed = atomicLoad(&(result.numbers[flatIndex]));\n     var success = 0;\n     for (; success == 0;) {\n       let new = bitcast<f32>(assumed) + updateValue;\n       let newI32 = bitcast<i32>(new);\n       let resValue = atomicCompareExchangeWeak(&(result.numbers[flatIndex]), assumed, newI32);\n       assumed = resValue[0];\n       success = resValue[1];\n     }\n     ";return`\n    ${s}\n\n      ${getMainHeaderAndGlobalIndexString()}\n\n        if (index < uniforms.size) {\n          let coords = getUpdatesCoordsFromFlatIndex(index);\n          var flattenedIndex = 0;\n          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {\n            let indexInside = i32(round(${t}));\n            flattenedIndex = flattenedIndex + indexInside * ${n};\n          }\n          let updateValue = ${o};\n          let flatIndex = getOutputFlatIndex(${r});\n\n         ${i}\n        }\n      }`}};function scatterNd3(e){const{inputs:t,backend:n,attrs:a}=e,{indices:r,updates:s}=t,{shape:o}=a,{sliceRank:i,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=backend_util_exports.calculateShapes(s,r,o),p=[d/u,u];if(0===d)return n.makeTensorInfo(o,r.dtype);const h=reshape5({inputs:{x:r},backend:n,attrs:{shape:[l,i]}}),m=reshape5({inputs:{x:s},backend:n,attrs:{shape:[l,u]}}),f=m.dtype,g=fill4({backend:n,attrs:{shape:p,value:0,dtype:f}}),x=[{type:"int32",data:[i]},{type:"int32",data:c},{type:"int32",data:[util_exports.sizeFromShape(m.shape)]}],y=new ScatterOptimizedProgram(m.shape,i,h.shape.length,m.shape.length,c,p,f),A=n.runWebGPUProgram(y,[m,h],f,x,g),b=reshape5({inputs:{x:A},backend:n,attrs:{shape:o}});return n.disposeData(h.dataId),n.disposeData(m.dataId),n.disposeData(A.dataId),b}var scatterNdConfig3={kernelName:ScatterNd,backendName:"webgpu",kernelFunc:scatterNd3},SelectProgram2=class{constructor(e,t,n){this.variableNames=["c","a","b"],this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workGroupSize),this.cRank=e,this.rank=n,this.shaderKey="select"}getUserCode(){let e,t;if(this.rank>4)throw Error(`Where for rank ${this.rank} is not yet supported`);if(1===this.rank)t="resRC",e="resRC";else{const n=["resRC.x","resRC.y","resRC.z","resRC.w"],a=[],r=[];for(let e=0;e<this.outputShape.length;e++)r.push(`${n[e]}`),e<this.cRank&&a.push(`${n[e]}`);e=a.join(),t=r.join()}return`\n      ${getMainHeaderAndGlobalIndexString()}\n        if (index < uniforms.size) {\n          let resRC = getCoordsFromFlatIndex(index);\n          let cVal = getC(${e});\n          if (cVal >= 1.0) {\n            setOutputFlat(index, getA(${t}));\n          } else {\n            setOutputFlat(index, getB(${t}));\n          }\n        }\n      }\n    `}};function select4(e){const{inputs:t,backend:n}=e,{condition:a,t:r,e:s}=t,o=new SelectProgram2(a.shape.length,r.shape,r.shape.length);return n.runWebGPUProgram(o,[a,r,s],upcastType(r.dtype,s.dtype))}var selectConfig3={kernelName:Select,backendName:"webgpu",kernelFunc:select4},sigmoid4=unaryKernelFunc3({opType:UnaryOpType.SIGMOID}),sigmoidConfig3={kernelName:Sigmoid,backendName:"webgpu",kernelFunc:sigmoid4},sin4=unaryKernelFunc3({opType:UnaryOpType.SIN}),sinConfig3={kernelName:Sin,backendName:"webgpu",kernelFunc:sin4},sinh4=unaryKernelFunc3({opType:UnaryOpType.SINH}),sinhConfig3={kernelName:Sinh,backendName:"webgpu",kernelFunc:sinh4},sub4=binaryKernelFunc3({opSnippet:BinaryOpType.SUB,cpuKernelImpl:subImplCPU2,supportsComplex:!0}),subConfig3={kernelName:Sub,backendName:"webgpu",kernelFunc:sub4};function softmax5(e){const{inputs:t,backend:n,attrs:a}=e,{logits:r}=t,{dim:s}=a,o=util_exports.parseAxisParam([s],r.shape),i=max5({inputs:{x:r},backend:n,attrs:{reductionIndices:o,keepDims:!1}}),l=backend_util_exports.expandShapeToKeepDim(i.shape,o),u=reshape5({inputs:{x:i},backend:n,attrs:{shape:l}}),c=sub4({inputs:{a:r,b:u},backend:n}),d=exp4({inputs:{x:c},backend:n}),p=sum5({inputs:{x:d},backend:n,attrs:{axis:o,keepDims:!1}}),h=reshape5({inputs:{x:p},backend:n,attrs:{shape:l}}),m=realDiv2({inputs:{a:d,b:h},backend:n});return n.disposeData(i.dataId),n.disposeData(u.dataId),n.disposeData(c.dataId),n.disposeData(d.dataId),n.disposeData(p.dataId),n.disposeData(h.dataId),m}var softmaxConfig3={kernelName:Softmax,backendName:"webgpu",kernelFunc:softmax5},spaceToBatchND4=e=>{const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:s,paddings:o}=a;util_exports.assert(r.shape.length<=4,(()=>"spaceToBatchND for rank > 4 with a WebGPU backend not implemented yet"));const i=s.reduce(((e,t)=>e*t)),l=[[0,0]];l.push(...o);for(let e=1+s.length;e<r.shape.length;++e)l.push([0,0]);const u=[],c=padV23({inputs:{x:r},backend:n,attrs:{paddings:l,constantValue:0}}),d=backend_util_exports.getReshaped(c.shape,s,i,!1),p=backend_util_exports.getPermuted(d.length,s.length,!1),h=backend_util_exports.getReshapedPermuted(c.shape,s,i,!1),m=reshape5({inputs:{x:c},backend:n,attrs:{shape:d}}),f=transpose4({inputs:{x:m},backend:n,attrs:{perm:p}}),g=reshape5({inputs:{x:f},backend:n,attrs:{shape:h}});return u.push(c),u.push(m),u.push(f),u.forEach((e=>n.disposeData(e.dataId))),g},spaceToBatchNDConfig3={kernelName:SpaceToBatchND,backendName:"webgpu",kernelFunc:spaceToBatchND4},ScatterProgram2=class{constructor(e,t,n,a,r,s,o=!0){this.variableNames=["updates","indices","defaultValue"],this.workGroupSize=[64,1,1],this.workPerThread=4,this.size=!0,this.outputShape=s,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]);const i=t>1;this.shaderKey=`scatter_${n}_${a}_${i}`;const l=getCoordsDataType2(r.length);this.uniforms=`updateSize : i32; sliceDim : i32; strides: ${l};`;let u="";1===n?u="i":2===n&&(u="i, j"),this.indicesSnippet=`getIndices(${u})`;let c="";1===a?c="i":2===a&&(c="i, coords[1]"),this.updatesSnippet=`getUpdates(${c})`,this.strideString=i?"uniforms.strides[j]":"uniforms.strides"}getUserCode(){return`\n      ${getMainHeaderAndGlobalIndexString()}\n\n        let globalIndex = index * ${this.workPerThread};\n        if (globalIndex < uniforms.size) {\n          var sum = vec4<f32>(0.0);\n          var found = vec4<bool>(false);\n          for (var i = 0; i < uniforms.updateSize; i = i + 1) {\n            var flattenedIndex = 0;\n            for (var j = 0; j < uniforms.sliceDim; j = j + 1) {\n              let indexInside = i32(round(${this.indicesSnippet}));\n              flattenedIndex = flattenedIndex + indexInside * ${this.strideString};\n            }\n            for (var innerIndex = 0; innerIndex < ${this.workPerThread}; innerIndex = innerIndex + 1) {\n              let curIndex = globalIndex + innerIndex;\n              let coords = getCoordsFromFlatIndex(curIndex);\n              if (flattenedIndex == coords[0]) {\n                sum[innerIndex] = sum[innerIndex] + ${this.updatesSnippet};\n                found[innerIndex] = true;\n              }\n            }\n          }\n          for (var innerIndex = 0; innerIndex < ${this.workPerThread}; innerIndex = innerIndex + 1) {\n            let curIndex = globalIndex + innerIndex;\n            if (curIndex < uniforms.size)\n            {\n              setOutputFlat(curIndex, mix(getDefaultValue(), sum[innerIndex], f32(found[innerIndex])));\n            }\n          }\n        }\n      }`}};function sparseToDense4(e){const{inputs:t,backend:n,attrs:a}=e,{sparseIndices:r,sparseValues:s,defaultValue:o}=t,{outputShape:i}=a,{sliceRank:l,numUpdates:u,strides:c,outputSize:d}=backend_util_exports.calculateShapes(s,r,i),p=[{type:"int32",data:[u]},{type:"int32",data:[l]},{type:"int32",data:c}],h=new ScatterProgram2(u,l,r.shape.length,s.shape.length,c,[d,1],!1),m=n.runWebGPUProgram(h,[s,r,o],s.dtype,p),f=reshape5({inputs:{x:m},backend:n,attrs:{shape:i}});return n.disposeData(m.dataId),f}var sparseToDenseConfig3={kernelName:SparseToDense,backendName:"webgpu",kernelFunc:sparseToDense4};function splitV3(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{numOrSizeSplits:s,axis:o}=a,i=util_exports.parseAxisParam(o,r.shape)[0],l=backend_util_exports.prepareSplitSize(r,s,i),u=r.shape.length,c=new Array(u).fill(0),d=r.shape.slice();return l.map((e=>{const t=[...d];t[i]=e;const a=slice4({inputs:{x:r},backend:n,attrs:{begin:c,size:t}});return c[i]+=e,a}))}var splitVConfig3={kernelName:SplitV,backendName:"webgpu",kernelFunc:splitV3},sqrt4=unaryKernelFunc3({opType:UnaryOpType.SQRT}),sqrtConfig3={kernelName:Sqrt,backendName:"webgpu",kernelFunc:sqrt4},squareConfig3={kernelName:Square,backendName:"webgpu",kernelFunc:({inputs:e,backend:t})=>{const{x:n}=e,a=t,r=new UnaryOpProgram2(n.shape,UnaryOpType.SQUARE);return a.runWebGPUProgram(r,[n],n.dtype)}},squaredDifference4=binaryKernelFunc3({opSnippet:BinaryOpType.SQUARED_DIFFERENCE}),squaredDifferenceConfig3={kernelName:SquaredDifference,backendName:"webgpu",kernelFunc:squaredDifference4},StridedSliceProgram2=class{constructor(e){this.variableNames=["x"],this.workPerThread=1,this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]);const t=getCoordsDataType2(this.outputShape.length);this.uniforms=`begin : ${t};  strides : ${t}; `,this.shaderKey="stridedSlice"}getUserCode(){let e="";if(1===this.outputShape.length)e="coords * uniforms.strides + uniforms.begin";else{let t=0;e=this.outputShape.map(((e,n)=>(t++,1===this.outputShape.length?`coords * uniforms.strides[${n}] + uniforms.begin[${n}]`:`coords[${t-1}] * uniforms.strides[${n}] + uniforms.begin[${n}]`))).join(",")}return`\n       ${getMainHeaderAndGlobalIndexString()}\n         if (index < uniforms.size) {\n           let coords = getCoordsFromFlatIndex(index);\n           setOutputFlat(index, getX(${e}));\n         }\n       }\n     `}};function stridedSlice4(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{begin:s,end:o,strides:i,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:d,shrinkAxisMask:p}=a,{finalShapeSparse:h,finalShape:m,isIdentity:f,sliceDim0:g,isSimpleSlice:x,begin:y,end:A,strides:b}=slice_util_exports.sliceInfo(r.shape,s,o,i,l,u,c,d,p);let v;if(f)v=reshape5({inputs:{x:r},backend:n,attrs:{shape:m}});else if(g||x){util_exports.assert(r.shape.length>=1,(()=>`Input must have rank at least 1, got: ${r.shape.length}`));const e=slice_util_exports.computeOutShape(y,A,b),t=slice4({inputs:{x:r},backend:n,attrs:{begin:y,size:e}});v=reshape5({inputs:{x:t},backend:n,attrs:{shape:m}}),n.disposeData(t.dataId)}else{if(n.shouldExecuteOnCPU([r])){const e=n.readSync(r.dataId),t=buffer(r.shape,r.dtype,e),a=stridedSliceImplCPU2(h,t,b,y);v=n.makeTensorInfo(m,r.dtype,a.values)}else{const e=new StridedSliceProgram2(h),t=[{type:"int32",data:y},{type:"int32",data:b}],a=n.runWebGPUProgram(e,[r],r.dtype,t);v=reshape5({inputs:{x:a},backend:n,attrs:{shape:m}}),n.disposeData(a.dataId)}}return v}var stridedSliceConfig3={kernelName:StridedSlice,backendName:"webgpu",kernelFunc:stridedSlice4};function stringNGrams4(e){const{inputs:t,backend:n,attrs:a}=e,{separator:r,nGramWidths:s,leftPad:o,rightPad:i,padWidth:l,preserveShortSequences:u}=a,{data:c,dataSplits:d}=t,p=n.readSync(c.dataId),h=n.readSync(d.dataId),[m,f]=stringNGramsImplCPU2(p,h,r,s,o,i,l,u);return[n.makeTensorInfo([m.length],"string",m),n.makeTensorInfo(d.shape,"int32",f)]}var stringNGramsConfig3={kernelName:StringNGrams,backendName:"webgpu",kernelFunc:stringNGrams4},tanh5=unaryKernelFunc3({opType:UnaryOpType.TANH}),tanhConfig3={kernelName:Tanh,backendName:"webgpu",kernelFunc:tanh5},TileProgram2=class{constructor(e,t){this.variableNames=["A"],this.workGroupSize=[64,1,1],this.size=!0;const n=new Array(e.length);for(let a=0;a<n.length;a++)n[a]=e[a]*t[a];this.outputShape=n,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workGroupSize),this.rank=this.outputShape.length,this.shaderKey="tile"}getUserCode(){const e=getSourceCoords5(this.rank,"uniforms.");return`\n      ${getMainHeaderAndGlobalIndexString()}\n        if (index < uniforms.size) {\n          let resRC = getCoordsFromFlatIndex(index);\n          setOutputFlat(index, getA(${e}));\n        }\n      }\n    `}};function getSourceCoords5(e,t=""){if(e>=5)throw Error(`Tile for rank ${e} is not yet supported`);if(1===e)return`(resRC % ${t}aShape)`;const n=["resRC.x","resRC.y","resRC.z","resRC.w"],a=[];for(let r=0;r<e;r++)a.push(`(${n[r]} % ${t}aShape[${r}])`);return a.join()}function tile5(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{reps:s}=a;if(n.shouldExecuteOnCPU([r])||"string"===r.dtype||r.shape.length>=5){const e=n.readSync(r.dataId),t="string"===r.dtype?e.map((e=>util_exports.decodeString(e))):e,a=buffer(r.shape,r.dtype,t),o=tileImplCPU2(a,s);return n.makeTensorInfo(o.shape,o.dtype,o.values)}const o=new TileProgram2(r.shape,s);return n.runWebGPUProgram(o,[r],r.dtype)}var tileConfig3={kernelName:Tile,backendName:"webgpu",kernelFunc:tile5},SwapProgram2=class{constructor(e){this.variableNames=["x","indices"],this.workGroupSize=[256,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workGroupSize),this.uniforms="inputSize : i32; firstPass : i32; negativeInf : f32;\n        dir : i32; inc : i32;",this.shaderKey="swap"}getUserCode(){return`\n        ${getMainHeaderAndGlobalIndexString()}\n          if (index < uniforms.size) {\n            let outC = getCoordsFromFlatIndex(index);\n            let batch = outC[0];\n            let elemIdx = outC[1];\n            // We compare elements pair-wise within a group of size 2 * inc.\n            // The comparing rule for each group alternates between ascending\n            // and descending. Within each group, we compare each pair at\n            // positions i and i+inc. To decide whether an element at position i\n            // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n            // inc, it is in the first half of the group, we denote it as x0,\n            // otherwise we denote it as x1.\n            // For example, as shown in the Bitonic top K paper referenced\n            // above, Figure5(a) shows that element[1] is in the second half of\n            // the group when group size is 2, but it is in the first half of\n            // the group when group size is 4.\n            let isFirstInPair = elemIdx % (2 * uniforms.inc) < uniforms.inc;\n            var i = 0;\n            if (isFirstInPair) {\n              i = elemIdx;\n            } else {\n              i = elemIdx - uniforms.inc;\n            }\n\n            var i0 = 0;\n            if (uniforms.firstPass == 1) {\n              i0 = i;\n            } else {\n              i0 = i32(getIndices(batch, i));\n            }\n\n            var i1 = 0;\n            if (uniforms.firstPass == 1) {\n              i1 = i + uniforms.inc;\n            } else {\n              i1 = i32(getIndices(batch, i + uniforms.inc));\n            }\n\n            var x0 = f32(0.0);\n            var x1 = f32(0.0);\n            if (i0 < uniforms.inputSize) {\n              x0 = getX(batch, i0);\n            } else {\n              x0 = uniforms.negativeInf;\n            }\n            if (i1 < uniforms.inputSize) {\n              x1 = getX(batch, i1);\n            } else {\n              x1 = uniforms.negativeInf;\n            }\n\n            let reverse = elemIdx % (2 * uniforms.dir) >= uniforms.dir;\n            let isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n            if (reverse == isGreater) {\n              // Elements in opposite order of direction\n              let iTemp = i0;\n              i0 = i1;\n              i1 = iTemp;\n            }\n            if (isFirstInPair) {\n              setOutputFlat(index, f32(i0));\n            } else {\n              setOutputFlat(index, f32(i1));\n            }\n          }\n        }\n      `}},MergeProgram2=class{constructor(e){this.variableNames=["x","indices"],this.workGroupSize=[256,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workGroupSize),this.uniforms="inputSize : i32; firstPass : i32; k : i32;",this.shaderKey="merge"}getUserCode(){return`\n        ${getMainHeaderAndGlobalIndexString()}\n          if (index < uniforms.size) {\n            let outC = getCoordsFromFlatIndex(index);\n            let batch = outC[0];\n            let elemIdx = outC[1];\n            // The output size is half of the previous size.\n            // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _\n            // (k=4), we only need to output the indices at positions |, the\n            // indices at positions _ can be thrown away, see Figure5(b) After\n            // Phase 2 (Merge phase) in the Bitonic Top K paper referenced\n            // above.\n            // For example, the paper shows we only need to output the orange\n            // bars. The output sequence should look like this | | | | | | | |.\n            // Because the sequence is halved, to map the output index back to\n            // the previous sequence to find the corresponding value, we need\n            // to double the index. When we double the index, we basically\n            // interpolate a position, so 2i looks like\n            // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k\n            // position of each 2k positions by - elemIdx % k. E.g. for output\n            // at index 4,5,6,7, we want to get the corresponding element at\n            // original index 8,9,10,11, for output at index 8,9,10,11,\n            // we want to get the corresponding element at original index\n            // 16,17,18,19, so on and so forth.\n\n            var i = 0;\n            if (elemIdx < uniforms.k) {\n              i = elemIdx;\n            } else {\n              i = elemIdx * 2 - elemIdx % uniforms.k;\n            }\n            var i0 = 0;\n            if (uniforms.firstPass == 1) {\n              i0 = i;\n            } else {\n              i0 = i32(getIndices(batch, i));\n            }\n            var i1 = 0;\n            if (uniforms.firstPass == 1) {\n              i1 = i + uniforms.k;\n            } else {\n              i1 = i32(getIndices(batch, i + uniforms.k));\n            }\n\n            let x0 = getX(batch, i0);\n            var x1 = f32(0.0);\n            if (i1 < uniforms.inputSize) {\n              x1 = getX(batch, i1);\n            } else {\n              x1 = x0;\n            }\n\n            if (x0 >= x1) {\n              setOutputFlat(index, f32(i0));\n            } else {\n              setOutputFlat(index, f32(i1));\n            }\n          }\n        }\n      `}};function disposeIntermediateTensorInfoOrNull2(e,t){null!==t&&e.disposeData(t.dataId)}function roundUpToPow22(e){let t=1;for(;t<e;)t*=2;return t}function topK3(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{k:s,sorted:o}=a,i=r.shape,l=i[i.length-1];if(n.shouldExecuteOnCPU([r])){const e=n.readSync(r.dataId),[t,a]=topKImplCPU2(e,i,r.dtype,s,o);return[n.makeTensorInfo(t.shape,t.dtype,t.values),n.makeTensorInfo(a.shape,a.dtype,a.values)]}if(0===s)return i[i.length-1]=0,[n.makeTensorInfo(i,r.dtype,[]),n.makeTensorInfo(i,"int32",[])];if(1===l)return[r,fill4({attrs:{shape:i,dtype:"int32",value:0},backend:n})];const u=util_exports.sizeFromShape(i)/l,c=reshape5({inputs:{x:r},attrs:{shape:[u,l]},backend:n}),d=roundUpToPow22(s),p=roundUpToPow22(l);let h=null;const m=()=>null===h?[c,c]:[c,h],f=(e,t,a)=>{const r=m(),s=new SwapProgram2(a),o=[{type:"int32",data:[l]},{type:"int32",data:[null===h?1:0]},{type:"float32",data:[Number.NEGATIVE_INFINITY]},{type:"int32",data:[e]},{type:"int32",data:[t]}],i=h;h=n.runWebGPUProgram(s,r,"int32",o),disposeIntermediateTensorInfoOrNull2(n,i)};for(let e=1;e<d;e*=2){const t=2*e;for(let n=e;n>=1;n/=2)f(t,n,[u,p])}for(let e=p;e>d;e/=2){const t=m(),a=new MergeProgram2([u,e/2]),r=[{type:"int32",data:[l]},{type:"int32",data:[null===h?1:0]},{type:"int32",data:[d]}],s=h;h=n.runWebGPUProgram(a,t,"int32",r),disposeIntermediateTensorInfoOrNull2(n,s);const o=d/2,i=2*o;for(let e=o;e>=1;e/=2)f(i,e,h.shape)}let g=h;h=slice4({inputs:{x:h},backend:n,attrs:{begin:0,size:[u,s]}}),disposeIntermediateTensorInfoOrNull2(n,g);let x=gatherV23({inputs:{x:c,indices:h},backend:n,attrs:{axis:1,batchDims:1}});disposeIntermediateTensorInfoOrNull2(n,c);const y=i.slice(0,-1);y.push(s),g=h,h=reshape5({inputs:{x:h},attrs:{shape:y},backend:n}),disposeIntermediateTensorInfoOrNull2(n,g);const A=x;return x=reshape5({inputs:{x:x},attrs:{shape:y},backend:n}),disposeIntermediateTensorInfoOrNull2(n,A),[x,h]}var topKConfig3={kernelName:TopK,backendName:"webgpu",kernelFunc:topK3},TransformProgram2=class{constructor(e){this.variableNames=["Image","Transforms"],this.uniforms="interpolationModeId : i32; fillModeId : i32; fillValue : f32;",this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="transform"}getUserCode(){return`\n          fn mapCoord(outCoord : f32, len : f32) -> f32{\n            var inCoord = outCoord;\n            if(uniforms.fillModeId == 2) {\n              if (inCoord < 0.0) {\n                if (len <= 1.0) {\n                  inCoord = 0.0;\n                } else {\n                  let sz2 = 2.0 * len;\n                  if (inCoord < sz2) {\n                    inCoord = sz2 * f32(i32(f32(-inCoord / sz2))) +\n                    inCoord;\n                  }\n                  if (inCoord < -len) {\n                    inCoord = inCoord + sz2;\n                  } else {\n                    inCoord = -inCoord - 1.0;\n                  }\n                }\n              } elseif (inCoord > len - 1.0) {\n                if (len <= 1.0) {\n                  inCoord = 0.0;\n                } else {\n                  let sz2 = 2.0 * len;\n                  inCoord = inCoord - sz2 * f32(i32(f32(inCoord / sz2)));\n                  if (inCoord >= len) {\n                    inCoord = sz2 - inCoord - 1.0;\n                  }\n                }\n              }\n              return clamp(inCoord, 0.0, len - 1.0);\n            } elseif (uniforms.fillModeId == 3) {\n              if (inCoord < 0.0) {\n                if (len <= 1.0) {\n                  inCoord = 0.0;\n                } else {\n                  let sz = len - 1.0;\n                  inCoord = inCoord + len * (f32(i32(f32(-inCoord / sz))) + 1.0);\n                }\n              } elseif (inCoord > len - 1.0) {\n                if (len <= 1.0) {\n                  inCoord = 0.0;\n                } else {\n                  let sz = len - 1.0;\n                  inCoord = inCoord - len * f32(i32(f32(inCoord / sz)));\n                }\n              }\n              return clamp(inCoord, 0.0, len - 1.0);\n            } elseif (uniforms.fillModeId == 4) {\n              return clamp(outCoord, 0.0, len - 1.0);\n            }\n            return outCoord;\n          }\n          fn readWithFillValue(batch : i32, coordY : i32, coordX : i32,\n            channel : i32) -> f32 {\n            var outputValue : f32;\n            if (0 <= coordY && coordY < uniforms.imageShape[1] && 0 <= coordX && coordX < uniforms.imageShape[2]) {\n                outputValue = getImage(batch, coordY, coordX, channel);\n            } else {\n              outputValue = uniforms.fillValue;\n            }\n            return outputValue;\n          }\n\n          ${getMainHeaderAndGlobalIndexString()}\n            if (index < uniforms.size) {\n              let coords = getCoordsFromFlatIndex(index);\n              var outputValue : f32;\n              let batch = coords[0];\n              let x = coords[2];\n              let y = coords[1];\n              let channel = coords[3];\n              let xf = f32(x);\n              let yf = f32(y);\n              let a1 = getTransforms(batch, 0);\n              let a2 = getTransforms(batch, 1);\n              let a3 = getTransforms(batch, 2);\n              let b1 = getTransforms(batch, 3);\n              let b2 = getTransforms(batch, 4);\n              let b3 = getTransforms(batch, 5);\n              let c1 = getTransforms(batch, 6);\n              let c2 = getTransforms(batch, 7);\n              let projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = uniforms.fillValue;\n              } else {\n                let inX = (a1 * xf + a2 * yf + a3) / projection;\n                let inY = (b1 * xf + b2 * yf + b3) / projection;\n                let mapX = mapCoord(inX, f32(uniforms.imageShape[2]));\n                let mapY = mapCoord(inY, f32(uniforms.imageShape[1]));\n\n                if (uniforms.interpolationModeId == 1) {\n                  let coordY = i32(round(mapY));\n                  let coordX = i32(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  let yFloor = floor(mapY);\n                  let xFloor = floor(mapX);\n                  let yCeil = yFloor + 1.0;\n                  let xCeil = xFloor + 1.0;\n                  let valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, i32(yFloor), i32(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, i32(yFloor), i32(xCeil), channel);\n                  let valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, i32(yCeil), i32(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, i32(yCeil), i32(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutputFlat(index, outputValue);\n            }\n          }\n        `}};function transform4(e){const{inputs:t,backend:n,attrs:a}=e,{image:r,transforms:s}=t,{interpolation:o,fillMode:i,fillValue:l,outputShape:u}=a,[c,d,p,h]=r.shape,[m,f]=null!=u?u:[d,p],g=new TransformProgram2([c,m,f,h]),x="nearest"===o?1:2;let y;switch(i){case"constant":default:y=1;break;case"reflect":y=2;break;case"wrap":y=3;break;case"nearest":y=4}const A=[{type:"int32",data:[x]},{type:"int32",data:[y]},{type:"float32",data:[l]}];return n.runWebGPUProgram(g,[r,s],"float32",A)}var transformConfig3={kernelName:Transform,backendName:"webgpu",kernelFunc:transform4};function unpack3(e){const{inputs:t,backend:n,attrs:a}=e,{value:r}=t;let{axis:s}=a;s<0&&(s+=r.shape.length);const o=r,i=o.shape.length,l=r.shape[s],u=new Array(i-1);let c=0;for(let e=0;e<i;e++)e!==s&&(u[c++]=o.shape[e]);const d=[],p=new Array(i).fill(0),h=o.shape.slice();h[s]=1;const m=new Array(l);for(let e=0;e<m.length;e++){p[s]=e;const t=slice4({inputs:{x:o},backend:n,attrs:{begin:p,size:h}}),a=reshape5({inputs:{x:t},backend:n,attrs:{shape:u}});m[e]=a,d.push(t)}return d.forEach((e=>n.disposeData(e.dataId))),m}var unpackConfig3={kernelName:Unpack,backendName:"webgpu",kernelFunc:unpack3},kernelConfigs3=[_fusedMatMulConfig3,absConfig3,addConfig3,addNConfig3,argMaxConfig3,argMinConfig3,avgPoolConfig3,batchMatMulConfig3,batchToSpaceNDConfig3,castConfig3,ceilConfig3,clipByValueConfig2,complexConfig3,concatConfig3,conv2DConfig3,conv2DBackpropInputConfig3,cosConfig3,coshConfig3,cropAndResizeConfig3,depthToSpaceConfig3,depthwiseConv2dNativeConfig3,einsumConfig3,eluConfig3,equalConfig3,expandDimsConfig3,expConfig3,expm1Config3,fillConfig3,flipLeftRightConfig3,fromPixelsConfig2,floorConfig3,floorDivConfig3,fusedBatchNormConfig,fusedConv2DConfig3,fusedDepthwiseConv2DConfig3,gatherNdConfig3,gatherV2Config3,greaterConfig3,greaterEqualConfig3,identityConfig3,imagConfig3,lessConfig3,lessEqualConfig3,logConfig3,logicalAndConfig3,logicalNotConfig3,maxConfig3,maximumConfig3,maxPoolConfig3,meanConfig3,minConfig3,minimumConfig3,mirrorPadConfig3,multiplyConfig3,negConfig3,nonMaxSuppressionV3Config3,nonMaxSuppressionV5Config3,notEqualConfig3,onesLikeConfig3,packConfig3,padV2Config3,preluConfig3,prodConfig3,powConfig3,rangeConfig3,realConfig3,realDivConfig3,reluConfig3,relu6Config3,reshapeConfig3,resizeBilinearConfig3,resizeNearestNeighborConfig3,rotateWithOffsetConfig3,rsqrtConfig3,scatterNdConfig3,selectConfig3,sigmoidConfig3,sinConfig3,sinhConfig3,sliceConfig3,stridedSliceConfig3,stringNGramsConfig3,softmaxConfig3,spaceToBatchNDConfig3,splitVConfig3,sparseToDenseConfig3,sqrtConfig3,squareConfig3,squaredDifferenceConfig3,subConfig3,sumConfig3,tanhConfig3,tileConfig3,topKConfig3,transformConfig3,transposeConfig3,unpackConfig3,zerosLikeConfig3];for(const e of kernelConfigs3)registerKernel(e);var BufferManager=class{constructor(e){this.device=e,this.numUsedBuffers=0,this.numFreeBuffers=0,this.freeBuffers=new Map,this.usedBuffers=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireBuffer(e,t){const n=getBufferKey(e,t);if(this.freeBuffers.has(n)||this.freeBuffers.set(n,[]),this.usedBuffers.has(n)||this.usedBuffers.set(n,[]),this.numBytesUsed+=e,this.numUsedBuffers++,this.freeBuffers.get(n).length>0){this.numFreeBuffers--;const e=this.freeBuffers.get(n).shift();return this.usedBuffers.get(n).push(e),e}this.numBytesAllocated+=e;const a=this.device.createBuffer({size:e,usage:t});return this.usedBuffers.get(n).push(a),a}releaseBuffer(e,t,n){if(null==this.freeBuffers)return;const a=getBufferKey(t,n);this.freeBuffers.has(a)||this.freeBuffers.set(a,[]),this.freeBuffers.get(a).push(e),this.numFreeBuffers++,this.numUsedBuffers--;const r=this.usedBuffers.get(a),s=r.indexOf(e);if(s<0)throw new Error("Cannot release a buffer that was never provided by this buffer manager");r.splice(s,1),this.numBytesUsed-=t}getNumUsedBuffers(){return this.numUsedBuffers}getNumFreeBuffers(){return this.numFreeBuffers}reset(){this.freeBuffers=new Map,this.usedBuffers=new Map,this.numUsedBuffers=0,this.numFreeBuffers=0,this.numBytesUsed=0,this.numBytesAllocated=0}dispose(){null==this.freeBuffers&&null==this.usedBuffers||(this.freeBuffers.forEach(((e,t)=>{e.forEach((e=>{e.destroy()}))})),this.usedBuffers.forEach(((e,t)=>{e.forEach((e=>{e.destroy()}))})),this.freeBuffers=null,this.usedBuffers=null,this.numUsedBuffers=0,this.numFreeBuffers=0,this.numBytesUsed=0,this.numBytesAllocated=0)}};function getBufferKey(e,t){return`${e}_${t}`}var FromPixelsProgram2=class{constructor(){this.outputShape=[0],this.variableNames=[],this.workGroupSize=[256,1,1],this.lastUniformData=[],this.inputTexture=null,this.layout=null,this.lastPixelSize={width:0,height:0},this.disposed=!1,this.shaderKey="fromPixels",this.useImport=!1}updateOutputShape(e){util_exports.arraysEqual(this.outputShape,e)||(this.outputShape=e,this.workPerThread=e[2],this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]))}makeFromPixelsSource(){const e=this.useImport?"textureLoad(src, vec2<i32>(coords.yx));":"textureLoad(src, vec2<i32>(coords.yx), 0)";return`\n      [[binding(1), group(0)]] var src: ${this.useImport?"texture_external":"texture_2d<f32>"};\n\n      ${getMainHeaderAndGlobalIndexString()}\n        let flatIndexBase = index * uniforms.numChannels;\n        for (var i = 0; i < uniforms.numChannels; i = i + 1) {\n          let flatIndex = flatIndexBase + i;\n          if (flatIndex < uniforms.size) {\n            let coords = getCoordsFromFlatIndex(flatIndexBase);\n            let values = ${e};\n            result.numbers[flatIndex] = i32(floor(255.0 * values[i]));\n          }\n        }\n      }\n  `}getUserCode(){return this.makeFromPixelsSource()}setPipeline(e){this.pipeline=e}setUniform(e,t){if(!this.uniform){const n=e.createBuffer({size:4*t.length,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});this.uniform=n}!t||t.length===this.lastUniformData.length&&t.every(((e,t)=>e===this.lastUniformData[t]))||(e.queue.writeBuffer(this.uniform,0,new Uint32Array(t)),this.lastUniformData=t)}makeInputTexture(e,t,n){return this.inputTexture&&this.lastPixelSize.width===t&&this.lastPixelSize.height===n||(this.inputTexture&&this.inputTexture.destroy(),this.inputTexture=e.createTexture({size:[t,n],format:"rgba8unorm",usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING}),this.lastPixelSize.width=t,this.lastPixelSize.height=n),this.inputTexture}dispose(){this.disposed||(this.uniform&&this.uniform.destroy(),this.inputTexture&&this.inputTexture.destroy(),this.disposed=!0)}getLayout(e){return null===this.layout&&(this.layout=this.createTextureLayout(e)),this.layout}createTextureLayout(e){const t=[];t.push({binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}),t.push({binding:1,visibility:GPUShaderStage.COMPUTE,texture:{}}),t.push({binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{}});const n=e.createBindGroupLayout({entries:t});return{bindGroupLayout:n,pipelineLayout:e.createPipelineLayout({bindGroupLayouts:[n]})}}},FromPixelsImportProgram=class extends FromPixelsProgram2{constructor(){super(...arguments),this.layout=null,this.useImport=!0}getUserCode(){return this.makeFromPixelsSource()}getLayout(e){return null===this.layout&&(this.layout=this.createTextureImportLayout(e)),this.layout}createTextureImportLayout(e){const t=[];t.push({binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}),t.push({binding:1,visibility:GPUShaderStage.COMPUTE,externalTexture:{}}),t.push({binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{}});const n=e.createBindGroupLayout({entries:t});return{bindGroupLayout:n,pipelineLayout:e.createPipelineLayout({bindGroupLayouts:[n]})}}},CPU_HANDOFF_SIZE_THRESHOLD2=env().getNumber("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD"),_WebGPUBackend=class extends KernelBackend{constructor(e,t=!1){if(super(),this.commandQueueOwnedIds=new WeakSet,this.tensorDisposalQueue=[],this.uniformDisposalQueue=[],this.disposed=!1,this.uploadWaitMs=0,this.downloadWaitMs=0,this.dispatchNumberInEncoder=0,!isWebGPUSupported())throw new Error("WebGPU is not supported on this device");this.layoutCache={},this.pipelineCache={},this.device=e,this.queue=e.queue,this.currentCommandEncoder=null,this.currentComputePass=null,this.supportTimeQuery=t,this.bufferManager=new BufferManager(this.device),this.tensorMap=new DataStorage(this,engine()),this.supportTimeQuery&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:2})),env().getBool("WEBGPU_USE_PROFILE_TOOL")&&(this.dummyCanvas=document.createElement("canvas"),this.dummyCanvas.width=1,this.dummyCanvas.height=1,this.dummyContext=this.dummyCanvas.getContext("webgpu"),this.dummyContext.configure({device:e,format:"bgra8unorm"}),document.body.appendChild(this.dummyCanvas))}nextDataId(){return _WebGPUBackend.nextDataId++}floatPrecision(){return 32}defaultGpuBufferUsage(){return GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST}flushDisposalQueue(){this.tensorDisposalQueue.forEach((e=>{this.maybeReleaseBuffer(e),this.tensorMap.delete(e)})),this.uniformDisposalQueue.forEach((e=>this.bufferManager.releaseBuffer(e.buffer,e.byteSize,e.usage))),this.tensorDisposalQueue=[],this.uniformDisposalQueue=[]}disposeData(e,t=!1){if(this.tensorMap.has(e)){const n=this.tensorMap.get(e);if(n.refCount--,!t&&n.refCount>0)return!1;if(this.commandQueueOwnedIds.has(e))return this.tensorDisposalQueue.push(e),!1;this.maybeReleaseBuffer(e);const{complexTensorInfos:a}=this.tensorMap.get(e);null!=a&&(this.disposeData(a.real.dataId,!0),this.disposeData(a.imag.dataId,!0)),this.tensorMap.delete(e)}return!0}memory(){return{numBytesInGPU:this.bufferManager.numBytesUsed,numBytesAllocatedInGPU:this.bufferManager.numBytesAllocated,unreliable:!1}}getBufferManager(){return this.bufferManager}acquireBuffer(e,t=this.defaultGpuBufferUsage()){return this.bufferManager.acquireBuffer(e,t)}maybeReleaseBuffer(e){const t=this.tensorMap.get(e);null!=t&&null!=t.bufferInfo.buffer&&(this.bufferManager.releaseBuffer(t.bufferInfo.buffer,t.bufferInfo.byteSize,t.bufferInfo.usage),t.bufferInfo.buffer=null)}refCount(e){if(this.tensorMap.has(e)){return this.tensorMap.get(e).refCount}return 0}incRef(e){this.tensorMap.get(e).refCount++}decRef(e){if(this.tensorMap.has(e)){this.tensorMap.get(e).refCount--}}write(e,t,n){if("complex64"===n&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const a={id:this.nextDataId()},r=util_exports.sizeFromShape(t)*GPUBytesPerElement(n);return"bool"===n&&e instanceof Uint8Array&&(e=Int32Array.from(e)),this.tensorMap.set(a,{dtype:n,values:e,bufferInfo:{byteSize:r,usage:this.defaultGpuBufferUsage()},refCount:1}),a}move(e,t,n,a,r){if("complex64"===a)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const s=util_exports.sizeFromShape(n)*GPUBytesPerElement(a);this.tensorMap.set(e,{dtype:a,values:t,bufferInfo:{byteSize:s,usage:this.defaultGpuBufferUsage()},refCount:r})}submitQueue(){this.ensureComputePassEnded(),this.queue.submit([this.currentCommandEncoder.finish()]),this.currentCommandEncoder=null,this.dispatchNumberInEncoder=0,this.commandQueueOwnedIds=new WeakSet,this.flushDisposalQueue()}getBuffer(e){return this.uploadToGPU(e),this.tensorMap.get(e).bufferInfo.buffer}getFromPixelsProgram(e){switch(e){case"copyExternal":return this.fromPixelProgram||(this.fromPixelProgram=new FromPixelsProgram2),this.fromPixelProgram;case"import":return this.fromPixelImportProgram||(this.fromPixelImportProgram=new FromPixelsImportProgram),this.fromPixelImportProgram;default:return void util_exports.assert(!1,(()=>"Unsupported fromPixels shape"))}}ensureCommandEncoderReady(){this.currentCommandEncoder||(this.currentCommandEncoder=this.device.createCommandEncoder())}ensureComputePassEnded(){this.currentComputePass&&(this.currentComputePass.endPass(),this.currentComputePass=null)}getComputePass(){return this.currentComputePass||(this.currentComputePass=this.currentCommandEncoder.beginComputePass()),this.currentComputePass}async getBufferData(e){if(null!=e.values)return e.values;const t=this.acquireBuffer(e.bufferInfo.byteSize,GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ);this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.copyBufferToBuffer(e.bufferInfo.buffer,0,t,0,e.bufferInfo.byteSize),this.submitQueue(),await t.mapAsync(GPUMapMode.READ);const n=t.getMappedRange().slice(0);return t.unmap(),null!=t&&this.bufferManager.releaseBuffer(t,e.bufferInfo.byteSize,GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ),env().getBool("WEBGPU_USE_PROFILE_TOOL")&&(util_exports.assert(void 0!==this.dummyContext,(()=>"Fail to get context for profiling tool")),this.dummyContext.getCurrentTexture()),n}convertAndCacheOnCPU(e,t){const n=this.tensorMap.get(e);return this.maybeReleaseBuffer(e),n.values=t,n.values}readSync(e){const t=this.tensorMap.get(e),{values:n}=t;if(null==n)throw new Error("WebGPU readSync is only available for CPU-resident tensors.");return n}async read(e){if(!this.tensorMap.has(e))throw new Error(`Tensor ${e} was not registered!`);const t=this.tensorMap.get(e),{values:n}=t;if(null!=n)return this.convertAndCacheOnCPU(e,n);let a;if("complex64"===t.dtype){const e=await Promise.all([this.read(t.complexTensorInfos.real.dataId),this.read(t.complexTensorInfos.imag.dataId)]),n=e[0],r=e[1];a=backend_util_exports.mergeRealAndImagArrays(n,r)}else{a=ArrayBufferToTypedArray(await this.getBufferData(t),t.dtype)}return this.convertAndCacheOnCPU(e,a),a}bufferSync(e){const t=this.readSync(e.dataId);let n=t;if("string"===e.dtype)try{n=t.map((e=>util_exports.decodeString(e)))}catch(e){throw new Error("Failed to decode encoded string bytes into utf-8")}return buffer(e.shape,e.dtype,n)}async time(e){const t=this.activeTimers,n=[];let a=!1;null==this.programTimersStack?(this.programTimersStack=n,a=!0):this.activeTimers.push(n),this.activeTimers=n,e();const r=util_exports.flatten(this.activeTimers.map((e=>e.query))).filter((e=>null!=e)),s=util_exports.flatten(this.activeTimers.map((e=>e.name))).filter((e=>null!=e));this.activeTimers=t,a&&(this.programTimersStack=null);const o={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null},i=await Promise.all(r);return o.kernelMs=util_exports.sum(i),o.getExtraProfileInfo=()=>i.map(((e,t)=>({name:s[t],ms:e}))).map((e=>`${e.name}: ${e.ms}`)).join(", "),this.uploadWaitMs=0,this.downloadWaitMs=0,o}getAndSavePipeline(e,t){return e in this.pipelineCache||(this.pipelineCache[e]=t()),this.pipelineCache[e]}makeTensorInfo(e,t,n){let a;if("string"===t&&null!=n&&n.length>0&&util_exports.isString(n[0])){const r=n.map((e=>util_exports.encodeString(e)));a=this.write(r,e,t)}else a=this.write(n,e,t);return{dataId:a,shape:e,dtype:t}}tensorToBinding(e){if(!e)return null;const t=this.tensorMap.get(e.dataId);return{offset:0,size:t.bufferInfo.byteSize,buffer:t.bufferInfo.buffer}}async getQueryTime(e){return this.supportTimeQuery?this.getTimeFromQuerySet(e):0}uploadToGPU(e){const t=this.tensorMap.get(e);null==t.bufferInfo.buffer&&(t.bufferInfo.buffer=this.acquireBuffer(t.bufferInfo.byteSize),t.values&&this.queue.writeBuffer(t.bufferInfo.buffer,0,t.values))}makeUniformsDataView(e){const t=this.acquireBuffer(e.byteLength,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);return this.queue.writeBuffer(t,0,e),{offset:0,size:e.byteLength,buffer:t}}arrayToDataView(e,t){const n=new DataView(new ArrayBuffer(4*t));let a=0;return e.forEach((e=>{const t=e.data;if("int32"!==e.type&&"float32"!==e.type&&"uint32"!==e.type)throw new Error(`${e.type} not supported!`);"int32"===e.type?t.forEach((e=>{n.setInt32(4*a,e,!0),a++})):"uint32"===e.type?t.forEach((e=>{n.setUint32(4*a,e,!0),a++})):t.forEach((e=>{n.setFloat32(4*a,e,!0),a++}))})),n}computePadding(e){let t=0,n=0,a=0;const r=[];return e.forEach(((e,s)=>{let o;switch(0===e.data.length&&(e.data=[1]),e.data.length){case 0:case 1:o=1;break;case 2:o=2;break;case 3:case 4:o=4;break;default:util_exports.assert(!1,(()=>`Unsupported ${e.data.length}D shape`))}n=Math.ceil(t/o)*o-t;for(let t=0;t<n;++t)r.push({type:e.type,data:[0]}),a++;r.push({type:e.type,data:e.data}),a+=e.data.length,t+=e.data.length+n})),this.arrayToDataView(r,a)}createLayout(e){const t=[];t.push({binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}});for(let n=0;n<e;n++)t.push({binding:n+1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}});t.push({binding:e+1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}});const n=this.device.createBindGroupLayout({entries:t});return{bindGroupLayout:n,pipelineLayout:this.device.createPipelineLayout({bindGroupLayouts:[n]})}}getCachedOrCreateLayout(e){return e in this.layoutCache||(this.layoutCache[e]=this.createLayout(e)),this.layoutCache[e]}runWebGPUProgram(e,t,n,a,r){if(!r){if(r=this.makeTensorInfo(e.outputShape,n),0===util_exports.sizeFromShape(r.shape)){return this.tensorMap.get(r.dataId).values=util_exports.getTypedArrayFromDType(r.dtype,0),r}this.uploadToGPU(r.dataId)}let s=[{type:"float32",data:[NaN]}];const o=t.concat(r).map((e=>e.shape)),i="int32";o.map((e=>{s.push({type:i,data:e})}));const l=util_exports.computeStrides(r.shape);if(s.push({type:i,data:l}),e.size){const t=util_exports.sizeFromShape(e.outputShape);s.push({type:i,data:[e.isVec4?t/4:t]})}a&&(s=[...s,...a]);let u=null;const c=this.computePadding(s),d=c.byteLength;u=this.makeUniformsDataView(c);const p=t.map(((t,n)=>{if("complex64"===t.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");return this.uploadToGPU(t.dataId),{dtype:this.tensorMap.get(t.dataId).dtype,shape:t.shape,name:e.variableNames[n]}})),h=p.map((e=>e.dtype)).concat(r.dtype),m=p.map((e=>backend_util_exports.getBroadcastDims(e.shape,r.shape))),f=p.map((e=>util_exports.arraysEqual(e.shape,r.shape))).join("_"),g=m.map((e=>e.join("_"))).join(";"),x=makeShaderKey2(e,o,h,g,f),{bindGroupLayout:y,pipelineLayout:A}=this.getCachedOrCreateLayout(e.variableNames.length),b=this.getAndSavePipeline(x,(()=>compileProgram2(this.device,e,A,p,r))),v=null!=this.activeTimers,k=makeBindGroup(this.device,y,t.map((e=>this.tensorToBinding(e))),this.tensorToBinding(r),u);this.ensureCommandEncoderReady();const S=this.getComputePass();if(v&&this.supportTimeQuery&&S.writeTimestamp(this.querySet,0),S.setPipeline(b),S.setBindGroup(0,k),S.dispatch(e.dispatch[0],e.dispatch[1],e.dispatch[2]),v&&this.supportTimeQuery&&S.writeTimestamp(this.querySet,1),this.dispatchNumberInEncoder++,t.forEach((e=>{this.commandQueueOwnedIds.add(e.dataId)})),this.commandQueueOwnedIds.add(r.dataId),u){const e={byteSize:d,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM,buffer:u.buffer};this.uniformDisposalQueue.push(e)}return env().get("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE")<=this.dispatchNumberInEncoder&&this.submitQueue(),v&&this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(this.querySet)}),r}runFromPixelsProgram(e,t,n,a,r){const s=this.device.createBindGroup({layout:n.bindGroupLayout,entries:[{binding:0,resource:{buffer:t}},{binding:1,resource:a},{binding:2,resource:{buffer:e.uniform}}]});this.ensureCommandEncoderReady();const o=this.getComputePass(),i=null!=this.activeTimers;i&&this.supportTimeQuery&&o.writeTimestamp(this.querySet,0),o.setPipeline(e.pipeline),o.setBindGroup(0,s),o.dispatch(e.dispatch[0],e.dispatch[1],e.dispatch[2]),i&&this.supportTimeQuery&&o.writeTimestamp(this.querySet,1),this.commandQueueOwnedIds.add(r),this.submitQueue(),i&&this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(this.querySet)})}async getTimeFromQuerySet(e){const t=this.acquireBuffer(16,GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE),n=this.acquireBuffer(16,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.resolveQuerySet(e,0,2,t,0),this.currentCommandEncoder.copyBufferToBuffer(t,0,n,0,16),this.submitQueue(),await n.mapAsync(GPUMapMode.READ);const a=new BigUint64Array(n.getMappedRange()),r=Number(a[1]-a[0]);return n.unmap(),this.bufferManager.releaseBuffer(n,16,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST),this.bufferManager.releaseBuffer(t,16,GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE),r/1e6}shouldExecuteOnCPU(e,t=CPU_HANDOFF_SIZE_THRESHOLD2){return env().getBool("WEBGPU_CPU_FORWARD")&&e.every((e=>null==this.tensorMap.get(e.dataId).bufferInfo.buffer&&util_exports.sizeFromShape(e.shape)<t))}numDataIds(){return this.tensorMap.numDataIds()-this.tensorDisposalQueue.length}dispose(){this.disposed||(this.bufferManager.dispose(),this.fromPixelProgram&&this.fromPixelProgram.dispose(),this.fromPixelImportProgram&&this.fromPixelImportProgram.dispose(),this.disposed=!0)}},WebGPUBackend=_WebGPUBackend;WebGPUBackend.nextDataId=0;var CppDType,FusableActivation,wasmFusedMatMul,webgpu_exports={};function setup(e){wasmFusedMatMul=e.wasm.cwrap(_FusedMatMul,null,["number","array","number","number","array","number","number","number","number","number","number","number","number"])}function fusedBatchMatMul(e){const{inputs:t,backend:n,attrs:a}=e,{a:r,b:s,bias:o,preluActivationWeights:i}=t;if("float32"!==r.dtype||"float32"!==s.dtype)throw new Error("_FusedMatMul for non non-float32 tensors not yet supported.");const{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:d}=a,p=n.dataIdMap.get(r.dataId).id,h=n.dataIdMap.get(s.dataId).id;let m=0;if(null!=o){const e=n.dataIdMap.get(o.dataId);if(1!==e.shape.length)throw new Error(`_FusedMatMul only supports rank-1 bias but got rank ${e.shape.length}.`);m=e.id}const f=null==i?0:n.dataIdMap.get(i.dataId).id,g=FusableActivation[c];if(null==g)throw new Error(`${c} activation not yet supported for FusedConv2D in the wasm backend.`);const x=l?r.shape[2]:r.shape[1],y=u?s.shape[1]:s.shape[2],A=broadcast_util_exports.assertAndGetBroadcastShape(r.shape.slice(0,-2),s.shape.slice(0,-2)),b=n.makeOutput([...A,x,y],r.dtype),v=n.dataIdMap.get(b.dataId).id,k=new Uint8Array(new Int32Array(r.shape).buffer),S=new Uint8Array(new Int32Array(s.shape).buffer);return wasmFusedMatMul(p,k,r.shape.length,h,S,s.shape.length,l,u,g,m,f,d||0,v),b}__export2(webgpu_exports,{WebGPUBackend:()=>WebGPUBackend,webgpu_util:()=>webgpu_util_exports}),device_util_exports.isBrowser()&&isWebGPUSupported()&&registerBackend("webgpu",(async()=>{env().set("CHECK_COMPUTATION_FOR_ERRORS",!1);const e={powerPreference:env().get("WEBGPU_USE_LOW_POWER_GPU")?"low-power":"high-performance"},t=await navigator.gpu.requestAdapter(e);let n={};const a=t.features.has("timestamp-query");a?n={requiredFeatures:["timestamp-query"]}:console.warn("This device doesn't support timestamp-query extension. Start Chrome browser with flag --disable-dawn-features=disallow_unsafe_apis then try again. Or zero will shown for the kernel time when profiling mode isenabled. Using performance.now is not workable for webgpu sinceit doesn't support synchronously to read data from GPU.");const r=await t.requestDevice(n);return new WebGPUBackend(r,a)}),3),function(e){e[e.float32=0]="float32",e[e.int32=1]="int32",e[e.bool=2]="bool",e[e.string=3]="string",e[e.complex64=4]="complex64"}(CppDType||(CppDType={})),function(e){e[e.linear=0]="linear",e[e.relu=1]="relu",e[e.relu6=2]="relu6",e[e.prelu=3]="prelu",e[e.leakyrelu=4]="leakyrelu",e[e.sigmoid=5]="sigmoid",e[e.elu=6]="elu"}(FusableActivation||(FusableActivation={}));var fusedMatMulConfig={kernelName:_FusedMatMul,backendName:"wasm",setupFunc:setup,kernelFunc:fusedBatchMatMul};function createUnaryKernelConfig(e,t){let n;return{kernelName:e,backendName:"wasm",setupFunc:function(t){n=t.wasm.cwrap(e,null,["number","number","number"])},kernelFunc:function(e){const{backend:a,inputs:{x:r}}=e,s=a.dataIdMap.get(r.dataId).id,o=a.makeOutput(r.shape,t||r.dtype),i=a.dataIdMap.get(o.dataId).id;return 0===util_exports.sizeFromShape(o.shape)||n(s,CppDType[r.dtype],i),o}}}var absConfig4=createUnaryKernelConfig(Abs);function createBinaryKernelConfig(e,t,n){let a;return{kernelName:e,backendName:"wasm",setupFunc:function(t){a=t.wasm.cwrap(e,null,["number","array","number","number","array","number","number","number"])},kernelFunc:function(r){const{backend:s,inputs:o}=r,{a:i,b:l}=o,u=s.dataIdMap.get(i.dataId).id,c=s.dataIdMap.get(l.dataId).id,d=null!=n?n:i.dtype,p=backend_util_exports.assertAndGetBroadcastShape(i.shape,l.shape),h=s.makeOutput(p,d);if(0===util_exports.sizeFromShape(p))return h;const m=new Uint8Array(new Int32Array(i.shape).buffer),f=new Uint8Array(new Int32Array(l.shape).buffer),g=s.dataIdMap.get(h.dataId).id,x=()=>a(u,m,i.shape.length,c,f,l.shape.length,CppDType[i.dtype],g);if(t&&"float32"===i.dtype)return x(),h;const y=backend_util_exports.getBroadcastDims(i.shape,p),A=backend_util_exports.getBroadcastDims(l.shape,p),b=y.every(((e,t)=>e===t)),v=A.every(((e,t)=>e===t));if(b&&v)return x(),h;throw new Error(`Broadcasting along outer dims is not yet supported for ${i.dtype} ${e}.`)}}}var wasmFunc,supportsFullBroadcast=!0,addConfig4=createBinaryKernelConfig(Add,supportsFullBroadcast);function setupFunc(e){wasmFunc=e.wasm.cwrap(AddN,null,["array","number","number","number"])}function addn(e){const{inputs:t,backend:n}=e,a=n.makeOutput(t[0].shape,t[0].dtype);if(0===util_exports.sizeFromShape(a.shape))return a;const r=t.map((e=>n.dataIdMap.get(e.dataId).id)),s=new Uint8Array(new Int32Array(r).buffer),o=n.dataIdMap.get(a.dataId).id;return wasmFunc(s,r.length,CppDType[a.dtype],o),a}var addNConfig4={kernelName:AddN,backendName:"wasm",setupFunc:setupFunc,kernelFunc:addn};function identity5(e){const{inputs:{x:t},backend:n}=e,a=n.makeOutput(t.shape,t.dtype),r=n.typedArrayFromHeap(t);return n.typedArrayFromHeap(a).set(r),a}var wasmTranspose,identityConfig4={kernelName:Identity,backendName:"wasm",kernelFunc:identity5};function setup2(e){wasmTranspose=e.wasm.cwrap(Transpose,null,["number","array","number","number","number","array","number"])}function transpose5(e){const{inputs:t,backend:n,attrs:a}=e,[r,s]=removeOneSizeDims(t.x.shape,a.perm);let o=!0;for(let e=0;e<s.length;e++)s[e]!==e&&(o=!1);const i=computeOutShape4(t.x.shape,a.perm),l={dataId:t.x.dataId,shape:r,dtype:t.x.dtype};if(o){const e=identity5({inputs:t,backend:n});return e.shape=i,e}const u=n.makeOutput(i,l.dtype),c=n.dataIdMap.get(l.dataId).id,d=n.dataIdMap.get(u.dataId).id,p=new Uint8Array(new Int32Array(s).buffer),h=new Uint8Array(new Int32Array(l.shape).buffer);return wasmTranspose(c,h,l.shape.length,CppDType[l.dtype],d,p,s.length),u}function computeOutShape4(e,t){const n=new Array(e.length);for(let a=0;a<n.length;a++)n[a]=e[t[a]];return n}function removeOneSizeDims(e,t){const n=[],a=[];for(let r=0;r<e.length;++r)1!==e[r]&&n.push(e[r]),1!==e[t[r]]&&a.push(t[r]);for(let e=0;e<a.length;++e){let t=-1;for(let n=0;n<a.length;++n)a[n]>=e&&(-1===t||a[t]>a[n])&&(t=n);a[t]=e}return[n,a]}var wasmAll,transposeConfig4={kernelName:Transpose,backendName:"wasm",kernelFunc:transpose5,setupFunc:setup2};function permuteAxesAndTranspose(e,t,n){const a=e.shape,r=e.shape.length,s=util_exports.parseAxisParam(t,a);let o=s;const i=backend_util_exports.getAxesPermutation(o,r);let l=null,u=!1;if(null!=i){const t=new Array(r);for(let e=0;e<t.length;e++)t[e]=a[i[e]];o=backend_util_exports.getInnerMostAxes(o.length,r),l=transpose5({inputs:{x:e},attrs:{perm:i},backend:n});const s=n.dataIdMap.get(e.dataId).id;n.dataIdMap.get(l.dataId).id!==s&&(u=!0)}return{transposed:l,originalAxes:s,axes:o,inputWasTransposed:u}}function setup3(e){wasmAll=e.wasm.cwrap(All,null,["number, number, number"])}function all4(e){const{backend:t,inputs:n,attrs:a}=e,{axis:r,keepDims:s}=a,{x:o}=n;let i=t.dataIdMap.get(o.dataId).id,l=o;const{transposed:u,axes:c,originalAxes:d,inputWasTransposed:p}=permuteAxesAndTranspose(o,r,t);if(p){l=u,i=t.dataIdMap.get(u.dataId).id}const h=l.shape.length;backend_util_exports.assertAxesAreInnerMostDims("all",c,h);const[m,f]=backend_util_exports.computeOutAndReduceShapes(l.shape,c),g=util_exports.sizeFromShape(f),x=t.makeOutput(m,o.dtype);if(0!==util_exports.sizeFromShape(l.shape)){const e=t.dataIdMap.get(x.dataId).id;wasmAll(i,g,e)}if(p&&t.disposeData(u.dataId),s){const e=backend_util_exports.expandShapeToKeepDim(x.shape,d);x.shape=e}return x}var wasmAny,allConfig3={kernelName:All,backendName:"wasm",setupFunc:setup3,kernelFunc:all4};function setup4(e){wasmAny=e.wasm.cwrap(Any,null,["number, number, number"])}function any4(e){const{backend:t,inputs:n,attrs:a}=e,{axis:r,keepDims:s}=a,{x:o}=n;let i=t.dataIdMap.get(o.dataId).id,l=o;const{transposed:u,axes:c,originalAxes:d,inputWasTransposed:p}=permuteAxesAndTranspose(o,r,t);if(p){l=u,i=t.dataIdMap.get(u.dataId).id}const h=l.shape.length;backend_util_exports.assertAxesAreInnerMostDims("any",c,h);const[m,f]=backend_util_exports.computeOutAndReduceShapes(l.shape,c),g=util_exports.sizeFromShape(f),x=t.makeOutput(m,o.dtype);if(0!==util_exports.sizeFromShape(l.shape)){const e=t.dataIdMap.get(x.dataId).id;wasmAny(i,g,e)}if(p&&t.disposeData(u.dataId),s){const e=backend_util_exports.expandShapeToKeepDim(x.shape,d);x.shape=e}return x}var wasmFunc2,anyConfig3={kernelName:Any,backendName:"wasm",setupFunc:setup4,kernelFunc:any4};function setup5(e){wasmFunc2=e.wasm.cwrap(ArgMax,null,["number","number","number","number","number"])}function argmax(e){const{backend:t,inputs:n,attrs:a}=e,{axis:r}=a,{x:s}=n,o=t.dataIdMap.get(s.dataId).id;let i=o,l=s;const{transposed:u,axes:c,inputWasTransposed:d}=permuteAxesAndTranspose(s,r,t);if(d){const e=t.dataIdMap.get(u.dataId).id;e!==o&&(l=u,i=e)}const p=l.shape.slice(0,-1),h=t.makeOutput(p,"int32"),m=t.dataIdMap.get(h.dataId).id,f=util_exports.sizeFromShape(h.shape),g=l.shape[c[0]];return wasmFunc2(i,CppDType[l.dtype],f,g,m),d&&t.disposeData(u.dataId),h}var wasmAvgPool,argMaxConfig4={kernelName:ArgMax,backendName:"wasm",kernelFunc:argmax,setupFunc:setup5};function setup6(e){wasmAvgPool=e.wasm.cwrap(AvgPool,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function avgPool5(e){const{inputs:t,attrs:n,backend:a}=e,r=t.x,s=a.dataIdMap.get(r.dataId).id,{filterSize:o,strides:i,pad:l,dimRoundingMode:u}=n,c=backend_util_exports.computePool2DInfo(r.shape,o,i,1,l,u),d=c.filterHeight,p=c.filterWidth,h=c.padInfo.top,m=c.padInfo.right,f=c.padInfo.bottom,g=c.padInfo.left,x=c.strideHeight,y=c.strideWidth,A=c.inChannels;if("channelsLast"!==c.dataFormat)throw new Error(`wasm backend does not support dataFormat:'${c.dataFormat}'. Please use 'channelsLast'.`);if(1!==c.dilationWidth||1!==c.dilationHeight)throw new Error(`was backend only supports average pooling with dilation = [1, 1], got [${c.dilationHeight}, ${c.dilationWidth}].`);const b=a.makeOutput(c.outShape,"float32"),v=a.dataIdMap.get(b.dataId).id;return wasmAvgPool(s,r.shape[0],r.shape[1],r.shape[2],d,p,h,m,f,g,x,y,A,v),b}var avgPoolConfig4={kernelName:AvgPool,backendName:"wasm",setupFunc:setup6,kernelFunc:avgPool5};function reshape6(e){const{inputs:t,attrs:n}=e,{x:a}=t,{shape:r}=n,s=util_exports.sizeFromShape(a.shape),o=util_exports.inferFromImplicitShape(r,s);return util_exports.assert(s===util_exports.sizeFromShape(o),(()=>`new shape: ${o}, old shape: ${a.shape}. New shape and old shape must have the same number of elements.`)),e.backend.incRef(a.dataId),{dataId:a.dataId,shape:o,dtype:a.dtype}}var wasmBatchMatMul,reshapeConfig4={kernelName:Reshape,backendName:"wasm",kernelFunc:reshape6};function setup7(e){wasmBatchMatMul=e.wasm.cwrap(BatchMatMul,null,["number","array","number","number","array","number","number","number","number"])}function batchMatMul4(e){const{inputs:t,backend:n,attrs:a}=e,{a:r,b:s}=t,{transposeA:o,transposeB:i}=a;if("float32"!==r.dtype||"float32"!==s.dtype)throw new Error("BatchMatMul for non non-float32 tensors not yet supported.");const l=r.shape.length,u=s.shape.length,c=o?r.shape[l-2]:r.shape[l-1],d=i?s.shape[u-1]:s.shape[u-2],p=o?r.shape[l-1]:r.shape[l-2],h=i?s.shape[u-2]:s.shape[u-1],m=r.shape.slice(0,-2),f=s.shape.slice(0,-2),g=util_exports.sizeFromShape(m),x=util_exports.sizeFromShape(f),y=broadcast_util_exports.assertAndGetBroadcastShape(r.shape.slice(0,-2),s.shape.slice(0,-2)).concat([p,h]);util_exports.assert(c===d,(()=>`Error in matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${r.shape} and ${s.shape} and transposeA=${o} and transposeB=${i} must match.`));const A=i?[x,h,d]:[x,d,h],b=reshape6({inputs:{x:r},backend:n,attrs:{shape:o?[g,c,p]:[g,p,c]}}),v=reshape6({inputs:{x:s},backend:n,attrs:{shape:A}}),k=n.dataIdMap.get(b.dataId).id,S=n.dataIdMap.get(v.dataId).id,w=o?b.shape[2]:b.shape[1],C=i?v.shape[1]:v.shape[2],I=Math.max(g,x),T=n.makeOutput([I,w,C],b.dtype),N=n.dataIdMap.get(T.dataId).id,_=new Uint8Array(new Int32Array(b.shape).buffer),E=new Uint8Array(new Int32Array(v.shape).buffer);return wasmBatchMatMul(k,_,b.shape.length,S,E,v.shape.length,o,i,N),n.disposeData(b.dataId),n.disposeData(v.dataId),T.shape=y,T}var batchMatMulConfig4={kernelName:BatchMatMul,backendName:"wasm",setupFunc:setup7,kernelFunc:batchMatMul4};function slice5(e){const{inputs:{x:t},attrs:{begin:n,size:a},backend:r}=e,[s,o]=slice_util_exports.parseSliceParams(t,n,a),i=slice_util_exports.isSliceContinous(t.shape,s,o),l=r.readSync(t.dataId),u=r.makeOutput(o,t.dtype),c=util_exports.computeStrides(t.shape),d=r.dataIdMap.get(u.dataId);if(i){const e=slice_util_exports.computeFlatOffset(s,c);if("string"===t.dtype)d.stringBytes=l.slice(e,e+util_exports.sizeFromShape(o));else{r.typedArrayFromHeap(u).set(l.subarray(e,e+util_exports.sizeFromShape(o)))}return u}if("string"===t.dtype){const e=sliceImpl(l,s,o,t.shape,t.dtype);return d.stringBytes=e,u}const p=r.typedArrayFromHeap(u),h=t.shape.length;if(2===h)slice2d2(l,c[0],p,s,o);else if(3===h)slice3d2(l,c[0],c[1],p,s,o);else if(4===h)slice4d2(l,c[0],c[1],c[2],p,s,o);else{const e=sliceImpl(l,s,o,t.shape,t.dtype);p.set(e)}return u}function slice2d2(e,t,n,a,r){let s=0;const o=a[0],i=a[1],l=o+r[0];for(let a=o;a<l;a++){const o=a*t+i;n.set(e.subarray(o,o+r[1]),s),s+=r[1]}}function slice3d2(e,t,n,a,r,s){let o=0;const i=r[0],l=r[1],u=r[2],c=i+s[0],d=l+s[1];for(let r=i;r<c;r++)for(let i=l;i<d;i++){const l=r*t+i*n+u;a.set(e.subarray(l,l+s[2]),o),o+=s[2]}}function slice4d2(e,t,n,a,r,s,o){let i=0;const l=s[0],u=s[1],c=s[2],d=l+o[0],p=u+o[1],h=c+o[2],m=s[3];for(let s=l;s<d;s++)for(let l=u;l<p;l++)for(let u=c;u<h;u++){const c=s*t+l*n+u*a+m;r.set(e.subarray(c,c+o[3]),i),i+=o[3]}}var sliceConfig4={kernelName:Slice,backendName:"wasm",kernelFunc:slice5};function batchToSpaceND5(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:s,crops:o}=a,i=s.reduce(((e,t)=>e*t)),l=backend_util_exports.getReshaped(r.shape,s,i),u=backend_util_exports.getPermuted(l.length,s.length),c=backend_util_exports.getReshapedPermuted(r.shape,s,i),d=backend_util_exports.getSliceBeginCoords(o,s.length),p=backend_util_exports.getSliceSize(c,o,s.length),h=reshape6({inputs:{x:r},backend:n,attrs:{shape:l}}),m=transpose5({inputs:{x:h},backend:n,attrs:{perm:u}}),f=slice5({inputs:{x:reshape6({inputs:{x:m},backend:n,attrs:{shape:c}})},backend:n,attrs:{begin:d,size:p}});return n.disposeData(h.dataId),n.disposeData(m.dataId),n.disposeData(h.dataId),f}var batchToSpaceNDConfig4={kernelName:BatchToSpaceND,backendName:"wasm",kernelFunc:batchToSpaceND5};function cast6(e){const{inputs:{x:t},attrs:{dtype:n},backend:a}=e,r=a.makeOutput(t.shape,n),s=a.typedArrayFromHeap(t);return a.typedArrayFromHeap(r).set(s),r}var wasmClip,castConfig4={kernelName:Cast,backendName:"wasm",kernelFunc:cast6},ceilConfig4=createUnaryKernelConfig(Ceil);function setup8(e){wasmClip=e.wasm.cwrap(ClipByValue,null,["number","number","number","number"])}function clip2(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{clipValueMin:s,clipValueMax:o}=a,i=n.dataIdMap.get(r.dataId).id,l=n.makeOutput(r.shape,r.dtype),u=n.dataIdMap.get(l.dataId).id;return wasmClip(i,s,o,u),l}var clipByValueConfig3={kernelName:ClipByValue,backendName:"wasm",setupFunc:setup8,kernelFunc:clip2};function concat5(e){const{inputs:t,backend:n}=e,a=util_exports.parseAxisParam(e.attrs.axis,t[0].shape)[0];let r=backend_util_exports.computeOutShape(t.map((e=>e.shape)),a);const s=t.filter((e=>util_exports.sizeFromShape(e.shape)>0));if(1===s.length)return identity5({inputs:{x:s[0]},backend:n});const o=n.makeOutput(r,t[0].dtype);if(0===util_exports.sizeFromShape(r))return o;const i=s.map((e=>e.shape));if(backend_util_exports.assertParamsConsistent(i,a),"string"===s[0].dtype){const e=s.map((e=>{const t=util_exports.sizeFromShape(e.shape.slice(a));return reshape6({inputs:{x:e},backend:n,attrs:{shape:[-1,t]}})})),i=e.map((e=>({vals:n.readSync(e.dataId),shape:e.shape})));r=backend_util_exports.computeOutShape(e.map((e=>e.shape)),1);const l=1===e[0].shape[0],u=concatImpl(i,r,t[0].dtype,l),c=backend_util_exports.computeOutShape(s.map((e=>e.shape)),a);o.shape=c;return n.dataIdMap.get(o.dataId).stringBytes=backend_util_exports.fromStringArrayToUint8(u),e.forEach((e=>n.disposeData(e.dataId))),o}const l=util_exports.sizeFromShape(s[0].shape.slice(0,a));let u=0;const c=s.map((e=>{const t=util_exports.sizeFromShape(e.shape.slice(a));return u+=t,t})),d=s.map((e=>n.typedArrayFromHeap(e))),p=n.typedArrayFromHeap(o);for(let e=0;e<l;e++){let t=e*u;for(let n=0;n<d.length;n++){const a=c[n],r=e*a,s=d[n].subarray(r,r+a);p.set(s,t),t+=a}}return o}var wasmConv2d,concatConfig4={kernelName:Concat,backendName:"wasm",kernelFunc:concat5};function setup9(e){wasmConv2d=e.wasm.cwrap(Conv2D,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function conv2d6(e){const{inputs:t,attrs:n,backend:a}=e,{x:r,filter:s}=t,o=a.dataIdMap.get(r.dataId).id,i=a.dataIdMap.get(s.dataId).id,{strides:l,dilations:u,pad:c,dimRoundingMode:d,dataFormat:p}=n,h=backend_util_exports.convertConv2DDataFormat(p),m=backend_util_exports.computeConv2DInfo(r.shape,s.shape,l,u,c,d,!1,h),f=m.filterHeight,g=m.filterWidth,x=m.padInfo.top,y=m.padInfo.right,A=m.padInfo.bottom,b=m.padInfo.left,v=m.dilationHeight,k=m.dilationWidth,S=m.strideHeight,w=m.strideWidth,C=m.inChannels,I=m.outChannels,T="SAME"===m.padInfo.type?1:0;if("channelsLast"!==m.dataFormat)throw new Error(`wasm backend Conv2D does not support dataFormat:'${m.dataFormat}'. Please use 'channelsLast'.`);const N=a.makeOutput(m.outShape,"float32"),_=a.dataIdMap.get(N.dataId).id;return wasmConv2d(o,r.shape[0],r.shape[1],r.shape[2],i,f,g,x,y,A,b,T,v,k,S,w,C,I,_),N}var wasmConv2DBackpropInput,conv2DConfig4={kernelName:Conv2D,backendName:"wasm",setupFunc:setup9,kernelFunc:conv2d6};function setup10(e){wasmConv2DBackpropInput=e.wasm.cwrap(Conv2DBackpropInput,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function conv2DBackpropInput5(e){const{backend:t,inputs:n,attrs:a}=e,{dy:r,filter:s}=n,{strides:o,pad:i,dataFormat:l,dimRoundingMode:u,inputShape:c}=a,d=backend_util_exports.convertConv2DDataFormat(l),p=backend_util_exports.computeConv2DInfo(c,s.shape,o,1,i,u,!1,d),{batchSize:h,filterHeight:m,filterWidth:f,inChannels:g,inHeight:x,inWidth:y,outChannels:A,outHeight:b,outWidth:v,strideHeight:k,strideWidth:S}=p,w=m-1-p.padInfo.top,C=f-1-p.padInfo.left,I="channelsLast"===p.dataFormat,T=util_exports.computeStrides(p.inShape),N=util_exports.computeStrides(r.shape),[_,E,P]=util_exports.computeStrides(s.shape),R=T[0],M=I?T[1]:T[2],F=I?T[2]:1,D=I?1:T[1],O=N[0],z=I?N[1]:N[2],L=I?N[2]:1,$=I?1:N[1],B=t.makeOutput(p.inShape,"float32"),V=t.dataIdMap.get(B.dataId).id,U=t.dataIdMap.get(r.dataId).id,G=t.dataIdMap.get(s.dataId).id;return wasmConv2DBackpropInput(U,G,h,m,f,x,y,g,b,v,A,k,S,w,C,_,E,P,R,M,F,D,O,z,L,$,V),B}var InterpolationMethod,wasmCropAndResize,conv2DBackpropInputConfig4={kernelName:Conv2DBackpropInput,backendName:"wasm",setupFunc:setup10,kernelFunc:conv2DBackpropInput5},cosConfig4=createUnaryKernelConfig(Cos),coshConfig4=createUnaryKernelConfig(Cosh);function setup11(e){wasmCropAndResize=e.wasm.cwrap(CropAndResize,null,["number","number","number","number","array","number","number","number","number","number"])}function cropAndResize5(e){const{backend:t,inputs:n,attrs:a}=e,{method:r,extrapolationValue:s,cropSize:o}=a,{image:i,boxes:l,boxInd:u}=n,c=l.shape[0],[d,p]=o,h=[c,d,p,i.shape[3]];let m,f=t.dataIdMap.get(i.dataId);"float32"!==i.dtype&&(m=cast6({backend:t,inputs:{x:i},attrs:{dtype:"float32"}}),f=t.dataIdMap.get(m.dataId));const g=f.id,x=t.dataIdMap.get(l.dataId).id,y=t.dataIdMap.get(u.dataId).id,A=t.makeOutput(h,"float32"),b=t.dataIdMap.get(A.dataId).id,v=new Uint8Array(new Int32Array(i.shape).buffer);return wasmCropAndResize(g,x,y,c,v,d,p,InterpolationMethod[r],s,b),null!=m&&t.disposeData(m.dataId),A}!function(e){e[e.bilinear=0]="bilinear",e[e.nearest=1]="nearest"}(InterpolationMethod||(InterpolationMethod={}));var wasmCumsum,cropAndResizeConfig4={kernelName:CropAndResize,backendName:"wasm",setupFunc:setup11,kernelFunc:cropAndResize5};function setup12(e){wasmCumsum=e.wasm.cwrap(Cumsum,null,["number","number","number","number","number","number"])}function cumsum4(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,exclusive:o,reverse:i}=a,l=r.shape.length;util_exports.assert("float32"===r.dtype||"int32"===r.dtype,(()=>`cumsum does not support ${r.dtype} tensors in the WASM backend`));const u=backend_util_exports.getAxesPermutation([s],l);let c=r;null!==u&&(c=transpose5({inputs:{x:r},attrs:{perm:u},backend:n}));const d=backend_util_exports.getInnerMostAxes(1,l)[0];backend_util_exports.assertAxesAreInnerMostDims("cumsum",[d],l);const p=n.makeOutput(c.shape,c.dtype),h=c.shape[d],m=n.dataIdMap.get(c.dataId).id,f=n.dataIdMap.get(p.dataId).id;wasmCumsum(m,o?1:0,i?1:0,h,f,CppDType[r.dtype]);let g=p;if(null!==u){g=transpose5({inputs:{x:p},attrs:{perm:backend_util_exports.getUndoAxesPermutation(u)},backend:n}),n.disposeData(c.dataId),n.disposeData(p.dataId)}return g}var wasmDepthToSpace,cumsumConfig3={kernelName:Cumsum,backendName:"wasm",setupFunc:setup12,kernelFunc:cumsum4};function setup13(e){wasmDepthToSpace=e.wasm.cwrap(DepthToSpace,null,["number","number","number","array","number","array","array","number","number"])}function depthToSpace5(e){const{backend:t,inputs:n,attrs:a}=e,{x:r}=n,{blockSize:s,dataFormat:o}=a,i=r.shape[0],l=("NHWC"===o?r.shape[1]:r.shape[2])*s,u=("NHWC"===o?r.shape[2]:r.shape[3])*s,c=("NHWC"===o?r.shape[3]:r.shape[1])/(s*s),d="NHWC"===o?[i,l,u,c]:[i,c,l,u],p=t.makeOutput(d,"float32"),h=t.dataIdMap.get(r.dataId).id,m=new Uint8Array(new Int32Array(util_exports.computeStrides(r.shape)).buffer),f=new Uint8Array(new Int32Array(d).buffer),g=new Uint8Array(new Int32Array(util_exports.computeStrides(d)).buffer),x=t.dataIdMap.get(p.dataId).id;return wasmDepthToSpace(h,s,"NHWC"===o?1:0,m,r.shape.length-1,f,g,d.length,x),p}var wasmDepthwiseConv2d,depthToSpaceConfig4={kernelName:DepthToSpace,backendName:"wasm",setupFunc:setup13,kernelFunc:depthToSpace5};function setup14(e){wasmDepthwiseConv2d=e.wasm.cwrap(DepthwiseConv2dNative,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function depthwiseConv2d5(e){const{inputs:t,attrs:n,backend:a}=e,{x:r,filter:s}=t,o=a.dataIdMap.get(r.dataId).id,i=a.dataIdMap.get(s.dataId).id,{strides:l,dilations:u,pad:c,dimRoundingMode:d}=n,p=null==u?[1,1]:u,h=backend_util_exports.computeConv2DInfo(r.shape,s.shape,l,p,c,d,!0),m=h.filterHeight,f=h.filterWidth,g=h.padInfo.top,x=h.padInfo.right,y=h.padInfo.bottom,A=h.padInfo.left,b=h.dilationHeight,v=h.dilationWidth,k=h.strideHeight,S=h.strideWidth,w=h.inChannels,C=h.outChannels,I="SAME"===h.padInfo.type?1:0;if("channelsLast"!==h.dataFormat)throw new Error(`wasm backend DepthwiseConv2dNative does not support dataFormat:'${h.dataFormat}'. Please use 'channelsLast'.`);const T=a.makeOutput(h.outShape,"float32"),N=a.dataIdMap.get(T.dataId).id;return wasmDepthwiseConv2d(o,r.shape[0],r.shape[1],r.shape[2],i,m,f,g,x,y,A,I,b,v,k,S,w,C,N),T}var depthwiseConv2dNativeConfig4={kernelName:DepthwiseConv2dNative,backendName:"wasm",setupFunc:setup14,kernelFunc:depthwiseConv2d5},eluConfig4=createUnaryKernelConfig(Elu),supportsFullBroadcast2=!1,equalConfig4=createBinaryKernelConfig(Equal,supportsFullBroadcast2,"bool"),expConfig4=createUnaryKernelConfig(Exp,"float32");function expandDims6(e){const{inputs:t,attrs:n,backend:a}=e,{input:r}=t,{dim:s}=n,o=r.shape.length,i=r.shape.slice();let l=s;return s<0&&(util_exports.assert(-(o+1)<=s,(()=>`Axis must be in the interval [${-(o+1)}, ${o}]`)),l=o+s+1),i.splice(l,0,1),reshape6({inputs:{x:r},backend:a,attrs:{shape:i}})}var expandDimsConfig4={kernelName:ExpandDims,backendName:"wasm",kernelFunc:expandDims6};function fill5(e){const{attrs:{shape:t,value:n,dtype:a},backend:r}=e,s=r.makeOutput(t,a);return r.typedArrayFromHeap(s).fill(n),s}var wasmFlipLeftRight,fillConfig4={kernelName:Fill,backendName:"wasm",kernelFunc:fill5};function setup15(e){wasmFlipLeftRight=e.wasm.cwrap(FlipLeftRight,null,["number","number","number","number","number","number"])}function flipLeftRight2(e){const{inputs:t,backend:n}=e,{image:a}=t,r=n.makeOutput(a.shape,a.dtype),s=n.dataIdMap.get(a.dataId).id,o=n.dataIdMap.get(r.dataId).id,[i,l,u,c]=a.shape;return wasmFlipLeftRight(s,i,l,u,c,o),r}var wasmBatchNorm,flipLeftRightConfig4={kernelName:FlipLeftRight,backendName:"wasm",kernelFunc:flipLeftRight2,setupFunc:setup15},floorConfig4=createUnaryKernelConfig(Floor),supportsFullBroadcast3=!1,floorDivConfig4=createBinaryKernelConfig(FloorDiv,supportsFullBroadcast3);function setup16(e){wasmBatchNorm=e.wasm.cwrap(FusedBatchNorm,null,["number","number","number","number","number","number","number"])}function fusedBatchNorm(e){const{backend:t,inputs:n,attrs:a}=e,{varianceEpsilon:r}=a,{x:s,mean:o,variance:i,offset:l,scale:u}=n,c=t.dataIdMap.get(s.dataId).id,d=t.dataIdMap.get(o.dataId).id,p=t.dataIdMap.get(i.dataId).id,h=null!=l?t.dataIdMap.get(l.dataId).id:0,m=null!=u?t.dataIdMap.get(u.dataId).id:0,f=t.makeOutput(s.shape,s.dtype);if(0===util_exports.sizeFromShape(s.shape))return f;const g=t.dataIdMap.get(f.dataId).id;return wasmBatchNorm(c,d,p,h,m,r,g),f}var wasmFusedConv2d,fusedBatchNormConfig2={kernelName:FusedBatchNorm,backendName:"wasm",setupFunc:setup16,kernelFunc:fusedBatchNorm};function setup17(e){wasmFusedConv2d=e.wasm.cwrap(FusedConv2D,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function fusedConv2d3(e){const{inputs:t,attrs:n,backend:a}=e,{x:r,filter:s,bias:o,preluActivationWeights:i}=t,{strides:l,pad:u,dilations:c,dataFormat:d,dimRoundingMode:p,activation:h,leakyreluAlpha:m}=n,f=backend_util_exports.computeConv2DInfo(r.shape,s.shape,l,c,u,p),g=FusableActivation[h];if(null==g)throw new Error(`${h} activation not yet supported for FusedConv2D in the wasm backend.`);const x=a.dataIdMap.get(r.dataId).id,y=a.dataIdMap.get(s.dataId).id,A=f.outChannels;let b=0;if(null!=o){const e=a.dataIdMap.get(o.dataId);if(1!==e.shape.length)throw new Error(`FusedConv2D only supports rank-1 bias but got rank ${e.shape.length}.`);if(e.shape[0]!==A)throw new Error(`FusedConv2D bias shape (${e.shape}) does not match the number of output channels (${A})`);b=e.id}const v=f.filterHeight,k=f.filterWidth,S=f.padInfo.top,w=f.padInfo.right,C=f.padInfo.bottom,I=f.padInfo.left,T=f.dilationHeight,N=f.dilationWidth,_=f.strideHeight,E=f.strideWidth,P=f.inChannels,R="SAME"===f.padInfo.type?1:0,M=f.batchSize,F=f.inHeight,D=f.inWidth;if("NHWC"!==d)throw new Error(`wasm backend FusedConv2D does not support dataFormat:'${d}'. Please use 'NHWC'.`);const O=a.makeOutput(f.outShape,"float32"),z=a.dataIdMap.get(O.dataId).id,L=null==i?0:a.dataIdMap.get(i.dataId).id;return wasmFusedConv2d(x,M,F,D,y,v,k,b,S,w,C,I,R,T,N,_,E,P,A,g,L,m||0,z),O}var wasmFusedDepthwiseConv2d,fusedConv2DConfig4={kernelName:FusedConv2D,backendName:"wasm",setupFunc:setup17,kernelFunc:fusedConv2d3};function setup18(e){wasmFusedDepthwiseConv2d=e.wasm.cwrap(FusedDepthwiseConv2D,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function fusedDepthwiseConv2d(e){const{inputs:t,attrs:n,backend:a}=e,{x:r,filter:s,bias:o,preluActivationWeights:i}=t,{strides:l,pad:u,dilations:c,dataFormat:d,dimRoundingMode:p,activation:h,leakyreluAlpha:m}=n,f=backend_util_exports.computeConv2DInfo(r.shape,s.shape,l,c,u,p,!0),g=FusableActivation[h];if(null==g)throw new Error(`${h} activation not yet supported for FusedDepthwiseConv2D in the wasm backend.`);const x=a.dataIdMap.get(r.dataId).id,y=a.dataIdMap.get(s.dataId).id,A=f.outChannels;let b=0;if(null!=o){const e=a.dataIdMap.get(o.dataId);if(1!==e.shape.length)throw new Error(`FusedDepthwiseConv2D only supports rank-1 bias but got rank ${e.shape.length}.`);if(e.shape[0]!==A)throw new Error(`FusedDepthwiseConv2D bias shape (${e.shape}) does not match the number of output channels (${A})`);b=e.id}const v=f.filterHeight,k=f.filterWidth,S=f.padInfo.top,w=f.padInfo.right,C=f.padInfo.bottom,I=f.padInfo.left,T=f.dilationHeight,N=f.dilationWidth,_=f.strideHeight,E=f.strideWidth,P=f.inChannels,R="SAME"===f.padInfo.type?1:0,M=f.batchSize,F=f.inHeight,D=f.inWidth;if("NHWC"!==d)throw new Error(`wasm backend FusedDepthwiseConv2D does not support dataFormat:'${d}'. Please use 'NHWC'.`);const O=a.makeOutput(f.outShape,"float32"),z=a.dataIdMap.get(O.dataId).id,L=null==i?0:a.dataIdMap.get(i.dataId).id;return wasmFusedDepthwiseConv2d(x,M,F,D,y,v,k,b,S,w,C,I,R,T,N,_,E,P,A,g,L,m||0,z),O}var wasmGatherNd,fusedDepthwiseConv2DConfig4={kernelName:FusedDepthwiseConv2D,backendName:"wasm",setupFunc:setup18,kernelFunc:fusedDepthwiseConv2d};function setup19(e){wasmGatherNd=e.wasm.cwrap(GatherNd,null,["number","number","number","number","number","number","array","number"])}function gatherNd4(e){const{backend:t,inputs:n}=e,{params:a,indices:r}=n,[s,o,i,l]=gather_nd_util_exports.prepareAndValidate(a,r),u=t.makeOutput(s,a.dtype);if(0===o)return u;const c=r.shape,d=c[c.length-1],p=t.dataIdMap.get(a.dataId).id,h=t.dataIdMap.get(r.dataId).id,m=new Uint8Array(new Int32Array(l).buffer),f=t.dataIdMap.get(u.dataId).id;return wasmGatherNd(p,CppDType[a.dtype],h,o,d,i,m,f),u}var wasmGather,gatherNdConfig4={kernelName:GatherNd,backendName:"wasm",setupFunc:setup19,kernelFunc:gatherNd4};function setup20(e){wasmGather=e.wasm.cwrap("Gather",null,["number","number","array","number","number","number","array","number"])}function gatherV24(e){const{backend:t,inputs:n,attrs:a}=e,{x:r,indices:s}=n,{axis:o,batchDims:i}=a,l=util_exports.parseAxisParam(o,r.shape)[0],u=t.readSync(s.dataId),c=r.shape[l];for(let e=0;e<u.length;++e){const t=u[e];util_exports.assert(t<=c-1&&t>=0,(()=>`GatherV2: the index value ${t} is not in [0, ${c-1}]`))}const d=backend_util_exports.segment_util.collectGatherOpShapeInfo(r,s,l,i),p=reshape6({inputs:{x:r},attrs:{shape:[d.batchSize,d.outerSize,d.dimSize,d.sliceSize]},backend:t}),h=util_exports.sizeFromShape(s.shape),m=reshape6({inputs:{x:s},attrs:{shape:[d.batchSize,h/d.batchSize]},backend:t}),f=[d.batchSize,d.outerSize,h/d.batchSize,d.sliceSize],g=t.makeOutput(f,r.dtype);if(0===util_exports.sizeFromShape(r.shape))return g;const x=p.shape.length-1,y=t.dataIdMap.get(p.dataId).id,A=t.dataIdMap.get(m.dataId).id,b=t.dataIdMap.get(g.dataId).id,v=new Uint8Array(new Int32Array(util_exports.computeStrides(p.shape)).buffer),k=new Uint8Array(new Int32Array(util_exports.computeStrides(f)).buffer);return wasmGather(y,CppDType[r.dtype],v,x,A,d.batchSize,k,b),t.disposeData(p.dataId),t.disposeData(m.dataId),g.shape=d.outputShape,g}var wasmFunc3,gatherV2Config4={kernelName:GatherV2,backendName:"wasm",setupFunc:setup20,kernelFunc:gatherV24},supportsFullBroadcast4=!1,greaterConfig4=createBinaryKernelConfig(Greater,supportsFullBroadcast4,"bool"),supportsFullBroadcast5=!1,greaterEqualConfig4=createBinaryKernelConfig(GreaterEqual,supportsFullBroadcast5,"bool");function setupFunc2(e){wasmFunc3=e.wasm.cwrap(LeakyRelu,null,["number","number","number","number"])}function leakyRelu4(e){const{inputs:{x:t},attrs:{alpha:n},backend:a}=e,r=a.dataIdMap.get(t.dataId).id,s=a.makeOutput(t.shape,"float32");if(0!==util_exports.sizeFromShape(t.shape)){const e=a.dataIdMap.get(s.dataId).id;wasmFunc3(r,CppDType[t.dtype],n,e)}return s}var wasmMax,leakyReluConfig3={kernelName:LeakyRelu,backendName:"wasm",setupFunc:setupFunc2,kernelFunc:leakyRelu4},supportsFullBroadcast6=!1,lessConfig4=createBinaryKernelConfig(Less,supportsFullBroadcast6,"bool"),supportsFullBroadcast7=!1,lessEqualConfig4=createBinaryKernelConfig(LessEqual,supportsFullBroadcast7,"bool"),logConfig4=createUnaryKernelConfig(Log),supportsFullBroadcast8=!1,logicalAndConfig4=createBinaryKernelConfig(LogicalAnd,supportsFullBroadcast8,"bool");function setup21(e){wasmMax=e.wasm.cwrap(Max,null,["number","number","number","number"])}function max6(e){const{backend:t,inputs:n,attrs:a}=e,{reductionIndices:r,keepDims:s}=a,{x:o}=n;let i=t.dataIdMap.get(o.dataId).id,l=o;const{transposed:u,axes:c,originalAxes:d,inputWasTransposed:p}=permuteAxesAndTranspose(o,r,t);if(p){l=u,i=t.dataIdMap.get(u.dataId).id}const h=l.shape.length;backend_util_exports.assertAxesAreInnerMostDims("max",c,h);const[m,f]=backend_util_exports.computeOutAndReduceShapes(l.shape,c),g=util_exports.sizeFromShape(f),x=t.makeOutput(m,o.dtype);if(0!==util_exports.sizeFromShape(l.shape)){const e=t.dataIdMap.get(x.dataId).id;wasmMax(i,CppDType[o.dtype],g,e)}if(p&&t.disposeData(u.dataId),s){const e=backend_util_exports.expandShapeToKeepDim(x.shape,d);x.shape=e}return x}var wasmMaxPool,maxConfig4={kernelName:Max,backendName:"wasm",setupFunc:setup21,kernelFunc:max6},supportsFullBroadcast9=!1,maximumConfig4=createBinaryKernelConfig(Maximum,supportsFullBroadcast9);function setup22(e){wasmMaxPool=e.wasm.cwrap(MaxPool,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function maxPool5(e){const{inputs:t,attrs:n,backend:a}=e,r=t.x,s=a.dataIdMap.get(r.dataId).id;util_exports.assert("float32"===r.dtype,(()=>`Error in MaxPool: only float32 input is supported. Got ${r.dtype}.`));const{filterSize:o,strides:i,pad:l,dimRoundingMode:u}=n,c=backend_util_exports.computePool2DInfo(r.shape,o,i,1,l,u),d=c.filterHeight,p=c.filterWidth,h=c.padInfo.top,m=c.padInfo.right,f=c.padInfo.bottom,g=c.padInfo.left,x=c.dilationHeight,y=c.dilationWidth,A=c.strideHeight,b=c.strideWidth,v=c.inChannels,k=c.outChannels;if("channelsLast"!==c.dataFormat)throw new Error(`wasm backend does not support dataFormat:'${c.dataFormat}'. Please use 'channelsLast'.`);const S=a.makeOutput(c.outShape,"float32"),w=a.dataIdMap.get(S.dataId).id;return wasmMaxPool(s,r.shape[0],r.shape[1],r.shape[2],d,p,h,m,f,g,x,y,A,b,v,k,w),S}var wasmMean,maxPoolConfig4={kernelName:MaxPool,backendName:"wasm",setupFunc:setup22,kernelFunc:maxPool5};function setup23(e){wasmMean=e.wasm.cwrap(Mean,null,["number, number, number"])}function mean4(e){const{backend:t,inputs:n,attrs:a}=e,{axis:r,keepDims:s}=a,{x:o}=n,i=t.dataIdMap.get(o.dataId).id;let l=i,u=o;const{transposed:c,axes:d,originalAxes:p,inputWasTransposed:h}=permuteAxesAndTranspose(o,r,t);let m=d;if(h){const e=t.dataIdMap.get(c.dataId).id;e!==i&&(u=c,l=e,m=backend_util_exports.getInnerMostAxes(m.length,u.shape.length))}backend_util_exports.assertAxesAreInnerMostDims("mean",m,u.shape.length);const[f,g]=backend_util_exports.computeOutAndReduceShapes(u.shape,m),x=util_exports.sizeFromShape(g);let y=u;"float32"!==u.dtype&&(y=cast6({backend:t,inputs:{x:u},attrs:{dtype:"float32"}}),l=t.dataIdMap.get(y.dataId).id);const A=t.makeOutput(f,"float32");if(0!==util_exports.sizeFromShape(u.shape)){const e=t.dataIdMap.get(A.dataId).id;wasmMean(l,x,e)}if(h&&t.disposeData(c.dataId),s){const e=backend_util_exports.expandShapeToKeepDim(A.shape,p);A.shape=e}return"float32"!==u.dtype&&t.disposeData(y.dataId),A}var wasmMin,meanConfig4={kernelName:Mean,backendName:"wasm",setupFunc:setup23,kernelFunc:mean4};function setup24(e){wasmMin=e.wasm.cwrap(Min,null,["number","number","number","number"])}function min6(e){const{backend:t,inputs:n,attrs:a}=e,{axis:r,keepDims:s}=a,{x:o}=n,i=t.dataIdMap.get(o.dataId).id;let l=i,u=o;const{transposed:c,axes:d,originalAxes:p,inputWasTransposed:h}=permuteAxesAndTranspose(o,r,t);if(h){const e=t.dataIdMap.get(c.dataId).id;e!==i&&(u=c,l=e)}const m=u.shape.length;backend_util_exports.assertAxesAreInnerMostDims("min",d,m);const[f,g]=backend_util_exports.computeOutAndReduceShapes(u.shape,d),x=util_exports.sizeFromShape(g),y=t.makeOutput(f,u.dtype);if(0!==util_exports.sizeFromShape(u.shape)){const e=t.dataIdMap.get(y.dataId).id;wasmMin(l,CppDType[o.dtype],x,e)}if(h&&t.disposeData(c.dataId),s){const e=backend_util_exports.expandShapeToKeepDim(y.shape,p);y.shape=e}return y}var MirrorPaddingMode,wasmMirrorPad,minConfig4={kernelName:Min,backendName:"wasm",setupFunc:setup24,kernelFunc:min6},supportsFullBroadcast10=!1,minimumConfig4=createBinaryKernelConfig(Minimum,supportsFullBroadcast10);function setup25(e){wasmMirrorPad=e.wasm.cwrap(MirrorPad,null,["number","array","number","number","array","array","number","number"])}function mirrorPad3(e){const{inputs:{x:t},backend:n,attrs:{paddings:a,mode:r}}=e,s=a.map(((e,n)=>e[0]+t.shape[n]+e[1])),o=n.dataIdMap.get(t.dataId).id,i=n.makeOutput(s,t.dtype),l=n.dataIdMap.get(i.dataId).id,u=new Uint8Array(new Int32Array(t.shape).buffer),c=a.map((e=>e[0])),d=a.map((e=>e[1])),p=new Uint8Array(new Int32Array(c).buffer),h=new Uint8Array(new Int32Array(d).buffer);return wasmMirrorPad(o,u,t.shape.length,CppDType[t.dtype],p,h,MirrorPaddingMode[r],l),i}!function(e){e[e.reflect=0]="reflect",e[e.symmetric=1]="symmetric"}(MirrorPaddingMode||(MirrorPaddingMode={}));var wasmFunc4,mirrorPadConfig4={kernelName:MirrorPad,backendName:"wasm",kernelFunc:mirrorPad3,setupFunc:setup25},supportsFullBroadcast11=!0,multiplyConfig4=createBinaryKernelConfig(Multiply,supportsFullBroadcast11),negConfig4=createUnaryKernelConfig(Neg);function parseResultStruct(e,t){const n=new Int32Array(e.wasm.HEAPU8.buffer,t,4),a=n[0],r=n[1],s=n[2],o=n[3];return e.wasm._free(t),{pSelectedIndices:a,selectedSize:r,pSelectedScores:s,pValidOutputs:o}}function setup26(e){wasmFunc4=e.wasm.cwrap(NonMaxSuppressionV3,"number",["number","number","number","number","number"])}function kernelFunc(e){const{backend:t,inputs:n,attrs:a}=e,{iouThreshold:r,maxOutputSize:s,scoreThreshold:o}=a,{boxes:i,scores:l}=n,u=t.dataIdMap.get(i.dataId).id,c=t.dataIdMap.get(l.dataId).id,d=wasmFunc4(u,c,s,r,o),{pSelectedIndices:p,selectedSize:h,pSelectedScores:m,pValidOutputs:f}=parseResultStruct(t,d);t.wasm._free(m),t.wasm._free(f);return t.makeOutput([h],"int32",p)}var wasmFunc5,nonMaxSuppressionV3Config4={kernelName:NonMaxSuppressionV3,backendName:"wasm",setupFunc:setup26,kernelFunc:kernelFunc};function setup27(e){wasmFunc5=e.wasm.cwrap(NonMaxSuppressionV4,"number",["number","number","number","number","number","bool"])}function nonMaxSuppressionV43(e){const{backend:t,inputs:n,attrs:a}=e,{iouThreshold:r,maxOutputSize:s,scoreThreshold:o,padToMaxOutputSize:i}=a,{boxes:l,scores:u}=n,c=t.dataIdMap.get(l.dataId).id,d=t.dataIdMap.get(u.dataId).id,p=wasmFunc5(c,d,s,r,o,i),{pSelectedIndices:h,selectedSize:m,pSelectedScores:f,pValidOutputs:g}=parseResultStruct(t,p);t.wasm._free(f);return[t.makeOutput([m],"int32",h),t.makeOutput([],"int32",g)]}var wasmFunc6,nonMaxSuppressionV4Config3={kernelName:NonMaxSuppressionV4,backendName:"wasm",setupFunc:setup27,kernelFunc:nonMaxSuppressionV43};function setup28(e){wasmFunc6=e.wasm.cwrap(NonMaxSuppressionV5,"number",["number","number","number","number","number","number"])}function kernelFunc2(e){const{backend:t,inputs:n,attrs:a}=e,{iouThreshold:r,maxOutputSize:s,scoreThreshold:o,softNmsSigma:i}=a,{boxes:l,scores:u}=n,c=t.dataIdMap.get(l.dataId).id,d=t.dataIdMap.get(u.dataId).id,p=wasmFunc6(c,d,s,r,o,i),{pSelectedIndices:h,selectedSize:m,pSelectedScores:f,pValidOutputs:g}=parseResultStruct(t,p);t.wasm._free(g);return[t.makeOutput([m],"int32",h),t.makeOutput([m],"float32",f)]}var wasmOneHot,nonMaxSuppressionV5Config4={kernelName:NonMaxSuppressionV5,backendName:"wasm",setupFunc:setup28,kernelFunc:kernelFunc2},supportsFullBroadcast12=!1,notEqualConfig4=createBinaryKernelConfig(NotEqual,supportsFullBroadcast12,"bool");function setup29(e){wasmOneHot=e.wasm.cwrap(OneHot,null,["number","number","number","number","number"])}function oneHot4(e){const{inputs:t,backend:n,attrs:a}=e,{indices:r}=t,{depth:s,onValue:o,offValue:i}=a,l=n.makeOutput([...r.shape,s],"int32"),u=n.dataIdMap.get(l.dataId).id,c=n.dataIdMap.get(r.dataId).id;return wasmOneHot(c,s,o,i,u),l}var oneHotConfig3={kernelName:OneHot,backendName:"wasm",setupFunc:setup29,kernelFunc:oneHot4};function onesLike5(e){const{inputs:{x:t},backend:n}=e,a=n.makeOutput(t.shape,t.dtype);return n.typedArrayFromHeap(a).fill(1),a}var onesLikeConfig4={kernelName:OnesLike,backendName:"wasm",kernelFunc:onesLike5};function pack4(e){const{inputs:t,backend:n,attrs:a}=e,{axis:r}=a;if(1===t.length)return expandDims6({inputs:{input:t[0]},backend:n,attrs:{dim:r}});const s=t[0].shape,o=t[0].dtype;t.forEach((e=>{util_exports.assertShapesMatch(s,e.shape,"All tensors passed to stack must have matching shapes"),util_exports.assert(o===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const i=[],l=concat5({inputs:t.map((e=>{const t=expandDims6({inputs:{input:e},backend:n,attrs:{dim:r}});return i.push(t),t})),backend:n,attrs:{axis:r}});return i.forEach((e=>n.disposeData(e.dataId))),l}var wasmPadV2,packConfig4={kernelName:Pack,backendName:"wasm",kernelFunc:pack4};function setup30(e){wasmPadV2=e.wasm.cwrap(PadV2,null,["number","array","number","number","array","array","number","number"])}function pad2(e){const{inputs:{x:t},backend:n,attrs:{paddings:a,constantValue:r}}=e,s=a.map(((e,n)=>e[0]+t.shape[n]+e[1]));if(0===util_exports.sizeFromShape(t.shape))return fill5({backend:n,attrs:{shape:s,value:r,dtype:t.dtype}});const o=n.dataIdMap.get(t.dataId).id,i=n.makeOutput(s,t.dtype),l=n.dataIdMap.get(i.dataId).id,u=new Uint8Array(new Int32Array(t.shape).buffer),c=a.map((e=>e[0])),d=a.map((e=>e[1])),p=new Uint8Array(new Int32Array(c).buffer),h=new Uint8Array(new Int32Array(d).buffer);return wasmPadV2(o,u,t.shape.length,CppDType[t.dtype],p,h,r,l),i}var wasmPrelu,padV2Config4={kernelName:PadV2,backendName:"wasm",kernelFunc:pad2,setupFunc:setup30},supportsFullBroadcast13=!1,powConfig4=createBinaryKernelConfig(Pow,supportsFullBroadcast13);function setup31(e){wasmPrelu=e.wasm.cwrap(Prelu,null,["number","number","number"])}function prelu6(e){const{inputs:t,backend:n}=e,{x:a,alpha:r}=t,s=n.dataIdMap.get(a.dataId).id,o=n.dataIdMap.get(r.dataId).id;let i=s;const l=a;let u=l;"float32"!==l.dtype&&(u=cast6({backend:n,inputs:{x:a},attrs:{dtype:"float32"}}),i=n.dataIdMap.get(u.dataId).id);const c=n.makeOutput(a.shape,"float32"),d=n.dataIdMap.get(c.dataId).id;return wasmPrelu(i,o,d),"float32"!==l.dtype&&n.disposeData(u.dataId),c}var wasmProd,preluConfig4={kernelName:Prelu,backendName:"wasm",setupFunc:setup31,kernelFunc:prelu6};function setup32(e){wasmProd=e.wasm.cwrap(Prod,null,["number","number","number","number"])}function prod5(e){const{backend:t,inputs:n,attrs:a}=e,{axis:r,keepDims:s}=a,{x:o}=n,i=t.dataIdMap.get(o.dataId).id;let l=i,u=o;const{transposed:c,axes:d,originalAxes:p,inputWasTransposed:h}=permuteAxesAndTranspose(o,r,t);let m=d;if(h){const e=t.dataIdMap.get(c.dataId).id;e!==i&&(u=c,l=e,m=backend_util_exports.getInnerMostAxes(m.length,u.shape.length))}backend_util_exports.assertAxesAreInnerMostDims("prod",m,u.shape.length);const[f,g]=backend_util_exports.computeOutAndReduceShapes(u.shape,m),x=util_exports.sizeFromShape(g),y=t.makeOutput(f,u.dtype);if(0!==util_exports.sizeFromShape(u.shape)){const e=t.dataIdMap.get(y.dataId).id;wasmProd(l,x,CppDType[y.dtype],e)}if(h&&t.disposeData(c.dataId),s){const e=backend_util_exports.expandShapeToKeepDim(y.shape,p);y.shape=e}return y}var wasmResizeBilinear,prodConfig4={kernelName:Prod,backendName:"wasm",setupFunc:setup32,kernelFunc:prod5},range6=e=>{const{backend:t,attrs:n}=e,{start:a,stop:r,step:s,dtype:o}=n,i=rangeImpl(a,r,s,o),l=t.makeOutput([i.length],o);return t.typedArrayFromHeap(l).set(i),l},rangeConfig4={kernelName:Range,backendName:"wasm",kernelFunc:range6},supportsFullBroadcast14=!0,realDivConfig4=createBinaryKernelConfig(RealDiv,supportsFullBroadcast14),reluConfig4=createUnaryKernelConfig(Relu),relu6Config4=createUnaryKernelConfig(Relu6);function setup33(e){wasmResizeBilinear=e.wasm.cwrap(ResizeBilinear,null,["number","number","number","number","number","number","number","number","number","number"])}function resizeBilinear5(e){const{backend:t,inputs:n,attrs:a}=e,{images:r}=n,{alignCorners:s,halfPixelCenters:o,size:i}=a,[l,u]=i,[c,d,p,h]=r.shape,m=[c,l,u,h];let f,g=t.dataIdMap.get(r.dataId);"float32"!==g.dtype&&(f=cast6({backend:t,inputs:{x:r},attrs:{dtype:"float32"}}),g=t.dataIdMap.get(f.dataId));const x=g.id,y=t.makeOutput(m,"float32");if(0===util_exports.sizeFromShape(r.shape))return y;const A=t.dataIdMap.get(y.dataId).id;return wasmResizeBilinear(x,c,d,p,h,l,u,s?1:0,o?1:0,A),null!=f&&t.disposeData(f.dataId),y}var wasmReverse,resizeBilinearConfig4={kernelName:ResizeBilinear,backendName:"wasm",setupFunc:setup33,kernelFunc:resizeBilinear5};function setup34(e){wasmReverse=e.wasm.cwrap(Reverse,null,["number","array","number","array","number","number"])}function reverse4(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{dims:s}=a,o=util_exports.parseAxisParam(s,r.shape);if(0===r.shape.length)return identity5({inputs:{x:r},backend:n});const i=n.makeOutput(r.shape,r.dtype),l=n.dataIdMap.get(r.dataId).id,u=n.dataIdMap.get(i.dataId).id,c=new Uint8Array(new Int32Array(o).buffer),d=new Uint8Array(new Int32Array(r.shape).buffer);wasmReverse(l,c,o.length,d,r.shape.length,u);const p=reshape6({inputs:{x:i},attrs:{shape:r.shape},backend:n});return n.disposeData(i.dataId),p}var wasmRotate,reverseConfig3={kernelName:Reverse,backendName:"wasm",kernelFunc:reverse4,setupFunc:setup34};function setup35(e){wasmRotate=e.wasm.cwrap(RotateWithOffset,null,["number","number","number","number","number","number","number","number","array","number","number"])}function rotateWithOffset2(e){const{inputs:t,backend:n,attrs:a}=e,{image:r}=t,{radians:s,fillValue:o,center:i}=a,l=n.makeOutput(r.shape,r.dtype),u=n.dataIdMap.get(r.dataId).id,c=n.dataIdMap.get(l.dataId).id,[d,p,h,m]=r.shape,[f,g]=backend_util_exports.getImageCenter(i,p,h),x="number"==typeof o?[o,o,o,0===o?0:255]:[...o,255],y=new Uint8Array(new Int32Array(x).buffer);return wasmRotate(u,d,p,h,m,s,f,g,y,x.length,c),l}var wasmScatterNd,rotateWithOffsetConfig4={kernelName:RotateWithOffset,backendName:"wasm",kernelFunc:rotateWithOffset2,setupFunc:setup35},roundConfig3=createUnaryKernelConfig(Round),rsqrtConfig4=createUnaryKernelConfig(Rsqrt);function setup36(e){wasmScatterNd=e.wasm.cwrap(ScatterNd,null,["number","number","number","number","number","number","array","number","number"])}function scatterNd4(e){const{backend:t,inputs:n,attrs:a}=e,{indices:r,updates:s}=n,{shape:o}=a,i=t.makeOutput(o,s.dtype);if(0===util_exports.sizeFromShape(o))return i;const{sliceRank:l,numUpdates:u,sliceSize:c,strides:d,outputSize:p}=scatter_nd_util_exports.calculateShapes(s,r,o),h=t.dataIdMap.get(r.dataId).id,m=t.dataIdMap.get(s.dataId).id,f=new Uint8Array(new Int32Array(d).buffer),g=t.dataIdMap.get(i.dataId).id;return wasmScatterNd(h,m,CppDType[s.dtype],l,u,c,f,p,g),i}var wasmSelect,scatterNdConfig4={kernelName:ScatterNd,backendName:"wasm",setupFunc:setup36,kernelFunc:scatterNd4};function setup37(e){wasmSelect=e.wasm.cwrap("SelectV2",null,["number","number","number","number","number"])}function select5(e){const{inputs:t,backend:n}=e,{condition:a,t:r,e:s}=t,o=n.dataIdMap.get(a.dataId).id,i=n.dataIdMap.get(r.dataId).id,l=n.dataIdMap.get(s.dataId).id,u=n.makeOutput(r.shape,r.dtype),c=n.dataIdMap.get(u.dataId).id,d=a.shape.length,p=r.shape.length,h=0===d||d>1||1===p?1:util_exports.sizeFromShape(r.shape.slice(1));return wasmSelect(o,i,l,h,c),u}var wasmFunc7,selectConfig4={kernelName:Select,backendName:"wasm",kernelFunc:select5,setupFunc:setup37};function setup38(e){wasmFunc7=e.wasm.cwrap(Sigmoid,null,["number","number"])}function sigmoid5(e){const{backend:t,inputs:{x:n}}=e,a=t.dataIdMap.get(n.dataId).id,r=t.makeOutput(n.shape,n.dtype),s=t.dataIdMap.get(r.dataId).id;return 0===util_exports.sizeFromShape(r.shape)||wasmFunc7(a,s),r}var wasmFunc8,sigmoidConfig4={kernelName:"Sigmoid",backendName:"wasm",setupFunc:setup38,kernelFunc:sigmoid5},sinConfig4=createUnaryKernelConfig(Sin);function setup39(e){wasmFunc8=e.wasm.cwrap(Softmax,null,["number","number","number","number"])}function softmax6(e){const{backend:t,inputs:{logits:n},attrs:{dim:a}}=e,r=t.dataIdMap.get(n.dataId).id,s=t.makeOutput(n.shape,n.dtype),o=t.dataIdMap.get(s.dataId).id,i=n.shape[a],l=util_exports.sizeFromShape(n.shape)/i;return 0===util_exports.sizeFromShape(s.shape)||wasmFunc8(r,o,i,l),s}var softmaxConfig4={kernelName:Softmax,backendName:"wasm",setupFunc:setup39,kernelFunc:softmax6};function spaceToBatchND5(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:s,paddings:o}=a,i=util_exports.sizeFromShape(s),l=[[0,0]];l.push(...o);for(let e=1+s.length;e<r.shape.length;++e)l.push([0,0]);const u=padV2Config4.kernelFunc({inputs:{x:r},backend:n,attrs:{paddings:l,constantValue:0}}),c=backend_util_exports.getReshaped(u.shape,s,i,!1),d=backend_util_exports.getPermuted(c.length,s.length,!1),p=backend_util_exports.getReshapedPermuted(u.shape,s,i,!1),h=reshape6({inputs:{x:u},backend:n,attrs:{shape:c}}),m=transpose5({inputs:{x:h},backend:n,attrs:{perm:d}}),f=reshape6({inputs:{x:m},backend:n,attrs:{shape:p}});return n.disposeData(u.dataId),n.disposeData(h.dataId),n.disposeData(m.dataId),f}var spaceToBatchNDConfig4={kernelName:SpaceToBatchND,backendName:"wasm",kernelFunc:spaceToBatchND5};function splitV4(e){const{inputs:t,attrs:n,backend:a}=e,{x:r}=t,{numOrSizeSplits:s,axis:o}=n,i=util_exports.parseAxisParam(o,r.shape)[0],l=backend_util_exports.prepareSplitSize(r,s,i),u=new Array(r.shape.length).fill(0),c=r.shape.slice();return l.map((e=>{const t=[...c];t[i]=e;const n=slice5({inputs:{x:r},attrs:{begin:u,size:t},backend:a});return u[i]+=e,n}))}var wasmStep,splitVConfig4={kernelName:SplitV,backendName:"wasm",kernelFunc:splitV4},sqrtConfig4=createUnaryKernelConfig(Sqrt),squareConfig4=createUnaryKernelConfig(Square),supportsFullBroadcast15=!0,squaredDifferenceConfig4=createBinaryKernelConfig(SquaredDifference,supportsFullBroadcast15);function setup40(e){wasmStep=e.wasm.cwrap(Step,null,["number","number","number","number"])}function step4(e){const{backend:t,inputs:n,attrs:a}=e,{alpha:r}=a,{x:s}=n,o=t.dataIdMap.get(s.dataId).id,i=t.makeOutput(s.shape,s.dtype),l=t.dataIdMap.get(i.dataId).id;return wasmStep(o,r,CppDType[s.dtype],l),i}var wasmStridedSlice,stepConfig3={kernelName:Step,backendName:"wasm",setupFunc:setup40,kernelFunc:step4};function setup41(e){wasmStridedSlice=e.wasm.cwrap(StridedSlice,null,["number","array","number","array","array","array","array","array","number","number"])}function stridedSlice5(e){const{backend:t,inputs:n,attrs:a}=e,{x:r}=n,{begin:s,end:o,strides:i,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:d,shrinkAxisMask:p}=a,{finalShapeSparse:h,finalShape:m,isIdentity:f,sliceDim0:g,isSimpleSlice:x,begin:y,end:A,strides:b}=slice_util_exports.sliceInfo(r.shape,s,o,i,l,u,c,d,p);let v;if(f)v=reshape6({inputs:{x:r},backend:t,attrs:{shape:m}});else if(g||x){util_exports.assert(r.shape.length>=1,(()=>`Input must have rank at least 1, got: ${r.shape.length}`));const e=slice_util_exports.computeOutShape(y,A,b),n=slice5({inputs:{x:r},backend:t,attrs:{begin:y,size:e}});v=reshape6({inputs:{x:n},backend:t,attrs:{shape:m}}),t.disposeData(n.dataId)}else{const e=t.makeOutput(h,"float32"),n=t.dataIdMap.get(r.dataId).id,a=new Uint8Array(new Int32Array(util_exports.computeStrides(r.shape)).buffer),s=new Uint8Array(new Int32Array(y).buffer),o=new Uint8Array(new Int32Array(A).buffer),i=new Uint8Array(new Int32Array(b).buffer),l=new Uint8Array(new Int32Array(h).buffer),u=new Uint8Array(new Int32Array(util_exports.computeStrides(h)).buffer),c=t.dataIdMap.get(e.dataId).id;wasmStridedSlice(n,a,r.shape.length,s,o,i,l,u,h.length,c),v=reshape6({inputs:{x:e},backend:t,attrs:{shape:m}}),t.disposeData(e.dataId)}return v}var wasmSum,stridedSliceConfig4={kernelName:StridedSlice,backendName:"wasm",setupFunc:setup41,kernelFunc:stridedSlice5},supportsFullBroadcast16=!0,subConfig4=createBinaryKernelConfig(Sub,supportsFullBroadcast16);function setup42(e){wasmSum=e.wasm.cwrap(Sum,null,["number","number","number","number"])}function sum6(e){const{backend:t,inputs:n,attrs:a}=e,{axis:r,keepDims:s}=a,{x:o}=n,i=t.dataIdMap.get(o.dataId).id;let l=i,u=o;const{transposed:c,axes:d,originalAxes:p,inputWasTransposed:h}=permuteAxesAndTranspose(o,r,t);let m=d;if(h){const e=t.dataIdMap.get(c.dataId).id;e!==i&&(u=c,l=e,m=backend_util_exports.getInnerMostAxes(m.length,u.shape.length))}backend_util_exports.assertAxesAreInnerMostDims("sum",m,u.shape.length);const[f,g]=backend_util_exports.computeOutAndReduceShapes(u.shape,m),x=util_exports.sizeFromShape(g),y=t.makeOutput(f,u.dtype);if(0!==util_exports.sizeFromShape(u.shape)){const e=t.dataIdMap.get(y.dataId).id;wasmSum(l,x,CppDType[y.dtype],e)}if(h&&t.disposeData(c.dataId),s){const e=backend_util_exports.expandShapeToKeepDim(y.shape,p);y.shape=e}return y}var wasmTile,sumConfig4={kernelName:Sum,backendName:"wasm",setupFunc:setup42,kernelFunc:sum6},tanConfig3=createUnaryKernelConfig(Tan),tanhConfig4=createUnaryKernelConfig(Tanh);function setup43(e){wasmTile=e.wasm.cwrap(Tile,null,["number","array","number","array","number","number"])}function tile6(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,s=n.dataIdMap.get(r.dataId).id,{reps:o}=a,i=new Array(r.shape.length);for(let e=0;e<i.length;e++)i[e]=r.shape[e]*o[e];const l=new Uint8Array(new Int32Array(r.shape).buffer),u=new Uint8Array(new Int32Array(i).buffer),c=n.makeOutput(i,r.dtype),d=n.dataIdMap.get(c.dataId).id;return wasmTile(s,l,r.shape.length,u,i.length,CppDType[c.dtype],d),c}var wasmTopK,tileConfig4={kernelName:Tile,backendName:"wasm",setupFunc:setup43,kernelFunc:tile6};function setup44(e){wasmTopK=e.wasm.cwrap(TopK,null,["number","array","number","number","number","bool","number","number"])}var wasmTransform,topk2=({inputs:e,backend:t,attrs:n})=>{const{x:a}=e,{k:r,sorted:s}=n,o=t.dataIdMap.get(a.dataId).id,i=new Uint8Array(new Int32Array(a.shape).buffer),l=a.shape.slice();l[l.length-1]=r;const u=t.makeOutput(l,a.dtype),c=t.dataIdMap.get(u.dataId).id,d=t.makeOutput(l,"int32"),p=t.dataIdMap.get(d.dataId).id;return wasmTopK(o,i,a.shape.length,CppDType[a.dtype],r,s,c,p),[u,d]},topKConfig4={kernelName:TopK,backendName:"wasm",setupFunc:setup44,kernelFunc:topk2};function setup45(e){wasmTransform=e.wasm.cwrap(Transform,null,["number","number","bool","number","number","number","number","number","number","array","number","number","number","number","number"])}function transform5(e){const{backend:t,inputs:n,attrs:a}=e,{image:r,transforms:s}=n,{interpolation:o,fillMode:i,fillValue:l,outputShape:u}=a,[c,d,p,h]=r.shape,[m,f]=null!=u?u:[d,p],g=[c,m,f,h],x=new Uint8Array(new Int32Array(util_exports.computeStrides(r.shape)).buffer),y=t.makeOutput(g,r.dtype),A=t.dataIdMap.get(y.dataId).id,b=t.dataIdMap.get(r.dataId).id,v=t.dataIdMap.get(s.dataId).id,k="nearest"===o?1:2;let S;switch(i){case"constant":default:S=1;break;case"reflect":S=2;break;case"wrap":S=3;break;case"nearest":S=4}return wasmTransform(b,v,s.shape[0]>1,c,m,f,h,p,d,x,r.shape.length-1,k,S,l,A),y}var transformConfig4={kernelName:Transform,backendName:"wasm",setupFunc:setup45,kernelFunc:transform5};function unpack4(e){const{inputs:t,backend:n,attrs:a}=e,{value:r}=t;let{axis:s}=a;s<0&&(s+=r.shape.length);const o=r.shape[s],i=r.shape.length,l=new Array(i-1);let u=0;for(let e=0;e<i;e++)e!==s&&(l[u++]=r.shape[e]);const c=new Array(o),d=new Array(i).fill(0),p=r.shape.slice();p[s]=1;for(let e=0;e<c.length;e++)d[s]=e,c[e]=slice5({inputs:{x:r},attrs:{begin:d,size:p},backend:n});return c.map((({dataId:e,dtype:t})=>({dataId:e,dtype:t,shape:l})))}var unpackConfig4={kernelName:Unpack,backendName:"wasm",kernelFunc:unpack4};function zerosLike5(e){const{inputs:{x:t},backend:n}=e,a=n.makeOutput(t.shape,t.dtype);return n.typedArrayFromHeap(a).fill(0),a}var zerosLikeConfig4={kernelName:ZerosLike,backendName:"wasm",kernelFunc:zerosLike5},kernelConfigs4=[absConfig4,addConfig4,addNConfig4,allConfig3,anyConfig3,argMaxConfig4,avgPoolConfig4,batchMatMulConfig4,batchToSpaceNDConfig4,castConfig4,ceilConfig4,clipByValueConfig3,concatConfig4,conv2DConfig4,conv2DBackpropInputConfig4,cosConfig4,coshConfig4,cropAndResizeConfig4,cumsumConfig3,depthToSpaceConfig4,depthwiseConv2dNativeConfig4,eluConfig4,equalConfig4,expConfig4,expandDimsConfig4,fillConfig4,flipLeftRightConfig4,floorConfig4,floorDivConfig4,fusedMatMulConfig,fusedBatchNormConfig2,fusedConv2DConfig4,fusedDepthwiseConv2DConfig4,gatherNdConfig4,gatherV2Config4,greaterConfig4,greaterEqualConfig4,identityConfig4,leakyReluConfig3,lessConfig4,lessEqualConfig4,logConfig4,logicalAndConfig4,maxConfig4,maximumConfig4,maxPoolConfig4,meanConfig4,minConfig4,minimumConfig4,mirrorPadConfig4,multiplyConfig4,negConfig4,nonMaxSuppressionV3Config4,nonMaxSuppressionV4Config3,nonMaxSuppressionV5Config4,notEqualConfig4,oneHotConfig3,onesLikeConfig4,packConfig4,padV2Config4,powConfig4,preluConfig4,prodConfig4,rangeConfig4,realDivConfig4,reluConfig4,relu6Config4,reshapeConfig4,resizeBilinearConfig4,reverseConfig3,rotateWithOffsetConfig4,rsqrtConfig4,roundConfig3,scatterNdConfig4,selectConfig4,sigmoidConfig4,sinConfig4,sliceConfig4,softmaxConfig4,spaceToBatchNDConfig4,splitVConfig4,sqrtConfig4,squareConfig4,squaredDifferenceConfig4,stepConfig3,stridedSliceConfig4,subConfig4,sumConfig4,tanConfig3,tanhConfig4,tileConfig4,topKConfig4,transformConfig4,transposeConfig4,unpackConfig4,zerosLikeConfig4];for(const e of kernelConfigs4)registerKernel(e);var ENV6=env();ENV6.registerFlag("WASM_HAS_SIMD_SUPPORT",(async()=>WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11])))),ENV6.registerFlag("WASM_HAS_MULTITHREAD_SUPPORT",(async()=>{if(ENV6.get("IS_NODE"))return!1;try{return(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch(e){return!1}}));var import_tfjs_backend_wasm_threaded_simd=__toModule(require_tfjs_backend_wasm_threaded_simd()),wasmWorkerContents='var Module={};function threadPrintErr(){var text=Array.prototype.slice.call(arguments).join(" ");console.error(text)}function threadAlert(){var text=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:text,threadId:Module["_pthread_self"]()})}var err=threadPrintErr;this.alert=threadAlert;Module["instantiateWasm"]=function(info,receiveInstance){var instance=new WebAssembly.Instance(Module["wasmModule"],info);Module["wasmModule"]=null;receiveInstance(instance);return instance.exports};function moduleLoaded(){}this.onmessage=function(e){try{if(e.data.cmd==="load"){Module["wasmModule"]=e.data.wasmModule;Module["wasmMemory"]=e.data.wasmMemory;Module["buffer"]=Module["wasmMemory"].buffer;Module["ENVIRONMENT_IS_PTHREAD"]=true;if(typeof e.data.urlOrBlob==="string"){importScripts(e.data.urlOrBlob)}else{var objectUrl=URL.createObjectURL(e.data.urlOrBlob);importScripts(objectUrl);URL.revokeObjectURL(objectUrl)}WasmBackendModuleThreadedSimd(Module).then(function(instance){Module=instance;moduleLoaded()})}else if(e.data.cmd==="objectTransfer"){Module["PThread"].receiveObjectTransfer(e.data)}else if(e.data.cmd==="run"){Module["__performance_now_clock_drift"]=performance.now()-e.data.time;Module["__emscripten_thread_init"](e.data.threadInfoStruct,0,0);var max=e.data.stackBase;var top=e.data.stackBase+e.data.stackSize;Module["establishStackSpace"](top,max);Module["_emscripten_tls_init"]();Module["PThread"].receiveObjectTransfer(e.data);Module["PThread"].setThreadStatus(Module["_pthread_self"](),1);try{var result=Module["invokeEntryPoint"](e.data.start_routine,e.data.arg);if(!Module["getNoExitRuntime"]())Module["PThread"].threadExit(result)}catch(ex){if(ex==="Canceled!"){Module["PThread"].threadCancel()}else if(ex!="unwind"){if(ex instanceof Module["ExitStatus"]){if(Module["getNoExitRuntime"]()){}else{Module["PThread"].threadExit(ex.status)}}else{Module["PThread"].threadExit(-2);throw ex}}}}else if(e.data.cmd==="cancel"){if(Module["_pthread_self"]()){Module["PThread"].threadCancel()}}else if(e.data.target==="setimmediate"){}else if(e.data.cmd==="processThreadQueue"){if(Module["_pthread_self"]()){Module["_emscripten_current_thread_process_queued_calls"]()}}else{err("worker.js received unknown command "+e.data.cmd);err(e.data)}}catch(ex){err("worker.js onmessage() captured an uncaught exception: "+ex);if(ex&&ex.stack)err(ex.stack);throw ex}};if(typeof process==="object"&&typeof process.versions==="object"&&typeof process.versions.node==="string"){self={location:{href:__filename}};var onmessage=this.onmessage;var nodeWorkerThreads=require("worker_threads");global.Worker=nodeWorkerThreads.Worker;var parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",function(data){onmessage({data:data})});var nodeFS=require("fs");var nodeRead=function(filename){return nodeFS.readFileSync(filename,"utf8")};function globalEval(x){global.require=require;global.Module=Module;eval.call(null,x)}importScripts=function(f){globalEval(nodeRead(f))};postMessage=function(msg){parentPort.postMessage(msg)};if(typeof performance==="undefined"){performance={now:function(){return Date.now()}}}}',import_tfjs_backend_wasm=__toModule(require_tfjs_backend_wasm()),BackendWasm=class extends KernelBackend{constructor(e){super(),this.wasm=e,this.dataIdNextNumber=1,this.wasm.tfjs.initWithThreadsCount(threadsCount),actualThreadsCount=this.wasm.tfjs.getThreadsCount(),this.dataIdMap=new DataStorage(this,engine())}write(e,t,n){const a={id:this.dataIdNextNumber++};return this.move(a,e,t,n,1),a}numDataIds(){return this.dataIdMap.numDataIds()}async time(e){const t=util_exports.now();e();return{kernelMs:util_exports.now()-t}}move(e,t,n,a,r){const s=this.dataIdNextNumber++;if("string"===a){const o=t;return void this.dataIdMap.set(e,{id:s,stringBytes:o,shape:n,dtype:a,memoryOffset:null,refCount:r})}const o=util_exports.sizeFromShape(n),i=o*util_exports.bytesPerElement(a),l=this.wasm._malloc(i);this.dataIdMap.set(e,{id:s,memoryOffset:l,shape:n,dtype:a,refCount:r}),this.wasm.tfjs.registerTensor(s,o,l),null!=t&&this.wasm.HEAPU8.set(new Uint8Array(t.buffer,t.byteOffset,i),l)}async read(e){return this.readSync(e)}readSync(e){const{memoryOffset:t,dtype:n,shape:a,stringBytes:r}=this.dataIdMap.get(e);if("string"===n)return r;return typedArrayFromBuffer(this.wasm.HEAPU8.slice(t,t+util_exports.sizeFromShape(a)*util_exports.bytesPerElement(n)).buffer,n)}disposeData(e,t=!1){if(this.dataIdMap.has(e)){const n=this.dataIdMap.get(e);if(n.refCount--,!t&&n.refCount>0)return!1;this.wasm._free(n.memoryOffset),this.wasm.tfjs.disposeData(n.id),this.dataIdMap.delete(e)}return!0}refCount(e){if(this.dataIdMap.has(e)){return this.dataIdMap.get(e).refCount}return 0}incRef(e){const t=this.dataIdMap.get(e);null!=t&&t.refCount++}floatPrecision(){return 32}getMemoryOffset(e){return this.dataIdMap.get(e).memoryOffset}dispose(){this.wasm.tfjs.dispose(),"PThread"in this.wasm&&this.wasm.PThread.terminateAllThreads(),this.wasm=null}memory(){return{unreliable:!1}}makeOutput(e,t,n){let a;if(null==n)a=this.write(null,e,t);else{const r=this.dataIdNextNumber++;a={id:r},this.dataIdMap.set(a,{id:r,memoryOffset:n,shape:e,dtype:t,refCount:1});const s=util_exports.sizeFromShape(e);this.wasm.tfjs.registerTensor(r,s,n)}return{dataId:a,shape:e,dtype:t}}typedArrayFromHeap({shape:e,dtype:t,dataId:n}){const a=this.wasm.HEAPU8.buffer,{memoryOffset:r}=this.dataIdMap.get(n),s=util_exports.sizeFromShape(e);switch(t){case"float32":return new Float32Array(a,r,s);case"int32":return new Int32Array(a,r,s);case"bool":return new Uint8Array(a,r,s);default:throw new Error(`Unknown dtype ${t}`)}}};function createInstantiateWasmFunc(e){return(t,n)=>(util_exports.fetch(e,{credentials:"same-origin"}).then((a=>{a.ok||t.env.a(`failed to load wasm binary file at '${e}'`),a.arrayBuffer().then((e=>{WebAssembly.instantiate(e,t).then((e=>{n(e.instance,e.module)}))}))})),{})}function getPathToWasmBinary(e,t,n){if(null!=wasmPath)return wasmPath;let a="tfjs-backend-wasm.wasm";return e&&t?a="tfjs-backend-wasm-threaded-simd.wasm":e&&(a="tfjs-backend-wasm-simd.wasm"),null!=wasmFileMap&&null!=wasmFileMap[a]?wasmFileMap[a]:n+a}async function init(){const[e,t]=await Promise.all([env().getAsync("WASM_HAS_SIMD_SUPPORT"),env().getAsync("WASM_HAS_MULTITHREAD_SUPPORT")]);return new Promise(((n,a)=>{const r={locateFile:(n,a)=>{if(n.endsWith(".worker.js")){const e=new Blob([wasmWorkerContents],{type:"application/javascript"});return URL.createObjectURL(e)}return n.endsWith(".wasm")?getPathToWasmBinary(e,t,null!=wasmPathPrefix?wasmPathPrefix:a):a+n}};customFetch&&(r.instantiateWasm=createInstantiateWasmFunc(getPathToWasmBinary(e,t,null!=wasmPathPrefix?wasmPathPrefix:"")));let s,o=!1;r.onAbort=()=>{if(o)return;if(initAborted)return;initAborted=!0;a({message:"Make sure the server can serve the `.wasm` file relative to the bundled js file. For more details see https://github.com/tensorflow/tfjs/blob/master/tfjs-backend-wasm/README.md#using-bundlers"})},t&&e&&null==wasmPath?(r.mainScriptUrlOrBlob=new Blob(["var WasmBackendModuleThreadedSimd = "+import_tfjs_backend_wasm_threaded_simd.default.toString()],{type:"text/javascript"}),s=(0,import_tfjs_backend_wasm_threaded_simd.default)(r)):s=(0,import_tfjs_backend_wasm.default)(r),s.then((e=>{o=!0,initAborted=!1;e.tfjs={init:e.cwrap("init",null,[]),initWithThreadsCount:e.cwrap("init_with_threads_count",null,["number"]),getThreadsCount:e.cwrap("get_threads_count","number",[]),registerTensor:e.cwrap("register_tensor",null,["number","number","number"]),disposeData:e.cwrap("dispose_data",null,["number"]),dispose:e.cwrap("dispose",null,[])},n({wasm:e})}))}))}function typedArrayFromBuffer(e,t){switch(t){case"float32":return new Float32Array(e);case"int32":return new Int32Array(e);case"bool":return new Uint8Array(e);default:throw new Error(`Unknown dtype ${t}`)}}var wasmBinaryNames=["tfjs-backend-wasm.wasm","tfjs-backend-wasm-simd.wasm","tfjs-backend-wasm-threaded-simd.wasm"],wasmPath=null,wasmPathPrefix=null,wasmFileMap={},initAborted=!1,customFetch=!1;function setWasmPath(e,t=!1){if(deprecationWarn("setWasmPath has been deprecated in favor of setWasmPaths and will be removed in a future release."),initAborted)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPath()` before you call `tf.setBackend()` or `tf.ready()`");wasmPath=e,customFetch=t}function setWasmPaths(e,t=!1){if(initAborted)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPaths()` before you call `tf.setBackend()` or `tf.ready()`");if("string"==typeof e)wasmPathPrefix=e;else{wasmFileMap=e;const t=wasmBinaryNames.filter((e=>null==wasmFileMap[e]));if(t.length>0)throw new Error(`There were no entries found for the following binaries: ${t.join(",")}. Please either call setWasmPaths with a map providing a path for each binary, or with a string indicating the directory where all the binaries can be found.`)}customFetch=t}var threadsCount=-1,actualThreadsCount=-1;function setThreadsCount(e){threadsCount=e}function getThreadsCount(){if(-1===actualThreadsCount)throw new Error("WASM backend not initialized.");return actualThreadsCount}var version7="0.0.0",WASM_PRIORITY=2;registerBackend("wasm",(async()=>{const{wasm:e}=await init();return new BackendWasm(e)}),WASM_PRIORITY);var externalVersion="3.11.0-20211110",version8={tfjs:externalVersion,"tfjs-core":externalVersion,"tfjs-data":externalVersion,"tfjs-layers":externalVersion,"tfjs-converter":externalVersion,"tfjs-backend-cpu":externalVersion,"tfjs-backend-webgl":externalVersion,"tfjs-backend-wasm":externalVersion},version_core=version8["tfjs-core"],vertexIdentity="\n  precision highp float;\n  attribute vec2 pos;\n  attribute vec2 uv;\n  varying vec2 vUv;\n  uniform float flipY;\n  void main(void) {\n    vUv = uv;\n    gl_Position = vec4(pos.x, pos.y*flipY, 0.0, 1.);\n  }\n",colorMatrixWithAlpha="\n  precision highp float;\n  varying vec2 vUv;\n  uniform sampler2D texture;\n  uniform float m[20];\n  void main(void) {\n    vec4 c = texture2D(texture, vUv);\n    gl_FragColor.r = m[0] * c.r + m[1] * c.g + m[2] * c.b + m[3] * c.a + m[4];\n    gl_FragColor.g = m[5] * c.r + m[6] * c.g + m[7] * c.b + m[8] * c.a + m[9];\n    gl_FragColor.b = m[10] * c.r + m[11] * c.g + m[12] * c.b + m[13] * c.a + m[14];\n    gl_FragColor.a = m[15] * c.r + m[16] * c.g + m[17] * c.b + m[18] * c.a + m[19];\n  }\n",colorMatrixWithoutAlpha="\n  precision highp float;\n  varying vec2 vUv;\n  uniform sampler2D texture;\n  uniform float m[20];\n  void main(void) {\n    vec4 c = texture2D(texture, vUv);\n    gl_FragColor.r = m[0] * c.r + m[1] * c.g + m[2] * c.b + m[4];\n    gl_FragColor.g = m[5] * c.r + m[6] * c.g + m[7] * c.b + m[9];\n    gl_FragColor.b = m[10] * c.r + m[11] * c.g + m[12] * c.b + m[14];\n    gl_FragColor.a = c.a;\n  }\n",pixelate="\n  precision highp float;\n  varying vec2 vUv;\n  uniform vec2 size;\n  uniform sampler2D texture;\n  vec2 pixelate(vec2 coord, vec2 size) {\n    return floor( coord / size ) * size;\n  }\n  void main(void) {\n    gl_FragColor = vec4(0.0);\n    vec2 coord = pixelate(vUv, size);\n    gl_FragColor += texture2D(texture, coord);\n  }\n",blur="\n  precision highp float;\n  varying vec2 vUv;\n  uniform sampler2D texture;\n  uniform vec2 px;\n  void main(void) {\n    gl_FragColor = vec4(0.0);\n    gl_FragColor += texture2D(texture, vUv + vec2(-7.0*px.x, -7.0*px.y))*0.0044299121055113265;\n    gl_FragColor += texture2D(texture, vUv + vec2(-6.0*px.x, -6.0*px.y))*0.00895781211794;\n    gl_FragColor += texture2D(texture, vUv + vec2(-5.0*px.x, -5.0*px.y))*0.0215963866053;\n    gl_FragColor += texture2D(texture, vUv + vec2(-4.0*px.x, -4.0*px.y))*0.0443683338718;\n    gl_FragColor += texture2D(texture, vUv + vec2(-3.0*px.x, -3.0*px.y))*0.0776744219933;\n    gl_FragColor += texture2D(texture, vUv + vec2(-2.0*px.x, -2.0*px.y))*0.115876621105;\n    gl_FragColor += texture2D(texture, vUv + vec2(-1.0*px.x, -1.0*px.y))*0.147308056121;\n    gl_FragColor += texture2D(texture, vUv                             )*0.159576912161;\n    gl_FragColor += texture2D(texture, vUv + vec2( 1.0*px.x,  1.0*px.y))*0.147308056121;\n    gl_FragColor += texture2D(texture, vUv + vec2( 2.0*px.x,  2.0*px.y))*0.115876621105;\n    gl_FragColor += texture2D(texture, vUv + vec2( 3.0*px.x,  3.0*px.y))*0.0776744219933;\n    gl_FragColor += texture2D(texture, vUv + vec2( 4.0*px.x,  4.0*px.y))*0.0443683338718;\n    gl_FragColor += texture2D(texture, vUv + vec2( 5.0*px.x,  5.0*px.y))*0.0215963866053;\n    gl_FragColor += texture2D(texture, vUv + vec2( 6.0*px.x,  6.0*px.y))*0.00895781211794;\n    gl_FragColor += texture2D(texture, vUv + vec2( 7.0*px.x,  7.0*px.y))*0.0044299121055113265;\n  }\n",convolution="\n  precision highp float;\n  varying vec2 vUv;\n  uniform sampler2D texture;\n  uniform vec2 px;\n  uniform float m[9];\n  void main(void) {\n    vec4 c11 = texture2D(texture, vUv - px); // top left\n    vec4 c12 = texture2D(texture, vec2(vUv.x, vUv.y - px.y)); // top center\n    vec4 c13 = texture2D(texture, vec2(vUv.x + px.x, vUv.y - px.y)); // top right\n    vec4 c21 = texture2D(texture, vec2(vUv.x - px.x, vUv.y) ); // mid left\n    vec4 c22 = texture2D(texture, vUv); // mid center\n    vec4 c23 = texture2D(texture, vec2(vUv.x + px.x, vUv.y) ); // mid right\n    vec4 c31 = texture2D(texture, vec2(vUv.x - px.x, vUv.y + px.y) ); // bottom left\n    vec4 c32 = texture2D(texture, vec2(vUv.x, vUv.y + px.y) ); // bottom center\n    vec4 c33 = texture2D(texture, vUv + px ); // bottom right\n    gl_FragColor = \n    c11 * m[0] + c12 * m[1] + c22 * m[2] +\n    c21 * m[3] + c22 * m[4] + c23 * m[5] +\n    c31 * m[6] + c32 * m[7] + c33 * m[8];\n    gl_FragColor.a = c22.a;\n  }\n",collect=(e,t,n)=>{const a=new RegExp("\\b"+t+" \\w+ (\\w+)","ig");e.replace(a,((e,t)=>(n[t]=0,e)))},GLProgram=class{constructor(e,t,n){__publicField(this,"uniform",{}),__publicField(this,"attribute",{}),__publicField(this,"gl"),__publicField(this,"id"),__publicField(this,"compile",((e,t)=>{const n=this.gl.createShader(t);return n?(this.gl.shaderSource(n,e),this.gl.compileShader(n),this.gl.getShaderParameter(n,this.gl.COMPILE_STATUS)?n:(log(`filter: gl compile failed: ${this.gl.getShaderInfoLog(n)}`),null)):(log("filter: could not create shader"),null)})),this.gl=e;const a=this.compile(t,this.gl.VERTEX_SHADER),r=this.compile(n,this.gl.FRAGMENT_SHADER);if(this.id=this.gl.createProgram(),a&&r)if(this.id)if(this.gl.attachShader(this.id,a),this.gl.attachShader(this.id,r),this.gl.linkProgram(this.id),this.gl.getProgramParameter(this.id,this.gl.LINK_STATUS)){this.gl.useProgram(this.id),collect(t,"attribute",this.attribute);for(const e in this.attribute)this.attribute[e]=this.gl.getAttribLocation(this.id,e);collect(t,"uniform",this.uniform),collect(n,"uniform",this.uniform);for(const e in this.uniform)this.uniform[e]=this.gl.getUniformLocation(this.id,e)}else log(`filter: gl link failed: ${this.gl.getProgramInfoLog(this.id)}`);else log("filter: could not create webgl program")}};function GLImageFilter(){let e=0,t=null,n=!1,a=-1,r=[null,null],s=[],o=null,i=null;const l=canvas(100,100),u={},c=1,d=l.getContext("webgl");if(this.gl=d,!d)return void log("filter: cannot get webgl context");function p(e){return r[e]=r[e]||function(e,t){const n=d.createFramebuffer();d.bindFramebuffer(d.FRAMEBUFFER,n);const a=d.createRenderbuffer();d.bindRenderbuffer(d.RENDERBUFFER,a);const r=d.createTexture();return d.bindTexture(d.TEXTURE_2D,r),d.texImage2D(d.TEXTURE_2D,0,d.RGBA,e,t,0,d.RGBA,d.UNSIGNED_BYTE,null),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_MAG_FILTER,d.LINEAR),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_MIN_FILTER,d.LINEAR),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_WRAP_S,d.CLAMP_TO_EDGE),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_WRAP_T,d.CLAMP_TO_EDGE),d.framebufferTexture2D(d.FRAMEBUFFER,d.COLOR_ATTACHMENT0,d.TEXTURE_2D,r,0),d.bindTexture(d.TEXTURE_2D,null),d.bindFramebuffer(d.FRAMEBUFFER,null),{fbo:n,texture:r}}(l.width,l.height),r[e]}function h(r=0){if(!i)return;let s=null,o=null,l=!1;s=0===e?t:p(a).texture||null,e++,!n||r&c?(a=(a+1)%2,o=p(a).fbo||null):(o=null,l=e%2==0),d.bindTexture(d.TEXTURE_2D,s),d.bindFramebuffer(d.FRAMEBUFFER,o),d.uniform1f(i.uniform.flipY,l?-1:1),d.drawArrays(d.TRIANGLES,0,6)}function m(e){if(u[e])return i=u[e],d.useProgram((i?i.id:null)||null),i;if(i=new GLProgram(d,vertexIdentity,e),!i)return log("filter: could not get webgl program"),null;const t=Float32Array.BYTES_PER_ELEMENT,n=4*t;return d.enableVertexAttribArray(i.attribute.pos),d.vertexAttribPointer(i.attribute.pos,2,d.FLOAT,!1,n,0*t),d.enableVertexAttribArray(i.attribute.uv),d.vertexAttribPointer(i.attribute.uv,2,d.FLOAT,!1,n,2*t),u[e]=i,i}const f={colorMatrix:e=>{const t=new Float32Array(e);t[4]/=255,t[9]/=255,t[14]/=255,t[19]/=255;const n=m(1===t[18]&&0===t[3]&&0===t[8]&&0===t[13]&&0===t[15]&&0===t[16]&&0===t[17]&&0===t[19]?colorMatrixWithoutAlpha:colorMatrixWithAlpha);n&&(d.uniform1fv(n.uniform.m,t),h())},brightness:e=>{const t=(e||0)+1;f.colorMatrix([t,0,0,0,0,0,t,0,0,0,0,0,t,0,0,0,0,0,1,0])},saturation:e=>{const t=2*(e||0)/3+1,n=-.5*(t-1);f.colorMatrix([t,n,n,0,0,n,t,n,0,0,n,n,t,0,0,0,0,0,1,0])},desaturate:()=>{f.saturation(-1)},contrast:e=>{const t=(e||0)+1,n=-128*(t-1);f.colorMatrix([t,0,0,0,n,0,t,0,0,n,0,0,t,0,n,0,0,0,1,0])},negative:()=>{f.contrast(-2)},hue:e=>{e=(e||0)/180*Math.PI;const t=Math.cos(e),n=Math.sin(e),a=.213,r=.715,s=.072;f.colorMatrix([a+.787*t+n*-a,r+t*-r+n*-r,s+t*-s+.928*n,0,0,a+t*-a+.143*n,r+t*(1-r)+.14*n,s+t*-s+-.283*n,0,0,a+t*-a+-.787*n,r+t*-r+n*r,s+.928*t+n*s,0,0,0,0,0,1,0])},desaturateLuminance:()=>{f.colorMatrix([.2764723,.929708,.0938197,0,-37.1,.2764723,.929708,.0938197,0,-37.1,.2764723,.929708,.0938197,0,-37.1,0,0,0,1,0])},sepia:()=>{f.colorMatrix([.393,.7689999,.18899999,0,0,.349,.6859999,.16799999,0,0,.272,.5339999,.13099999,0,0,0,0,0,1,0])},brownie:()=>{f.colorMatrix([.5997023498159715,.34553243048391263,-.2708298674538042,0,47.43192855600873,-.037703249837783157,.8609577587992641,.15059552388459913,0,-36.96841498319127,.24113635128153335,-.07441037908422492,.44972182064877153,0,-7.562075277591283,0,0,0,1,0])},vintagePinhole:()=>{f.colorMatrix([.6279345635605994,.3202183420819367,-.03965408211312453,0,9.651285835294123,.02578397704808868,.6441188644374771,.03259127616149294,0,7.462829176470591,.0466055556782719,-.0851232987247891,.5241648018700465,0,5.159190588235296,0,0,0,1,0])},kodachrome:()=>{f.colorMatrix([1.1285582396593525,-.3967382283601348,-.03992559172921793,0,63.72958762196502,-.16404339962244616,1.0835251566291304,-.05498805115633132,0,24.732407896706203,-.16786010706155763,-.5603416277695248,1.6014850761964943,0,35.62982807460946,0,0,0,1,0])},technicolor:()=>{f.colorMatrix([1.9125277891456083,-.8545344976951645,-.09155508482755585,0,11.793603434377337,-.3087833385928097,1.7658908555458428,-.10601743074722245,0,-70.35205161461398,-.231103377548616,-.7501899197440212,1.847597816108189,0,30.950940869491138,0,0,0,1,0])},polaroid:()=>{f.colorMatrix([1.438,-.062,-.062,0,0,-.122,1.378,-.122,0,0,-.016,-.016,1.483,0,0,0,0,0,1,0])},shiftToBGR:()=>{f.colorMatrix([0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,1,0])},convolution:e=>{const t=new Float32Array(e),n=1/l.width,a=1/l.height,r=m(convolution);r&&(d.uniform1fv(r.uniform.m,t),d.uniform2f(r.uniform.px,n,a),h())},detectEdges:()=>{f.convolution.call(this,[0,1,0,1,-4,1,0,1,0])},sobelX:()=>{f.convolution.call(this,[-1,0,1,-2,0,2,-1,0,1])},sobelY:()=>{f.convolution.call(this,[-1,-2,-1,0,0,0,1,2,1])},sharpen:e=>{const t=e||1;f.convolution.call(this,[0,-1*t,0,-1*t,1+4*t,-1*t,0,-1*t,0])},emboss:e=>{const t=e||1;f.convolution.call(this,[-2*t,-1*t,0,-1*t,1,1*t,0,1*t,2*t])},blur:e=>{const t=e/7/l.width,n=e/7/l.height,a=m(blur);a&&(d.uniform2f(a.uniform.px,0,n),h(c),d.uniform2f(a.uniform.px,t,0),h())},pixelate:e=>{const t=e/l.width,n=e/l.height,a=m(pixelate);a&&(d.uniform2f(a.uniform.size,t,n),h())}};this.add=function(e){const t=Array.prototype.slice.call(arguments,1),n=f[e];s.push({func:n,args:t})},this.reset=function(){s=[]},this.get=function(){return s},this.apply=function(a){!function(e,t){if(e!==l.width||t!==l.height){if(l.width=e,l.height=t,!o){const e=new Float32Array([-1,-1,0,1,1,-1,1,1,-1,1,0,0,-1,1,0,0,1,-1,1,1,1,1,1,0]);o=d.createBuffer(),d.bindBuffer(d.ARRAY_BUFFER,o),d.bufferData(d.ARRAY_BUFFER,e,d.STATIC_DRAW),d.pixelStorei(d.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!0)}d.viewport(0,0,l.width,l.height),r=[null,null]}}(a.width,a.height),e=0,t||(t=d.createTexture()),d.bindTexture(d.TEXTURE_2D,t),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_WRAP_S,d.CLAMP_TO_EDGE),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_WRAP_T,d.CLAMP_TO_EDGE),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_MIN_FILTER,d.NEAREST),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_MAG_FILTER,d.NEAREST),d.texImage2D(d.TEXTURE_2D,0,d.RGBA,d.RGBA,d.UNSIGNED_BYTE,a);for(let e=0;e<s.length;e++){n=e===s.length-1;const t=s[e];t.func.apply(this,t.args||[])}return l},this.draw=function(e){return this.add("brightness",0),this.apply(e)}}async function histogramEqualization(e){const t=4===e.shape.length?squeeze(e):e,n=split(t,3,2),a=[min(n[0]),min(n[1]),min(n[2])],r=[max(n[0]),max(n[1]),max(n[2])],s=await Promise.all(r.map((e=>e.data()))),o=.99*Math.max(s[0][0],s[1][0],s[2][0]),i=[sub(n[0],a[0]),sub(n[1],a[1]),sub(n[2],a[2])],l=[sub(r[0],a[0]),sub(r[1],a[1]),sub(r[2],a[2])],u=[div(o,l[0]),div(o,l[1]),div(o,l[2])],c=[mul(i[0],u[0]),mul(i[1],u[1]),mul(i[2],u[2])],d=stack([c[0],c[1],c[2]],2),p=reshape(d,[1,t.shape[0],t.shape[1],3]);return dispose([...n,...a,...r,...i,...l,...u,...c,d,t]),p}var fx,maxSize=2048,inCanvas=null,outCanvas=null,tmpCanvas=null,last={inputSum:0,cacheDiff:1,sumMethod:0,inputTensor:void 0};function canvas(e,t){let n;if(env2.browser)if(env2.worker){if("undefined"==typeof OffscreenCanvas)throw new Error("canvas error: attempted to run in web worker but OffscreenCanvas is not supported");n=new OffscreenCanvas(e,t)}else{if("undefined"==typeof document)throw new Error("canvas error: attempted to run in browser but DOM is not defined");n=document.createElement("canvas"),n.width=e,n.height=t}else void 0!==env2.Canvas?n=new env2.Canvas(e,t):void 0!==globalThis.Canvas&&(n=new globalThis.Canvas(e,t));return n}function copy(e,t){const n=t||canvas(e.width,e.height);return n.getContext("2d").drawImage(e,0,0),n}async function process2(e,t,n=!0){if(!e)return t.debug&&log("input error: input is missing"),{tensor:null,canvas:null};if(!(e instanceof Tensor||"undefined"!=typeof Image&&e instanceof Image||void 0!==env2.Canvas&&e instanceof env2.Canvas||void 0!==globalThis.Canvas&&e instanceof globalThis.Canvas||"undefined"!=typeof ImageData&&e instanceof ImageData||"undefined"!=typeof ImageBitmap&&e instanceof ImageBitmap||"undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement||"undefined"!=typeof HTMLMediaElement&&e instanceof HTMLMediaElement||"undefined"!=typeof HTMLVideoElement&&e instanceof HTMLVideoElement||"undefined"!=typeof HTMLCanvasElement&&e instanceof HTMLCanvasElement||"undefined"!=typeof OffscreenCanvas&&e instanceof OffscreenCanvas))throw new Error("input error: type is not recognized");if(e instanceof Tensor){let n=null;if(e.isDisposedInternal)throw new Error("input error: attempted to use tensor but it is disposed");if(!e.shape)throw new Error("input error: attempted to use tensor without a shape");if(3===e.shape.length){if(3===e.shape[2])n=expandDims(e,0);else if(4===e.shape[2]){const t=slice3d(e,[0,0,0],[-1,-1,3]);n=expandDims(t,0),dispose(t)}}else 4===e.shape.length&&(3===e.shape[3]?n=clone(e):4===e.shape[3]&&(n=slice4d(e,[0,0,0,0],[-1,-1,-1,3])));if(null==n||4!==n.shape.length||1!==n.shape[0]||3!==n.shape[3])throw new Error(`input error: attempted to use tensor with unrecognized shape: ${e.shape}`);if("int32"===n.dtype){const e=cast(n,"float32");dispose(n),n=e}return{tensor:n,canvas:t.filter.return?outCanvas:null}}{if(void 0!==e.readyState&&e.readyState<=2)return t.debug&&log("input stream is not ready"),{tensor:null,canvas:inCanvas};const a=e.naturalWidth||e.videoWidth||e.width||e.shape&&e.shape[1]>0,r=e.naturalHeight||e.videoHeight||e.height||e.shape&&e.shape[2]>0;if(!a||!r)return t.debug&&log("cannot determine input dimensions"),{tensor:null,canvas:inCanvas};let s=a,o=r;if(s>maxSize&&(s=maxSize,o=Math.trunc(s*r/a)),o>maxSize&&(o=maxSize,s=Math.trunc(o*a/r)),(t.filter.width||0)>0?s=t.filter.width:(t.filter.height||0)>0&&(s=a*((t.filter.height||0)/r)),(t.filter.height||0)>0?o=t.filter.height:(t.filter.width||0)>0&&(o=r*((t.filter.width||0)/a)),!s||!o)throw new Error("input error: cannot determine dimension");inCanvas&&(null==inCanvas?void 0:inCanvas.width)===s&&(null==inCanvas?void 0:inCanvas.height)===o||(inCanvas=canvas(s,o));const i=inCanvas.getContext("2d");if("undefined"!=typeof ImageData&&e instanceof ImageData?i.putImageData(e,0,0):t.filter.flip&&void 0!==i.translate?(i.translate(a,0),i.scale(-1,1),i.drawImage(e,0,0,a,r,0,0,null==inCanvas?void 0:inCanvas.width,null==inCanvas?void 0:inCanvas.height),i.setTransform(1,0,0,1,0,0)):i.drawImage(e,0,0,a,r,0,0,null==inCanvas?void 0:inCanvas.width,null==inCanvas?void 0:inCanvas.height),outCanvas&&inCanvas.width===outCanvas.width&&(null==inCanvas?void 0:inCanvas.height)===(null==outCanvas?void 0:outCanvas.height)||(outCanvas=canvas(inCanvas.width,inCanvas.height)),t.filter.enabled&&env2.webgl.supported){if(fx||(fx=env2.browser?new GLImageFilter:null),env2.filter=!!fx,!fx||!fx.add)return t.debug&&log("input process error: cannot initialize filters"),{tensor:null,canvas:inCanvas};fx.reset(),0!==t.filter.brightness&&fx.add("brightness",t.filter.brightness),0!==t.filter.contrast&&fx.add("contrast",t.filter.contrast),0!==t.filter.sharpness&&fx.add("sharpen",t.filter.sharpness),0!==t.filter.blur&&fx.add("blur",t.filter.blur),0!==t.filter.saturation&&fx.add("saturation",t.filter.saturation),0!==t.filter.hue&&fx.add("hue",t.filter.hue),t.filter.negative&&fx.add("negative"),t.filter.sepia&&fx.add("sepia"),t.filter.vintage&&fx.add("brownie"),t.filter.sepia&&fx.add("sepia"),t.filter.kodachrome&&fx.add("kodachrome"),t.filter.technicolor&&fx.add("technicolor"),t.filter.polaroid&&fx.add("polaroid"),0!==t.filter.pixelate&&fx.add("pixelate",t.filter.pixelate),outCanvas=fx.get()>0?fx.apply(inCanvas):fx.draw(inCanvas)}else copy(inCanvas,outCanvas),fx&&(fx=null),env2.filter=!!fx;if(!n)return{tensor:null,canvas:outCanvas};if(!outCanvas)throw new Error("canvas error: cannot create output");let l,u=3;if("undefined"!=typeof ImageData&&e instanceof ImageData||e.data&&e.width&&e.height)if(env2.browser&&browser_exports)l=browser_exports?browser_exports.fromPixels(e):null;else{u=e.data.length/e.height/e.width;l=tensor(new Uint8Array(e.data.buffer),[e.height,e.width,u],"int32")}else if(tmpCanvas&&outCanvas.width===tmpCanvas.width&&outCanvas.height===tmpCanvas.height||(tmpCanvas=canvas(outCanvas.width,outCanvas.height)),browser_exports&&env2.browser)"webgl"===t.backend||"humangl"===t.backend||"webgpu"===t.backend?l=browser_exports.fromPixels(outCanvas):(tmpCanvas=copy(outCanvas),l=browser_exports.fromPixels(tmpCanvas));else{const e=copy(outCanvas).getContext("2d").getImageData(0,0,s,o);u=e.data.length/s/o;l=tensor(new Uint8Array(e.data.buffer),[s,o,u])}if(4===u){const e=slice3d(l,[0,0,0],[-1,-1,3]);dispose(l),l=e}if(!l)throw new Error("input error: cannot create tensor");const c=cast(l,"float32"),d=t.filter.equalization?await histogramEqualization(c):expandDims(c,0);return dispose([l,c]),{tensor:d,canvas:t.filter.return?outCanvas:null}}}async function skip(e,t){let n=!1;if(0===e.cacheSensitivity||!t.shape||4!==t.shape.length||t.shape[1]>2048||t.shape[2]>2048)return n;if(last.inputTensor)if(last.inputTensor.shape[1]!==t.shape[1]||last.inputTensor.shape[2]!==t.shape[2])dispose(last.inputTensor),last.inputTensor=clone(t);else{const a={};a.diff=sub(t,last.inputTensor),a.squared=mul(a.diff,a.diff),a.sum=sum2(a.squared);const r=(await a.sum.data())[0]/(t.shape[1]||1)/(t.shape[2]||1)/255/3;dispose([last.inputTensor,a.diff,a.squared,a.sum]),last.inputTensor=clone(t),n=r<=e.cacheSensitivity}else last.inputTensor=clone(t);return n}async function compare(e,t,n){const a={};if(!t||!n||4!==t.shape.length||t.shape.length!==n.shape.length)return e.debug||log("invalid input tensor or tensor shapes do not match:",t.shape,n.shape),0;if(1!==t.shape[0]||1!==n.shape[0]||3!==t.shape[3]||3!==n.shape[3])return e.debug||log("input tensors must be of shape [1, height, width, 3]:",t.shape,n.shape),0;a.input1=clone(t),a.input2=t.shape[1]!==n.shape[1]||t.shape[2]!==n.shape[2]?image.resizeBilinear(n,[t.shape[1],t.shape[2]]):clone(n),a.diff=sub(a.input1,a.input2),a.squared=mul(a.diff,a.diff),a.sum=sum2(a.squared);const r=(await a.sum.data())[0]/(t.shape[1]||1)/(t.shape[2]||1)/255/3;return dispose([a.input1,a.input2,a.diff,a.squared,a.sum]),r}var model2,Env=class{constructor(){if(__publicField(this,"browser"),__publicField(this,"node"),__publicField(this,"worker"),__publicField(this,"platform",""),__publicField(this,"agent",""),__publicField(this,"backends",[]),__publicField(this,"initial"),__publicField(this,"filter"),__publicField(this,"tfjs"),__publicField(this,"offscreen"),__publicField(this,"perfadd",!1),__publicField(this,"wasm",{supported:void 0,backend:void 0,simd:void 0,multithread:void 0}),__publicField(this,"webgl",{supported:void 0,backend:void 0,version:void 0,renderer:void 0}),__publicField(this,"webgpu",{supported:void 0,backend:void 0,adapter:void 0}),__publicField(this,"cpu",{model:void 0,flags:[]}),__publicField(this,"kernels",[]),__publicField(this,"Canvas"),__publicField(this,"Image"),__publicField(this,"ImageData"),this.browser="undefined"!=typeof navigator,this.node="undefined"!=typeof process,this.tfjs={version:version_core},this.offscreen="undefined"!=typeof OffscreenCanvas,this.initial=!0,this.worker=this.browser&&this.offscreen?"undefined"!=typeof WorkerGlobalScope:void 0,"undefined"!=typeof navigator){const e=navigator.userAgent.match(/\(([^()]+)\)/g);if(e&&e[0]){const t=e[0].match(/\(([^()]+)\)/g);this.platform=t&&t[0]?t[0].replace(/\(|\)/g,""):"",this.agent=navigator.userAgent.replace(e[0],""),this.platform[1]&&(this.agent=this.agent.replace(e[1],"")),this.agent=this.agent.replace(/  /g," ")}}else"undefined"!=typeof process&&(this.platform=`${process.platform} ${process.arch}`,this.agent=`NodeJS ${process.version}`)}async updateBackend(){this.backends=Object.keys(engine().registryFactory),this.wasm.supported="undefined"!=typeof WebAssembly,this.wasm.backend=this.backends.includes("wasm"),this.wasm.supported&&this.wasm.backend&&"wasm"===getBackend()&&(this.wasm.simd=await env().getAsync("WASM_HAS_SIMD_SUPPORT"),this.wasm.multithread=await env().getAsync("WASM_HAS_MULTITHREAD_SUPPORT"));const e=canvas(100,100),t=e?e.getContext("webgl2"):void 0;if(this.webgl.supported=void 0!==t,this.webgl.backend=this.backends.includes("webgl"),this.webgl.supported&&this.webgl.backend&&("webgl"===getBackend()||"humangl"===getBackend())){const e="undefined"!==backend().gpgpu?await backend().getGPGPUContext().gl:null;e&&(this.webgl.version=e.getParameter(e.VERSION),this.webgl.renderer=e.getParameter(e.RENDERER))}this.webgpu.supported=this.browser&&void 0!==navigator.gpu,this.webgpu.backend=this.backends.includes("webgpu");try{this.webgpu.supported&&(this.webgpu.adapter=(await navigator.gpu.requestAdapter()).name),this.kernels=getKernelsForBackend(getBackend()).map((e=>e.kernelName.toLowerCase()))}catch(e){this.webgpu.supported=!1}}async updateCPU(){const e={model:"",flags:[]};if(this.node&&this.platform.startsWith("linux")){const t=__require("fs");try{const n=t.readFileSync("/proc/cpuinfo").toString();for(const t of n.split("\n"))t.startsWith("model name")&&(e.model=t.match(/:(.*)/g)[0].replace(":","").trim()),t.startsWith("flags")&&(e.flags=t.match(/:(.*)/g)[0].replace(":","").trim().split(" ").sort())}catch(e){}}this.cpu?this.cpu=e:Object.defineProperty(this,"cpu",{value:e})}},env2=new Env,version="2.5.2",last2=[],raceNames=["white","black","asian","indian","other"],ageWeights=[15,23,28,35.5,45.5,55.5,65],lastCount=0,lastTime=0,skipped=Number.MAX_SAFE_INTEGER;async function load(e){return env2.initial&&(model2=null),model2?e.debug&&log("cached model:",model2.modelUrl):(model2=await loadGraphModel(join(e.modelBasePath,e.face.gear.modelPath)))&&model2.modelUrl?e.debug&&log("load model:",model2.modelUrl):log("load model failed:",e.face.gear.modelPath),model2}async function predict(e,t,n,a){var r,s;if(!model2)return{age:0,gender:"unknown",genderScore:0,race:[]};const o=skipped<((null==(r=t.face.gear)?void 0:r.skipFrames)||0),i=((null==(s=t.face.gear)?void 0:s.skipTime)||0)>now()-lastTime;return t.skipAllowed&&i&&o&&lastCount===a&&last2[n]?(skipped++,last2[n]):(skipped=0,new Promise((async r=>{var s,o;if(!(null==model2?void 0:model2.inputs[0].shape))return;const i={};i.resize=image.cropAndResize(e,[[0,.1,.9,.9]],[0],[model2.inputs[0].shape[2],model2.inputs[0].shape[1]]);const l={age:0,gender:"unknown",genderScore:0,race:[]};(null==(s=t.face.gear)?void 0:s.enabled)&&([i.age,i.gender,i.race]=model2.execute(i.resize,["age_output","gender_output","race_output"]));const u=await i.gender.data();l.gender=u[0]>u[1]?"male":"female",l.genderScore=Math.round(100*(u[0]>u[1]?u[0]:u[1]))/100;const c=await i.race.data();for(let e=0;e<c.length;e++)c[e]>((null==(o=t.face.gear)?void 0:o.minConfidence)||.2)&&l.race.push({score:Math.round(100*c[e])/100,race:raceNames[e]});l.race.sort(((e,t)=>t.score-e.score));const d=Array.from(await i.age.data()).map(((e,t)=>[ageWeights[t],e])).sort(((e,t)=>t[1]-e[1]));let p=d[0][0];for(let e=1;e<d.length;e++)p+=d[e][1]*(d[e][0]-p);l.age=Math.round(10*p)/10,Object.keys(i).forEach((e=>dispose(i[e]))),last2[n]=l,lastCount=a,lastTime=now(),r(l)})))}var model3,constants={tf255:255,tf1:1,tf2:2,tf05:.5,tf127:127.5,rgb:[.2989,.587,.114]};function init2(){constants.tf255=scalar(255,"float32"),constants.tf1=scalar(1,"float32"),constants.tf2=scalar(2,"float32"),constants.tf05=scalar(.5,"float32"),constants.tf127=scalar(127.5,"float32"),constants.rgb=tensor1d([.2989,.587,.114],"float32")}var model4,last3=[],lastCount2=0,lastTime2=0,skipped2=Number.MAX_SAFE_INTEGER;async function load2(e){return env2.initial&&(model3=null),model3?e.debug&&log("cached model:",model3.modelUrl):(model3=await loadGraphModel(join(e.modelBasePath,e.face.ssrnet.modelPathAge)))&&model3.modelUrl?e.debug&&log("load model:",model3.modelUrl):log("load model failed:",e.face.ssrnet.modelPathAge),model3}async function predict2(e,t,n,a){var r,s,o,i;if(!model3)return{age:0};const l=skipped2<((null==(r=t.face.ssrnet)?void 0:r.skipFrames)||0),u=((null==(s=t.face.ssrnet)?void 0:s.skipTime)||0)>now()-lastTime2;return t.skipAllowed&&l&&u&&lastCount2===a&&(null==(o=last3[n])?void 0:o.age)&&(null==(i=last3[n])?void 0:i.age)>0?(skipped2++,last3[n]):(skipped2=0,new Promise((async r=>{if(!(null==model3?void 0:model3.inputs)||!model3.inputs[0]||!model3.inputs[0].shape)return;const s={};s.resize=image.resizeBilinear(e,[model3.inputs[0].shape[2],model3.inputs[0].shape[1]],!1),s.enhance=mul(s.resize,constants.tf255);const o={age:0};if(t.face.ssrnet.enabled&&(s.age=model3.execute(s.enhance)),s.age){const e=await s.age.data();o.age=Math.trunc(10*e[0])/10}Object.keys(s).forEach((e=>dispose(s[e]))),last3[n]=o,lastCount2=a,lastTime2=now(),r(o)})))}var model5,last4=[],lastCount3=0,lastTime3=0,skipped3=Number.MAX_SAFE_INTEGER,rgb=[.2989,.587,.114];async function load3(e){return env2.initial&&(model4=null),model4?e.debug&&log("cached model:",model4.modelUrl):(model4=await loadGraphModel(join(e.modelBasePath,e.face.ssrnet.modelPathGender)))&&model4.modelUrl?e.debug&&log("load model:",model4.modelUrl):log("load model failed:",e.face.ssrnet.modelPathGender),model4}async function predict3(e,t,n,a){var r,s,o,i;if(!model4)return{gender:"unknown",genderScore:0};const l=skipped3<((null==(r=t.face.ssrnet)?void 0:r.skipFrames)||0),u=((null==(s=t.face.ssrnet)?void 0:s.skipTime)||0)>now()-lastTime3;return t.skipAllowed&&l&&u&&lastCount3===a&&(null==(o=last4[n])?void 0:o.gender)&&(null==(i=last4[n])?void 0:i.genderScore)>0?(skipped3++,last4[n]):(skipped3=0,new Promise((async r=>{if(!(null==model4?void 0:model4.inputs[0].shape))return;const s={};s.resize=image.resizeBilinear(e,[model4.inputs[0].shape[2],model4.inputs[0].shape[1]],!1),s.enhance=tidy((()=>{const[e,t,n]=split(s.resize,3,3),a=mul(e,rgb[0]),r=mul(t,rgb[1]),o=mul(n,rgb[2]),i=addN([a,r,o]);return mul(sub(i,constants.tf05),2)}));const o={gender:"",genderScore:0};t.face.ssrnet.enabled&&(s.gender=model4.execute(s.enhance));const i=await s.gender.data();o.gender=i[0]>i[1]?"female":"male",o.genderScore=i[0]>i[1]?Math.trunc(100*i[0])/100:Math.trunc(100*i[1])/100,Object.keys(s).forEach((e=>dispose(s[e]))),last4[n]=o,lastCount3=a,lastTime3=now(),r(o)})))}var cached=[],skipped4=Number.MAX_SAFE_INTEGER,lastCount4=0,lastTime4=0;async function load4(e){var t,n;return env2.initial&&(model5=null),model5?e.debug&&log("cached model:",model5.modelUrl):(model5=await loadGraphModel(join(e.modelBasePath,(null==(t=e.face.antispoof)?void 0:t.modelPath)||"")))&&model5.modelUrl?e.debug&&log("load model:",model5.modelUrl):log("load model failed:",null==(n=e.face.antispoof)?void 0:n.modelPath),model5}async function predict4(e,t,n,a){var r,s;if(!model5)return 0;const o=((null==(r=t.face.antispoof)?void 0:r.skipTime)||0)>now()-lastTime4,i=skipped4<((null==(s=t.face.antispoof)?void 0:s.skipFrames)||0);return t.skipAllowed&&o&&i&&lastCount4===a&&cached[n]?(skipped4++,cached[n]):(skipped4=0,new Promise((async t=>{const r=image.resizeBilinear(e,[(null==model5?void 0:model5.inputs[0].shape)?model5.inputs[0].shape[2]:0,(null==model5?void 0:model5.inputs[0].shape)?model5.inputs[0].shape[1]:0],!1),s=null==model5?void 0:model5.execute(r),o=(await s.data())[0];cached[n]=Math.round(100*o)/100,lastCount4=a,lastTime4=now(),dispose([r,s]),t(cached[n])})))}var meshAnnotations={silhouette:[10,338,297,332,284,251,389,356,454,323,361,288,397,365,379,378,400,377,152,148,176,149,150,136,172,58,132,93,234,127,162,21,54,103,67,109],lipsUpperOuter:[61,185,40,39,37,0,267,269,270,409,291],lipsLowerOuter:[146,91,181,84,17,314,405,321,375,291],lipsUpperInner:[78,191,80,81,82,13,312,311,310,415,308],lipsLowerInner:[78,95,88,178,87,14,317,402,318,324,308],rightEyeUpper0:[246,161,160,159,158,157,173],rightEyeLower0:[33,7,163,144,145,153,154,155,133],rightEyeUpper1:[247,30,29,27,28,56,190],rightEyeLower1:[130,25,110,24,23,22,26,112,243],rightEyeUpper2:[113,225,224,223,222,221,189],rightEyeLower2:[226,31,228,229,230,231,232,233,244],rightEyeLower3:[143,111,117,118,119,120,121,128,245],rightEyebrowUpper:[156,70,63,105,66,107,55,193],rightEyebrowLower:[35,124,46,53,52,65],rightEyeIris:[473,474,475,476,477],leftEyeUpper0:[466,388,387,386,385,384,398],leftEyeLower0:[263,249,390,373,374,380,381,382,362],leftEyeUpper1:[467,260,259,257,258,286,414],leftEyeLower1:[359,255,339,254,253,252,256,341,463],leftEyeUpper2:[342,445,444,443,442,441,413],leftEyeLower2:[446,261,448,449,450,451,452,453,464],leftEyeLower3:[372,340,346,347,348,349,350,357,465],leftEyebrowUpper:[383,300,293,334,296,336,285,417],leftEyebrowLower:[265,353,276,283,282,295],leftEyeIris:[468,469,470,471,472],midwayBetweenEyes:[168],noseTip:[1],noseBottom:[2],noseRightCorner:[98],noseLeftCorner:[327],rightCheek:[205],leftCheek:[425]},meshLandmarks={count:468,mouth:13,symmetryLine:[13,meshAnnotations.midwayBetweenEyes[0]]},blazeFaceLandmarks={leftEye:0,rightEye:1,nose:2,mouth:3,leftEar:4,rightEar:5,symmetryLine:[3,2]},MESH_TO_IRIS_INDICES_MAP=[{key:"EyeUpper0",indices:[9,10,11,12,13,14,15]},{key:"EyeUpper1",indices:[25,26,27,28,29,30,31]},{key:"EyeUpper2",indices:[41,42,43,44,45,46,47]},{key:"EyeLower0",indices:[0,1,2,3,4,5,6,7,8]},{key:"EyeLower1",indices:[16,17,18,19,20,21,22,23,24]},{key:"EyeLower2",indices:[32,33,34,35,36,37,38,39,40]},{key:"EyeLower3",indices:[54,55,56,57,58,59,60,61,62]}],UV468=[[.499976992607117,.652534008026123],[.500025987625122,.547487020492554],[.499974012374878,.602371990680695],[.482113003730774,.471979022026062],[.500150978565216,.527155995368958],[.499909996986389,.498252987861633],[.499523013830185,.40106201171875],[.289712011814117,.380764007568359],[.499954998493195,.312398016452789],[.499987006187439,.269918978214264],[.500023007392883,.107050001621246],[.500023007392883,.666234016418457],[.5000159740448,.679224014282227],[.500023007392883,.692348003387451],[.499976992607117,.695277988910675],[.499976992607117,.70593398809433],[.499976992607117,.719385027885437],[.499976992607117,.737019002437592],[.499967992305756,.781370997428894],[.499816000461578,.562981009483337],[.473773002624512,.573909997940063],[.104906998574734,.254140973091125],[.365929991006851,.409575998783112],[.338757991790771,.41302502155304],[.311120003461838,.409460008144379],[.274657994508743,.389131009578705],[.393361985683441,.403706014156342],[.345234006643295,.344011008739471],[.370094001293182,.346076011657715],[.319321990013123,.347265005111694],[.297903001308441,.353591024875641],[.24779200553894,.410809993743896],[.396889001131058,.842755019664764],[.280097991228104,.375599980354309],[.106310002505779,.399955987930298],[.2099249958992,.391353011131287],[.355807989835739,.534406006336212],[.471751004457474,.65040397644043],[.474155008792877,.680191993713379],[.439785003662109,.657229006290436],[.414617002010345,.66654098033905],[.450374007225037,.680860996246338],[.428770989179611,.682690978050232],[.374971002340317,.727805018424988],[.486716985702515,.547628998756409],[.485300987958908,.527395009994507],[.257764995098114,.314490020275116],[.401223003864288,.455172002315521],[.429818987846375,.548614978790283],[.421351999044418,.533740997314453],[.276895999908447,.532056987285614],[.483370006084442,.499586999416351],[.33721199631691,.282882988452911],[.296391993761063,.293242990970612],[.169294998049736,.193813979625702],[.447580009698868,.302609980106354],[.392390012741089,.353887975215912],[.354490011930466,.696784019470215],[.067304998636246,.730105042457581],[.442739009857178,.572826027870178],[.457098007202148,.584792017936707],[.381974011659622,.694710969924927],[.392388999462128,.694203019142151],[.277076005935669,.271932005882263],[.422551989555359,.563233017921448],[.385919004678726,.281364023685455],[.383103013038635,.255840003490448],[.331431001424789,.119714021682739],[.229923993349075,.232002973556519],[.364500999450684,.189113974571228],[.229622006416321,.299540996551514],[.173287004232407,.278747975826263],[.472878992557526,.666198015213013],[.446828007698059,.668527007102966],[.422762006521225,.673889994621277],[.445307999849319,.580065965652466],[.388103008270264,.693961024284363],[.403039008378983,.706539988517761],[.403629004955292,.693953037261963],[.460041999816895,.557139039039612],[.431158006191254,.692366003990173],[.452181994915009,.692366003990173],[.475387006998062,.692366003990173],[.465828001499176,.779190003871918],[.472328990697861,.736225962638855],[.473087012767792,.717857003211975],[.473122000694275,.704625964164734],[.473033010959625,.695277988910675],[.427942007780075,.695277988910675],[.426479011774063,.703539967536926],[.423162013292313,.711845993995667],[.4183090031147,.720062971115112],[.390094995498657,.639572978019714],[.013953999616206,.560034036636353],[.499913990497589,.58014702796936],[.413199990987778,.69539999961853],[.409626007080078,.701822996139526],[.468080013990402,.601534962654114],[.422728985548019,.585985004901886],[.463079988956451,.593783974647522],[.37211999297142,.47341400384903],[.334562003612518,.496073007583618],[.411671012639999,.546965003013611],[.242175996303558,.14767599105835],[.290776997804642,.201445996761322],[.327338010072708,.256527006626129],[.399509996175766,.748921036720276],[.441727995872498,.261676013469696],[.429764986038208,.187834024429321],[.412198007106781,.108901023864746],[.288955003023148,.398952007293701],[.218936994671822,.435410976409912],[.41278201341629,.398970007896423],[.257135003805161,.355440020561218],[.427684992551804,.437960982322693],[.448339998722076,.536936044692993],[.178560003638268,.45755398273468],[.247308000922203,.457193970680237],[.286267012357712,.467674970626831],[.332827985286713,.460712015628815],[.368755996227264,.447206974029541],[.398963987827301,.432654976844788],[.476410001516342,.405806005001068],[.189241006970406,.523923993110657],[.228962004184723,.348950982093811],[.490725994110107,.562400996685028],[.404670000076294,.485132992267609],[.019469000399113,.401564002037048],[.426243007183075,.420431017875671],[.396993011236191,.548797011375427],[.266469985246658,.376977026462555],[.439121007919312,.51895797252655],[.032313998788595,.644356966018677],[.419054001569748,.387154996395111],[.462783008813858,.505746960639954],[.238978996872902,.779744982719421],[.198220998048782,.831938028335571],[.107550002634525,.540755033493042],[.183610007166862,.740257024765015],[.134409993886948,.333683013916016],[.385764002799988,.883153975009918],[.490967005491257,.579378008842468],[.382384985685349,.508572995662689],[.174399003386497,.397670984268188],[.318785011768341,.39623498916626],[.343364000320435,.400596976280212],[.396100014448166,.710216999053955],[.187885001301765,.588537991046906],[.430987000465393,.944064974784851],[.318993002176285,.898285031318665],[.266247987747192,.869701027870178],[.500023007392883,.190576016902924],[.499976992607117,.954452991485596],[.366169989109039,.398822009563446],[.393207013607025,.39553701877594],[.410373002290726,.391080021858215],[.194993004202843,.342101991176605],[.388664990663528,.362284004688263],[.365961998701096,.355970978736877],[.343364000320435,.355356991291046],[.318785011768341,.35834002494812],[.301414996385574,.363156020641327],[.058132998645306,.319076001644135],[.301414996385574,.387449026107788],[.499987989664078,.618434011936188],[.415838003158569,.624195992946625],[.445681989192963,.566076993942261],[.465844005346298,.620640993118286],[.49992299079895,.351523995399475],[.288718998432159,.819945991039276],[.335278987884521,.852819979190826],[.440512001514435,.902418971061707],[.128294005990028,.791940987110138],[.408771991729736,.373893976211548],[.455606997013092,.451801002025604],[.499877005815506,.908990025520325],[.375436991453171,.924192011356354],[.11421000212431,.615022003650665],[.448662012815475,.695277988910675],[.4480200111866,.704632043838501],[.447111994028091,.715808033943176],[.444831997156143,.730794012546539],[.430011987686157,.766808986663818],[.406787008047104,.685672998428345],[.400738000869751,.681069016456604],[.392399996519089,.677703022956848],[.367855995893478,.663918972015381],[.247923001646996,.601333022117615],[.452769994735718,.420849978923798],[.43639200925827,.359887003898621],[.416164010763168,.368713974952698],[.413385987281799,.692366003990173],[.228018000721931,.683571994304657],[.468268007040024,.352671027183533],[.411361992359161,.804327011108398],[.499989002943039,.469825029373169],[.479153990745544,.442654013633728],[.499974012374878,.439637005329132],[.432112008333206,.493588984012604],[.499886006116867,.866917014122009],[.49991300702095,.821729004383087],[.456548988819122,.819200992584229],[.344549000263214,.745438992977142],[.37890899181366,.574010014533997],[.374292999505997,.780184984207153],[.319687992334366,.570737957954407],[.357154995203018,.604269981384277],[.295284003019333,.621580958366394],[.447750002145767,.862477004528046],[.410986006259918,.508723020553589],[.31395098567009,.775308012962341],[.354128003120422,.812552988529205],[.324548006057739,.703992962837219],[.189096003770828,.646299958229065],[.279776990413666,.71465802192688],[.1338230073452,.682700991630554],[.336768001317978,.644733011722565],[.429883986711502,.466521978378296],[.455527991056442,.548622965812683],[.437114000320435,.558896005153656],[.467287987470627,.529924988746643],[.414712011814117,.335219979286194],[.37704598903656,.322777986526489],[.344107985496521,.320150971412659],[.312875986099243,.32233202457428],[.283526003360748,.333190023899078],[.241245999932289,.382785975933075],[.102986000478268,.468762993812561],[.267612010240555,.424560010433197],[.297879010438919,.433175981044769],[.333433985710144,.433878004550934],[.366427004337311,.426115989685059],[.396012008190155,.416696012020111],[.420121014118195,.41022801399231],[.007561000064015,.480777025222778],[.432949006557465,.569517970085144],[.458638995885849,.479089021682739],[.473466008901596,.545744001865387],[.476087987422943,.563830018043518],[.468472003936768,.555056989192963],[.433990985155106,.582361996173859],[.483518004417419,.562983989715576],[.482482999563217,.57784903049469],[.42645001411438,.389798998832703],[.438998997211456,.39649498462677],[.450067013502121,.400434017181396],[.289712011814117,.368252992630005],[.276670008897781,.363372981548309],[.517862021923065,.471948027610779],[.710287988185883,.380764007568359],[.526226997375488,.573909997940063],[.895093023777008,.254140973091125],[.634069979190826,.409575998783112],[.661242008209229,.41302502155304],[.688880026340485,.409460008144379],[.725341975688934,.389131009578705],[.606630027294159,.40370500087738],[.654766023159027,.344011008739471],[.629905998706818,.346076011657715],[.680678009986877,.347265005111694],[.702096998691559,.353591024875641],[.75221198797226,.410804986953735],[.602918028831482,.842862963676453],[.719901978969574,.375599980354309],[.893692970275879,.399959981441498],[.790081977844238,.391354024410248],[.643998026847839,.534487962722778],[.528249025344849,.65040397644043],[.525849997997284,.680191040039062],[.560214996337891,.657229006290436],[.585384011268616,.66654098033905],[.549625992774963,.680860996246338],[.57122802734375,.682691991329193],[.624852001667023,.72809898853302],[.513050019741058,.547281980514526],[.51509702205658,.527251958847046],[.742246985435486,.314507007598877],[.598631024360657,.454979002475739],[.570338010787964,.548575043678284],[.578631997108459,.533622980117798],[.723087012767792,.532054007053375],[.516445994377136,.499638974666595],[.662801027297974,.282917976379395],[.70362401008606,.293271005153656],[.830704987049103,.193813979625702],[.552385985851288,.302568018436432],[.607609987258911,.353887975215912],[.645429015159607,.696707010269165],[.932694971561432,.730105042457581],[.557260990142822,.572826027870178],[.542901992797852,.584792017936707],[.6180260181427,.694710969924927],[.607590973377228,.694203019142151],[.722943007946014,.271963000297546],[.577413976192474,.563166975975037],[.614082992076874,.281386971473694],[.616907000541687,.255886018276215],[.668509006500244,.119913995265961],[.770092010498047,.232020974159241],[.635536015033722,.189248979091644],[.77039098739624,.299556016921997],[.826722025871277,.278755009174347],[.527121007442474,.666198015213013],[.553171992301941,.668527007102966],[.577238023281097,.673889994621277],[.554691970348358,.580065965652466],[.611896991729736,.693961024284363],[.59696102142334,.706539988517761],[.596370995044708,.693953037261963],[.539958000183105,.557139039039612],[.568841993808746,.692366003990173],[.547818005084991,.692366003990173],[.52461302280426,.692366003990173],[.534089982509613,.779141008853912],[.527670979499817,.736225962638855],[.526912987232208,.717857003211975],[.526877999305725,.704625964164734],[.526966989040375,.695277988910675],[.572058022022247,.695277988910675],[.573521018028259,.703539967536926],[.57683801651001,.711845993995667],[.581691026687622,.720062971115112],[.609944999217987,.639909982681274],[.986046016216278,.560034036636353],[.5867999792099,.69539999961853],[.590372025966644,.701822996139526],[.531915009021759,.601536989212036],[.577268004417419,.585934996604919],[.536915004253387,.593786001205444],[.627542972564697,.473352015018463],[.665585994720459,.495950996875763],[.588353991508484,.546862006187439],[.757824003696442,.14767599105835],[.709249973297119,.201507985591888],[.672684013843536,.256581008434296],[.600408971309662,.74900496006012],[.55826598405838,.261672019958496],[.570303976535797,.187870979309082],[.588165998458862,.109044015407562],[.711045026779175,.398952007293701],[.781069993972778,.435405015945435],[.587247014045715,.398931980133057],[.742869973182678,.355445981025696],[.572156012058258,.437651991844177],[.55186802148819,.536570012569427],[.821442008018494,.457556009292603],[.752701997756958,.457181990146637],[.71375697851181,.467626988887787],[.66711300611496,.460672974586487],[.631101012229919,.447153985500336],[.6008620262146,.432473003864288],[.523481011390686,.405627012252808],[.810747981071472,.523926019668579],[.771045982837677,.348959028720856],[.509127020835876,.562718033790588],[.595292985439301,.485023975372314],[.980530977249146,.401564002037048],[.573499977588654,.420000016689301],[.602994978427887,.548687994480133],[.733529984951019,.376977026462555],[.560611009597778,.519016981124878],[.967685997486115,.644356966018677],[.580985009670258,.387160003185272],[.537728011608124,.505385041236877],[.760966002941132,.779752969741821],[.801778972148895,.831938028335571],[.892440974712372,.54076099395752],[.816350996494293,.740260004997253],[.865594983100891,.333687007427216],[.614073991775513,.883246004581451],[.508952975273132,.579437971115112],[.617941975593567,.508316040039062],[.825608015060425,.397674977779388],[.681214988231659,.39623498916626],[.656635999679565,.400596976280212],[.603900015354156,.710216999053955],[.81208598613739,.588539004325867],[.56801301240921,.944564998149872],[.681007981300354,.898285031318665],[.733752012252808,.869701027870178],[.633830010890961,.398822009563446],[.606792986392975,.39553701877594],[.589659988880157,.391062021255493],[.805015981197357,.342108011245728],[.611334979534149,.362284004688263],[.634037971496582,.355970978736877],[.656635999679565,.355356991291046],[.681214988231659,.35834002494812],[.698584973812103,.363156020641327],[.941866993904114,.319076001644135],[.698584973812103,.387449026107788],[.584177017211914,.624107003211975],[.554318010807037,.566076993942261],[.534153997898102,.62064003944397],[.711217999458313,.819975018501282],[.664629995822906,.852871000766754],[.559099972248077,.902631998062134],[.871706008911133,.791940987110138],[.591234028339386,.373893976211548],[.544341027736664,.451583981513977],[.624562978744507,.924192011356354],[.88577002286911,.615028977394104],[.551338016986847,.695277988910675],[.551980018615723,.704632043838501],[.552887976169586,.715808033943176],[.555167973041534,.730794012546539],[.569944024085999,.767035007476807],[.593203008174896,.685675978660583],[.599261999130249,.681069016456604],[.607599973678589,.677703022956848],[.631937980651855,.663500010967255],[.752032995223999,.601315021514893],[.547226011753082,.420395016670227],[.563543975353241,.359827995300293],[.583841025829315,.368713974952698],[.586614012718201,.692366003990173],[.771915018558502,.683578014373779],[.531597018241882,.352482974529266],[.588370978832245,.804440975189209],[.52079701423645,.442565023899078],[.567984998226166,.493479013442993],[.543282985687256,.819254994392395],[.655317008495331,.745514988899231],[.621008992195129,.574018001556396],[.625559985637665,.78031200170517],[.680198013782501,.570719003677368],[.64276397228241,.604337990283966],[.704662978649139,.621529996395111],[.552012026309967,.862591981887817],[.589071989059448,.508637011051178],[.685944974422455,.775357007980347],[.645735025405884,.812640011310577],[.675342977046967,.703978002071381],[.810858011245728,.646304965019226],[.72012197971344,.714666962623596],[.866151988506317,.682704985141754],[.663187026977539,.644596993923187],[.570082008838654,.466325998306274],[.544561982154846,.548375964164734],[.562758982181549,.558784961700439],[.531987011432648,.530140042304993],[.585271000862122,.335177004337311],[.622952997684479,.32277899980545],[.655896008014679,.320163011550903],[.687132000923157,.322345972061157],[.716481983661652,.333200991153717],[.758756995201111,.382786989212036],[.897013008594513,.468769013881683],[.732392013072968,.424547016620636],[.70211398601532,.433162987232208],[.66652500629425,.433866024017334],[.633504986763,.426087975502014],[.603875994682312,.416586995124817],[.579657971858978,.409945011138916],[.992439985275269,.480777025222778],[.567192018032074,.569419980049133],[.54136598110199,.478899002075195],[.526564002037048,.546118021011353],[.523913025856018,.563830018043518],[.531529009342194,.555056989192963],[.566035985946655,.582329034805298],[.51631098985672,.563053965568542],[.5174720287323,.577877044677734],[.573594987392426,.389806985855103],[.560697972774506,.395331978797913],[.549755990505219,.399751007556915],[.710287988185883,.368252992630005],[.723330020904541,.363372981548309]],TRI468=[127,34,139,11,0,37,232,231,120,72,37,39,128,121,47,232,121,128,104,69,67,175,171,148,157,154,155,118,50,101,73,39,40,9,151,108,48,115,131,194,204,211,74,40,185,80,42,183,40,92,186,230,229,118,202,212,214,83,18,17,76,61,146,160,29,30,56,157,173,106,204,194,135,214,192,203,165,98,21,71,68,51,45,4,144,24,23,77,146,91,205,50,187,201,200,18,91,106,182,90,91,181,85,84,17,206,203,36,148,171,140,92,40,39,193,189,244,159,158,28,247,246,161,236,3,196,54,68,104,193,168,8,117,228,31,189,193,55,98,97,99,126,47,100,166,79,218,155,154,26,209,49,131,135,136,150,47,126,217,223,52,53,45,51,134,211,170,140,67,69,108,43,106,91,230,119,120,226,130,247,63,53,52,238,20,242,46,70,156,78,62,96,46,53,63,143,34,227,173,155,133,123,117,111,44,125,19,236,134,51,216,206,205,154,153,22,39,37,167,200,201,208,36,142,100,57,212,202,20,60,99,28,158,157,35,226,113,160,159,27,204,202,210,113,225,46,43,202,204,62,76,77,137,123,116,41,38,72,203,129,142,64,98,240,49,102,64,41,73,74,212,216,207,42,74,184,169,170,211,170,149,176,105,66,69,122,6,168,123,147,187,96,77,90,65,55,107,89,90,180,101,100,120,63,105,104,93,137,227,15,86,85,129,102,49,14,87,86,55,8,9,100,47,121,145,23,22,88,89,179,6,122,196,88,95,96,138,172,136,215,58,172,115,48,219,42,80,81,195,3,51,43,146,61,171,175,199,81,82,38,53,46,225,144,163,110,246,33,7,52,65,66,229,228,117,34,127,234,107,108,69,109,108,151,48,64,235,62,78,191,129,209,126,111,35,143,163,161,246,117,123,50,222,65,52,19,125,141,221,55,65,3,195,197,25,7,33,220,237,44,70,71,139,122,193,245,247,130,33,71,21,162,153,158,159,170,169,150,188,174,196,216,186,92,144,160,161,2,97,167,141,125,241,164,167,37,72,38,12,145,159,160,38,82,13,63,68,71,226,35,111,158,153,154,101,50,205,206,92,165,209,198,217,165,167,97,220,115,218,133,112,243,239,238,241,214,135,169,190,173,133,171,208,32,125,44,237,86,87,178,85,86,179,84,85,180,83,84,181,201,83,182,137,93,132,76,62,183,61,76,184,57,61,185,212,57,186,214,207,187,34,143,156,79,239,237,123,137,177,44,1,4,201,194,32,64,102,129,213,215,138,59,166,219,242,99,97,2,94,141,75,59,235,24,110,228,25,130,226,23,24,229,22,23,230,26,22,231,112,26,232,189,190,243,221,56,190,28,56,221,27,28,222,29,27,223,30,29,224,247,30,225,238,79,20,166,59,75,60,75,240,147,177,215,20,79,166,187,147,213,112,233,244,233,128,245,128,114,188,114,217,174,131,115,220,217,198,236,198,131,134,177,132,58,143,35,124,110,163,7,228,110,25,356,389,368,11,302,267,452,350,349,302,303,269,357,343,277,452,453,357,333,332,297,175,152,377,384,398,382,347,348,330,303,304,270,9,336,337,278,279,360,418,262,431,304,408,409,310,415,407,270,409,410,450,348,347,422,430,434,313,314,17,306,307,375,387,388,260,286,414,398,335,406,418,364,367,416,423,358,327,251,284,298,281,5,4,373,374,253,307,320,321,425,427,411,421,313,18,321,405,406,320,404,405,315,16,17,426,425,266,377,400,369,322,391,269,417,465,464,386,257,258,466,260,388,456,399,419,284,332,333,417,285,8,346,340,261,413,441,285,327,460,328,355,371,329,392,439,438,382,341,256,429,420,360,364,394,379,277,343,437,443,444,283,275,440,363,431,262,369,297,338,337,273,375,321,450,451,349,446,342,467,293,334,282,458,461,462,276,353,383,308,324,325,276,300,293,372,345,447,382,398,362,352,345,340,274,1,19,456,248,281,436,427,425,381,256,252,269,391,393,200,199,428,266,330,329,287,273,422,250,462,328,258,286,384,265,353,342,387,259,257,424,431,430,342,353,276,273,335,424,292,325,307,366,447,345,271,303,302,423,266,371,294,455,460,279,278,294,271,272,304,432,434,427,272,407,408,394,430,431,395,369,400,334,333,299,351,417,168,352,280,411,325,319,320,295,296,336,319,403,404,330,348,349,293,298,333,323,454,447,15,16,315,358,429,279,14,15,316,285,336,9,329,349,350,374,380,252,318,402,403,6,197,419,318,319,325,367,364,365,435,367,397,344,438,439,272,271,311,195,5,281,273,287,291,396,428,199,311,271,268,283,444,445,373,254,339,263,466,249,282,334,296,449,347,346,264,447,454,336,296,299,338,10,151,278,439,455,292,407,415,358,371,355,340,345,372,390,249,466,346,347,280,442,443,282,19,94,370,441,442,295,248,419,197,263,255,359,440,275,274,300,383,368,351,412,465,263,467,466,301,368,389,380,374,386,395,378,379,412,351,419,436,426,322,373,390,388,2,164,393,370,462,461,164,0,267,302,11,12,374,373,387,268,12,13,293,300,301,446,261,340,385,384,381,330,266,425,426,423,391,429,355,437,391,327,326,440,457,438,341,382,362,459,457,461,434,430,394,414,463,362,396,369,262,354,461,457,316,403,402,315,404,403,314,405,404,313,406,405,421,418,406,366,401,361,306,408,407,291,409,408,287,410,409,432,436,410,434,416,411,264,368,383,309,438,457,352,376,401,274,275,4,421,428,262,294,327,358,433,416,367,289,455,439,462,370,326,2,326,370,305,460,455,254,449,448,255,261,446,253,450,449,252,451,450,256,452,451,341,453,452,413,464,463,441,413,414,258,442,441,257,443,442,259,444,443,260,445,444,467,342,445,459,458,250,289,392,290,290,328,460,376,433,435,250,290,392,411,416,433,341,463,464,453,464,465,357,465,412,343,412,399,360,363,440,437,399,456,420,456,363,401,435,288,372,383,353,339,255,249,448,261,255,133,243,190,133,155,112,33,246,247,33,130,25,398,384,286,362,398,414,362,463,341,263,359,467,263,249,255,466,467,260,75,60,166,238,239,79,162,127,139,72,11,37,121,232,120,73,72,39,114,128,47,233,232,128,103,104,67,152,175,148,173,157,155,119,118,101,74,73,40,107,9,108,49,48,131,32,194,211,184,74,185,191,80,183,185,40,186,119,230,118,210,202,214,84,83,17,77,76,146,161,160,30,190,56,173,182,106,194,138,135,192,129,203,98,54,21,68,5,51,4,145,144,23,90,77,91,207,205,187,83,201,18,181,91,182,180,90,181,16,85,17,205,206,36,176,148,140,165,92,39,245,193,244,27,159,28,30,247,161,174,236,196,103,54,104,55,193,8,111,117,31,221,189,55,240,98,99,142,126,100,219,166,218,112,155,26,198,209,131,169,135,150,114,47,217,224,223,53,220,45,134,32,211,140,109,67,108,146,43,91,231,230,120,113,226,247,105,63,52,241,238,242,124,46,156,95,78,96,70,46,63,116,143,227,116,123,111,1,44,19,3,236,51,207,216,205,26,154,22,165,39,167,199,200,208,101,36,100,43,57,202,242,20,99,56,28,157,124,35,113,29,160,27,211,204,210,124,113,46,106,43,204,96,62,77,227,137,116,73,41,72,36,203,142,235,64,240,48,49,64,42,41,74,214,212,207,183,42,184,210,169,211,140,170,176,104,105,69,193,122,168,50,123,187,89,96,90,66,65,107,179,89,180,119,101,120,68,63,104,234,93,227,16,15,85,209,129,49,15,14,86,107,55,9,120,100,121,153,145,22,178,88,179,197,6,196,89,88,96,135,138,136,138,215,172,218,115,219,41,42,81,5,195,51,57,43,61,208,171,199,41,81,38,224,53,225,24,144,110,105,52,66,118,229,117,227,34,234,66,107,69,10,109,151,219,48,235,183,62,191,142,129,126,116,111,143,7,163,246,118,117,50,223,222,52,94,19,141,222,221,65,196,3,197,45,220,44,156,70,139,188,122,245,139,71,162,145,153,159,149,170,150,122,188,196,206,216,92,163,144,161,164,2,167,242,141,241,0,164,37,11,72,12,144,145,160,12,38,13,70,63,71,31,226,111,157,158,154,36,101,205,203,206,165,126,209,217,98,165,97,237,220,218,237,239,241,210,214,169,140,171,32,241,125,237,179,86,178,180,85,179,181,84,180,182,83,181,194,201,182,177,137,132,184,76,183,185,61,184,186,57,185,216,212,186,192,214,187,139,34,156,218,79,237,147,123,177,45,44,4,208,201,32,98,64,129,192,213,138,235,59,219,141,242,97,97,2,141,240,75,235,229,24,228,31,25,226,230,23,229,231,22,230,232,26,231,233,112,232,244,189,243,189,221,190,222,28,221,223,27,222,224,29,223,225,30,224,113,247,225,99,60,240,213,147,215,60,20,166,192,187,213,243,112,244,244,233,245,245,128,188,188,114,174,134,131,220,174,217,236,236,198,134,215,177,58,156,143,124,25,110,7,31,228,25,264,356,368,0,11,267,451,452,349,267,302,269,350,357,277,350,452,357,299,333,297,396,175,377,381,384,382,280,347,330,269,303,270,151,9,337,344,278,360,424,418,431,270,304,409,272,310,407,322,270,410,449,450,347,432,422,434,18,313,17,291,306,375,259,387,260,424,335,418,434,364,416,391,423,327,301,251,298,275,281,4,254,373,253,375,307,321,280,425,411,200,421,18,335,321,406,321,320,405,314,315,17,423,426,266,396,377,369,270,322,269,413,417,464,385,386,258,248,456,419,298,284,333,168,417,8,448,346,261,417,413,285,326,327,328,277,355,329,309,392,438,381,382,256,279,429,360,365,364,379,355,277,437,282,443,283,281,275,363,395,431,369,299,297,337,335,273,321,348,450,349,359,446,467,283,293,282,250,458,462,300,276,383,292,308,325,283,276,293,264,372,447,346,352,340,354,274,19,363,456,281,426,436,425,380,381,252,267,269,393,421,200,428,371,266,329,432,287,422,290,250,328,385,258,384,446,265,342,386,387,257,422,424,430,445,342,276,422,273,424,306,292,307,352,366,345,268,271,302,358,423,371,327,294,460,331,279,294,303,271,304,436,432,427,304,272,408,395,394,431,378,395,400,296,334,299,6,351,168,376,352,411,307,325,320,285,295,336,320,319,404,329,330,349,334,293,333,366,323,447,316,15,315,331,358,279,317,14,316,8,285,9,277,329,350,253,374,252,319,318,403,351,6,419,324,318,325,397,367,365,288,435,397,278,344,439,310,272,311,248,195,281,375,273,291,175,396,199,312,311,268,276,283,445,390,373,339,295,282,296,448,449,346,356,264,454,337,336,299,337,338,151,294,278,455,308,292,415,429,358,355,265,340,372,388,390,466,352,346,280,295,442,282,354,19,370,285,441,295,195,248,197,457,440,274,301,300,368,417,351,465,251,301,389,385,380,386,394,395,379,399,412,419,410,436,322,387,373,388,326,2,393,354,370,461,393,164,267,268,302,12,386,374,387,312,268,13,298,293,301,265,446,340,380,385,381,280,330,425,322,426,391,420,429,437,393,391,326,344,440,438,458,459,461,364,434,394,428,396,262,274,354,457,317,316,402,316,315,403,315,314,404,314,313,405,313,421,406,323,366,361,292,306,407,306,291,408,291,287,409,287,432,410,427,434,411,372,264,383,459,309,457,366,352,401,1,274,4,418,421,262,331,294,358,435,433,367,392,289,439,328,462,326,94,2,370,289,305,455,339,254,448,359,255,446,254,253,449,253,252,450,252,256,451,256,341,452,414,413,463,286,441,414,286,258,441,258,257,442,257,259,443,259,260,444,260,467,445,309,459,250,305,289,290,305,290,460,401,376,435,309,250,392,376,411,433,453,341,464,357,453,465,343,357,412,437,343,399,344,360,440,420,437,456,360,420,363,361,401,288,265,372,353,390,339,249,339,448,255],VTX68=[127,234,132,58,172,150,149,148,152,377,378,379,397,288,361,454,356,70,63,105,66,107,336,296,334,293,300,168,6,195,4,98,97,2,326,327,33,160,158,133,153,144,362,385,387,263,373,380,57,40,37,0,267,270,287,321,314,17,84,91,78,81,13,311,308,402,14,178],VTX33=[33,133,362,263,1,62,308,159,145,386,374,6,102,331,2,13,14,70,105,107,336,334,300,54,10,284,50,280,234,454,58,288,152],VTX7=[33,133,362,263,1,78,308],UV68=VTX68.map((e=>UV468[e])),UV33=VTX33.map((e=>UV468[e])),UV7=VTX7.map((e=>UV468[e])),getBoxSize=e=>[Math.abs(e.endPoint[0]-e.startPoint[0]),Math.abs(e.endPoint[1]-e.startPoint[1])],getBoxCenter=e=>[e.startPoint[0]+(e.endPoint[0]-e.startPoint[0])/2,e.startPoint[1]+(e.endPoint[1]-e.startPoint[1])/2],getClampedBox=(e,t)=>e?[Math.trunc(Math.max(0,e.startPoint[0])),Math.trunc(Math.max(0,e.startPoint[1])),Math.trunc(Math.min(t.shape[2]||0,e.endPoint[0])-Math.max(0,e.startPoint[0])),Math.trunc(Math.min(t.shape[1]||0,e.endPoint[1])-Math.max(0,e.startPoint[1]))]:[0,0,0,0],getRawBox=(e,t)=>e?[e.startPoint[0]/(t.shape[2]||0),e.startPoint[1]/(t.shape[1]||0),(e.endPoint[0]-e.startPoint[0])/(t.shape[2]||0),(e.endPoint[1]-e.startPoint[1])/(t.shape[1]||0)]:[0,0,0,0],scaleBoxCoordinates=(e,t)=>({startPoint:[e.startPoint[0]*t[0],e.startPoint[1]*t[1]],endPoint:[e.endPoint[0]*t[0],e.endPoint[1]*t[1]],landmarks:e.landmarks,confidence:e.confidence}),cutBoxFromImageAndResize=(e,t,n)=>{const a=t.shape[1],r=t.shape[2],s=image.cropAndResize(t,[[e.startPoint[1]/a,e.startPoint[0]/r,e.endPoint[1]/a,e.endPoint[0]/r]],[0],n),o=div(s,constants.tf255);return dispose(s),o},enlargeBox=(e,t)=>{const n=getBoxCenter(e),a=getBoxSize(e),r=[t*a[0]/2,t*a[1]/2];return{startPoint:[n[0]-r[0],n[1]-r[1]],endPoint:[n[0]+r[0],n[1]+r[1]],landmarks:e.landmarks,confidence:e.confidence}},squarifyBox=e=>{const t=getBoxCenter(e),n=getBoxSize(e),a=Math.max(...n)/2;return{startPoint:[Math.round(t[0]-a),Math.round(t[1]-a)],endPoint:[Math.round(t[0]+a),Math.round(t[1]+a)],landmarks:e.landmarks,confidence:e.confidence}},calculateLandmarksBoundingBox=e=>{const t=e.map((e=>e[0])),n=e.map((e=>e[1]));return{startPoint:[Math.min(...t),Math.min(...n)],endPoint:[Math.max(...t),Math.max(...n)],landmarks:e}},fixedRotationMatrix=[[1,0,0],[0,1,0],[0,0,1]],normalizeRadians=e=>e-2*Math.PI*Math.floor((e+Math.PI)/(2*Math.PI)),computeRotation=(e,t)=>normalizeRadians(Math.PI/2-Math.atan2(-(t[1]-e[1]),t[0]-e[0])),buildTranslationMatrix=(e,t)=>[[1,0,e],[0,1,t],[0,0,1]],dot4=(e,t)=>{let n=0;for(let a=0;a<e.length;a++)n+=e[a]*t[a];return n},getColumnFrom2DArr=(e,t)=>{const n=[];for(let a=0;a<e.length;a++)n.push(e[a][t]);return n},multiplyTransformMatrices=(e,t)=>{const n=[],a=e.length;for(let r=0;r<a;r++){n.push([]);for(let s=0;s<a;s++)n[r].push(dot4(e[r],getColumnFrom2DArr(t,s)))}return n},buildRotationMatrix=(e,t)=>{const n=Math.cos(e),a=Math.sin(e),r=[[n,-a,0],[a,n,0],[0,0,1]],s=buildTranslationMatrix(t[0],t[1]),o=multiplyTransformMatrices(s,r),i=buildTranslationMatrix(-t[0],-t[1]);return multiplyTransformMatrices(o,i)},invertTransformMatrix=e=>{const t=[[e[0][0],e[1][0]],[e[0][1],e[1][1]]],n=[e[0][2],e[1][2]],a=[-dot4(t[0],n),-dot4(t[1],n)];return[t[0].concat(a[0]),t[1].concat(a[1]),[0,0,1]]},rotatePoint=(e,t)=>[dot4(e,t[0]),dot4(e,t[1])];function generateAnchors(e){const t={strides:[e/16,e/8],anchors:[2,6]},n=[];for(let a=0;a<t.strides.length;a++){const r=t.strides[a],s=Math.floor((e+r-1)/r),o=Math.floor((e+r-1)/r),i=t.anchors[a];for(let e=0;e<s;e++){const t=r*(e+.5);for(let e=0;e<o;e++){const a=r*(e+.5);for(let e=0;e<i;e++)n.push([a,t])}}}return n}function transformRawCoords(e,t,n,a,r){const s=getBoxSize(t),o=e.map((e=>[s[0]/r*(e[0]-r/2),s[1]/r*(e[1]-r/2),e[2]||0])),i=n&&0!==n&&Math.abs(n)>.2,l=i?buildRotationMatrix(n,[0,0]):fixedRotationMatrix,u=i?o.map((e=>[...rotatePoint(e,l),e[2]])):o,c=i?invertTransformMatrix(a):fixedRotationMatrix,d=[...getBoxCenter({startPoint:t.startPoint,endPoint:t.endPoint}),1];return u.map((e=>[Math.round(e[0]+dot4(d,c[0])),Math.round(e[1]+dot4(d,c[1])),Math.round(e[2]||0)]))}function correctFaceRotation(e,t,n,a){const r=t.landmarks.length>=meshLandmarks.count?meshLandmarks.symmetryLine:blazeFaceLandmarks.symmetryLine;let s,o=0,i=fixedRotationMatrix;if(e&&env2.kernels.includes("rotatewithoffset")){o=computeRotation(t.landmarks[r[0]],t.landmarks[r[1]]);if(o&&0!==o&&Math.abs(o)>.2){const e=getBoxCenter({startPoint:t.startPoint,endPoint:t.endPoint}),r=[e[0]/n.shape[2],e[1]/n.shape[1]],l=image.rotateWithOffset(n,o,0,r);i=buildRotationMatrix(-o,e),s=cutBoxFromImageAndResize(t,l,[a,a]),dispose(l)}else s=cutBoxFromImageAndResize(t,n,[a,a])}else s=cutBoxFromImageAndResize(t,n,[a,a]);return[o,i,s]}var model6,keypointsCount=6,anchors=null,inputSize=0,inputSizeT=null,size=()=>inputSize;async function load5(e){var t,n;return env2.initial&&(model6=null),model6?e.debug&&log("cached model:",model6.modelUrl):(model6=await loadGraphModel(join(e.modelBasePath,(null==(t=e.face.detector)?void 0:t.modelPath)||"")))&&model6.modelUrl?e.debug&&log("load model:",model6.modelUrl):log("load model failed:",null==(n=e.face.detector)?void 0:n.modelPath),inputSize=model6.inputs[0].shape?model6.inputs[0].shape[2]:0,inputSizeT=scalar(inputSize,"int32"),anchors=tensor2d(generateAnchors(inputSize)),model6}function decodeBounds(e){const t={};t.boxStarts=slice(e,[0,1],[-1,2]),t.centers=add2(t.boxStarts,anchors),t.boxSizes=slice(e,[0,3],[-1,2]),t.boxSizesNormalized=div(t.boxSizes,inputSizeT),t.centersNormalized=div(t.centers,inputSizeT),t.halfBoxSize=div(t.boxSizesNormalized,constants.tf2),t.starts=sub(t.centersNormalized,t.halfBoxSize),t.ends=add2(t.centersNormalized,t.halfBoxSize),t.startNormalized=mul(t.starts,inputSizeT),t.endNormalized=mul(t.ends,inputSizeT);const n=concat2d([t.startNormalized,t.endNormalized],1);return Object.keys(t).forEach((e=>dispose(t[e]))),n}async function getBoxes(e,t){var n,a,r,s;if(!e||e.isDisposedInternal||4!==e.shape.length||e.shape[1]<1||e.shape[2]<1)return{boxes:[]};const o={};o.resized=image.resizeBilinear(e,[inputSize,inputSize]),o.div=div(o.resized,constants.tf127),o.normalized=sub(o.div,constants.tf05);const i=null==model6?void 0:model6.execute(o.normalized);if(Array.isArray(i)){const e=i.sort(((e,t)=>e.size-t.size));o.concat384=concat([e[0],e[2]],2),o.concat512=concat([e[1],e[3]],2),o.concat=concat([o.concat512,o.concat384],1),o.batch=squeeze(o.concat,0)}else o.batch=squeeze(i);dispose(i),o.boxes=decodeBounds(o.batch),o.logits=slice(o.batch,[0,0],[-1,1]),o.sigmoid=sigmoid(o.logits),o.scores=squeeze(o.sigmoid),o.nms=await image.nonMaxSuppressionAsync(o.boxes,o.scores,(null==(n=t.face.detector)?void 0:n.maxDetected)||0,(null==(a=t.face.detector)?void 0:a.iouThreshold)||0,(null==(r=t.face.detector)?void 0:r.minConfidence)||0);const l=await o.nms.array(),u=[],c=await o.scores.data();for(let e=0;e<l.length;e++){const n=c[l[e]];if(n>((null==(s=t.face.detector)?void 0:s.minConfidence)||0)){const t={};t.bbox=slice(o.boxes,[l[e],0],[1,-1]),t.slice=slice(o.batch,[l[e],keypointsCount-1],[1,-1]),t.squeeze=squeeze(t.slice),t.landmarks=reshape(t.squeeze,[keypointsCount,-1]);const a=await t.bbox.data();u.push({box:{startPoint:[a[0],a[1]],endPoint:[a[2],a[3]]},landmarks:await t.landmarks.array(),confidence:n}),Object.keys(t).forEach((e=>dispose(t[e])))}}return Object.keys(o).forEach((e=>dispose(o[e]))),{boxes:u,scaleFactor:[e.shape[2]/inputSize,e.shape[1]/inputSize]}}var blazeposecoords_exports={};__export(blazeposecoords_exports,{connected:()=>connected,kpt:()=>kpt});var outputNodes,kpt=["nose","leftEyeInside","leftEye","leftEyeOutside","rightEyeInside","rightEye","rightEyeOutside","leftEar","rightEar","leftMouth","rightMouth","leftShoulder","rightShoulder","leftElbow","rightElbow","leftWrist","rightWrist","leftPalm","rightPalm","leftIndex","rightIndex","leftPinky","rightPinky","leftHip","rightHip","leftKnee","rightKnee","leftAnkle","rightAnkle","leftHeel","rightHeel","leftFoot","rightFoot","bodyCenter","bodyTop","leftThumb","leftHand","rightThumb","rightHand"],connected={leftLeg:["leftHip","leftKnee","leftAnkle","leftHeel","leftFoot"],rightLeg:["rightHip","rightKnee","rightAnkle","rightHeel","rightFoot"],torso:["leftShoulder","rightShoulder","rightHip","leftHip","leftShoulder"],leftArm:["leftShoulder","leftElbow","leftWrist","leftPalm"],rightArm:["rightShoulder","rightElbow","rightWrist","rightPalm"],leftHand:[],rightHand:[],head:[]},env3={initial:!0},models=[null,null],inputSize2=[[0,0],[0,0]],skipped5=Number.MAX_SAFE_INTEGER,cache=null,padding=[[0,0],[0,0],[0,0],[0,0]],lastTime5=0;async function loadDetect(e){var t,n,a;if(env3.initial&&(models[0]=null),!models[0]&&(null==(t=e.body.detector)?void 0:t.modelPath)){models[0]=await loadGraphModel(join(e.modelBasePath,(null==(n=e.body.detector)?void 0:n.modelPath)||""));const t=Object.values(models[0].modelSignature.inputs);inputSize2[0][0]=Array.isArray(t)?parseInt(t[0].tensorShape.dim[1].size):0,inputSize2[0][1]=Array.isArray(t)?parseInt(t[0].tensorShape.dim[2].size):0,models[0]&&models[0].modelUrl?e.debug&&log("load model:",models[0].modelUrl):log("load model failed:",null==(a=e.body.detector)?void 0:a.modelPath)}else e.debug&&models[0]&&log("cached model:",models[0].modelUrl);return models[0]}async function loadPose(e){var t;if(env3.initial&&(models[1]=null),models[1])e.debug&&log("cached model:",models[1].modelUrl);else{models[1]=await loadGraphModel(join(e.modelBasePath,e.body.modelPath||""));const n=Object.values(models[1].modelSignature.inputs);inputSize2[1][0]=Array.isArray(n)?parseInt(n[0].tensorShape.dim[1].size):0,inputSize2[1][1]=Array.isArray(n)?parseInt(n[0].tensorShape.dim[2].size):0,outputNodes=(null==(t=e.body.modelPath)?void 0:t.includes("lite"))?["ld_3d","output_segmentation","output_heatmap","world_3d","output_poseflag"]:["Identity","Identity_2","Identity_3","Identity_4","Identity_1"],models[1]&&models[1].modelUrl?e.debug&&log("load model:",models[1].modelUrl):log("load model failed:",e.body.modelPath)}return models[1]}function calculateBoxes(e,t){const n=e.map((e=>e.position[0])),a=e.map((e=>e.position[1])),r=[Math.min(...n),Math.min(...a),Math.max(...n)-Math.min(...n),Math.max(...a)-Math.min(...a)];return{keypointsBox:r,keypointsBoxRaw:[r[0]/t[0],r[1]/t[1],r[2]/t[0],r[3]/t[1]]}}async function prepareImage(e){const t={};if(!e.shape||!e.shape[1]||!e.shape[2])return e;padding=[[0,0],[e.shape[2]>e.shape[1]?Math.trunc((e.shape[2]-e.shape[1])/2):0,e.shape[2]>e.shape[1]?Math.trunc((e.shape[2]-e.shape[1])/2):0],[e.shape[1]>e.shape[2]?Math.trunc((e.shape[1]-e.shape[2])/2):0,e.shape[1]>e.shape[2]?Math.trunc((e.shape[1]-e.shape[2])/2):0],[0,0]],t.pad=pad(e,padding),t.resize=image.resizeBilinear(t.pad,[inputSize2[1][0],inputSize2[1][1]]);const n=div(t.resize,constants.tf255);return Object.keys(t).forEach((e=>dispose(t[e]))),n}function rescaleKeypoints(e,t){for(const n of e)n.position=[n.position[0]*(t[0]+padding[2][0]+padding[2][1])/t[0]-padding[2][0],n.position[1]*(t[1]+padding[1][0]+padding[1][1])/t[1]-padding[1][0],n.position[2]],n.positionRaw=[n.position[0]/t[0],n.position[1]/t[1],n.position[2]];return e}var sigmoid6=e=>1-1/(1+Math.exp(e));async function detectParts(e,t,n){var a;const r={};r.input=await prepareImage(e),[r.ld,r.segmentation,r.heatmap,r.world,r.poseflag]=null==(a=models[1])?void 0:a.execute(r.input,outputNodes);const s=(await r.poseflag.data())[0],o=Math.max(0,(s-.8)/(1-.8)),i=await r.ld.data(),l=[];for(let e=0;e<i.length/5;e++){const t=sigmoid6(i[5*e+3]),a=sigmoid6(i[5*e+4]),r=Math.trunc(100*t*a*o)/100,s=[i[5*e+0]/inputSize2[1][0],i[5*e+1]/inputSize2[1][1],i[5*e+2]+0],u=[Math.trunc(n[0]*s[0]),Math.trunc(n[1]*s[1]),s[2]];l.push({part:kpt[e],positionRaw:s,position:u,score:r})}if(o<(t.body.minConfidence||0))return null;const u=rescaleKeypoints(l,n),c=calculateBoxes(u,[n[0],n[1]]);Object.keys(r).forEach((e=>dispose(r[e])));const d={};for(const[e,n]of Object.entries(connected)){const a=[];for(let e=0;e<n.length-1;e++){const r=u.find((t=>t.part===n[e])),s=u.find((t=>t.part===n[e+1]));r&&s&&r.score>(t.body.minConfidence||0)&&s.score>(t.body.minConfidence||0)&&a.push([r.position,s.position])}d[e]=a}return{id:0,score:Math.trunc(100*o)/100,box:c.keypointsBox,boxRaw:c.keypointsBoxRaw,keypoints:u,annotations:d}}async function predict5(e,t){const n=[e.shape[2]||0,e.shape[1]||0],a=(t.body.skipTime||0)>now()-lastTime5,r=skipped5<(t.body.skipFrames||0);return t.skipAllowed&&a&&r&&null!==cache?skipped5++:(cache=await detectParts(e,t,n),lastTime5=now(),skipped5=0),cache?[cache]:[]}var model7,labels=[{class:1,label:"person"},{class:2,label:"bicycle"},{class:3,label:"car"},{class:4,label:"motorcycle"},{class:5,label:"airplane"},{class:6,label:"bus"},{class:7,label:"train"},{class:8,label:"truck"},{class:9,label:"boat"},{class:10,label:"traffic light"},{class:11,label:"fire hydrant"},{class:12,label:"stop sign"},{class:13,label:"parking meter"},{class:14,label:"bench"},{class:15,label:"bird"},{class:16,label:"cat"},{class:17,label:"dog"},{class:18,label:"horse"},{class:19,label:"sheep"},{class:20,label:"cow"},{class:21,label:"elephant"},{class:22,label:"bear"},{class:23,label:"zebra"},{class:24,label:"giraffe"},{class:25,label:"backpack"},{class:26,label:"umbrella"},{class:27,label:"handbag"},{class:28,label:"tie"},{class:29,label:"suitcase"},{class:30,label:"frisbee"},{class:31,label:"skis"},{class:32,label:"snowboard"},{class:33,label:"sports ball"},{class:34,label:"kite"},{class:35,label:"baseball bat"},{class:36,label:"baseball glove"},{class:37,label:"skateboard"},{class:38,label:"surfboard"},{class:39,label:"tennis racket"},{class:40,label:"bottle"},{class:41,label:"wine glass"},{class:42,label:"cup"},{class:43,label:"fork"},{class:44,label:"knife"},{class:45,label:"spoon"},{class:46,label:"bowl"},{class:47,label:"banana"},{class:48,label:"apple"},{class:49,label:"sandwich"},{class:50,label:"orange"},{class:51,label:"broccoli"},{class:52,label:"carrot"},{class:53,label:"hot dog"},{class:54,label:"pizza"},{class:55,label:"donut"},{class:56,label:"cake"},{class:57,label:"chair"},{class:58,label:"couch"},{class:59,label:"potted plant"},{class:60,label:"bed"},{class:61,label:"dining table"},{class:62,label:"toilet"},{class:63,label:"tv"},{class:64,label:"laptop"},{class:65,label:"mouse"},{class:66,label:"remote"},{class:67,label:"keyboard"},{class:68,label:"cell phone"},{class:69,label:"microwave"},{class:70,label:"oven"},{class:71,label:"toaster"},{class:72,label:"sink"},{class:73,label:"refrigerator"},{class:74,label:"book"},{class:75,label:"clock"},{class:76,label:"vase"},{class:77,label:"scissors"},{class:78,label:"teddy bear"},{class:79,label:"hair drier"},{class:80,label:"toothbrush"}],inputSize3=0,last5=[],lastTime6=0,skipped6=Number.MAX_SAFE_INTEGER;async function load6(e){if(env2.initial&&(model7=null),model7)e.debug&&log("cached model:",model7.modelUrl);else{model7=await loadGraphModel(join(e.modelBasePath,e.object.modelPath||""));const t=Object.values(model7.modelSignature.inputs);inputSize3=Array.isArray(t)?parseInt(t[0].tensorShape.dim[2].size):0,model7&&model7.modelUrl?e.debug&&log("load model:",model7.modelUrl):log("load model failed:",e.object.modelPath)}return model7}async function process3(e,t,n){if(!e)return[];const a={},r=[],s=await e.array();a.squeeze=squeeze(e);const o=split(a.squeeze,6,1);a.stack=stack([o[1],o[0],o[3],o[2]],1),a.boxes=squeeze(a.stack),a.scores=squeeze(o[4]),a.classes=squeeze(o[5]),dispose([e,...o]),a.nms=await image.nonMaxSuppressionAsync(a.boxes,a.scores,n.object.maxDetected,n.object.iouThreshold,n.object.minConfidence);const i=await a.nms.data();let l=0;for(const e of Array.from(i)){const n=Math.trunc(100*s[0][e][4])/100,a=s[0][e][5],o=labels[a].label,[i,u]=[s[0][e][0]/inputSize3,s[0][e][1]/inputSize3],c=[i,u,s[0][e][2]/inputSize3-i,s[0][e][3]/inputSize3-u],d=[Math.trunc(c[0]*t[0]),Math.trunc(c[1]*t[1]),Math.trunc(c[2]*t[0]),Math.trunc(c[3]*t[1])];r.push({id:l++,score:n,class:a,label:o,box:d,boxRaw:c})}return Object.keys(a).forEach((e=>dispose(a[e]))),r}async function predict6(e,t){const n=(t.object.skipTime||0)>now()-lastTime6,a=skipped6<(t.object.skipFrames||0);return t.skipAllowed&&n&&a&&last5.length>0?(skipped6++,last5):(skipped6=0,new Promise((async n=>{const a=[e.shape[2],e.shape[1]],r=image.resizeBilinear(e,[inputSize3,inputSize3]),s=t.object.enabled?null==model7?void 0:model7.execute(r,["tower_0/detections"]):null;lastTime6=now(),dispose(r);const o=await process3(s,a,t);last5=o,n(o)})))}var efficientposecoords_exports={};__export(efficientposecoords_exports,{connected:()=>connected2,kpt:()=>kpt2});var model8,kpt2=["head","neck","rightShoulder","rightElbow","rightWrist","chest","leftShoulder","leftElbow","leftWrist","bodyCenter","rightHip","rightKnee","rightAnkle","leftHip","leftKnee","leftAnkle"],connected2={leftLeg:["leftHip","leftKnee","leftAnkle"],rightLeg:["rightHip","rightKnee","rightAnkle"],torso:["leftShoulder","rightShoulder","rightHip","leftHip","leftShoulder"],leftArm:["leftShoulder","leftElbow","leftWrist"],rightArm:["rightShoulder","rightElbow","rightWrist"],head:[]},lastTime7=0,cache2={id:0,keypoints:[],box:[0,0,0,0],boxRaw:[0,0,0,0],score:0,annotations:{}},skipped7=Number.MAX_SAFE_INTEGER;async function load7(e){return env2.initial&&(model8=null),model8?e.debug&&log("cached model:",model8.modelUrl):(model8=await loadGraphModel(join(e.modelBasePath,e.body.modelPath||"")))&&model8.modelUrl?e.debug&&log("load model:",model8.modelUrl):log("load model failed:",e.body.modelPath),model8}async function max2d(e,t){const[n,a]=e.shape,r=reshape(e,[a*n]),s=max(r,0),o=(await s.data())[0];if(dispose([r,s]),o>t){const e=argMax(r,0),t=mod(e,n),a=(await t.data())[0],s=div(e,scalar(n,"int32")),i=(await s.data())[0];return dispose([t,s]),[a,i,o]}return[0,0,o]}async function predict7(e,t){const n=(t.body.skipTime||0)>now()-lastTime7,a=skipped7<(t.body.skipFrames||0);return t.skipAllowed&&n&&a&&Object.keys(cache2.keypoints).length>0?(skipped7++,[cache2]):(skipped7=0,new Promise((async n=>{var a;const r=tidy((()=>{if(!(null==model8?void 0:model8.inputs[0].shape))return null;const t=image.resizeBilinear(e,[model8.inputs[0].shape[2],model8.inputs[0].shape[1]],!1),n=mul(t,constants.tf2);return sub(n,constants.tf1)}));let s;if(t.body.enabled&&(s=null==model8?void 0:model8.execute(r)),lastTime7=now(),dispose(r),s){cache2.keypoints.length=0;const n=s.squeeze();dispose(s);const r=n.unstack(2);dispose(n);for(let n=0;n<r.length;n++){const[s,o,i]=await max2d(r[n],t.body.minConfidence);i>((null==(a=t.body)?void 0:a.minConfidence)||0)&&cache2.keypoints.push({score:Math.round(100*i)/100,part:kpt2[n],positionRaw:[s/model8.inputs[0].shape[2],o/model8.inputs[0].shape[1]],position:[Math.round(e.shape[2]*s/model8.inputs[0].shape[2]),Math.round(e.shape[1]*o/model8.inputs[0].shape[1])]})}r.forEach((e=>dispose(e)))}cache2.score=cache2.keypoints.reduce(((e,t)=>t.score>e?t.score:e),0);const o=cache2.keypoints.map((e=>e.position[0])),i=cache2.keypoints.map((e=>e.position[1]));cache2.box=[Math.min(...o),Math.min(...i),Math.max(...o)-Math.min(...o),Math.max(...i)-Math.min(...i)];const l=cache2.keypoints.map((e=>e.positionRaw[0])),u=cache2.keypoints.map((e=>e.positionRaw[1]));cache2.boxRaw=[Math.min(...l),Math.min(...u),Math.max(...l)-Math.min(...l),Math.max(...u)-Math.min(...u)];for(const[e,n]of Object.entries(connected2)){const a=[];for(let e=0;e<n.length-1;e++){const r=cache2.keypoints.find((t=>t.part===n[e])),s=cache2.keypoints.find((t=>t.part===n[e+1]));r&&s&&r.score>(t.body.minConfidence||0)&&s.score>(t.body.minConfidence||0)&&a.push([r.position,s.position])}cache2.annotations[e]=a}n([cache2])})))}var model9,model10,annotations=["angry","disgust","fear","happy","sad","surprise","neutral"],last6=[],lastCount5=0,lastTime8=0,skipped8=Number.MAX_SAFE_INTEGER;async function load8(e){var t,n;return env2.initial&&(model9=null),model9?e.debug&&log("cached model:",model9.modelUrl):(model9=await loadGraphModel(join(e.modelBasePath,(null==(t=e.face.emotion)?void 0:t.modelPath)||"")))&&model9.modelUrl?e.debug&&log("load model:",model9.modelUrl):log("load model failed:",null==(n=e.face.emotion)?void 0:n.modelPath),model9}async function predict8(e,t,n,a){var r,s;if(!model9)return[];const o=skipped8<((null==(r=t.face.emotion)?void 0:r.skipFrames)||0),i=((null==(s=t.face.emotion)?void 0:s.skipTime)||0)>now()-lastTime8;return t.skipAllowed&&i&&o&&lastCount5===a&&last6[n]&&last6[n].length>0?(skipped8++,last6[n]):(skipped8=0,new Promise((async r=>{var s,o;const i=[];if(null==(s=t.face.emotion)?void 0:s.enabled){const n={},a=(null==model9?void 0:model9.inputs[0].shape)?model9.inputs[0].shape[2]:0;n.resize=image.resizeBilinear(e,[a,a],!1),n.channels=mul(n.resize,constants.rgb),n.grayscale=sum2(n.channels,3,!0),n.grayscaleSub=sub(n.grayscale,constants.tf05),n.grayscaleMul=mul(n.grayscaleSub,constants.tf2),n.emotion=null==model9?void 0:model9.execute(n.grayscaleMul),lastTime8=now();const r=await n.emotion.data();for(let e=0;e<r.length;e++)r[e]>((null==(o=t.face.emotion)?void 0:o.minConfidence)||0)&&i.push({score:Math.min(.99,Math.trunc(100*r[e])/100),emotion:annotations[e]});i.sort(((e,t)=>t.score-e.score)),Object.keys(n).forEach((e=>dispose(n[e])))}last6[n]=i,lastCount5=a,r(i)})))}var model11,last7=[],lastCount6=0,lastTime9=0,skipped9=Number.MAX_SAFE_INTEGER;async function load9(e){const t=join(e.modelBasePath,e.face.mobilefacenet.modelPath);return env2.initial&&(model10=null),model10?e.debug&&log("cached model:",t):(model10=await loadGraphModel(t))?e.debug&&log("load model:",t):log("load model failed:",e.face.mobilefacenet.modelPath),model10}async function predict9(e,t,n,a){var r,s;if(!model10)return[];const o=skipped9<((null==(r=t.face.embedding)?void 0:r.skipFrames)||0),i=((null==(s=t.face.embedding)?void 0:s.skipTime)||0)>now()-lastTime9;return t.skipAllowed&&i&&o&&lastCount6===a&&last7[n]?(skipped9++,last7[n]):new Promise((async r=>{var s;let o=[];if((null==(s=t.face.embedding)?void 0:s.enabled)&&(null==model10?void 0:model10.inputs[0].shape)){const t={};t.crop=image.resizeBilinear(e,[model10.inputs[0].shape[2],model10.inputs[0].shape[1]],!1),t.data=null==model10?void 0:model10.execute(t.crop);const n=await t.data.data();o=Array.from(n)}last7[n]=o,lastCount6=a,lastTime9=now(),r(o)}))}var inputSize4=0,irisEnlarge=2.3,leftOutline=meshAnnotations.leftEyeLower0,rightOutline=meshAnnotations.rightEyeLower0,eyeLandmarks={leftBounds:[leftOutline[0],leftOutline[leftOutline.length-1]],rightBounds:[rightOutline[0],rightOutline[rightOutline.length-1]]},irisLandmarks={upperCenter:3,lowerCenter:4,index:71,numCoordinates:76};async function load10(e){var t,n;return env2.initial&&(model11=null),model11?e.debug&&log("cached model:",model11.modelUrl):(model11=await loadGraphModel(join(e.modelBasePath,(null==(t=e.face.iris)?void 0:t.modelPath)||"")))&&model11.modelUrl?e.debug&&log("load model:",model11.modelUrl):log("load model failed:",null==(n=e.face.iris)?void 0:n.modelPath),-1===(inputSize4=model11.inputs[0].shape?model11.inputs[0].shape[2]:0)&&(inputSize4=64),model11}function replaceRawCoordinates(e,t,n,a){for(let r=0;r<MESH_TO_IRIS_INDICES_MAP.length;r++){const{key:s,indices:o}=MESH_TO_IRIS_INDICES_MAP[r],i=meshAnnotations[`${n}${s}`];if(!a||a.includes(s))for(let n=0;n<o.length;n++){const a=o[n];e[i[n]]=[t[a][0],t[a][1],(t[a][2]+e[i[n]][2])/2]}}}var getLeftToRightEyeDepthDifference=e=>e[eyeLandmarks.leftBounds[0]][2]-e[eyeLandmarks.rightBounds[0]][2],getEyeBox=(e,t,n,a,r,s=!1)=>{const o=squarifyBox(enlargeBox(calculateLandmarksBoundingBox([e[n],e[a]]),irisEnlarge)),i=getBoxSize(o);let l=image.cropAndResize(t,[[o.startPoint[1]/r,o.startPoint[0]/r,o.endPoint[1]/r,o.endPoint[0]/r]],[0],[inputSize4,inputSize4]);if(s&&env2.kernels.includes("flipleftright")){const e=image.flipLeftRight(l);dispose(l),l=e}return{box:o,boxSize:i,crop:l}},getEyeCoords=(e,t,n,a=!1)=>{const r=[];for(let s=0;s<irisLandmarks.numCoordinates;s++){const o=e[3*s],i=e[3*s+1],l=e[3*s+2];r.push([(a?1-o/inputSize4:o/inputSize4)*n[0]+t.startPoint[0],i/inputSize4*n[1]+t.startPoint[1],l])}return{rawCoords:r,iris:r.slice(irisLandmarks.index)}},getAdjustedIrisCoords=(e,t,n)=>{const a=e[meshAnnotations[`${n}EyeUpper0`][irisLandmarks.upperCenter]][2],r=e[meshAnnotations[`${n}EyeLower0`][irisLandmarks.lowerCenter]][2],s=(a+r)/2;return t.map(((e,t)=>{let n=s;return 2===t?n=a:4===t&&(n=r),[e[0],e[1],n]}))};async function augmentIris(e,t,n,a){if(!model11)return n.debug&&log("face mesh iris detection requested, but model is not loaded"),e;const{box:r,boxSize:s,crop:o}=getEyeBox(e,t,eyeLandmarks.leftBounds[0],eyeLandmarks.leftBounds[1],a,!0),{box:i,boxSize:l,crop:u}=getEyeBox(e,t,eyeLandmarks.rightBounds[0],eyeLandmarks.rightBounds[1],a,!0),c=concat([o,u]);dispose(o),dispose(u);const d=model11.execute(c);dispose(c);const p=await d.data();dispose(d);const h=p.slice(0,3*irisLandmarks.numCoordinates),{rawCoords:m,iris:f}=getEyeCoords(h,r,s,!0),g=p.slice(3*irisLandmarks.numCoordinates),{rawCoords:x,iris:y}=getEyeCoords(g,i,l),A=getLeftToRightEyeDepthDifference(e);Math.abs(A)<30?(replaceRawCoordinates(e,m,"left",null),replaceRawCoordinates(e,x,"right",null)):A<1?replaceRawCoordinates(e,m,"left",["EyeUpper0","EyeLower0"]):replaceRawCoordinates(e,x,"right",["EyeUpper0","EyeLower0"]);const b=getAdjustedIrisCoords(e,f,"left"),v=getAdjustedIrisCoords(e,y,"right");return e.concat(b).concat(v)}var boxCache=[],model12=null,inputSize5=0,skipped10=Number.MAX_SAFE_INTEGER,lastTime10=0;async function predict10(e,t){var n,a,r,s,o,i,l,u,c,d,p;const h=((null==(n=t.face.detector)?void 0:n.skipTime)||0)>now()-lastTime10,m=skipped10<((null==(a=t.face.detector)?void 0:a.skipFrames)||0);if(t.skipAllowed&&h&&m&&0!==boxCache.length)skipped10++;else{const n=await getBoxes(e,t);lastTime10=now(),boxCache=[];for(const e of n.boxes){const a={startPoint:e.box.startPoint,endPoint:e.box.endPoint,landmarks:e.landmarks,confidence:e.confidence},s=scaleBoxCoordinates(a,n.scaleFactor),o=enlargeBox(s,Math.sqrt((null==(r=t.face.detector)?void 0:r.cropFactor)||1.6)),i=squarifyBox(o);boxCache.push(i)}skipped10=0}const f=[],g=[];let x=0;for(let n=0;n<boxCache.length;n++){let a,r=boxCache[n],h=0;const m={id:x++,mesh:[],meshRaw:[],box:[0,0,0,0],boxRaw:[0,0,0,0],score:0,boxScore:0,faceScore:0,annotations:{}};if([h,a,m.tensor]=correctFaceRotation(null==(s=t.face.detector)?void 0:s.rotation,r,e,(null==(o=t.face.mesh)?void 0:o.enabled)?inputSize5:size()),null==(i=null==t?void 0:t.filter)?void 0:i.equalization){const e=await histogramEqualization(m.tensor);dispose(m.tensor),m.tensor=e}if(m.boxScore=Math.round(100*r.confidence)/100,null==(l=t.face.mesh)?void 0:l.enabled)if(model12){const[n,s,o]=model12.execute(m.tensor),i=await s.data();m.faceScore=Math.round(100*i[0])/100;const l=reshape(o,[-1,3]);let f=await l.array();if(dispose([o,l,s,n]),m.faceScore<((null==(u=t.face.detector)?void 0:u.minConfidence)||1))r.confidence=m.faceScore;else{(null==(c=t.face.iris)?void 0:c.enabled)&&(f=await augmentIris(f,m.tensor,t,inputSize5)),m.mesh=transformRawCoords(f,r,h,a,inputSize5),m.meshRaw=m.mesh.map((t=>[t[0]/(e.shape[2]||0),t[1]/(e.shape[1]||0),(t[2]||0)/inputSize5]));for(const e of Object.keys(meshAnnotations))m.annotations[e]=meshAnnotations[e].map((e=>m.mesh[e]));r=squarifyBox({...enlargeBox(calculateLandmarksBoundingBox(m.mesh),(null==(d=t.face.detector)?void 0:d.cropFactor)||1.6),confidence:r.confidence}),m.box=getClampedBox(r,e),m.boxRaw=getRawBox(r,e),m.score=m.faceScore,g.push(r),dispose(m.tensor),[h,a,m.tensor]=correctFaceRotation(null==(p=t.face.detector)?void 0:p.rotation,r,e,inputSize5)}}else t.debug&&log("face mesh detection requested, but model is not loaded");else{m.box=getClampedBox(r,e),m.boxRaw=getRawBox(r,e),m.score=m.boxScore,m.mesh=r.landmarks.map((e=>[(r.startPoint[0]+r.endPoint[0])/2+(r.endPoint[0]+r.startPoint[0])*e[0]/size(),(r.startPoint[1]+r.endPoint[1])/2+(r.endPoint[1]+r.startPoint[1])*e[1]/size()])),m.meshRaw=m.mesh.map((t=>[t[0]/(e.shape[2]||0),t[1]/(e.shape[1]||0),(t[2]||0)/inputSize5]));for(const e of Object.keys(blazeFaceLandmarks))m.annotations[e]=[m.mesh[blazeFaceLandmarks[e]]]}f.push(m)}return boxCache=[...g],f}async function load11(e){var t,n;return env2.initial&&(model12=null),model12?e.debug&&log("cached model:",model12.modelUrl):(model12=await loadGraphModel(join(e.modelBasePath,(null==(t=e.face.mesh)?void 0:t.modelPath)||"")))&&model12.modelUrl?e.debug&&log("load model:",model12.modelUrl):log("load model failed:",null==(n=e.face.mesh)?void 0:n.modelPath),inputSize5=model12.inputs[0].shape?model12.inputs[0].shape[2]:0,model12}var model13,triangulation=TRI468,uvmap=UV468,last8=[],lastTime11=0,lastCount7=0,skipped11=Number.MAX_SAFE_INTEGER;async function load12(e){var t,n;const a=join(e.modelBasePath,(null==(t=e.face.description)?void 0:t.modelPath)||"");return env2.initial&&(model13=null),model13?e.debug&&log("cached model:",a):(model13=await loadGraphModel(a))?e.debug&&log("load model:",a):log("load model failed:",(null==(n=e.face.description)?void 0:n.modelPath)||""),model13}function enhance2(e){const t=e.image||e.tensor||e;if(!(null==model13?void 0:model13.inputs[0].shape))return t;const n=image.resizeBilinear(t,[model13.inputs[0].shape[2],model13.inputs[0].shape[1]],!1),a=mul(n,constants.tf255);return dispose(n),a}async function predict11(e,t,n,a){var r,s,o,i;if(!model13)return{age:0,gender:"unknown",genderScore:0,descriptor:[]};const l=skipped11<((null==(r=t.face.description)?void 0:r.skipFrames)||0),u=((null==(s=t.face.description)?void 0:s.skipTime)||0)>now()-lastTime11;return t.skipAllowed&&l&&u&&lastCount7===a&&(null==(o=last8[n])?void 0:o.age)&&(null==(i=last8[n])?void 0:i.age)>0?(skipped11++,last8[n]):(skipped11=0,new Promise((async r=>{var s,o;const i={age:0,gender:"unknown",genderScore:0,descriptor:[]};if(null==(s=t.face.description)?void 0:s.enabled){const n=enhance2(e),a=null==model13?void 0:model13.execute(n);lastTime11=now(),dispose(n);const r=await a.find((e=>1===e.shape[1])),s=await r.data(),l=Math.trunc(200*Math.abs(s[0]-.5))/100;l>((null==(o=t.face.description)?void 0:o.minConfidence)||0)&&(i.gender=s[0]<=.5?"female":"male",i.genderScore=Math.min(.99,l));const u=argMax(a.find((e=>100===e.shape[1])),1),c=(await u.data())[0];dispose(u);const d=a.find((e=>100===e.shape[1])),p=await d.data();i.age=Math.round(p[c-1]>p[c+1]?10*c-100*p[c-1]:10*c+100*p[c+1])/10;const h=a.find((e=>1024===e.shape[1])),m=h?await h.data():[];i.descriptor=Array.from(m),a.forEach((e=>dispose(e)))}last8[n]=i,lastCount7=a,r(i)})))}function getBoxSize2(e){return[Math.abs(e.endPoint[0]-e.startPoint[0]),Math.abs(e.endPoint[1]-e.startPoint[1])]}function getBoxCenter2(e){return[e.startPoint[0]+(e.endPoint[0]-e.startPoint[0])/2,e.startPoint[1]+(e.endPoint[1]-e.startPoint[1])/2]}function cutBoxFromImageAndResize2(e,t,n){const a=t.shape[1],r=t.shape[2],s=[[e.startPoint[1]/a,e.startPoint[0]/r,e.endPoint[1]/a,e.endPoint[0]/r]];return image.cropAndResize(t,s,[0],n)}function scaleBoxCoordinates2(e,t){return{startPoint:[e.startPoint[0]*t[0],e.startPoint[1]*t[1]],endPoint:[e.endPoint[0]*t[0],e.endPoint[1]*t[1]],palmLandmarks:e.palmLandmarks.map((e=>[e[0]*t[0],e[1]*t[1]])),confidence:e.confidence}}function enlargeBox2(e,t=1.5){const n=getBoxCenter2(e),a=getBoxSize2(e),r=[t*a[0]/2,t*a[1]/2];return{startPoint:[n[0]-r[0],n[1]-r[1]],endPoint:[n[0]+r[0],n[1]+r[1]],palmLandmarks:e.palmLandmarks}}function squarifyBox2(e){const t=getBoxCenter2(e),n=getBoxSize2(e),a=Math.max(...n)/2;return{startPoint:[t[0]-a,t[1]-a],endPoint:[t[0]+a,t[1]+a],palmLandmarks:e.palmLandmarks}}function normalizeRadians2(e){return e-2*Math.PI*Math.floor((e+Math.PI)/(2*Math.PI))}function computeRotation2(e,t){return normalizeRadians2(Math.PI/2-Math.atan2(-(t[1]-e[1]),t[0]-e[0]))}var buildTranslationMatrix2=(e,t)=>[[1,0,e],[0,1,t],[0,0,1]];function dot5(e,t){let n=0;for(let a=0;a<e.length;a++)n+=e[a]*t[a];return n}function getColumnFrom2DArr2(e,t){const n=[];for(let a=0;a<e.length;a++)n.push(e[a][t]);return n}function multiplyTransformMatrices2(e,t){const n=[],a=e.length;for(let r=0;r<a;r++){n.push([]);for(let s=0;s<a;s++)n[r].push(dot5(e[r],getColumnFrom2DArr2(t,s)))}return n}function buildRotationMatrix2(e,t){const n=Math.cos(e),a=Math.sin(e),r=[[n,-a,0],[a,n,0],[0,0,1]],s=multiplyTransformMatrices2(buildTranslationMatrix2(t[0],t[1]),r);return multiplyTransformMatrices2(s,buildTranslationMatrix2(-t[0],-t[1]))}function invertTransformMatrix2(e){const t=[[e[0][0],e[1][0]],[e[0][1],e[1][1]]],n=[e[0][2],e[1][2]],a=[-dot5(t[0],n),-dot5(t[1],n)];return[t[0].concat(a[0]),t[1].concat(a[1]),[0,0,1]]}function rotatePoint2(e,t){return[dot5(e,t[0]),dot5(e,t[1])]}var anchors2=[{x:.015625,y:.015625},{x:.015625,y:.015625},{x:.046875,y:.015625},{x:.046875,y:.015625},{x:.078125,y:.015625},{x:.078125,y:.015625},{x:.109375,y:.015625},{x:.109375,y:.015625},{x:.140625,y:.015625},{x:.140625,y:.015625},{x:.171875,y:.015625},{x:.171875,y:.015625},{x:.203125,y:.015625},{x:.203125,y:.015625},{x:.234375,y:.015625},{x:.234375,y:.015625},{x:.265625,y:.015625},{x:.265625,y:.015625},{x:.296875,y:.015625},{x:.296875,y:.015625},{x:.328125,y:.015625},{x:.328125,y:.015625},{x:.359375,y:.015625},{x:.359375,y:.015625},{x:.390625,y:.015625},{x:.390625,y:.015625},{x:.421875,y:.015625},{x:.421875,y:.015625},{x:.453125,y:.015625},{x:.453125,y:.015625},{x:.484375,y:.015625},{x:.484375,y:.015625},{x:.515625,y:.015625},{x:.515625,y:.015625},{x:.546875,y:.015625},{x:.546875,y:.015625},{x:.578125,y:.015625},{x:.578125,y:.015625},{x:.609375,y:.015625},{x:.609375,y:.015625},{x:.640625,y:.015625},{x:.640625,y:.015625},{x:.671875,y:.015625},{x:.671875,y:.015625},{x:.703125,y:.015625},{x:.703125,y:.015625},{x:.734375,y:.015625},{x:.734375,y:.015625},{x:.765625,y:.015625},{x:.765625,y:.015625},{x:.796875,y:.015625},{x:.796875,y:.015625},{x:.828125,y:.015625},{x:.828125,y:.015625},{x:.859375,y:.015625},{x:.859375,y:.015625},{x:.890625,y:.015625},{x:.890625,y:.015625},{x:.921875,y:.015625},{x:.921875,y:.015625},{x:.953125,y:.015625},{x:.953125,y:.015625},{x:.984375,y:.015625},{x:.984375,y:.015625},{x:.015625,y:.046875},{x:.015625,y:.046875},{x:.046875,y:.046875},{x:.046875,y:.046875},{x:.078125,y:.046875},{x:.078125,y:.046875},{x:.109375,y:.046875},{x:.109375,y:.046875},{x:.140625,y:.046875},{x:.140625,y:.046875},{x:.171875,y:.046875},{x:.171875,y:.046875},{x:.203125,y:.046875},{x:.203125,y:.046875},{x:.234375,y:.046875},{x:.234375,y:.046875},{x:.265625,y:.046875},{x:.265625,y:.046875},{x:.296875,y:.046875},{x:.296875,y:.046875},{x:.328125,y:.046875},{x:.328125,y:.046875},{x:.359375,y:.046875},{x:.359375,y:.046875},{x:.390625,y:.046875},{x:.390625,y:.046875},{x:.421875,y:.046875},{x:.421875,y:.046875},{x:.453125,y:.046875},{x:.453125,y:.046875},{x:.484375,y:.046875},{x:.484375,y:.046875},{x:.515625,y:.046875},{x:.515625,y:.046875},{x:.546875,y:.046875},{x:.546875,y:.046875},{x:.578125,y:.046875},{x:.578125,y:.046875},{x:.609375,y:.046875},{x:.609375,y:.046875},{x:.640625,y:.046875},{x:.640625,y:.046875},{x:.671875,y:.046875},{x:.671875,y:.046875},{x:.703125,y:.046875},{x:.703125,y:.046875},{x:.734375,y:.046875},{x:.734375,y:.046875},{x:.765625,y:.046875},{x:.765625,y:.046875},{x:.796875,y:.046875},{x:.796875,y:.046875},{x:.828125,y:.046875},{x:.828125,y:.046875},{x:.859375,y:.046875},{x:.859375,y:.046875},{x:.890625,y:.046875},{x:.890625,y:.046875},{x:.921875,y:.046875},{x:.921875,y:.046875},{x:.953125,y:.046875},{x:.953125,y:.046875},{x:.984375,y:.046875},{x:.984375,y:.046875},{x:.015625,y:.078125},{x:.015625,y:.078125},{x:.046875,y:.078125},{x:.046875,y:.078125},{x:.078125,y:.078125},{x:.078125,y:.078125},{x:.109375,y:.078125},{x:.109375,y:.078125},{x:.140625,y:.078125},{x:.140625,y:.078125},{x:.171875,y:.078125},{x:.171875,y:.078125},{x:.203125,y:.078125},{x:.203125,y:.078125},{x:.234375,y:.078125},{x:.234375,y:.078125},{x:.265625,y:.078125},{x:.265625,y:.078125},{x:.296875,y:.078125},{x:.296875,y:.078125},{x:.328125,y:.078125},{x:.328125,y:.078125},{x:.359375,y:.078125},{x:.359375,y:.078125},{x:.390625,y:.078125},{x:.390625,y:.078125},{x:.421875,y:.078125},{x:.421875,y:.078125},{x:.453125,y:.078125},{x:.453125,y:.078125},{x:.484375,y:.078125},{x:.484375,y:.078125},{x:.515625,y:.078125},{x:.515625,y:.078125},{x:.546875,y:.078125},{x:.546875,y:.078125},{x:.578125,y:.078125},{x:.578125,y:.078125},{x:.609375,y:.078125},{x:.609375,y:.078125},{x:.640625,y:.078125},{x:.640625,y:.078125},{x:.671875,y:.078125},{x:.671875,y:.078125},{x:.703125,y:.078125},{x:.703125,y:.078125},{x:.734375,y:.078125},{x:.734375,y:.078125},{x:.765625,y:.078125},{x:.765625,y:.078125},{x:.796875,y:.078125},{x:.796875,y:.078125},{x:.828125,y:.078125},{x:.828125,y:.078125},{x:.859375,y:.078125},{x:.859375,y:.078125},{x:.890625,y:.078125},{x:.890625,y:.078125},{x:.921875,y:.078125},{x:.921875,y:.078125},{x:.953125,y:.078125},{x:.953125,y:.078125},{x:.984375,y:.078125},{x:.984375,y:.078125},{x:.015625,y:.109375},{x:.015625,y:.109375},{x:.046875,y:.109375},{x:.046875,y:.109375},{x:.078125,y:.109375},{x:.078125,y:.109375},{x:.109375,y:.109375},{x:.109375,y:.109375},{x:.140625,y:.109375},{x:.140625,y:.109375},{x:.171875,y:.109375},{x:.171875,y:.109375},{x:.203125,y:.109375},{x:.203125,y:.109375},{x:.234375,y:.109375},{x:.234375,y:.109375},{x:.265625,y:.109375},{x:.265625,y:.109375},{x:.296875,y:.109375},{x:.296875,y:.109375},{x:.328125,y:.109375},{x:.328125,y:.109375},{x:.359375,y:.109375},{x:.359375,y:.109375},{x:.390625,y:.109375},{x:.390625,y:.109375},{x:.421875,y:.109375},{x:.421875,y:.109375},{x:.453125,y:.109375},{x:.453125,y:.109375},{x:.484375,y:.109375},{x:.484375,y:.109375},{x:.515625,y:.109375},{x:.515625,y:.109375},{x:.546875,y:.109375},{x:.546875,y:.109375},{x:.578125,y:.109375},{x:.578125,y:.109375},{x:.609375,y:.109375},{x:.609375,y:.109375},{x:.640625,y:.109375},{x:.640625,y:.109375},{x:.671875,y:.109375},{x:.671875,y:.109375},{x:.703125,y:.109375},{x:.703125,y:.109375},{x:.734375,y:.109375},{x:.734375,y:.109375},{x:.765625,y:.109375},{x:.765625,y:.109375},{x:.796875,y:.109375},{x:.796875,y:.109375},{x:.828125,y:.109375},{x:.828125,y:.109375},{x:.859375,y:.109375},{x:.859375,y:.109375},{x:.890625,y:.109375},{x:.890625,y:.109375},{x:.921875,y:.109375},{x:.921875,y:.109375},{x:.953125,y:.109375},{x:.953125,y:.109375},{x:.984375,y:.109375},{x:.984375,y:.109375},{x:.015625,y:.140625},{x:.015625,y:.140625},{x:.046875,y:.140625},{x:.046875,y:.140625},{x:.078125,y:.140625},{x:.078125,y:.140625},{x:.109375,y:.140625},{x:.109375,y:.140625},{x:.140625,y:.140625},{x:.140625,y:.140625},{x:.171875,y:.140625},{x:.171875,y:.140625},{x:.203125,y:.140625},{x:.203125,y:.140625},{x:.234375,y:.140625},{x:.234375,y:.140625},{x:.265625,y:.140625},{x:.265625,y:.140625},{x:.296875,y:.140625},{x:.296875,y:.140625},{x:.328125,y:.140625},{x:.328125,y:.140625},{x:.359375,y:.140625},{x:.359375,y:.140625},{x:.390625,y:.140625},{x:.390625,y:.140625},{x:.421875,y:.140625},{x:.421875,y:.140625},{x:.453125,y:.140625},{x:.453125,y:.140625},{x:.484375,y:.140625},{x:.484375,y:.140625},{x:.515625,y:.140625},{x:.515625,y:.140625},{x:.546875,y:.140625},{x:.546875,y:.140625},{x:.578125,y:.140625},{x:.578125,y:.140625},{x:.609375,y:.140625},{x:.609375,y:.140625},{x:.640625,y:.140625},{x:.640625,y:.140625},{x:.671875,y:.140625},{x:.671875,y:.140625},{x:.703125,y:.140625},{x:.703125,y:.140625},{x:.734375,y:.140625},{x:.734375,y:.140625},{x:.765625,y:.140625},{x:.765625,y:.140625},{x:.796875,y:.140625},{x:.796875,y:.140625},{x:.828125,y:.140625},{x:.828125,y:.140625},{x:.859375,y:.140625},{x:.859375,y:.140625},{x:.890625,y:.140625},{x:.890625,y:.140625},{x:.921875,y:.140625},{x:.921875,y:.140625},{x:.953125,y:.140625},{x:.953125,y:.140625},{x:.984375,y:.140625},{x:.984375,y:.140625},{x:.015625,y:.171875},{x:.015625,y:.171875},{x:.046875,y:.171875},{x:.046875,y:.171875},{x:.078125,y:.171875},{x:.078125,y:.171875},{x:.109375,y:.171875},{x:.109375,y:.171875},{x:.140625,y:.171875},{x:.140625,y:.171875},{x:.171875,y:.171875},{x:.171875,y:.171875},{x:.203125,y:.171875},{x:.203125,y:.171875},{x:.234375,y:.171875},{x:.234375,y:.171875},{x:.265625,y:.171875},{x:.265625,y:.171875},{x:.296875,y:.171875},{x:.296875,y:.171875},{x:.328125,y:.171875},{x:.328125,y:.171875},{x:.359375,y:.171875},{x:.359375,y:.171875},{x:.390625,y:.171875},{x:.390625,y:.171875},{x:.421875,y:.171875},{x:.421875,y:.171875},{x:.453125,y:.171875},{x:.453125,y:.171875},{x:.484375,y:.171875},{x:.484375,y:.171875},{x:.515625,y:.171875},{x:.515625,y:.171875},{x:.546875,y:.171875},{x:.546875,y:.171875},{x:.578125,y:.171875},{x:.578125,y:.171875},{x:.609375,y:.171875},{x:.609375,y:.171875},{x:.640625,y:.171875},{x:.640625,y:.171875},{x:.671875,y:.171875},{x:.671875,y:.171875},{x:.703125,y:.171875},{x:.703125,y:.171875},{x:.734375,y:.171875},{x:.734375,y:.171875},{x:.765625,y:.171875},{x:.765625,y:.171875},{x:.796875,y:.171875},{x:.796875,y:.171875},{x:.828125,y:.171875},{x:.828125,y:.171875},{x:.859375,y:.171875},{x:.859375,y:.171875},{x:.890625,y:.171875},{x:.890625,y:.171875},{x:.921875,y:.171875},{x:.921875,y:.171875},{x:.953125,y:.171875},{x:.953125,y:.171875},{x:.984375,y:.171875},{x:.984375,y:.171875},{x:.015625,y:.203125},{x:.015625,y:.203125},{x:.046875,y:.203125},{x:.046875,y:.203125},{x:.078125,y:.203125},{x:.078125,y:.203125},{x:.109375,y:.203125},{x:.109375,y:.203125},{x:.140625,y:.203125},{x:.140625,y:.203125},{x:.171875,y:.203125},{x:.171875,y:.203125},{x:.203125,y:.203125},{x:.203125,y:.203125},{x:.234375,y:.203125},{x:.234375,y:.203125},{x:.265625,y:.203125},{x:.265625,y:.203125},{x:.296875,y:.203125},{x:.296875,y:.203125},{x:.328125,y:.203125},{x:.328125,y:.203125},{x:.359375,y:.203125},{x:.359375,y:.203125},{x:.390625,y:.203125},{x:.390625,y:.203125},{x:.421875,y:.203125},{x:.421875,y:.203125},{x:.453125,y:.203125},{x:.453125,y:.203125},{x:.484375,y:.203125},{x:.484375,y:.203125},{x:.515625,y:.203125},{x:.515625,y:.203125},{x:.546875,y:.203125},{x:.546875,y:.203125},{x:.578125,y:.203125},{x:.578125,y:.203125},{x:.609375,y:.203125},{x:.609375,y:.203125},{x:.640625,y:.203125},{x:.640625,y:.203125},{x:.671875,y:.203125},{x:.671875,y:.203125},{x:.703125,y:.203125},{x:.703125,y:.203125},{x:.734375,y:.203125},{x:.734375,y:.203125},{x:.765625,y:.203125},{x:.765625,y:.203125},{x:.796875,y:.203125},{x:.796875,y:.203125},{x:.828125,y:.203125},{x:.828125,y:.203125},{x:.859375,y:.203125},{x:.859375,y:.203125},{x:.890625,y:.203125},{x:.890625,y:.203125},{x:.921875,y:.203125},{x:.921875,y:.203125},{x:.953125,y:.203125},{x:.953125,y:.203125},{x:.984375,y:.203125},{x:.984375,y:.203125},{x:.015625,y:.234375},{x:.015625,y:.234375},{x:.046875,y:.234375},{x:.046875,y:.234375},{x:.078125,y:.234375},{x:.078125,y:.234375},{x:.109375,y:.234375},{x:.109375,y:.234375},{x:.140625,y:.234375},{x:.140625,y:.234375},{x:.171875,y:.234375},{x:.171875,y:.234375},{x:.203125,y:.234375},{x:.203125,y:.234375},{x:.234375,y:.234375},{x:.234375,y:.234375},{x:.265625,y:.234375},{x:.265625,y:.234375},{x:.296875,y:.234375},{x:.296875,y:.234375},{x:.328125,y:.234375},{x:.328125,y:.234375},{x:.359375,y:.234375},{x:.359375,y:.234375},{x:.390625,y:.234375},{x:.390625,y:.234375},{x:.421875,y:.234375},{x:.421875,y:.234375},{x:.453125,y:.234375},{x:.453125,y:.234375},{x:.484375,y:.234375},{x:.484375,y:.234375},{x:.515625,y:.234375},{x:.515625,y:.234375},{x:.546875,y:.234375},{x:.546875,y:.234375},{x:.578125,y:.234375},{x:.578125,y:.234375},{x:.609375,y:.234375},{x:.609375,y:.234375},{x:.640625,y:.234375},{x:.640625,y:.234375},{x:.671875,y:.234375},{x:.671875,y:.234375},{x:.703125,y:.234375},{x:.703125,y:.234375},{x:.734375,y:.234375},{x:.734375,y:.234375},{x:.765625,y:.234375},{x:.765625,y:.234375},{x:.796875,y:.234375},{x:.796875,y:.234375},{x:.828125,y:.234375},{x:.828125,y:.234375},{x:.859375,y:.234375},{x:.859375,y:.234375},{x:.890625,y:.234375},{x:.890625,y:.234375},{x:.921875,y:.234375},{x:.921875,y:.234375},{x:.953125,y:.234375},{x:.953125,y:.234375},{x:.984375,y:.234375},{x:.984375,y:.234375},{x:.015625,y:.265625},{x:.015625,y:.265625},{x:.046875,y:.265625},{x:.046875,y:.265625},{x:.078125,y:.265625},{x:.078125,y:.265625},{x:.109375,y:.265625},{x:.109375,y:.265625},{x:.140625,y:.265625},{x:.140625,y:.265625},{x:.171875,y:.265625},{x:.171875,y:.265625},{x:.203125,y:.265625},{x:.203125,y:.265625},{x:.234375,y:.265625},{x:.234375,y:.265625},{x:.265625,y:.265625},{x:.265625,y:.265625},{x:.296875,y:.265625},{x:.296875,y:.265625},{x:.328125,y:.265625},{x:.328125,y:.265625},{x:.359375,y:.265625},{x:.359375,y:.265625},{x:.390625,y:.265625},{x:.390625,y:.265625},{x:.421875,y:.265625},{x:.421875,y:.265625},{x:.453125,y:.265625},{x:.453125,y:.265625},{x:.484375,y:.265625},{x:.484375,y:.265625},{x:.515625,y:.265625},{x:.515625,y:.265625},{x:.546875,y:.265625},{x:.546875,y:.265625},{x:.578125,y:.265625},{x:.578125,y:.265625},{x:.609375,y:.265625},{x:.609375,y:.265625},{x:.640625,y:.265625},{x:.640625,y:.265625},{x:.671875,y:.265625},{x:.671875,y:.265625},{x:.703125,y:.265625},{x:.703125,y:.265625},{x:.734375,y:.265625},{x:.734375,y:.265625},{x:.765625,y:.265625},{x:.765625,y:.265625},{x:.796875,y:.265625},{x:.796875,y:.265625},{x:.828125,y:.265625},{x:.828125,y:.265625},{x:.859375,y:.265625},{x:.859375,y:.265625},{x:.890625,y:.265625},{x:.890625,y:.265625},{x:.921875,y:.265625},{x:.921875,y:.265625},{x:.953125,y:.265625},{x:.953125,y:.265625},{x:.984375,y:.265625},{x:.984375,y:.265625},{x:.015625,y:.296875},{x:.015625,y:.296875},{x:.046875,y:.296875},{x:.046875,y:.296875},{x:.078125,y:.296875},{x:.078125,y:.296875},{x:.109375,y:.296875},{x:.109375,y:.296875},{x:.140625,y:.296875},{x:.140625,y:.296875},{x:.171875,y:.296875},{x:.171875,y:.296875},{x:.203125,y:.296875},{x:.203125,y:.296875},{x:.234375,y:.296875},{x:.234375,y:.296875},{x:.265625,y:.296875},{x:.265625,y:.296875},{x:.296875,y:.296875},{x:.296875,y:.296875},{x:.328125,y:.296875},{x:.328125,y:.296875},{x:.359375,y:.296875},{x:.359375,y:.296875},{x:.390625,y:.296875},{x:.390625,y:.296875},{x:.421875,y:.296875},{x:.421875,y:.296875},{x:.453125,y:.296875},{x:.453125,y:.296875},{x:.484375,y:.296875},{x:.484375,y:.296875},{x:.515625,y:.296875},{x:.515625,y:.296875},{x:.546875,y:.296875},{x:.546875,y:.296875},{x:.578125,y:.296875},{x:.578125,y:.296875},{x:.609375,y:.296875},{x:.609375,y:.296875},{x:.640625,y:.296875},{x:.640625,y:.296875},{x:.671875,y:.296875},{x:.671875,y:.296875},{x:.703125,y:.296875},{x:.703125,y:.296875},{x:.734375,y:.296875},{x:.734375,y:.296875},{x:.765625,y:.296875},{x:.765625,y:.296875},{x:.796875,y:.296875},{x:.796875,y:.296875},{x:.828125,y:.296875},{x:.828125,y:.296875},{x:.859375,y:.296875},{x:.859375,y:.296875},{x:.890625,y:.296875},{x:.890625,y:.296875},{x:.921875,y:.296875},{x:.921875,y:.296875},{x:.953125,y:.296875},{x:.953125,y:.296875},{x:.984375,y:.296875},{x:.984375,y:.296875},{x:.015625,y:.328125},{x:.015625,y:.328125},{x:.046875,y:.328125},{x:.046875,y:.328125},{x:.078125,y:.328125},{x:.078125,y:.328125},{x:.109375,y:.328125},{x:.109375,y:.328125},{x:.140625,y:.328125},{x:.140625,y:.328125},{x:.171875,y:.328125},{x:.171875,y:.328125},{x:.203125,y:.328125},{x:.203125,y:.328125},{x:.234375,y:.328125},{x:.234375,y:.328125},{x:.265625,y:.328125},{x:.265625,y:.328125},{x:.296875,y:.328125},{x:.296875,y:.328125},{x:.328125,y:.328125},{x:.328125,y:.328125},{x:.359375,y:.328125},{x:.359375,y:.328125},{x:.390625,y:.328125},{x:.390625,y:.328125},{x:.421875,y:.328125},{x:.421875,y:.328125},{x:.453125,y:.328125},{x:.453125,y:.328125},{x:.484375,y:.328125},{x:.484375,y:.328125},{x:.515625,y:.328125},{x:.515625,y:.328125},{x:.546875,y:.328125},{x:.546875,y:.328125},{x:.578125,y:.328125},{x:.578125,y:.328125},{x:.609375,y:.328125},{x:.609375,y:.328125},{x:.640625,y:.328125},{x:.640625,y:.328125},{x:.671875,y:.328125},{x:.671875,y:.328125},{x:.703125,y:.328125},{x:.703125,y:.328125},{x:.734375,y:.328125},{x:.734375,y:.328125},{x:.765625,y:.328125},{x:.765625,y:.328125},{x:.796875,y:.328125},{x:.796875,y:.328125},{x:.828125,y:.328125},{x:.828125,y:.328125},{x:.859375,y:.328125},{x:.859375,y:.328125},{x:.890625,y:.328125},{x:.890625,y:.328125},{x:.921875,y:.328125},{x:.921875,y:.328125},{x:.953125,y:.328125},{x:.953125,y:.328125},{x:.984375,y:.328125},{x:.984375,y:.328125},{x:.015625,y:.359375},{x:.015625,y:.359375},{x:.046875,y:.359375},{x:.046875,y:.359375},{x:.078125,y:.359375},{x:.078125,y:.359375},{x:.109375,y:.359375},{x:.109375,y:.359375},{x:.140625,y:.359375},{x:.140625,y:.359375},{x:.171875,y:.359375},{x:.171875,y:.359375},{x:.203125,y:.359375},{x:.203125,y:.359375},{x:.234375,y:.359375},{x:.234375,y:.359375},{x:.265625,y:.359375},{x:.265625,y:.359375},{x:.296875,y:.359375},{x:.296875,y:.359375},{x:.328125,y:.359375},{x:.328125,y:.359375},{x:.359375,y:.359375},{x:.359375,y:.359375},{x:.390625,y:.359375},{x:.390625,y:.359375},{x:.421875,y:.359375},{x:.421875,y:.359375},{x:.453125,y:.359375},{x:.453125,y:.359375},{x:.484375,y:.359375},{x:.484375,y:.359375},{x:.515625,y:.359375},{x:.515625,y:.359375},{x:.546875,y:.359375},{x:.546875,y:.359375},{x:.578125,y:.359375},{x:.578125,y:.359375},{x:.609375,y:.359375},{x:.609375,y:.359375},{x:.640625,y:.359375},{x:.640625,y:.359375},{x:.671875,y:.359375},{x:.671875,y:.359375},{x:.703125,y:.359375},{x:.703125,y:.359375},{x:.734375,y:.359375},{x:.734375,y:.359375},{x:.765625,y:.359375},{x:.765625,y:.359375},{x:.796875,y:.359375},{x:.796875,y:.359375},{x:.828125,y:.359375},{x:.828125,y:.359375},{x:.859375,y:.359375},{x:.859375,y:.359375},{x:.890625,y:.359375},{x:.890625,y:.359375},{x:.921875,y:.359375},{x:.921875,y:.359375},{x:.953125,y:.359375},{x:.953125,y:.359375},{x:.984375,y:.359375},{x:.984375,y:.359375},{x:.015625,y:.390625},{x:.015625,y:.390625},{x:.046875,y:.390625},{x:.046875,y:.390625},{x:.078125,y:.390625},{x:.078125,y:.390625},{x:.109375,y:.390625},{x:.109375,y:.390625},{x:.140625,y:.390625},{x:.140625,y:.390625},{x:.171875,y:.390625},{x:.171875,y:.390625},{x:.203125,y:.390625},{x:.203125,y:.390625},{x:.234375,y:.390625},{x:.234375,y:.390625},{x:.265625,y:.390625},{x:.265625,y:.390625},{x:.296875,y:.390625},{x:.296875,y:.390625},{x:.328125,y:.390625},{x:.328125,y:.390625},{x:.359375,y:.390625},{x:.359375,y:.390625},{x:.390625,y:.390625},{x:.390625,y:.390625},{x:.421875,y:.390625},{x:.421875,y:.390625},{x:.453125,y:.390625},{x:.453125,y:.390625},{x:.484375,y:.390625},{x:.484375,y:.390625},{x:.515625,y:.390625},{x:.515625,y:.390625},{x:.546875,y:.390625},{x:.546875,y:.390625},{x:.578125,y:.390625},{x:.578125,y:.390625},{x:.609375,y:.390625},{x:.609375,y:.390625},{x:.640625,y:.390625},{x:.640625,y:.390625},{x:.671875,y:.390625},{x:.671875,y:.390625},{x:.703125,y:.390625},{x:.703125,y:.390625},{x:.734375,y:.390625},{x:.734375,y:.390625},{x:.765625,y:.390625},{x:.765625,y:.390625},{x:.796875,y:.390625},{x:.796875,y:.390625},{x:.828125,y:.390625},{x:.828125,y:.390625},{x:.859375,y:.390625},{x:.859375,y:.390625},{x:.890625,y:.390625},{x:.890625,y:.390625},{x:.921875,y:.390625},{x:.921875,y:.390625},{x:.953125,y:.390625},{x:.953125,y:.390625},{x:.984375,y:.390625},{x:.984375,y:.390625},{x:.015625,y:.421875},{x:.015625,y:.421875},{x:.046875,y:.421875},{x:.046875,y:.421875},{x:.078125,y:.421875},{x:.078125,y:.421875},{x:.109375,y:.421875},{x:.109375,y:.421875},{x:.140625,y:.421875},{x:.140625,y:.421875},{x:.171875,y:.421875},{x:.171875,y:.421875},{x:.203125,y:.421875},{x:.203125,y:.421875},{x:.234375,y:.421875},{x:.234375,y:.421875},{x:.265625,y:.421875},{x:.265625,y:.421875},{x:.296875,y:.421875},{x:.296875,y:.421875},{x:.328125,y:.421875},{x:.328125,y:.421875},{x:.359375,y:.421875},{x:.359375,y:.421875},{x:.390625,y:.421875},{x:.390625,y:.421875},{x:.421875,y:.421875},{x:.421875,y:.421875},{x:.453125,y:.421875},{x:.453125,y:.421875},{x:.484375,y:.421875},{x:.484375,y:.421875},{x:.515625,y:.421875},{x:.515625,y:.421875},{x:.546875,y:.421875},{x:.546875,y:.421875},{x:.578125,y:.421875},{x:.578125,y:.421875},{x:.609375,y:.421875},{x:.609375,y:.421875},{x:.640625,y:.421875},{x:.640625,y:.421875},{x:.671875,y:.421875},{x:.671875,y:.421875},{x:.703125,y:.421875},{x:.703125,y:.421875},{x:.734375,y:.421875},{x:.734375,y:.421875},{x:.765625,y:.421875},{x:.765625,y:.421875},{x:.796875,y:.421875},{x:.796875,y:.421875},{x:.828125,y:.421875},{x:.828125,y:.421875},{x:.859375,y:.421875},{x:.859375,y:.421875},{x:.890625,y:.421875},{x:.890625,y:.421875},{x:.921875,y:.421875},{x:.921875,y:.421875},{x:.953125,y:.421875},{x:.953125,y:.421875},{x:.984375,y:.421875},{x:.984375,y:.421875},{x:.015625,y:.453125},{x:.015625,y:.453125},{x:.046875,y:.453125},{x:.046875,y:.453125},{x:.078125,y:.453125},{x:.078125,y:.453125},{x:.109375,y:.453125},{x:.109375,y:.453125},{x:.140625,y:.453125},{x:.140625,y:.453125},{x:.171875,y:.453125},{x:.171875,y:.453125},{x:.203125,y:.453125},{x:.203125,y:.453125},{x:.234375,y:.453125},{x:.234375,y:.453125},{x:.265625,y:.453125},{x:.265625,y:.453125},{x:.296875,y:.453125},{x:.296875,y:.453125},{x:.328125,y:.453125},{x:.328125,y:.453125},{x:.359375,y:.453125},{x:.359375,y:.453125},{x:.390625,y:.453125},{x:.390625,y:.453125},{x:.421875,y:.453125},{x:.421875,y:.453125},{x:.453125,y:.453125},{x:.453125,y:.453125},{x:.484375,y:.453125},{x:.484375,y:.453125},{x:.515625,y:.453125},{x:.515625,y:.453125},{x:.546875,y:.453125},{x:.546875,y:.453125},{x:.578125,y:.453125},{x:.578125,y:.453125},{x:.609375,y:.453125},{x:.609375,y:.453125},{x:.640625,y:.453125},{x:.640625,y:.453125},{x:.671875,y:.453125},{x:.671875,y:.453125},{x:.703125,y:.453125},{x:.703125,y:.453125},{x:.734375,y:.453125},{x:.734375,y:.453125},{x:.765625,y:.453125},{x:.765625,y:.453125},{x:.796875,y:.453125},{x:.796875,y:.453125},{x:.828125,y:.453125},{x:.828125,y:.453125},{x:.859375,y:.453125},{x:.859375,y:.453125},{x:.890625,y:.453125},{x:.890625,y:.453125},{x:.921875,y:.453125},{x:.921875,y:.453125},{x:.953125,y:.453125},{x:.953125,y:.453125},{x:.984375,y:.453125},{x:.984375,y:.453125},{x:.015625,y:.484375},{x:.015625,y:.484375},{x:.046875,y:.484375},{x:.046875,y:.484375},{x:.078125,y:.484375},{x:.078125,y:.484375},{x:.109375,y:.484375},{x:.109375,y:.484375},{x:.140625,y:.484375},{x:.140625,y:.484375},{x:.171875,y:.484375},{x:.171875,y:.484375},{x:.203125,y:.484375},{x:.203125,y:.484375},{x:.234375,y:.484375},{x:.234375,y:.484375},{x:.265625,y:.484375},{x:.265625,y:.484375},{x:.296875,y:.484375},{x:.296875,y:.484375},{x:.328125,y:.484375},{x:.328125,y:.484375},{x:.359375,y:.484375},{x:.359375,y:.484375},{x:.390625,y:.484375},{x:.390625,y:.484375},{x:.421875,y:.484375},{x:.421875,y:.484375},{x:.453125,y:.484375},{x:.453125,y:.484375},{x:.484375,y:.484375},{x:.484375,y:.484375},{x:.515625,y:.484375},{x:.515625,y:.484375},{x:.546875,y:.484375},{x:.546875,y:.484375},{x:.578125,y:.484375},{x:.578125,y:.484375},{x:.609375,y:.484375},{x:.609375,y:.484375},{x:.640625,y:.484375},{x:.640625,y:.484375},{x:.671875,y:.484375},{x:.671875,y:.484375},{x:.703125,y:.484375},{x:.703125,y:.484375},{x:.734375,y:.484375},{x:.734375,y:.484375},{x:.765625,y:.484375},{x:.765625,y:.484375},{x:.796875,y:.484375},{x:.796875,y:.484375},{x:.828125,y:.484375},{x:.828125,y:.484375},{x:.859375,y:.484375},{x:.859375,y:.484375},{x:.890625,y:.484375},{x:.890625,y:.484375},{x:.921875,y:.484375},{x:.921875,y:.484375},{x:.953125,y:.484375},{x:.953125,y:.484375},{x:.984375,y:.484375},{x:.984375,y:.484375},{x:.015625,y:.515625},{x:.015625,y:.515625},{x:.046875,y:.515625},{x:.046875,y:.515625},{x:.078125,y:.515625},{x:.078125,y:.515625},{x:.109375,y:.515625},{x:.109375,y:.515625},{x:.140625,y:.515625},{x:.140625,y:.515625},{x:.171875,y:.515625},{x:.171875,y:.515625},{x:.203125,y:.515625},{x:.203125,y:.515625},{x:.234375,y:.515625},{x:.234375,y:.515625},{x:.265625,y:.515625},{x:.265625,y:.515625},{x:.296875,y:.515625},{x:.296875,y:.515625},{x:.328125,y:.515625},{x:.328125,y:.515625},{x:.359375,y:.515625},{x:.359375,y:.515625},{x:.390625,y:.515625},{x:.390625,y:.515625},{x:.421875,y:.515625},{x:.421875,y:.515625},{x:.453125,y:.515625},{x:.453125,y:.515625},{x:.484375,y:.515625},{x:.484375,y:.515625},{x:.515625,y:.515625},{x:.515625,y:.515625},{x:.546875,y:.515625},{x:.546875,y:.515625},{x:.578125,y:.515625},{x:.578125,y:.515625},{x:.609375,y:.515625},{x:.609375,y:.515625},{x:.640625,y:.515625},{x:.640625,y:.515625},{x:.671875,y:.515625},{x:.671875,y:.515625},{x:.703125,y:.515625},{x:.703125,y:.515625},{x:.734375,y:.515625},{x:.734375,y:.515625},{x:.765625,y:.515625},{x:.765625,y:.515625},{x:.796875,y:.515625},{x:.796875,y:.515625},{x:.828125,y:.515625},{x:.828125,y:.515625},{x:.859375,y:.515625},{x:.859375,y:.515625},{x:.890625,y:.515625},{x:.890625,y:.515625},{x:.921875,y:.515625},{x:.921875,y:.515625},{x:.953125,y:.515625},{x:.953125,y:.515625},{x:.984375,y:.515625},{x:.984375,y:.515625},{x:.015625,y:.546875},{x:.015625,y:.546875},{x:.046875,y:.546875},{x:.046875,y:.546875},{x:.078125,y:.546875},{x:.078125,y:.546875},{x:.109375,y:.546875},{x:.109375,y:.546875},{x:.140625,y:.546875},{x:.140625,y:.546875},{x:.171875,y:.546875},{x:.171875,y:.546875},{x:.203125,y:.546875},{x:.203125,y:.546875},{x:.234375,y:.546875},{x:.234375,y:.546875},{x:.265625,y:.546875},{x:.265625,y:.546875},{x:.296875,y:.546875},{x:.296875,y:.546875},{x:.328125,y:.546875},{x:.328125,y:.546875},{x:.359375,y:.546875},{x:.359375,y:.546875},{x:.390625,y:.546875},{x:.390625,y:.546875},{x:.421875,y:.546875},{x:.421875,y:.546875},{x:.453125,y:.546875},{x:.453125,y:.546875},{x:.484375,y:.546875},{x:.484375,y:.546875},{x:.515625,y:.546875},{x:.515625,y:.546875},{x:.546875,y:.546875},{x:.546875,y:.546875},{x:.578125,y:.546875},{x:.578125,y:.546875},{x:.609375,y:.546875},{x:.609375,y:.546875},{x:.640625,y:.546875},{x:.640625,y:.546875},{x:.671875,y:.546875},{x:.671875,y:.546875},{x:.703125,y:.546875},{x:.703125,y:.546875},{x:.734375,y:.546875},{x:.734375,y:.546875},{x:.765625,y:.546875},{x:.765625,y:.546875},{x:.796875,y:.546875},{x:.796875,y:.546875},{x:.828125,y:.546875},{x:.828125,y:.546875},{x:.859375,y:.546875},{x:.859375,y:.546875},{x:.890625,y:.546875},{x:.890625,y:.546875},{x:.921875,y:.546875},{x:.921875,y:.546875},{x:.953125,y:.546875},{x:.953125,y:.546875},{x:.984375,y:.546875},{x:.984375,y:.546875},{x:.015625,y:.578125},{x:.015625,y:.578125},{x:.046875,y:.578125},{x:.046875,y:.578125},{x:.078125,y:.578125},{x:.078125,y:.578125},{x:.109375,y:.578125},{x:.109375,y:.578125},{x:.140625,y:.578125},{x:.140625,y:.578125},{x:.171875,y:.578125},{x:.171875,y:.578125},{x:.203125,y:.578125},{x:.203125,y:.578125},{x:.234375,y:.578125},{x:.234375,y:.578125},{x:.265625,y:.578125},{x:.265625,y:.578125},{x:.296875,y:.578125},{x:.296875,y:.578125},{x:.328125,y:.578125},{x:.328125,y:.578125},{x:.359375,y:.578125},{x:.359375,y:.578125},{x:.390625,y:.578125},{x:.390625,y:.578125},{x:.421875,y:.578125},{x:.421875,y:.578125},{x:.453125,y:.578125},{x:.453125,y:.578125},{x:.484375,y:.578125},{x:.484375,y:.578125},{x:.515625,y:.578125},{x:.515625,y:.578125},{x:.546875,y:.578125},{x:.546875,y:.578125},{x:.578125,y:.578125},{x:.578125,y:.578125},{x:.609375,y:.578125},{x:.609375,y:.578125},{x:.640625,y:.578125},{x:.640625,y:.578125},{x:.671875,y:.578125},{x:.671875,y:.578125},{x:.703125,y:.578125},{x:.703125,y:.578125},{x:.734375,y:.578125},{x:.734375,y:.578125},{x:.765625,y:.578125},{x:.765625,y:.578125},{x:.796875,y:.578125},{x:.796875,y:.578125},{x:.828125,y:.578125},{x:.828125,y:.578125},{x:.859375,y:.578125},{x:.859375,y:.578125},{x:.890625,y:.578125},{x:.890625,y:.578125},{x:.921875,y:.578125},{x:.921875,y:.578125},{x:.953125,y:.578125},{x:.953125,y:.578125},{x:.984375,y:.578125},{x:.984375,y:.578125},{x:.015625,y:.609375},{x:.015625,y:.609375},{x:.046875,y:.609375},{x:.046875,y:.609375},{x:.078125,y:.609375},{x:.078125,y:.609375},{x:.109375,y:.609375},{x:.109375,y:.609375},{x:.140625,y:.609375},{x:.140625,y:.609375},{x:.171875,y:.609375},{x:.171875,y:.609375},{x:.203125,y:.609375},{x:.203125,y:.609375},{x:.234375,y:.609375},{x:.234375,y:.609375},{x:.265625,y:.609375},{x:.265625,y:.609375},{x:.296875,y:.609375},{x:.296875,y:.609375},{x:.328125,y:.609375},{x:.328125,y:.609375},{x:.359375,y:.609375},{x:.359375,y:.609375},{x:.390625,y:.609375},{x:.390625,y:.609375},{x:.421875,y:.609375},{x:.421875,y:.609375},{x:.453125,y:.609375},{x:.453125,y:.609375},{x:.484375,y:.609375},{x:.484375,y:.609375},{x:.515625,y:.609375},{x:.515625,y:.609375},{x:.546875,y:.609375},{x:.546875,y:.609375},{x:.578125,y:.609375},{x:.578125,y:.609375},{x:.609375,y:.609375},{x:.609375,y:.609375},{x:.640625,y:.609375},{x:.640625,y:.609375},{x:.671875,y:.609375},{x:.671875,y:.609375},{x:.703125,y:.609375},{x:.703125,y:.609375},{x:.734375,y:.609375},{x:.734375,y:.609375},{x:.765625,y:.609375},{x:.765625,y:.609375},{x:.796875,y:.609375},{x:.796875,y:.609375},{x:.828125,y:.609375},{x:.828125,y:.609375},{x:.859375,y:.609375},{x:.859375,y:.609375},{x:.890625,y:.609375},{x:.890625,y:.609375},{x:.921875,y:.609375},{x:.921875,y:.609375},{x:.953125,y:.609375},{x:.953125,y:.609375},{x:.984375,y:.609375},{x:.984375,y:.609375},{x:.015625,y:.640625},{x:.015625,y:.640625},{x:.046875,y:.640625},{x:.046875,y:.640625},{x:.078125,y:.640625},{x:.078125,y:.640625},{x:.109375,y:.640625},{x:.109375,y:.640625},{x:.140625,y:.640625},{x:.140625,y:.640625},{x:.171875,y:.640625},{x:.171875,y:.640625},{x:.203125,y:.640625},{x:.203125,y:.640625},{x:.234375,y:.640625},{x:.234375,y:.640625},{x:.265625,y:.640625},{x:.265625,y:.640625},{x:.296875,y:.640625},{x:.296875,y:.640625},{x:.328125,y:.640625},{x:.328125,y:.640625},{x:.359375,y:.640625},{x:.359375,y:.640625},{x:.390625,y:.640625},{x:.390625,y:.640625},{x:.421875,y:.640625},{x:.421875,y:.640625},{x:.453125,y:.640625},{x:.453125,y:.640625},{x:.484375,y:.640625},{x:.484375,y:.640625},{x:.515625,y:.640625},{x:.515625,y:.640625},{x:.546875,y:.640625},{x:.546875,y:.640625},{x:.578125,y:.640625},{x:.578125,y:.640625},{x:.609375,y:.640625},{x:.609375,y:.640625},{x:.640625,y:.640625},{x:.640625,y:.640625},{x:.671875,y:.640625},{x:.671875,y:.640625},{x:.703125,y:.640625},{x:.703125,y:.640625},{x:.734375,y:.640625},{x:.734375,y:.640625},{x:.765625,y:.640625},{x:.765625,y:.640625},{x:.796875,y:.640625},{x:.796875,y:.640625},{x:.828125,y:.640625},{x:.828125,y:.640625},{x:.859375,y:.640625},{x:.859375,y:.640625},{x:.890625,y:.640625},{x:.890625,y:.640625},{x:.921875,y:.640625},{x:.921875,y:.640625},{x:.953125,y:.640625},{x:.953125,y:.640625},{x:.984375,y:.640625},{x:.984375,y:.640625},{x:.015625,y:.671875},{x:.015625,y:.671875},{x:.046875,y:.671875},{x:.046875,y:.671875},{x:.078125,y:.671875},{x:.078125,y:.671875},{x:.109375,y:.671875},{x:.109375,y:.671875},{x:.140625,y:.671875},{x:.140625,y:.671875},{x:.171875,y:.671875},{x:.171875,y:.671875},{x:.203125,y:.671875},{x:.203125,y:.671875},{x:.234375,y:.671875},{x:.234375,y:.671875},{x:.265625,y:.671875},{x:.265625,y:.671875},{x:.296875,y:.671875},{x:.296875,y:.671875},{x:.328125,y:.671875},{x:.328125,y:.671875},{x:.359375,y:.671875},{x:.359375,y:.671875},{x:.390625,y:.671875},{x:.390625,y:.671875},{x:.421875,y:.671875},{x:.421875,y:.671875},{x:.453125,y:.671875},{x:.453125,y:.671875},{x:.484375,y:.671875},{x:.484375,y:.671875},{x:.515625,y:.671875},{x:.515625,y:.671875},{x:.546875,y:.671875},{x:.546875,y:.671875},{x:.578125,y:.671875},{x:.578125,y:.671875},{x:.609375,y:.671875},{x:.609375,y:.671875},{x:.640625,y:.671875},{x:.640625,y:.671875},{x:.671875,y:.671875},{x:.671875,y:.671875},{x:.703125,y:.671875},{x:.703125,y:.671875},{x:.734375,y:.671875},{x:.734375,y:.671875},{x:.765625,y:.671875},{x:.765625,y:.671875},{x:.796875,y:.671875},{x:.796875,y:.671875},{x:.828125,y:.671875},{x:.828125,y:.671875},{x:.859375,y:.671875},{x:.859375,y:.671875},{x:.890625,y:.671875},{x:.890625,y:.671875},{x:.921875,y:.671875},{x:.921875,y:.671875},{x:.953125,y:.671875},{x:.953125,y:.671875},{x:.984375,y:.671875},{x:.984375,y:.671875},{x:.015625,y:.703125},{x:.015625,y:.703125},{x:.046875,y:.703125},{x:.046875,y:.703125},{x:.078125,y:.703125},{x:.078125,y:.703125},{x:.109375,y:.703125},{x:.109375,y:.703125},{x:.140625,y:.703125},{x:.140625,y:.703125},{x:.171875,y:.703125},{x:.171875,y:.703125},{x:.203125,y:.703125},{x:.203125,y:.703125},{x:.234375,y:.703125},{x:.234375,y:.703125},{x:.265625,y:.703125},{x:.265625,y:.703125},{x:.296875,y:.703125},{x:.296875,y:.703125},{x:.328125,y:.703125},{x:.328125,y:.703125},{x:.359375,y:.703125},{x:.359375,y:.703125},{x:.390625,y:.703125},{x:.390625,y:.703125},{x:.421875,y:.703125},{x:.421875,y:.703125},{x:.453125,y:.703125},{x:.453125,y:.703125},{x:.484375,y:.703125},{x:.484375,y:.703125},{x:.515625,y:.703125},{x:.515625,y:.703125},{x:.546875,y:.703125},{x:.546875,y:.703125},{x:.578125,y:.703125},{x:.578125,y:.703125},{x:.609375,y:.703125},{x:.609375,y:.703125},{x:.640625,y:.703125},{x:.640625,y:.703125},{x:.671875,y:.703125},{x:.671875,y:.703125},{x:.703125,y:.703125},{x:.703125,y:.703125},{x:.734375,y:.703125},{x:.734375,y:.703125},{x:.765625,y:.703125},{x:.765625,y:.703125},{x:.796875,y:.703125},{x:.796875,y:.703125},{x:.828125,y:.703125},{x:.828125,y:.703125},{x:.859375,y:.703125},{x:.859375,y:.703125},{x:.890625,y:.703125},{x:.890625,y:.703125},{x:.921875,y:.703125},{x:.921875,y:.703125},{x:.953125,y:.703125},{x:.953125,y:.703125},{x:.984375,y:.703125},{x:.984375,y:.703125},{x:.015625,y:.734375},{x:.015625,y:.734375},{x:.046875,y:.734375},{x:.046875,y:.734375},{x:.078125,y:.734375},{x:.078125,y:.734375},{x:.109375,y:.734375},{x:.109375,y:.734375},{x:.140625,y:.734375},{x:.140625,y:.734375},{x:.171875,y:.734375},{x:.171875,y:.734375},{x:.203125,y:.734375},{x:.203125,y:.734375},{x:.234375,y:.734375},{x:.234375,y:.734375},{x:.265625,y:.734375},{x:.265625,y:.734375},{x:.296875,y:.734375},{x:.296875,y:.734375},{x:.328125,y:.734375},{x:.328125,y:.734375},{x:.359375,y:.734375},{x:.359375,y:.734375},{x:.390625,y:.734375},{x:.390625,y:.734375},{x:.421875,y:.734375},{x:.421875,y:.734375},{x:.453125,y:.734375},{x:.453125,y:.734375},{x:.484375,y:.734375},{x:.484375,y:.734375},{x:.515625,y:.734375},{x:.515625,y:.734375},{x:.546875,y:.734375},{x:.546875,y:.734375},{x:.578125,y:.734375},{x:.578125,y:.734375},{x:.609375,y:.734375},{x:.609375,y:.734375},{x:.640625,y:.734375},{x:.640625,y:.734375},{x:.671875,y:.734375},{x:.671875,y:.734375},{x:.703125,y:.734375},{x:.703125,y:.734375},{x:.734375,y:.734375},{x:.734375,y:.734375},{x:.765625,y:.734375},{x:.765625,y:.734375},{x:.796875,y:.734375},{x:.796875,y:.734375},{x:.828125,y:.734375},{x:.828125,y:.734375},{x:.859375,y:.734375},{x:.859375,y:.734375},{x:.890625,y:.734375},{x:.890625,y:.734375},{x:.921875,y:.734375},{x:.921875,y:.734375},{x:.953125,y:.734375},{x:.953125,y:.734375},{x:.984375,y:.734375},{x:.984375,y:.734375},{x:.015625,y:.765625},{x:.015625,y:.765625},{x:.046875,y:.765625},{x:.046875,y:.765625},{x:.078125,y:.765625},{x:.078125,y:.765625},{x:.109375,y:.765625},{x:.109375,y:.765625},{x:.140625,y:.765625},{x:.140625,y:.765625},{x:.171875,y:.765625},{x:.171875,y:.765625},{x:.203125,y:.765625},{x:.203125,y:.765625},{x:.234375,y:.765625},{x:.234375,y:.765625},{x:.265625,y:.765625},{x:.265625,y:.765625},{x:.296875,y:.765625},{x:.296875,y:.765625},{x:.328125,y:.765625},{x:.328125,y:.765625},{x:.359375,y:.765625},{x:.359375,y:.765625},{x:.390625,y:.765625},{x:.390625,y:.765625},{x:.421875,y:.765625},{x:.421875,y:.765625},{x:.453125,y:.765625},{x:.453125,y:.765625},{x:.484375,y:.765625},{x:.484375,y:.765625},{x:.515625,y:.765625},{x:.515625,y:.765625},{x:.546875,y:.765625},{x:.546875,y:.765625},{x:.578125,y:.765625},{x:.578125,y:.765625},{x:.609375,y:.765625},{x:.609375,y:.765625},{x:.640625,y:.765625},{x:.640625,y:.765625},{x:.671875,y:.765625},{x:.671875,y:.765625},{x:.703125,y:.765625},{x:.703125,y:.765625},{x:.734375,y:.765625},{x:.734375,y:.765625},{x:.765625,y:.765625},{x:.765625,y:.765625},{x:.796875,y:.765625},{x:.796875,y:.765625},{x:.828125,y:.765625},{x:.828125,y:.765625},{x:.859375,y:.765625},{x:.859375,y:.765625},{x:.890625,y:.765625},{x:.890625,y:.765625},{x:.921875,y:.765625},{x:.921875,y:.765625},{x:.953125,y:.765625},{x:.953125,y:.765625},{x:.984375,y:.765625},{x:.984375,y:.765625},{x:.015625,y:.796875},{x:.015625,y:.796875},{x:.046875,y:.796875},{x:.046875,y:.796875},{x:.078125,y:.796875},{x:.078125,y:.796875},{x:.109375,y:.796875},{x:.109375,y:.796875},{x:.140625,y:.796875},{x:.140625,y:.796875},{x:.171875,y:.796875},{x:.171875,y:.796875},{x:.203125,y:.796875},{x:.203125,y:.796875},{x:.234375,y:.796875},{x:.234375,y:.796875},{x:.265625,y:.796875},{x:.265625,y:.796875},{x:.296875,y:.796875},{x:.296875,y:.796875},{x:.328125,y:.796875},{x:.328125,y:.796875},{x:.359375,y:.796875},{x:.359375,y:.796875},{x:.390625,y:.796875},{x:.390625,y:.796875},{x:.421875,y:.796875},{x:.421875,y:.796875},{x:.453125,y:.796875},{x:.453125,y:.796875},{x:.484375,y:.796875},{x:.484375,y:.796875},{x:.515625,y:.796875},{x:.515625,y:.796875},{x:.546875,y:.796875},{x:.546875,y:.796875},{x:.578125,y:.796875},{x:.578125,y:.796875},{x:.609375,y:.796875},{x:.609375,y:.796875},{x:.640625,y:.796875},{x:.640625,y:.796875},{x:.671875,y:.796875},{x:.671875,y:.796875},{x:.703125,y:.796875},{x:.703125,y:.796875},{x:.734375,y:.796875},{x:.734375,y:.796875},{x:.765625,y:.796875},{x:.765625,y:.796875},{x:.796875,y:.796875},{x:.796875,y:.796875},{x:.828125,y:.796875},{x:.828125,y:.796875},{x:.859375,y:.796875},{x:.859375,y:.796875},{x:.890625,y:.796875},{x:.890625,y:.796875},{x:.921875,y:.796875},{x:.921875,y:.796875},{x:.953125,y:.796875},{x:.953125,y:.796875},{x:.984375,y:.796875},{x:.984375,y:.796875},{x:.015625,y:.828125},{x:.015625,y:.828125},{x:.046875,y:.828125},{x:.046875,y:.828125},{x:.078125,y:.828125},{x:.078125,y:.828125},{x:.109375,y:.828125},{x:.109375,y:.828125},{x:.140625,y:.828125},{x:.140625,y:.828125},{x:.171875,y:.828125},{x:.171875,y:.828125},{x:.203125,y:.828125},{x:.203125,y:.828125},{x:.234375,y:.828125},{x:.234375,y:.828125},{x:.265625,y:.828125},{x:.265625,y:.828125},{x:.296875,y:.828125},{x:.296875,y:.828125},{x:.328125,y:.828125},{x:.328125,y:.828125},{x:.359375,y:.828125},{x:.359375,y:.828125},{x:.390625,y:.828125},{x:.390625,y:.828125},{x:.421875,y:.828125},{x:.421875,y:.828125},{x:.453125,y:.828125},{x:.453125,y:.828125},{x:.484375,y:.828125},{x:.484375,y:.828125},{x:.515625,y:.828125},{x:.515625,y:.828125},{x:.546875,y:.828125},{x:.546875,y:.828125},{x:.578125,y:.828125},{x:.578125,y:.828125},{x:.609375,y:.828125},{x:.609375,y:.828125},{x:.640625,y:.828125},{x:.640625,y:.828125},{x:.671875,y:.828125},{x:.671875,y:.828125},{x:.703125,y:.828125},{x:.703125,y:.828125},{x:.734375,y:.828125},{x:.734375,y:.828125},{x:.765625,y:.828125},{x:.765625,y:.828125},{x:.796875,y:.828125},{x:.796875,y:.828125},{x:.828125,y:.828125},{x:.828125,y:.828125},{x:.859375,y:.828125},{x:.859375,y:.828125},{x:.890625,y:.828125},{x:.890625,y:.828125},{x:.921875,y:.828125},{x:.921875,y:.828125},{x:.953125,y:.828125},{x:.953125,y:.828125},{x:.984375,y:.828125},{x:.984375,y:.828125},{x:.015625,y:.859375},{x:.015625,y:.859375},{x:.046875,y:.859375},{x:.046875,y:.859375},{x:.078125,y:.859375},{x:.078125,y:.859375},{x:.109375,y:.859375},{x:.109375,y:.859375},{x:.140625,y:.859375},{x:.140625,y:.859375},{x:.171875,y:.859375},{x:.171875,y:.859375},{x:.203125,y:.859375},{x:.203125,y:.859375},{x:.234375,y:.859375},{x:.234375,y:.859375},{x:.265625,y:.859375},{x:.265625,y:.859375},{x:.296875,y:.859375},{x:.296875,y:.859375},{x:.328125,y:.859375},{x:.328125,y:.859375},{x:.359375,y:.859375},{x:.359375,y:.859375},{x:.390625,y:.859375},{x:.390625,y:.859375},{x:.421875,y:.859375},{x:.421875,y:.859375},{x:.453125,y:.859375},{x:.453125,y:.859375},{x:.484375,y:.859375},{x:.484375,y:.859375},{x:.515625,y:.859375},{x:.515625,y:.859375},{x:.546875,y:.859375},{x:.546875,y:.859375},{x:.578125,y:.859375},{x:.578125,y:.859375},{x:.609375,y:.859375},{x:.609375,y:.859375},{x:.640625,y:.859375},{x:.640625,y:.859375},{x:.671875,y:.859375},{x:.671875,y:.859375},{x:.703125,y:.859375},{x:.703125,y:.859375},{x:.734375,y:.859375},{x:.734375,y:.859375},{x:.765625,y:.859375},{x:.765625,y:.859375},{x:.796875,y:.859375},{x:.796875,y:.859375},{x:.828125,y:.859375},{x:.828125,y:.859375},{x:.859375,y:.859375},{x:.859375,y:.859375},{x:.890625,y:.859375},{x:.890625,y:.859375},{x:.921875,y:.859375},{x:.921875,y:.859375},{x:.953125,y:.859375},{x:.953125,y:.859375},{x:.984375,y:.859375},{x:.984375,y:.859375},{x:.015625,y:.890625},{x:.015625,y:.890625},{x:.046875,y:.890625},{x:.046875,y:.890625},{x:.078125,y:.890625},{x:.078125,y:.890625},{x:.109375,y:.890625},{x:.109375,y:.890625},{x:.140625,y:.890625},{x:.140625,y:.890625},{x:.171875,y:.890625},{x:.171875,y:.890625},{x:.203125,y:.890625},{x:.203125,y:.890625},{x:.234375,y:.890625},{x:.234375,y:.890625},{x:.265625,y:.890625},{x:.265625,y:.890625},{x:.296875,y:.890625},{x:.296875,y:.890625},{x:.328125,y:.890625},{x:.328125,y:.890625},{x:.359375,y:.890625},{x:.359375,y:.890625},{x:.390625,y:.890625},{x:.390625,y:.890625},{x:.421875,y:.890625},{x:.421875,y:.890625},{x:.453125,y:.890625},{x:.453125,y:.890625},{x:.484375,y:.890625},{x:.484375,y:.890625},{x:.515625,y:.890625},{x:.515625,y:.890625},{x:.546875,y:.890625},{x:.546875,y:.890625},{x:.578125,y:.890625},{x:.578125,y:.890625},{x:.609375,y:.890625},{x:.609375,y:.890625},{x:.640625,y:.890625},{x:.640625,y:.890625},{x:.671875,y:.890625},{x:.671875,y:.890625},{x:.703125,y:.890625},{x:.703125,y:.890625},{x:.734375,y:.890625},{x:.734375,y:.890625},{x:.765625,y:.890625},{x:.765625,y:.890625},{x:.796875,y:.890625},{x:.796875,y:.890625},{x:.828125,y:.890625},{x:.828125,y:.890625},{x:.859375,y:.890625},{x:.859375,y:.890625},{x:.890625,y:.890625},{x:.890625,y:.890625},{x:.921875,y:.890625},{x:.921875,y:.890625},{x:.953125,y:.890625},{x:.953125,y:.890625},{x:.984375,y:.890625},{x:.984375,y:.890625},{x:.015625,y:.921875},{x:.015625,y:.921875},{x:.046875,y:.921875},{x:.046875,y:.921875},{x:.078125,y:.921875},{x:.078125,y:.921875},{x:.109375,y:.921875},{x:.109375,y:.921875},{x:.140625,y:.921875},{x:.140625,y:.921875},{x:.171875,y:.921875},{x:.171875,y:.921875},{x:.203125,y:.921875},{x:.203125,y:.921875},{x:.234375,y:.921875},{x:.234375,y:.921875},{x:.265625,y:.921875},{x:.265625,y:.921875},{x:.296875,y:.921875},{x:.296875,y:.921875},{x:.328125,y:.921875},{x:.328125,y:.921875},{x:.359375,y:.921875},{x:.359375,y:.921875},{x:.390625,y:.921875},{x:.390625,y:.921875},{x:.421875,y:.921875},{x:.421875,y:.921875},{x:.453125,y:.921875},{x:.453125,y:.921875},{x:.484375,y:.921875},{x:.484375,y:.921875},{x:.515625,y:.921875},{x:.515625,y:.921875},{x:.546875,y:.921875},{x:.546875,y:.921875},{x:.578125,y:.921875},{x:.578125,y:.921875},{x:.609375,y:.921875},{x:.609375,y:.921875},{x:.640625,y:.921875},{x:.640625,y:.921875},{x:.671875,y:.921875},{x:.671875,y:.921875},{x:.703125,y:.921875},{x:.703125,y:.921875},{x:.734375,y:.921875},{x:.734375,y:.921875},{x:.765625,y:.921875},{x:.765625,y:.921875},{x:.796875,y:.921875},{x:.796875,y:.921875},{x:.828125,y:.921875},{x:.828125,y:.921875},{x:.859375,y:.921875},{x:.859375,y:.921875},{x:.890625,y:.921875},{x:.890625,y:.921875},{x:.921875,y:.921875},{x:.921875,y:.921875},{x:.953125,y:.921875},{x:.953125,y:.921875},{x:.984375,y:.921875},{x:.984375,y:.921875},{x:.015625,y:.953125},{x:.015625,y:.953125},{x:.046875,y:.953125},{x:.046875,y:.953125},{x:.078125,y:.953125},{x:.078125,y:.953125},{x:.109375,y:.953125},{x:.109375,y:.953125},{x:.140625,y:.953125},{x:.140625,y:.953125},{x:.171875,y:.953125},{x:.171875,y:.953125},{x:.203125,y:.953125},{x:.203125,y:.953125},{x:.234375,y:.953125},{x:.234375,y:.953125},{x:.265625,y:.953125},{x:.265625,y:.953125},{x:.296875,y:.953125},{x:.296875,y:.953125},{x:.328125,y:.953125},{x:.328125,y:.953125},{x:.359375,y:.953125},{x:.359375,y:.953125},{x:.390625,y:.953125},{x:.390625,y:.953125},{x:.421875,y:.953125},{x:.421875,y:.953125},{x:.453125,y:.953125},{x:.453125,y:.953125},{x:.484375,y:.953125},{x:.484375,y:.953125},{x:.515625,y:.953125},{x:.515625,y:.953125},{x:.546875,y:.953125},{x:.546875,y:.953125},{x:.578125,y:.953125},{x:.578125,y:.953125},{x:.609375,y:.953125},{x:.609375,y:.953125},{x:.640625,y:.953125},{x:.640625,y:.953125},{x:.671875,y:.953125},{x:.671875,y:.953125},{x:.703125,y:.953125},{x:.703125,y:.953125},{x:.734375,y:.953125},{x:.734375,y:.953125},{x:.765625,y:.953125},{x:.765625,y:.953125},{x:.796875,y:.953125},{x:.796875,y:.953125},{x:.828125,y:.953125},{x:.828125,y:.953125},{x:.859375,y:.953125},{x:.859375,y:.953125},{x:.890625,y:.953125},{x:.890625,y:.953125},{x:.921875,y:.953125},{x:.921875,y:.953125},{x:.953125,y:.953125},{x:.953125,y:.953125},{x:.984375,y:.953125},{x:.984375,y:.953125},{x:.015625,y:.984375},{x:.015625,y:.984375},{x:.046875,y:.984375},{x:.046875,y:.984375},{x:.078125,y:.984375},{x:.078125,y:.984375},{x:.109375,y:.984375},{x:.109375,y:.984375},{x:.140625,y:.984375},{x:.140625,y:.984375},{x:.171875,y:.984375},{x:.171875,y:.984375},{x:.203125,y:.984375},{x:.203125,y:.984375},{x:.234375,y:.984375},{x:.234375,y:.984375},{x:.265625,y:.984375},{x:.265625,y:.984375},{x:.296875,y:.984375},{x:.296875,y:.984375},{x:.328125,y:.984375},{x:.328125,y:.984375},{x:.359375,y:.984375},{x:.359375,y:.984375},{x:.390625,y:.984375},{x:.390625,y:.984375},{x:.421875,y:.984375},{x:.421875,y:.984375},{x:.453125,y:.984375},{x:.453125,y:.984375},{x:.484375,y:.984375},{x:.484375,y:.984375},{x:.515625,y:.984375},{x:.515625,y:.984375},{x:.546875,y:.984375},{x:.546875,y:.984375},{x:.578125,y:.984375},{x:.578125,y:.984375},{x:.609375,y:.984375},{x:.609375,y:.984375},{x:.640625,y:.984375},{x:.640625,y:.984375},{x:.671875,y:.984375},{x:.671875,y:.984375},{x:.703125,y:.984375},{x:.703125,y:.984375},{x:.734375,y:.984375},{x:.734375,y:.984375},{x:.765625,y:.984375},{x:.765625,y:.984375},{x:.796875,y:.984375},{x:.796875,y:.984375},{x:.828125,y:.984375},{x:.828125,y:.984375},{x:.859375,y:.984375},{x:.859375,y:.984375},{x:.890625,y:.984375},{x:.890625,y:.984375},{x:.921875,y:.984375},{x:.921875,y:.984375},{x:.953125,y:.984375},{x:.953125,y:.984375},{x:.984375,y:.984375},{x:.984375,y:.984375},{x:.03125,y:.03125},{x:.03125,y:.03125},{x:.09375,y:.03125},{x:.09375,y:.03125},{x:.15625,y:.03125},{x:.15625,y:.03125},{x:.21875,y:.03125},{x:.21875,y:.03125},{x:.28125,y:.03125},{x:.28125,y:.03125},{x:.34375,y:.03125},{x:.34375,y:.03125},{x:.40625,y:.03125},{x:.40625,y:.03125},{x:.46875,y:.03125},{x:.46875,y:.03125},{x:.53125,y:.03125},{x:.53125,y:.03125},{x:.59375,y:.03125},{x:.59375,y:.03125},{x:.65625,y:.03125},{x:.65625,y:.03125},{x:.71875,y:.03125},{x:.71875,y:.03125},{x:.78125,y:.03125},{x:.78125,y:.03125},{x:.84375,y:.03125},{x:.84375,y:.03125},{x:.90625,y:.03125},{x:.90625,y:.03125},{x:.96875,y:.03125},{x:.96875,y:.03125},{x:.03125,y:.09375},{x:.03125,y:.09375},{x:.09375,y:.09375},{x:.09375,y:.09375},{x:.15625,y:.09375},{x:.15625,y:.09375},{x:.21875,y:.09375},{x:.21875,y:.09375},{x:.28125,y:.09375},{x:.28125,y:.09375},{x:.34375,y:.09375},{x:.34375,y:.09375},{x:.40625,y:.09375},{x:.40625,y:.09375},{x:.46875,y:.09375},{x:.46875,y:.09375},{x:.53125,y:.09375},{x:.53125,y:.09375},{x:.59375,y:.09375},{x:.59375,y:.09375},{x:.65625,y:.09375},{x:.65625,y:.09375},{x:.71875,y:.09375},{x:.71875,y:.09375},{x:.78125,y:.09375},{x:.78125,y:.09375},{x:.84375,y:.09375},{x:.84375,y:.09375},{x:.90625,y:.09375},{x:.90625,y:.09375},{x:.96875,y:.09375},{x:.96875,y:.09375},{x:.03125,y:.15625},{x:.03125,y:.15625},{x:.09375,y:.15625},{x:.09375,y:.15625},{x:.15625,y:.15625},{x:.15625,y:.15625},{x:.21875,y:.15625},{x:.21875,y:.15625},{x:.28125,y:.15625},{x:.28125,y:.15625},{x:.34375,y:.15625},{x:.34375,y:.15625},{x:.40625,y:.15625},{x:.40625,y:.15625},{x:.46875,y:.15625},{x:.46875,y:.15625},{x:.53125,y:.15625},{x:.53125,y:.15625},{x:.59375,y:.15625},{x:.59375,y:.15625},{x:.65625,y:.15625},{x:.65625,y:.15625},{x:.71875,y:.15625},{x:.71875,y:.15625},{x:.78125,y:.15625},{x:.78125,y:.15625},{x:.84375,y:.15625},{x:.84375,y:.15625},{x:.90625,y:.15625},{x:.90625,y:.15625},{x:.96875,y:.15625},{x:.96875,y:.15625},{x:.03125,y:.21875},{x:.03125,y:.21875},{x:.09375,y:.21875},{x:.09375,y:.21875},{x:.15625,y:.21875},{x:.15625,y:.21875},{x:.21875,y:.21875},{x:.21875,y:.21875},{x:.28125,y:.21875},{x:.28125,y:.21875},{x:.34375,y:.21875},{x:.34375,y:.21875},{x:.40625,y:.21875},{x:.40625,y:.21875},{x:.46875,y:.21875},{x:.46875,y:.21875},{x:.53125,y:.21875},{x:.53125,y:.21875},{x:.59375,y:.21875},{x:.59375,y:.21875},{x:.65625,y:.21875},{x:.65625,y:.21875},{x:.71875,y:.21875},{x:.71875,y:.21875},{x:.78125,y:.21875},{x:.78125,y:.21875},{x:.84375,y:.21875},{x:.84375,y:.21875},{x:.90625,y:.21875},{x:.90625,y:.21875},{x:.96875,y:.21875},{x:.96875,y:.21875},{x:.03125,y:.28125},{x:.03125,y:.28125},{x:.09375,y:.28125},{x:.09375,y:.28125},{x:.15625,y:.28125},{x:.15625,y:.28125},{x:.21875,y:.28125},{x:.21875,y:.28125},{x:.28125,y:.28125},{x:.28125,y:.28125},{x:.34375,y:.28125},{x:.34375,y:.28125},{x:.40625,y:.28125},{x:.40625,y:.28125},{x:.46875,y:.28125},{x:.46875,y:.28125},{x:.53125,y:.28125},{x:.53125,y:.28125},{x:.59375,y:.28125},{x:.59375,y:.28125},{x:.65625,y:.28125},{x:.65625,y:.28125},{x:.71875,y:.28125},{x:.71875,y:.28125},{x:.78125,y:.28125},{x:.78125,y:.28125},{x:.84375,y:.28125},{x:.84375,y:.28125},{x:.90625,y:.28125},{x:.90625,y:.28125},{x:.96875,y:.28125},{x:.96875,y:.28125},{x:.03125,y:.34375},{x:.03125,y:.34375},{x:.09375,y:.34375},{x:.09375,y:.34375},{x:.15625,y:.34375},{x:.15625,y:.34375},{x:.21875,y:.34375},{x:.21875,y:.34375},{x:.28125,y:.34375},{x:.28125,y:.34375},{x:.34375,y:.34375},{x:.34375,y:.34375},{x:.40625,y:.34375},{x:.40625,y:.34375},{x:.46875,y:.34375},{x:.46875,y:.34375},{x:.53125,y:.34375},{x:.53125,y:.34375},{x:.59375,y:.34375},{x:.59375,y:.34375},{x:.65625,y:.34375},{x:.65625,y:.34375},{x:.71875,y:.34375},{x:.71875,y:.34375},{x:.78125,y:.34375},{x:.78125,y:.34375},{x:.84375,y:.34375},{x:.84375,y:.34375},{x:.90625,y:.34375},{x:.90625,y:.34375},{x:.96875,y:.34375},{x:.96875,y:.34375},{x:.03125,y:.40625},{x:.03125,y:.40625},{x:.09375,y:.40625},{x:.09375,y:.40625},{x:.15625,y:.40625},{x:.15625,y:.40625},{x:.21875,y:.40625},{x:.21875,y:.40625},{x:.28125,y:.40625},{x:.28125,y:.40625},{x:.34375,y:.40625},{x:.34375,y:.40625},{x:.40625,y:.40625},{x:.40625,y:.40625},{x:.46875,y:.40625},{x:.46875,y:.40625},{x:.53125,y:.40625},{x:.53125,y:.40625},{x:.59375,y:.40625},{x:.59375,y:.40625},{x:.65625,y:.40625},{x:.65625,y:.40625},{x:.71875,y:.40625},{x:.71875,y:.40625},{x:.78125,y:.40625},{x:.78125,y:.40625},{x:.84375,y:.40625},{x:.84375,y:.40625},{x:.90625,y:.40625},{x:.90625,y:.40625},{x:.96875,y:.40625},{x:.96875,y:.40625},{x:.03125,y:.46875},{x:.03125,y:.46875},{x:.09375,y:.46875},{x:.09375,y:.46875},{x:.15625,y:.46875},{x:.15625,y:.46875},{x:.21875,y:.46875},{x:.21875,y:.46875},{x:.28125,y:.46875},{x:.28125,y:.46875},{x:.34375,y:.46875},{x:.34375,y:.46875},{x:.40625,y:.46875},{x:.40625,y:.46875},{x:.46875,y:.46875},{x:.46875,y:.46875},{x:.53125,y:.46875},{x:.53125,y:.46875},{x:.59375,y:.46875},{x:.59375,y:.46875},{x:.65625,y:.46875},{x:.65625,y:.46875},{x:.71875,y:.46875},{x:.71875,y:.46875},{x:.78125,y:.46875},{x:.78125,y:.46875},{x:.84375,y:.46875},{x:.84375,y:.46875},{x:.90625,y:.46875},{x:.90625,y:.46875},{x:.96875,y:.46875},{x:.96875,y:.46875},{x:.03125,y:.53125},{x:.03125,y:.53125},{x:.09375,y:.53125},{x:.09375,y:.53125},{x:.15625,y:.53125},{x:.15625,y:.53125},{x:.21875,y:.53125},{x:.21875,y:.53125},{x:.28125,y:.53125},{x:.28125,y:.53125},{x:.34375,y:.53125},{x:.34375,y:.53125},{x:.40625,y:.53125},{x:.40625,y:.53125},{x:.46875,y:.53125},{x:.46875,y:.53125},{x:.53125,y:.53125},{x:.53125,y:.53125},{x:.59375,y:.53125},{x:.59375,y:.53125},{x:.65625,y:.53125},{x:.65625,y:.53125},{x:.71875,y:.53125},{x:.71875,y:.53125},{x:.78125,y:.53125},{x:.78125,y:.53125},{x:.84375,y:.53125},{x:.84375,y:.53125},{x:.90625,y:.53125},{x:.90625,y:.53125},{x:.96875,y:.53125},{x:.96875,y:.53125},{x:.03125,y:.59375},{x:.03125,y:.59375},{x:.09375,y:.59375},{x:.09375,y:.59375},{x:.15625,y:.59375},{x:.15625,y:.59375},{x:.21875,y:.59375},{x:.21875,y:.59375},{x:.28125,y:.59375},{x:.28125,y:.59375},{x:.34375,y:.59375},{x:.34375,y:.59375},{x:.40625,y:.59375},{x:.40625,y:.59375},{x:.46875,y:.59375},{x:.46875,y:.59375},{x:.53125,y:.59375},{x:.53125,y:.59375},{x:.59375,y:.59375},{x:.59375,y:.59375},{x:.65625,y:.59375},{x:.65625,y:.59375},{x:.71875,y:.59375},{x:.71875,y:.59375},{x:.78125,y:.59375},{x:.78125,y:.59375},{x:.84375,y:.59375},{x:.84375,y:.59375},{x:.90625,y:.59375},{x:.90625,y:.59375},{x:.96875,y:.59375},{x:.96875,y:.59375},{x:.03125,y:.65625},{x:.03125,y:.65625},{x:.09375,y:.65625},{x:.09375,y:.65625},{x:.15625,y:.65625},{x:.15625,y:.65625},{x:.21875,y:.65625},{x:.21875,y:.65625},{x:.28125,y:.65625},{x:.28125,y:.65625},{x:.34375,y:.65625},{x:.34375,y:.65625},{x:.40625,y:.65625},{x:.40625,y:.65625},{x:.46875,y:.65625},{x:.46875,y:.65625},{x:.53125,y:.65625},{x:.53125,y:.65625},{x:.59375,y:.65625},{x:.59375,y:.65625},{x:.65625,y:.65625},{x:.65625,y:.65625},{x:.71875,y:.65625},{x:.71875,y:.65625},{x:.78125,y:.65625},{x:.78125,y:.65625},{x:.84375,y:.65625},{x:.84375,y:.65625},{x:.90625,y:.65625},{x:.90625,y:.65625},{x:.96875,y:.65625},{x:.96875,y:.65625},{x:.03125,y:.71875},{x:.03125,y:.71875},{x:.09375,y:.71875},{x:.09375,y:.71875},{x:.15625,y:.71875},{x:.15625,y:.71875},{x:.21875,y:.71875},{x:.21875,y:.71875},{x:.28125,y:.71875},{x:.28125,y:.71875},{x:.34375,y:.71875},{x:.34375,y:.71875},{x:.40625,y:.71875},{x:.40625,y:.71875},{x:.46875,y:.71875},{x:.46875,y:.71875},{x:.53125,y:.71875},{x:.53125,y:.71875},{x:.59375,y:.71875},{x:.59375,y:.71875},{x:.65625,y:.71875},{x:.65625,y:.71875},{x:.71875,y:.71875},{x:.71875,y:.71875},{x:.78125,y:.71875},{x:.78125,y:.71875},{x:.84375,y:.71875},{x:.84375,y:.71875},{x:.90625,y:.71875},{x:.90625,y:.71875},{x:.96875,y:.71875},{x:.96875,y:.71875},{x:.03125,y:.78125},{x:.03125,y:.78125},{x:.09375,y:.78125},{x:.09375,y:.78125},{x:.15625,y:.78125},{x:.15625,y:.78125},{x:.21875,y:.78125},{x:.21875,y:.78125},{x:.28125,y:.78125},{x:.28125,y:.78125},{x:.34375,y:.78125},{x:.34375,y:.78125},{x:.40625,y:.78125},{x:.40625,y:.78125},{x:.46875,y:.78125},{x:.46875,y:.78125},{x:.53125,y:.78125},{x:.53125,y:.78125},{x:.59375,y:.78125},{x:.59375,y:.78125},{x:.65625,y:.78125},{x:.65625,y:.78125},{x:.71875,y:.78125},{x:.71875,y:.78125},{x:.78125,y:.78125},{x:.78125,y:.78125},{x:.84375,y:.78125},{x:.84375,y:.78125},{x:.90625,y:.78125},{x:.90625,y:.78125},{x:.96875,y:.78125},{x:.96875,y:.78125},{x:.03125,y:.84375},{x:.03125,y:.84375},{x:.09375,y:.84375},{x:.09375,y:.84375},{x:.15625,y:.84375},{x:.15625,y:.84375},{x:.21875,y:.84375},{x:.21875,y:.84375},{x:.28125,y:.84375},{x:.28125,y:.84375},{x:.34375,y:.84375},{x:.34375,y:.84375},{x:.40625,y:.84375},{x:.40625,y:.84375},{x:.46875,y:.84375},{x:.46875,y:.84375},{x:.53125,y:.84375},{x:.53125,y:.84375},{x:.59375,y:.84375},{x:.59375,y:.84375},{x:.65625,y:.84375},{x:.65625,y:.84375},{x:.71875,y:.84375},{x:.71875,y:.84375},{x:.78125,y:.84375},{x:.78125,y:.84375},{x:.84375,y:.84375},{x:.84375,y:.84375},{x:.90625,y:.84375},{x:.90625,y:.84375},{x:.96875,y:.84375},{x:.96875,y:.84375},{x:.03125,y:.90625},{x:.03125,y:.90625},{x:.09375,y:.90625},{x:.09375,y:.90625},{x:.15625,y:.90625},{x:.15625,y:.90625},{x:.21875,y:.90625},{x:.21875,y:.90625},{x:.28125,y:.90625},{x:.28125,y:.90625},{x:.34375,y:.90625},{x:.34375,y:.90625},{x:.40625,y:.90625},{x:.40625,y:.90625},{x:.46875,y:.90625},{x:.46875,y:.90625},{x:.53125,y:.90625},{x:.53125,y:.90625},{x:.59375,y:.90625},{x:.59375,y:.90625},{x:.65625,y:.90625},{x:.65625,y:.90625},{x:.71875,y:.90625},{x:.71875,y:.90625},{x:.78125,y:.90625},{x:.78125,y:.90625},{x:.84375,y:.90625},{x:.84375,y:.90625},{x:.90625,y:.90625},{x:.90625,y:.90625},{x:.96875,y:.90625},{x:.96875,y:.90625},{x:.03125,y:.96875},{x:.03125,y:.96875},{x:.09375,y:.96875},{x:.09375,y:.96875},{x:.15625,y:.96875},{x:.15625,y:.96875},{x:.21875,y:.96875},{x:.21875,y:.96875},{x:.28125,y:.96875},{x:.28125,y:.96875},{x:.34375,y:.96875},{x:.34375,y:.96875},{x:.40625,y:.96875},{x:.40625,y:.96875},{x:.46875,y:.96875},{x:.46875,y:.96875},{x:.53125,y:.96875},{x:.53125,y:.96875},{x:.59375,y:.96875},{x:.59375,y:.96875},{x:.65625,y:.96875},{x:.65625,y:.96875},{x:.71875,y:.96875},{x:.71875,y:.96875},{x:.78125,y:.96875},{x:.78125,y:.96875},{x:.84375,y:.96875},{x:.84375,y:.96875},{x:.90625,y:.96875},{x:.90625,y:.96875},{x:.96875,y:.96875},{x:.96875,y:.96875},{x:.0625,y:.0625},{x:.0625,y:.0625},{x:.0625,y:.0625},{x:.0625,y:.0625},{x:.0625,y:.0625},{x:.0625,y:.0625},{x:.1875,y:.0625},{x:.1875,y:.0625},{x:.1875,y:.0625},{x:.1875,y:.0625},{x:.1875,y:.0625},{x:.1875,y:.0625},{x:.3125,y:.0625},{x:.3125,y:.0625},{x:.3125,y:.0625},{x:.3125,y:.0625},{x:.3125,y:.0625},{x:.3125,y:.0625},{x:.4375,y:.0625},{x:.4375,y:.0625},{x:.4375,y:.0625},{x:.4375,y:.0625},{x:.4375,y:.0625},{x:.4375,y:.0625},{x:.5625,y:.0625},{x:.5625,y:.0625},{x:.5625,y:.0625},{x:.5625,y:.0625},{x:.5625,y:.0625},{x:.5625,y:.0625},{x:.6875,y:.0625},{x:.6875,y:.0625},{x:.6875,y:.0625},{x:.6875,y:.0625},{x:.6875,y:.0625},{x:.6875,y:.0625},{x:.8125,y:.0625},{x:.8125,y:.0625},{x:.8125,y:.0625},{x:.8125,y:.0625},{x:.8125,y:.0625},{x:.8125,y:.0625},{x:.9375,y:.0625},{x:.9375,y:.0625},{x:.9375,y:.0625},{x:.9375,y:.0625},{x:.9375,y:.0625},{x:.9375,y:.0625},{x:.0625,y:.1875},{x:.0625,y:.1875},{x:.0625,y:.1875},{x:.0625,y:.1875},{x:.0625,y:.1875},{x:.0625,y:.1875},{x:.1875,y:.1875},{x:.1875,y:.1875},{x:.1875,y:.1875},{x:.1875,y:.1875},{x:.1875,y:.1875},{x:.1875,y:.1875},{x:.3125,y:.1875},{x:.3125,y:.1875},{x:.3125,y:.1875},{x:.3125,y:.1875},{x:.3125,y:.1875},{x:.3125,y:.1875},{x:.4375,y:.1875},{x:.4375,y:.1875},{x:.4375,y:.1875},{x:.4375,y:.1875},{x:.4375,y:.1875},{x:.4375,y:.1875},{x:.5625,y:.1875},{x:.5625,y:.1875},{x:.5625,y:.1875},{x:.5625,y:.1875},{x:.5625,y:.1875},{x:.5625,y:.1875},{x:.6875,y:.1875},{x:.6875,y:.1875},{x:.6875,y:.1875},{x:.6875,y:.1875},{x:.6875,y:.1875},{x:.6875,y:.1875},{x:.8125,y:.1875},{x:.8125,y:.1875},{x:.8125,y:.1875},{x:.8125,y:.1875},{x:.8125,y:.1875},{x:.8125,y:.1875},{x:.9375,y:.1875},{x:.9375,y:.1875},{x:.9375,y:.1875},{x:.9375,y:.1875},{x:.9375,y:.1875},{x:.9375,y:.1875},{x:.0625,y:.3125},{x:.0625,y:.3125},{x:.0625,y:.3125},{x:.0625,y:.3125},{x:.0625,y:.3125},{x:.0625,y:.3125},{x:.1875,y:.3125},{x:.1875,y:.3125},{x:.1875,y:.3125},{x:.1875,y:.3125},{x:.1875,y:.3125},{x:.1875,y:.3125},{x:.3125,y:.3125},{x:.3125,y:.3125},{x:.3125,y:.3125},{x:.3125,y:.3125},{x:.3125,y:.3125},{x:.3125,y:.3125},{x:.4375,y:.3125},{x:.4375,y:.3125},{x:.4375,y:.3125},{x:.4375,y:.3125},{x:.4375,y:.3125},{x:.4375,y:.3125},{x:.5625,y:.3125},{x:.5625,y:.3125},{x:.5625,y:.3125},{x:.5625,y:.3125},{x:.5625,y:.3125},{x:.5625,y:.3125},{x:.6875,y:.3125},{x:.6875,y:.3125},{x:.6875,y:.3125},{x:.6875,y:.3125},{x:.6875,y:.3125},{x:.6875,y:.3125},{x:.8125,y:.3125},{x:.8125,y:.3125},{x:.8125,y:.3125},{x:.8125,y:.3125},{x:.8125,y:.3125},{x:.8125,y:.3125},{x:.9375,y:.3125},{x:.9375,y:.3125},{x:.9375,y:.3125},{x:.9375,y:.3125},{x:.9375,y:.3125},{x:.9375,y:.3125},{x:.0625,y:.4375},{x:.0625,y:.4375},{x:.0625,y:.4375},{x:.0625,y:.4375},{x:.0625,y:.4375},{x:.0625,y:.4375},{x:.1875,y:.4375},{x:.1875,y:.4375},{x:.1875,y:.4375},{x:.1875,y:.4375},{x:.1875,y:.4375},{x:.1875,y:.4375},{x:.3125,y:.4375},{x:.3125,y:.4375},{x:.3125,y:.4375},{x:.3125,y:.4375},{x:.3125,y:.4375},{x:.3125,y:.4375},{x:.4375,y:.4375},{x:.4375,y:.4375},{x:.4375,y:.4375},{x:.4375,y:.4375},{x:.4375,y:.4375},{x:.4375,y:.4375},{x:.5625,y:.4375},{x:.5625,y:.4375},{x:.5625,y:.4375},{x:.5625,y:.4375},{x:.5625,y:.4375},{x:.5625,y:.4375},{x:.6875,y:.4375},{x:.6875,y:.4375},{x:.6875,y:.4375},{x:.6875,y:.4375},{x:.6875,y:.4375},{x:.6875,y:.4375},{x:.8125,y:.4375},{x:.8125,y:.4375},{x:.8125,y:.4375},{x:.8125,y:.4375},{x:.8125,y:.4375},{x:.8125,y:.4375},{x:.9375,y:.4375},{x:.9375,y:.4375},{x:.9375,y:.4375},{x:.9375,y:.4375},{x:.9375,y:.4375},{x:.9375,y:.4375},{x:.0625,y:.5625},{x:.0625,y:.5625},{x:.0625,y:.5625},{x:.0625,y:.5625},{x:.0625,y:.5625},{x:.0625,y:.5625},{x:.1875,y:.5625},{x:.1875,y:.5625},{x:.1875,y:.5625},{x:.1875,y:.5625},{x:.1875,y:.5625},{x:.1875,y:.5625},{x:.3125,y:.5625},{x:.3125,y:.5625},{x:.3125,y:.5625},{x:.3125,y:.5625},{x:.3125,y:.5625},{x:.3125,y:.5625},{x:.4375,y:.5625},{x:.4375,y:.5625},{x:.4375,y:.5625},{x:.4375,y:.5625},{x:.4375,y:.5625},{x:.4375,y:.5625},{x:.5625,y:.5625},{x:.5625,y:.5625},{x:.5625,y:.5625},{x:.5625,y:.5625},{x:.5625,y:.5625},{x:.5625,y:.5625},{x:.6875,y:.5625},{x:.6875,y:.5625},{x:.6875,y:.5625},{x:.6875,y:.5625},{x:.6875,y:.5625},{x:.6875,y:.5625},{x:.8125,y:.5625},{x:.8125,y:.5625},{x:.8125,y:.5625},{x:.8125,y:.5625},{x:.8125,y:.5625},{x:.8125,y:.5625},{x:.9375,y:.5625},{x:.9375,y:.5625},{x:.9375,y:.5625},{x:.9375,y:.5625},{x:.9375,y:.5625},{x:.9375,y:.5625},{x:.0625,y:.6875},{x:.0625,y:.6875},{x:.0625,y:.6875},{x:.0625,y:.6875},{x:.0625,y:.6875},{x:.0625,y:.6875},{x:.1875,y:.6875},{x:.1875,y:.6875},{x:.1875,y:.6875},{x:.1875,y:.6875},{x:.1875,y:.6875},{x:.1875,y:.6875},{x:.3125,y:.6875},{x:.3125,y:.6875},{x:.3125,y:.6875},{x:.3125,y:.6875},{x:.3125,y:.6875},{x:.3125,y:.6875},{x:.4375,y:.6875},{x:.4375,y:.6875},{x:.4375,y:.6875},{x:.4375,y:.6875},{x:.4375,y:.6875},{x:.4375,y:.6875},{x:.5625,y:.6875},{x:.5625,y:.6875},{x:.5625,y:.6875},{x:.5625,y:.6875},{x:.5625,y:.6875},{x:.5625,y:.6875},{x:.6875,y:.6875},{x:.6875,y:.6875},{x:.6875,y:.6875},{x:.6875,y:.6875},{x:.6875,y:.6875},{x:.6875,y:.6875},{x:.8125,y:.6875},{x:.8125,y:.6875},{x:.8125,y:.6875},{x:.8125,y:.6875},{x:.8125,y:.6875},{x:.8125,y:.6875},{x:.9375,y:.6875},{x:.9375,y:.6875},{x:.9375,y:.6875},{x:.9375,y:.6875},{x:.9375,y:.6875},{x:.9375,y:.6875},{x:.0625,y:.8125},{x:.0625,y:.8125},{x:.0625,y:.8125},{x:.0625,y:.8125},{x:.0625,y:.8125},{x:.0625,y:.8125},{x:.1875,y:.8125},{x:.1875,y:.8125},{x:.1875,y:.8125},{x:.1875,y:.8125},{x:.1875,y:.8125},{x:.1875,y:.8125},{x:.3125,y:.8125},{x:.3125,y:.8125},{x:.3125,y:.8125},{x:.3125,y:.8125},{x:.3125,y:.8125},{x:.3125,y:.8125},{x:.4375,y:.8125},{x:.4375,y:.8125},{x:.4375,y:.8125},{x:.4375,y:.8125},{x:.4375,y:.8125},{x:.4375,y:.8125},{x:.5625,y:.8125},{x:.5625,y:.8125},{x:.5625,y:.8125},{x:.5625,y:.8125},{x:.5625,y:.8125},{x:.5625,y:.8125},{x:.6875,y:.8125},{x:.6875,y:.8125},{x:.6875,y:.8125},{x:.6875,y:.8125},{x:.6875,y:.8125},{x:.6875,y:.8125},{x:.8125,y:.8125},{x:.8125,y:.8125},{x:.8125,y:.8125},{x:.8125,y:.8125},{x:.8125,y:.8125},{x:.8125,y:.8125},{x:.9375,y:.8125},{x:.9375,y:.8125},{x:.9375,y:.8125},{x:.9375,y:.8125},{x:.9375,y:.8125},{x:.9375,y:.8125},{x:.0625,y:.9375},{x:.0625,y:.9375},{x:.0625,y:.9375},{x:.0625,y:.9375},{x:.0625,y:.9375},{x:.0625,y:.9375},{x:.1875,y:.9375},{x:.1875,y:.9375},{x:.1875,y:.9375},{x:.1875,y:.9375},{x:.1875,y:.9375},{x:.1875,y:.9375},{x:.3125,y:.9375},{x:.3125,y:.9375},{x:.3125,y:.9375},{x:.3125,y:.9375},{x:.3125,y:.9375},{x:.3125,y:.9375},{x:.4375,y:.9375},{x:.4375,y:.9375},{x:.4375,y:.9375},{x:.4375,y:.9375},{x:.4375,y:.9375},{x:.4375,y:.9375},{x:.5625,y:.9375},{x:.5625,y:.9375},{x:.5625,y:.9375},{x:.5625,y:.9375},{x:.5625,y:.9375},{x:.5625,y:.9375},{x:.6875,y:.9375},{x:.6875,y:.9375},{x:.6875,y:.9375},{x:.6875,y:.9375},{x:.6875,y:.9375},{x:.6875,y:.9375},{x:.8125,y:.9375},{x:.8125,y:.9375},{x:.8125,y:.9375},{x:.8125,y:.9375},{x:.8125,y:.9375},{x:.8125,y:.9375},{x:.9375,y:.9375},{x:.9375,y:.9375},{x:.9375,y:.9375},{x:.9375,y:.9375},{x:.9375,y:.9375},{x:.9375,y:.9375}],HandDetector=class{constructor(e){__publicField(this,"model"),__publicField(this,"anchors"),__publicField(this,"anchorsTensor"),__publicField(this,"inputSize"),__publicField(this,"inputSizeTensor"),__publicField(this,"doubleInputSizeTensor"),this.model=e,this.anchors=anchors2.map((e=>[e.x,e.y])),this.anchorsTensor=tensor2d(this.anchors),this.inputSize=this.model&&this.model.inputs&&this.model.inputs[0].shape?this.model.inputs[0].shape[2]:0,this.inputSizeTensor=tensor1d([this.inputSize,this.inputSize]),this.doubleInputSizeTensor=tensor1d([2*this.inputSize,2*this.inputSize])}normalizeBoxes(e){const t={};t.boxOffsets=slice(e,[0,0],[-1,2]),t.boxSizes=slice(e,[0,2],[-1,2]),t.div=div(t.boxOffsets,this.inputSizeTensor),t.boxCenterPoints=add2(t.div,this.anchorsTensor),t.halfBoxSizes=div(t.boxSizes,this.doubleInputSizeTensor),t.sub=sub(t.boxCenterPoints,t.halfBoxSizes),t.startPoints=mul(t.sub,this.inputSizeTensor),t.add=add2(t.boxCenterPoints,t.halfBoxSizes),t.endPoints=mul(t.add,this.inputSizeTensor);const n=concat2d([t.startPoints,t.endPoints],1);return Object.keys(t).forEach((e=>dispose(t[e]))),n}normalizeLandmarks(e,t){const n={};n.reshape=reshape(e,[-1,7,2]),n.div=div(n.reshape,this.inputSizeTensor),n.landmarks=add2(n.div,this.anchors[t]);const a=mul(n.landmarks,this.inputSizeTensor);return Object.keys(n).forEach((e=>dispose(n[e]))),a}async predict(e,t){const n={};n.resize=image.resizeBilinear(e,[this.inputSize,this.inputSize]),n.div=div(n.resize,constants.tf127),n.image=sub(n.div,constants.tf1),n.batched=this.model.execute(n.image),n.predictions=squeeze(n.batched),n.slice=slice(n.predictions,[0,0],[-1,1]),n.sigmoid=sigmoid(n.slice),n.scores=squeeze(n.sigmoid);const a=await n.scores.data();n.boxes=slice(n.predictions,[0,1],[-1,4]),n.norm=this.normalizeBoxes(n.boxes),n.nms=await image.nonMaxSuppressionAsync(n.norm,n.scores,3*t.hand.maxDetected,t.hand.iouThreshold,t.hand.minConfidence);const r=await n.nms.array(),s=[];for(const t of r){const r={};r.box=slice(n.norm,[t,0],[1,-1]),r.slice=slice(n.predictions,[t,5],[1,14]),r.norm=this.normalizeLandmarks(r.slice,t),r.palmLandmarks=reshape(r.norm,[-1,2]);const o=await r.box.data(),i=scaleBoxCoordinates2({startPoint:o.slice(0,2),endPoint:o.slice(2,4),palmLandmarks:await r.palmLandmarks.array(),confidence:a[t]},[e.shape[2]/this.inputSize,e.shape[1]/this.inputSize]);s.push(i),Object.keys(r).forEach((e=>dispose(r[e])))}return Object.keys(n).forEach((e=>dispose(n[e]))),s}},palmBoxEnlargeFactor=5,handBoxEnlargeFactor=1.65,palmLandmarkIds=[0,5,9,13,17,1,2],palmLandmarksPalmBase=0,palmLandmarksMiddleFingerBase=2,lastTime12=0,HandPipeline=class{constructor(e,t){__publicField(this,"handDetector"),__publicField(this,"handPoseModel"),__publicField(this,"inputSize"),__publicField(this,"storedBoxes"),__publicField(this,"skipped"),__publicField(this,"detectedHands"),this.handDetector=e,this.handPoseModel=t,this.inputSize=this.handPoseModel&&this.handPoseModel.inputs[0].shape?this.handPoseModel.inputs[0].shape[2]:0,this.storedBoxes=[],this.skipped=Number.MAX_SAFE_INTEGER,this.detectedHands=0}calculateLandmarksBoundingBox(e){const t=e.map((e=>e[0])),n=e.map((e=>e[1]));return{startPoint:[Math.min(...t),Math.min(...n)],endPoint:[Math.max(...t),Math.max(...n)]}}getBoxForPalmLandmarks(e,t){const n=e.map((e=>rotatePoint2([...e,1],t)));return enlargeBox2(squarifyBox2(this.calculateLandmarksBoundingBox(n)),palmBoxEnlargeFactor)}getBoxForHandLandmarks(e){const t=enlargeBox2(squarifyBox2(this.calculateLandmarksBoundingBox(e)),handBoxEnlargeFactor);t.palmLandmarks=[];for(let n=0;n<palmLandmarkIds.length;n++)t.palmLandmarks.push(e[palmLandmarkIds[n]].slice(0,2));return t}transformRawCoords(e,t,n,a){const r=getBoxSize2(t),s=[r[0]/this.inputSize,r[1]/this.inputSize,(r[0]+r[1])/this.inputSize/2],o=e.map((e=>[s[0]*(e[0]-this.inputSize/2),s[1]*(e[1]-this.inputSize/2),s[2]*e[2]])),i=buildRotationMatrix2(n,[0,0]),l=o.map((e=>[...rotatePoint2(e,i),e[2]])),u=invertTransformMatrix2(a),c=[...getBoxCenter2(t),1],d=[dot5(c,u[0]),dot5(c,u[1])];return l.map((e=>[Math.trunc(e[0]+d[0]),Math.trunc(e[1]+d[1]),Math.trunc(e[2])]))}async estimateHands(e,t){let n,a=!1;const r=(t.hand.skipTime||0)>now()-lastTime12,s=this.skipped<(t.hand.skipFrames||0);t.skipAllowed&&r&&s&&(n=await this.handDetector.predict(e,t),this.skipped=0),t.skipAllowed&&this.skipped++,n&&n.length>0&&(n.length!==this.detectedHands&&this.detectedHands!==t.hand.maxDetected||!t.hand.landmarks)&&(this.detectedHands=0,this.storedBoxes=[...n],this.storedBoxes.length>0&&(a=!0));const o=[];for(let n=0;n<this.storedBoxes.length;n++){const r=this.storedBoxes[n];if(r)if(t.hand.landmarks){const s=t.hand.rotation?computeRotation2(r.palmLandmarks[palmLandmarksPalmBase],r.palmLandmarks[palmLandmarksMiddleFingerBase]):0,i=getBoxCenter2(r),l=[i[0]/e.shape[2],i[1]/e.shape[1]],u=t.hand.rotation&&env2.kernels.includes("rotatewithoffset")?image.rotateWithOffset(e,s,0,l):e.clone(),c=buildRotationMatrix2(-s,i),d=a?this.getBoxForPalmLandmarks(r.palmLandmarks,c):r,p=cutBoxFromImageAndResize2(d,u,[this.inputSize,this.inputSize]),h=div(p,constants.tf255);dispose(p),dispose(u);const[m,f]=this.handPoseModel.execute(h);lastTime12=now(),dispose(h);const g=(await m.data())[0];if(dispose(m),g>=t.hand.minConfidence/4){const e=reshape(f,[-1,3]),t=await e.array();dispose(f),dispose(e);const a=this.transformRawCoords(t,d,s,c),i=this.getBoxForHandLandmarks(a);this.storedBoxes[n]={...i,confidence:g};const l={landmarks:a,confidence:g,boxConfidence:r.confidence,fingerConfidence:g,box:{topLeft:i.startPoint,bottomRight:i.endPoint}};o.push(l)}else this.storedBoxes[n]=null;dispose(f)}else{const e=enlargeBox2(squarifyBox2(r),handBoxEnlargeFactor),t={confidence:r.confidence,boxConfidence:r.confidence,fingerConfidence:0,box:{topLeft:e.startPoint,bottomRight:e.endPoint},landmarks:[]};o.push(t)}}return this.storedBoxes=this.storedBoxes.filter((e=>null!==e)),this.detectedHands=o.length,o.length>t.hand.maxDetected&&(o.length=t.hand.maxDetected),o}},Finger={thumb:0,index:1,middle:2,ring:3,pinky:4,all:[0,1,2,3,4],nameMapping:{0:"thumb",1:"index",2:"middle",3:"ring",4:"pinky"},pointsMapping:{0:[[0,1],[1,2],[2,3],[3,4]],1:[[0,5],[5,6],[6,7],[7,8]],2:[[0,9],[9,10],[10,11],[11,12]],3:[[0,13],[13,14],[14,15],[15,16]],4:[[0,17],[17,18],[18,19],[19,20]]},getName:e=>Finger.nameMapping[e],getPoints:e=>Finger.pointsMapping[e]},FingerCurl={none:0,half:1,full:2,nameMapping:{0:"none",1:"half",2:"full"},getName:e=>FingerCurl.nameMapping[e]},FingerDirection={verticalUp:0,verticalDown:1,horizontalLeft:2,horizontalRight:3,diagonalUpRight:4,diagonalUpLeft:5,diagonalDownRight:6,diagonalDownLeft:7,nameMapping:{0:"verticalUp",1:"verticalDown",2:"horizontalLeft",3:"horizontalRight",4:"diagonalUpRight",5:"diagonalUpLeft",6:"diagonalDownRight",7:"diagonalDownLeft"},getName:e=>FingerDirection.nameMapping[e]},FingerGesture=class{constructor(e){__publicField(this,"name"),__publicField(this,"curls"),__publicField(this,"directions"),__publicField(this,"weights"),__publicField(this,"weightsRelative"),this.name=e,this.curls={},this.directions={},this.weights=[1,1,1,1,1],this.weightsRelative=[1,1,1,1,1]}curl(e,t,n){void 0===this.curls[e]&&(this.curls[e]=[]),this.curls[e].push([t,n])}direction(e,t,n){this.directions[e]||(this.directions[e]=[]),this.directions[e].push([t,n])}weight(e,t){this.weights[e]=t;const n=this.weights.reduce(((e,t)=>e+t),0);this.weightsRelative=this.weights.map((e=>5*e/n))}matchAgainst(e,t){let n=0;for(const t in e){const a=e[t],r=this.curls[t];if(void 0!==r){for(const[e,s]of r)if(a===e){n+=s*this.weightsRelative[t];break}}else n+=this.weightsRelative[t]}for(const e in t){const a=t[e],r=this.directions[e];if(void 0!==r){for(const[t,s]of r)if(a===t){n+=s*this.weightsRelative[e];break}}else n+=this.weightsRelative[e]}return n/10}},{thumb:thumb,index:index,middle:middle,ring:ring,pinky:pinky}=Finger,{none:none,half:half,full:full}=FingerCurl,{verticalUp:verticalUp,verticalDown:verticalDown,horizontalLeft:horizontalLeft,horizontalRight:horizontalRight,diagonalUpRight:diagonalUpRight,diagonalUpLeft:diagonalUpLeft,diagonalDownRight:diagonalDownRight,diagonalDownLeft:diagonalDownLeft}=FingerDirection,ThumbsUp=new FingerGesture("thumbs up");ThumbsUp.curl(thumb,none,1),ThumbsUp.direction(thumb,verticalUp,1),ThumbsUp.direction(thumb,diagonalUpLeft,.25),ThumbsUp.direction(thumb,diagonalUpRight,.25);for(const e of[Finger.index,Finger.middle,Finger.ring,Finger.pinky])ThumbsUp.curl(e,full,1),ThumbsUp.direction(e,horizontalLeft,1),ThumbsUp.direction(e,horizontalRight,1);var Victory=new FingerGesture("victory");Victory.curl(thumb,half,.5),Victory.curl(thumb,none,.5),Victory.direction(thumb,verticalUp,1),Victory.direction(thumb,diagonalUpLeft,1),Victory.curl(index,none,1),Victory.direction(index,verticalUp,.75),Victory.direction(index,diagonalUpLeft,1),Victory.curl(middle,none,1),Victory.direction(middle,verticalUp,1),Victory.direction(middle,diagonalUpLeft,.75),Victory.curl(ring,full,1),Victory.direction(ring,verticalUp,.2),Victory.direction(ring,diagonalUpLeft,1),Victory.direction(ring,horizontalLeft,.2),Victory.curl(pinky,full,1),Victory.direction(pinky,verticalUp,.2),Victory.direction(pinky,diagonalUpLeft,1),Victory.direction(pinky,horizontalLeft,.2),Victory.weight(index,2),Victory.weight(middle,2);var Point=new FingerGesture("point");Point.curl(thumb,full,1),Point.curl(index,none,.5),Point.curl(middle,full,.5),Point.curl(ring,full,.5),Point.curl(pinky,full,.5),Point.weight(index,2),Point.weight(middle,2);var MiddleFinger=new FingerGesture("middle finger");MiddleFinger.curl(thumb,none,1),MiddleFinger.curl(index,full,.5),MiddleFinger.curl(middle,full,.5),MiddleFinger.curl(ring,full,.5),MiddleFinger.curl(pinky,full,.5),MiddleFinger.weight(index,2),MiddleFinger.weight(middle,2);var OpenPalm=new FingerGesture("open palm");OpenPalm.curl(thumb,none,.75),OpenPalm.curl(index,none,.75),OpenPalm.curl(middle,none,.75),OpenPalm.curl(ring,none,.75),OpenPalm.curl(pinky,none,.75);var fingergesture_default=[ThumbsUp,Victory,Point,MiddleFinger,OpenPalm],minConfidence=.7,options={HALF_CURL_START_LIMIT:60,NO_CURL_START_LIMIT:130,DISTANCE_VOTE_POWER:1.1,SINGLE_ANGLE_VOTE_POWER:.9,TOTAL_ANGLE_VOTE_POWER:1.6};function calculateSlope(e,t,n,a){const r=(t-a)/(e-n);let s=180*Math.atan(r)/Math.PI;return s<=0?s=-s:s>0&&(s=180-s),s}function getSlopes(e,t){if(!e||!t)return[0,0];const n=calculateSlope(e[0],e[1],t[0],t[1]);if(2===e.length)return n;return[n,calculateSlope(e[1],e[2],t[1],t[2])]}function angleOrientationAt(e,t=1){let n=0,a=0,r=0;return e>=75&&e<=105?n=1*t:e>=25&&e<=155?a=1*t:r=1*t,[n,a,r]}function estimateFingerCurl(e,t,n){const a=e[0]-t[0],r=e[0]-n[0],s=t[0]-n[0],o=e[1]-t[1],i=e[1]-n[1],l=t[1]-n[1],u=e[2]-t[2],c=e[2]-n[2],d=t[2]-n[2],p=Math.sqrt(a*a+o*o+u*u),h=Math.sqrt(r*r+i*i+c*c),m=Math.sqrt(s*s+l*l+d*d);let f=(m*m+p*p-h*h)/(2*m*p);f>1?f=1:f<-1&&(f=-1);let g,x=Math.acos(f);return x=57.2958*x%180,g=x>options.NO_CURL_START_LIMIT?FingerCurl.none:x>options.HALF_CURL_START_LIMIT?FingerCurl.half:FingerCurl.full,g}function estimateHorizontalDirection(e,t,n,a){let r;return r=a===Math.abs(e)?e>0?FingerDirection.horizontalLeft:FingerDirection.horizontalRight:a===Math.abs(t)?t>0?FingerDirection.horizontalLeft:FingerDirection.horizontalRight:n>0?FingerDirection.horizontalLeft:FingerDirection.horizontalRight,r}function estimateVerticalDirection(e,t,n,a){let r;return r=a===Math.abs(e)?e<0?FingerDirection.verticalDown:FingerDirection.verticalUp:a===Math.abs(t)?t<0?FingerDirection.verticalDown:FingerDirection.verticalUp:n<0?FingerDirection.verticalDown:FingerDirection.verticalUp,r}function estimateDiagonalDirection(e,t,n,a,r,s,o,i){let l;const u=estimateVerticalDirection(e,t,n,a),c=estimateHorizontalDirection(r,s,o,i);return l=u===FingerDirection.verticalUp?c===FingerDirection.horizontalLeft?FingerDirection.diagonalUpLeft:FingerDirection.diagonalUpRight:c===FingerDirection.horizontalLeft?FingerDirection.diagonalDownLeft:FingerDirection.diagonalDownRight,l}function calculateFingerDirection(e,t,n,a){const r=e[0]-t[0],s=e[0]-n[0],o=t[0]-n[0],i=e[1]-t[1],l=e[1]-n[1],u=t[1]-n[1],c=Math.max(Math.abs(r),Math.abs(s),Math.abs(o)),d=Math.max(Math.abs(i),Math.abs(l),Math.abs(u));let p=0,h=0,m=0;const f=d/(c+1e-5);f>1.5?p+=options.DISTANCE_VOTE_POWER:f>.66?h+=options.DISTANCE_VOTE_POWER:m+=options.DISTANCE_VOTE_POWER;const g=Math.sqrt(r*r+i*i),x=Math.sqrt(s*s+l*l),y=Math.sqrt(o*o+u*u),A=Math.max(g,x,y);let b=e[0],v=e[1],k=n[0],S=n[1];A===g?(k=n[0],S=n[1]):A===y&&(b=t[0],v=t[1]);const w=angleOrientationAt(getSlopes([b,v],[k,S]),options.TOTAL_ANGLE_VOTE_POWER);p+=w[0],h+=w[1],m+=w[2];for(const e of a){const t=angleOrientationAt(e,options.SINGLE_ANGLE_VOTE_POWER);p+=t[0],h+=t[1],m+=t[2]}let C;return C=p===Math.max(p,h,m)?estimateVerticalDirection(l,i,u,d):m===Math.max(h,m)?estimateHorizontalDirection(s,r,o,c):estimateDiagonalDirection(l,i,u,d,s,r,o,c),C}function estimate(e){const t=[],n=[],a=[],r=[];if(!e)return{curls:a,directions:r};for(const a of Finger.all){const r=Finger.getPoints(a),s=[],o=[];for(const t of r){const n=getSlopes(e[t[0]],e[t[1]]),a=n[0],r=n[1];s.push(a),o.push(r)}t.push(s),n.push(o)}for(const n of Finger.all){const s=n===Finger.thumb?1:0,o=Finger.getPoints(n),i=e[o[s][0]],l=e[o[s+1][1]],u=e[o[3][1]],c=estimateFingerCurl(i,l,u),d=calculateFingerDirection(i,l,u,t[n].slice(s));a[n]=c,r[n]=d}return{curls:a,directions:r}}function analyze(e){if(!e||0===e.length)return null;const t=estimate(e),n={};for(const e of Finger.all)n[Finger.getName(e)]={curl:FingerCurl.getName(t.curls[e]),direction:FingerDirection.getName(t.directions[e])};return n}function match(e){const t=[];if(!e||0===e.length)return t;const n=estimate(e);for(const e of fingergesture_default){const a=e.matchAgainst(n.curls,n.directions);a>=minConfidence&&t.push({name:e.name,confidence:a})}return t}var handDetectorModel,handPoseModel,handPipeline,meshAnnotations2={thumb:[1,2,3,4],index:[5,6,7,8],middle:[9,10,11,12],ring:[13,14,15,16],pinky:[17,18,19,20],palm:[0]};async function predict12(e,t){const n=await handPipeline.estimateHands(e,t);if(!n)return[];const a=[];for(let t=0;t<n.length;t++){const r={};if(n[t].landmarks)for(const e of Object.keys(meshAnnotations2))r[e]=meshAnnotations2[e].map((e=>n[t].landmarks[e]));const s=n[t].landmarks;let o=[Number.MAX_SAFE_INTEGER,Number.MAX_SAFE_INTEGER,0,0],i=[0,0,0,0];if(s&&s.length>0){for(const e of s)e[0]<o[0]&&(o[0]=e[0]),e[1]<o[1]&&(o[1]=e[1]),e[0]>o[2]&&(o[2]=e[0]),e[1]>o[3]&&(o[3]=e[1]);o[2]-=o[0],o[3]-=o[1],i=[o[0]/(e.shape[2]||0),o[1]/(e.shape[1]||0),o[2]/(e.shape[2]||0),o[3]/(e.shape[1]||0)]}else o=n[t].box?[Math.trunc(Math.max(0,n[t].box.topLeft[0])),Math.trunc(Math.max(0,n[t].box.topLeft[1])),Math.trunc(Math.min(e.shape[2]||0,n[t].box.bottomRight[0])-Math.max(0,n[t].box.topLeft[0])),Math.trunc(Math.min(e.shape[1]||0,n[t].box.bottomRight[1])-Math.max(0,n[t].box.topLeft[1]))]:[0,0,0,0],i=[n[t].box.topLeft[0]/(e.shape[2]||0),n[t].box.topLeft[1]/(e.shape[1]||0),(n[t].box.bottomRight[0]-n[t].box.topLeft[0])/(e.shape[2]||0),(n[t].box.bottomRight[1]-n[t].box.topLeft[1])/(e.shape[1]||0)];const l=analyze(s);a.push({id:t,score:Math.round(100*n[t].confidence)/100,boxScore:Math.round(100*n[t].boxConfidence)/100,fingerScore:Math.round(100*n[t].fingerConfidence)/100,label:"hand",box:o,boxRaw:i,keypoints:s,annotations:r,landmarks:l})}return a}async function load13(e){var t,n,a,r,s,o;env2.initial&&(handDetectorModel=null,handPoseModel=null),handDetectorModel&&handPoseModel?(e.debug&&log("cached model:",handDetectorModel.modelUrl),e.debug&&log("cached model:",handPoseModel.modelUrl)):([handDetectorModel,handPoseModel]=await Promise.all([e.hand.enabled?loadGraphModel(join(e.modelBasePath,(null==(t=e.hand.detector)?void 0:t.modelPath)||""),{fromTFHub:((null==(n=e.hand.detector)?void 0:n.modelPath)||"").includes("tfhub.dev")}):null,e.hand.landmarks?loadGraphModel(join(e.modelBasePath,(null==(a=e.hand.skeleton)?void 0:a.modelPath)||""),{fromTFHub:((null==(r=e.hand.skeleton)?void 0:r.modelPath)||"").includes("tfhub.dev")}):null]),e.hand.enabled&&(handDetectorModel&&handDetectorModel.modelUrl?e.debug&&log("load model:",handDetectorModel.modelUrl):log("load model failed:",(null==(s=e.hand.detector)?void 0:s.modelPath)||""),handPoseModel&&handPoseModel.modelUrl?e.debug&&log("load model:",handPoseModel.modelUrl):log("load model failed:",(null==(o=e.hand.skeleton)?void 0:o.modelPath)||"")));const i=new HandDetector(handDetectorModel);return handPipeline=new HandPipeline(i,handPoseModel),[handDetectorModel,handPoseModel]}function calc(e,t=[1,1]){const n=[e.map((e=>e[0])),e.map((e=>e[1]))],a=[Math.min(...n[0]),Math.min(...n[1])],r=[Math.max(...n[0]),Math.max(...n[1])],s=[a[0],a[1],r[0]-a[0],r[1]-a[1]];return{box:s,boxRaw:[s[0]/t[0],s[1]/t[1],s[2]/t[0],s[3]/t[1]]}}function square4(e,t=[1,1]){const n=[e.map((e=>e[0])),e.map((e=>e[1]))],a=[Math.min(...n[0]),Math.min(...n[1])],r=[Math.max(...n[0]),Math.max(...n[1])],s=[(a[0]+r[0])/2,(a[1]+r[1])/2],o=Math.max(s[0]-a[0],s[1]-a[1],-s[0]+r[0],-s[1]+r[1]),i=[Math.trunc(s[0]-o),Math.trunc(s[1]-o),Math.trunc(2*o),Math.trunc(2*o)];return{box:i,boxRaw:[i[0]/t[0],i[1]/t[1],i[2]/t[0],i[3]/t[1]]}}function scale2(e,t){const n=[e[2]*t,e[3]*t];return[e[0]-(n[0]-e[2])/2,e[1]-(n[1]-e[3])/2,n[0],n[1]]}function crop(e){return[Math.max(0,e[1]),Math.max(0,e[0]),Math.min(1,e[3]+e[1]),Math.min(1,e[2]+e[0])]}var model14,models2=[null,null],modelOutputNodes=["StatefulPartitionedCall/Postprocessor/Slice","StatefulPartitionedCall/Postprocessor/ExpandDims_1"],inputSize6=[[0,0],[0,0]],classes=["hand","fist","pinch","point","face","tip","pinchtip"],faceIndex=4,boxExpandFact=1.6,maxDetectorResolution=512,detectorExpandFact=1.4,skipped12=Number.MAX_SAFE_INTEGER,lastTime13=0,outputSize=[0,0],cache3={boxes:[],hands:[]},fingerMap={thumb:[1,2,3,4],index:[5,6,7,8],middle:[9,10,11,12],ring:[13,14,15,16],pinky:[17,18,19,20],palm:[0]};async function loadDetect2(e){var t,n;if(env2.initial&&(models2[0]=null),models2[0])e.debug&&log("cached model:",models2[0].modelUrl);else{fakeOps(["tensorlistreserve","enter","tensorlistfromtensor","merge","loopcond","switch","exit","tensorliststack","nextiteration","tensorlistsetitem","tensorlistgetitem","reciprocal","shape","split","where"],e),models2[0]=await loadGraphModel(join(e.modelBasePath,(null==(t=e.hand.detector)?void 0:t.modelPath)||""));const a=Object.values(models2[0].modelSignature.inputs);inputSize6[0][0]=Array.isArray(a)?parseInt(a[0].tensorShape.dim[1].size):0,inputSize6[0][1]=Array.isArray(a)?parseInt(a[0].tensorShape.dim[2].size):0,models2[0]&&models2[0].modelUrl?e.debug&&log("load model:",models2[0].modelUrl):log("load model failed:",null==(n=e.hand.detector)?void 0:n.modelPath)}return models2[0]}async function loadSkeleton(e){var t,n;if(env2.initial&&(models2[1]=null),models2[1])e.debug&&log("cached model:",models2[1].modelUrl);else{models2[1]=await loadGraphModel(join(e.modelBasePath,(null==(t=e.hand.skeleton)?void 0:t.modelPath)||""));const a=Object.values(models2[1].modelSignature.inputs);inputSize6[1][0]=Array.isArray(a)?parseInt(a[0].tensorShape.dim[1].size):0,inputSize6[1][1]=Array.isArray(a)?parseInt(a[0].tensorShape.dim[2].size):0,models2[1]&&models2[1].modelUrl?e.debug&&log("load model:",models2[1].modelUrl):log("load model failed:",null==(n=e.hand.skeleton)?void 0:n.modelPath)}return models2[1]}async function detectHands(e,t){const n=[];if(!e||!models2[0])return n;const a={},r=(e.shape[2]||1)/(e.shape[1]||1),s=Math.min(8*Math.round((e.shape[1]||0)/8),maxDetectorResolution),o=8*Math.round(s*r/8);a.resize=image.resizeBilinear(e,[s,o]),a.cast=cast(a.resize,"int32"),[a.rawScores,a.rawBoxes]=await models2[0].executeAsync(a.cast,modelOutputNodes),a.boxes=squeeze(a.rawBoxes,[0,2]),a.scores=squeeze(a.rawScores,[0]);const i=unstack(a.scores,1);dispose(i[faceIndex]),i.splice(faceIndex,1),a.filtered=stack(i,1),dispose(i),a.max=max(a.filtered,1),a.argmax=argMax(a.filtered,1);let l=0;a.nms=await image.nonMaxSuppressionAsync(a.boxes,a.max,t.hand.maxDetected,t.hand.iouThreshold,t.hand.minConfidence);const u=await a.nms.data(),c=await a.max.data(),d=await a.argmax.data();for(const e of Array.from(u)){const t=slice(a.boxes,e,1),r=await t.data();dispose(t);const s=[r[1],r[0],r[3]-r[1],r[2]-r[0]],o=scale2(s,detectorExpandFact),i=crop(o),u=[Math.trunc(s[0]*outputSize[0]),Math.trunc(s[1]*outputSize[1]),Math.trunc(s[2]*outputSize[0]),Math.trunc(s[3]*outputSize[1])],p={id:l++,score:c[e],box:u,boxRaw:o,boxCrop:i,label:classes[d[e]]};n.push(p)}return Object.keys(a).forEach((e=>dispose(a[e]))),n.sort(((e,t)=>t.score-e.score)),n.length>(t.hand.maxDetected||1)&&(n.length=t.hand.maxDetected||1),n}async function detectFingers(e,t,n){const a={id:t.id,score:Math.round(100*t.score)/100,boxScore:Math.round(100*t.score)/100,fingerScore:0,box:t.box,boxRaw:t.boxRaw,label:t.label,keypoints:[],landmarks:{},annotations:{}};if(e&&models2[1]&&n.hand.landmarks&&t.score>(n.hand.minConfidence||0)){const r={};r.crop=image.cropAndResize(e,[t.boxCrop],[0],[inputSize6[1][0],inputSize6[1][1]],"bilinear"),r.div=div(r.crop,constants.tf255),[r.score,r.keypoints]=models2[1].execute(r.div,["Identity_1","Identity"]);const s=(await r.score.data())[0],o=(100-Math.trunc(100/(1+Math.exp(s))))/100;if(o>=(n.hand.minConfidence||0)){a.fingerScore=o,r.reshaped=reshape(r.keypoints,[-1,3]);const e=(await r.reshaped.array()).map((e=>[e[0]/inputSize6[1][1],e[1]/inputSize6[1][0],e[2]||0])).map((e=>[e[0]*t.boxRaw[2],e[1]*t.boxRaw[3],e[2]||0]));a.keypoints=e.map((e=>[outputSize[0]*(e[0]+t.boxRaw[0]),outputSize[1]*(e[1]+t.boxRaw[1]),e[2]||0])),a.landmarks=analyze(a.keypoints);for(const e of Object.keys(fingerMap))a.annotations[e]=fingerMap[e].map((e=>a.landmarks&&a.keypoints[e]?a.keypoints[e]:null))}Object.keys(r).forEach((e=>dispose(r[e])))}return a}async function predict13(e,t){var n,a;if(!(models2[0]&&models2[1]&&(null==(n=models2[0])?void 0:n.inputs[0].shape)&&(null==(a=models2[1])?void 0:a.inputs[0].shape)))return[];outputSize=[e.shape[2]||0,e.shape[1]||0],skipped12++;const r=(t.hand.skipTime||0)>now()-lastTime13,s=skipped12<(t.hand.skipFrames||0);return t.skipAllowed&&r&&s?cache3.hands:new Promise((async n=>{const a=3*(t.hand.skipTime||0)>now()-lastTime13,r=skipped12<3*(t.hand.skipFrames||0);t.skipAllowed&&cache3.hands.length===t.hand.maxDetected||t.skipAllowed&&a&&r&&cache3.hands.length>0?cache3.hands=await Promise.all(cache3.boxes.map((n=>detectFingers(e,n,t)))):(cache3.boxes=await detectHands(e,t),lastTime13=now(),cache3.hands=await Promise.all(cache3.boxes.map((n=>detectFingers(e,n,t)))),skipped12=0);const s=[...cache3.boxes];if(cache3.boxes.length=0,t.cacheSensitivity>0)for(let n=0;n<cache3.hands.length;n++){const a=square4(cache3.hands[n].keypoints,outputSize);if(a.box[2]/(e.shape[2]||1)>.05&&a.box[3]/(e.shape[1]||1)>.05&&cache3.hands[n].fingerScore&&cache3.hands[n].fingerScore>(t.hand.minConfidence||0)){const e=scale2(a.box,boxExpandFact),t=scale2(a.boxRaw,boxExpandFact),r=crop(t);cache3.boxes.push({...s[n],box:e,boxRaw:t,boxCrop:r})}}for(let e=0;e<cache3.hands.length;e++){const t=calc(cache3.hands[e].keypoints,outputSize);cache3.hands[e].box=t.box,cache3.hands[e].boxRaw=t.boxRaw}n(cache3.hands)}))}var cached2=[],skipped13=Number.MAX_SAFE_INTEGER,lastCount8=0,lastTime14=0;async function load14(e){var t,n;return env2.initial&&(model14=null),model14?e.debug&&log("cached model:",model14.modelUrl):(model14=await loadGraphModel(join(e.modelBasePath,(null==(t=e.face.liveness)?void 0:t.modelPath)||"")))&&model14.modelUrl?e.debug&&log("load model:",model14.modelUrl):log("load model failed:",null==(n=e.face.liveness)?void 0:n.modelPath),model14}async function predict14(e,t,n,a){var r,s;if(!model14)return 0;const o=((null==(r=t.face.liveness)?void 0:r.skipTime)||0)>now()-lastTime14,i=skipped13<((null==(s=t.face.liveness)?void 0:s.skipFrames)||0);return t.skipAllowed&&o&&i&&lastCount8===a&&cached2[n]?(skipped13++,cached2[n]):(skipped13=0,new Promise((async t=>{const r=image.resizeBilinear(e,[(null==model14?void 0:model14.inputs[0].shape)?model14.inputs[0].shape[2]:0,(null==model14?void 0:model14.inputs[0].shape)?model14.inputs[0].shape[1]:0],!1),s=null==model14?void 0:model14.execute(r),o=(await s.data())[0];cached2[n]=Math.round(100*o)/100,lastCount8=a,lastTime14=now(),dispose([r,s]),t(cached2[n])})))}var movenetcoords_exports={};__export(movenetcoords_exports,{connected:()=>connected3,horizontal:()=>horizontal,kpt:()=>kpt3,relative:()=>relative,vertical:()=>vertical});var model15,kpt3=["nose","leftEye","rightEye","leftEar","rightEar","leftShoulder","rightShoulder","leftElbow","rightElbow","leftWrist","rightWrist","leftHip","rightHip","leftKnee","rightKnee","leftAnkle","rightAnkle"],horizontal=[["leftEye","rightEye"],["leftEar","rightEar"],["leftShoulder","rightShoulder"],["leftElbow","rightElbow"],["leftWrist","rightWrist"],["leftHip","rightHip"],["leftKnee","rightKnee"],["leftAnkle","rightAnkle"]],vertical=[["leftKnee","leftShoulder"],["rightKnee","rightShoulder"],["leftAnkle","leftKnee"],["rightAnkle","rightKnee"]],relative=[[["leftHip","rightHip"],["leftShoulder","rightShoulder"]],[["leftElbow","rightElbow"],["leftShoulder","rightShoulder"]]],connected3={leftLeg:["leftHip","leftKnee","leftAnkle"],rightLeg:["rightHip","rightKnee","rightAnkle"],torso:["leftShoulder","rightShoulder","rightHip","leftHip","leftShoulder"],leftArm:["leftShoulder","leftElbow","leftWrist"],rightArm:["rightShoulder","rightElbow","rightWrist"],head:[]},maxJitter=.005,cache4={keypoints:[],padding:[[0,0],[0,0],[0,0],[0,0]]};function bodyParts(e){for(const t of horizontal){const n=e.keypoints.findIndex((e=>e.part===t[0])),a=e.keypoints.findIndex((e=>e.part===t[1]));if(e.keypoints[n]&&e.keypoints[a]&&e.keypoints[n].position[0]<e.keypoints[a].position[0]){const t=e.keypoints[n];e.keypoints[n]=e.keypoints[a],e.keypoints[a]=t}}for(const t of vertical){const n=e.keypoints.findIndex((e=>e&&e.part===t[0])),a=e.keypoints.findIndex((e=>e&&e.part===t[1]));e.keypoints[n]&&e.keypoints[a]&&e.keypoints[n].position[1]<e.keypoints[a].position[1]&&e.keypoints.splice(n,1)}for(const[t,n]of relative){const a=e.keypoints.findIndex((e=>e&&e.part===t[0])),r=e.keypoints.findIndex((e=>e&&e.part===t[1])),s=e.keypoints.findIndex((e=>e&&e.part===n[0])),o=e.keypoints.findIndex((e=>e&&e.part===n[1]));if(!e.keypoints[s]||!e.keypoints[o])continue;const i=e.keypoints[a]?[Math.abs(e.keypoints[s].position[0]-e.keypoints[a].position[0]),Math.abs(e.keypoints[o].position[0]-e.keypoints[a].position[0])]:[0,0],l=e.keypoints[r]?[Math.abs(e.keypoints[o].position[0]-e.keypoints[r].position[0]),Math.abs(e.keypoints[s].position[0]-e.keypoints[r].position[0])]:[0,0];if(i[0]>i[1]||l[0]>l[1]){const t=e.keypoints[a];e.keypoints[a]=e.keypoints[r],e.keypoints[r]=t}}}function jitter(e){for(let t=0;t<e.length;t++)if(e[t]&&cache4.keypoints[t]){const n=[Math.abs(e[t].positionRaw[0]-cache4.keypoints[t].positionRaw[0]),Math.abs(e[t].positionRaw[1]-cache4.keypoints[t].positionRaw[1])];n[0]<maxJitter&&n[1]<maxJitter?e[t]=cache4.keypoints[t]:cache4.keypoints[t]=e[t]}else cache4.keypoints[t]=e[t];return e}function padInput(e,t){const n={};if(!e.shape||!e.shape[1]||!e.shape[2])return e;cache4.padding=[[0,0],[e.shape[2]>e.shape[1]?Math.trunc((e.shape[2]-e.shape[1])/2):0,e.shape[2]>e.shape[1]?Math.trunc((e.shape[2]-e.shape[1])/2):0],[e.shape[1]>e.shape[2]?Math.trunc((e.shape[1]-e.shape[2])/2):0,e.shape[1]>e.shape[2]?Math.trunc((e.shape[1]-e.shape[2])/2):0],[0,0]],n.pad=pad(e,cache4.padding),n.resize=image.resizeBilinear(n.pad,[t,t]);const a=cast(n.resize,"int32");return Object.keys(n).forEach((e=>dispose(n[e]))),a}function rescaleBody(e,t){e.keypoints=e.keypoints.filter((e=>e&&e.position));for(const n of e.keypoints)n.position=[n.position[0]*(t[0]+cache4.padding[2][0]+cache4.padding[2][1])/t[0]-cache4.padding[2][0],n.position[1]*(t[1]+cache4.padding[1][0]+cache4.padding[1][1])/t[1]-cache4.padding[1][0]],n.positionRaw=[n.position[0]/t[0],n.position[1]/t[1]];const n=calc(e.keypoints.map((e=>e.position)),t);return e.box=n.box,e.boxRaw=n.boxRaw,e}var model16,inputSize7=0,skipped14=Number.MAX_SAFE_INTEGER,cache5={boxes:[],bodies:[],last:0};async function load15(e){return env2.initial&&(model15=null),model15?e.debug&&log("cached model:",model15.modelUrl):(fakeOps(["size"],e),(model15=await loadGraphModel(join(e.modelBasePath,e.body.modelPath||"")))&&model15.modelUrl?e.debug&&log("load model:",model15.modelUrl):log("load model failed:",e.body.modelPath)),inputSize7=model15.inputs[0].shape?model15.inputs[0].shape[2]:0,model15}async function parseSinglePose(e,t,n){const a=e[0][0],r=[];let s=0;for(let e=0;e<a.length;e++)if(s=a[e][2],s>t.body.minConfidence){const t=[a[e][1],a[e][0]];r.push({score:Math.round(100*s)/100,part:kpt3[e],positionRaw:t,position:[Math.round((n.shape[2]||0)*t[0]),Math.round((n.shape[1]||0)*t[1])]})}s=r.reduce(((e,t)=>t.score>e?t.score:e),0);const o=[],i=calc(r.map((e=>e.position)),[n.shape[2],n.shape[1]]),l={};for(const[e,n]of Object.entries(connected3)){const a=[];for(let e=0;e<n.length-1;e++){const s=r.find((t=>t.part===n[e])),o=r.find((t=>t.part===n[e+1]));s&&o&&s.score>(t.body.minConfidence||0)&&o.score>(t.body.minConfidence||0)&&a.push([s.position,o.position])}l[e]=a}const u={id:0,score:s,box:i.box,boxRaw:i.boxRaw,keypoints:r,annotations:l};return bodyParts(u),o.push(u),o}async function parseMultiPose(e,t,n){const a=[];for(let r=0;r<e[0].length;r++){const s=e[0][r],o=Math.round(100*s[55])/100;if(o>t.body.minConfidence){const e=[];for(let a=0;a<17;a++){const r=s[3*a+2];if(r>t.body.minConfidence){const t=[s[3*a+1],s[3*a+0]];e.push({part:kpt3[a],score:Math.round(100*r)/100,positionRaw:t,position:[Math.round((n.shape[2]||0)*t[0]),Math.round((n.shape[1]||0)*t[1])]})}}const i=calc(e.map((e=>e.position)),[n.shape[2],n.shape[1]]),l={};for(const[n,a]of Object.entries(connected3)){const r=[];for(let n=0;n<a.length-1;n++){const s=e.find((e=>e.part===a[n])),o=e.find((e=>e.part===a[n+1]));s&&o&&s.score>(t.body.minConfidence||0)&&o.score>(t.body.minConfidence||0)&&r.push([s.position,o.position])}l[n]=r}const u={id:r,score:o,box:i.box,boxRaw:i.boxRaw,keypoints:[...e],annotations:l};bodyParts(u),a.push(u)}}return a.sort(((e,t)=>t.score-e.score)),a.length>t.body.maxDetected&&(a.length=t.body.maxDetected),a}async function predict15(e,t){if(!model15||!(null==model15?void 0:model15.inputs[0].shape))return[];t.skipAllowed||(cache5.boxes.length=0),skipped14++;const n=(t.body.skipTime||0)>now()-cache5.last,a=skipped14<(t.body.skipFrames||0);return t.skipAllowed&&n&&a?cache5.bodies:new Promise((async n=>{const a={};skipped14=0,a.input=padInput(e,inputSize7),a.res=null==model15?void 0:model15.execute(a.input),cache5.last=now();const r=await a.res.array();cache5.bodies=17===a.res.shape[2]?await parseSinglePose(r,t,e):await parseMultiPose(r,t,e);for(const t of cache5.bodies)rescaleBody(t,[e.shape[2]||1,e.shape[1]||1]),jitter(t.keypoints);Object.keys(a).forEach((e=>dispose(a[e]))),n(cache5.bodies)}))}var last9=[],lastTime15=0,skipped15=Number.MAX_SAFE_INTEGER,scaleBox=2.5;async function load16(e){if(!model16||env2.initial){model16=await loadGraphModel(join(e.modelBasePath,e.object.modelPath||""));const t=Object.values(model16.modelSignature.inputs);model16.inputSize=Array.isArray(t)?parseInt(t[0].tensorShape.dim[2].size):null,model16&&model16.modelUrl?e.debug&&log("load model:",model16.modelUrl):log("load model failed:",e.object.modelPath)}else e.debug&&log("cached model:",model16.modelUrl);return model16}async function process4(e,t,n,a){let r=0,s=[];for(const o of[1,2,4])tidy((async()=>{var i,l;const u=13*o,c=null==(i=e.find((e=>e.shape[1]===u**2&&e.shape[2]===labels.length)))?void 0:i.squeeze(),d=null==(l=e.find((e=>e.shape[1]===u**2&&e.shape[2]<labels.length)))?void 0:l.squeeze(),p=d.reshape([-1,4,d.shape[1]/4]),h=await p.argMax(2).array(),m=await c.array();for(let e=0;e<c.shape[0];e++)for(let i=0;i<c.shape[1];i++){const l=m[e][i];if(l>a.object.minConfidence&&61!==i){const a=(.5+Math.trunc(e%u))/u,c=(.5+Math.trunc(e/u))/u,d=h[e].map((e=>e*(u/o/t))),[p,m]=[a-scaleBox/o*d[0],c-scaleBox/o*d[1]],[f,g]=[a+scaleBox/o*d[2]-p,c+scaleBox/o*d[3]-m];let x=[p,m,f,g];x=x.map((e=>Math.max(0,Math.min(e,1))));const y=[x[0]*n[0],x[1]*n[1],x[2]*n[0],x[3]*n[1]],A={id:r++,score:Math.round(100*l)/100,class:i+1,label:labels[i].label,box:y.map((e=>Math.trunc(e))),boxRaw:x};s.push(A)}}}));e.forEach((e=>dispose(e)));const o=s.map((e=>[e.boxRaw[1],e.boxRaw[0],e.boxRaw[3],e.boxRaw[2]])),i=s.map((e=>e.score));let l=[];if(o&&o.length>0){const e=await image.nonMaxSuppressionAsync(o,i,a.object.maxDetected,a.object.iouThreshold,a.object.minConfidence);l=await e.data(),dispose(e)}return s=s.filter(((e,t)=>l.includes(t))).sort(((e,t)=>t.score-e.score)),s}async function predict16(e,t){const n=(t.object.skipTime||0)>now()-lastTime15,a=skipped15<(t.object.skipFrames||0);return t.skipAllowed&&n&&a&&last9.length>0?(skipped15++,last9):(skipped15=0,env2.kernels.includes("mod")&&env2.kernels.includes("sparsetodense")?new Promise((async n=>{const a=[e.shape[2],e.shape[1]],r=image.resizeBilinear(e,[model16.inputSize,model16.inputSize],!1),s=div(r,constants.tf255),o=s.transpose([0,3,1,2]);let i;dispose(s),dispose(r),t.object.enabled&&(i=model16.execute(o)),lastTime15=now(),dispose(o);const l=await process4(i,model16.inputSize,a,t);last9=l,n(l)})):last9)}var partNames=["nose","leftEye","rightEye","leftEar","rightEar","leftShoulder","rightShoulder","leftElbow","rightElbow","leftWrist","rightWrist","leftHip","rightHip","leftKnee","rightKnee","leftAnkle","rightAnkle"],count2=partNames.length,partIds=partNames.reduce(((e,t,n)=>(e[t]=n,e)),{}),connectedPartNames=[["leftHip","leftShoulder"],["leftElbow","leftShoulder"],["leftElbow","leftWrist"],["leftHip","leftKnee"],["leftKnee","leftAnkle"],["rightHip","rightShoulder"],["rightElbow","rightShoulder"],["rightElbow","rightWrist"],["rightHip","rightKnee"],["rightKnee","rightAnkle"],["leftShoulder","rightShoulder"],["leftHip","rightHip"]],connectedPartIndices=connectedPartNames.map((([e,t])=>[partIds[e],partIds[t]])),poseChain=[["nose","leftEye"],["leftEye","leftEar"],["nose","rightEye"],["rightEye","rightEar"],["nose","leftShoulder"],["leftShoulder","leftElbow"],["leftElbow","leftWrist"],["leftShoulder","leftHip"],["leftHip","leftKnee"],["leftKnee","leftAnkle"],["nose","rightShoulder"],["rightShoulder","rightElbow"],["rightElbow","rightWrist"],["rightShoulder","rightHip"],["rightHip","rightKnee"],["rightKnee","rightAnkle"]];function getBoundingBox(e){const t=e.reduce((({maxX:e,maxY:t,minX:n,minY:a},{position:{x:r,y:s}})=>({maxX:Math.max(e,r),maxY:Math.max(t,s),minX:Math.min(n,r),minY:Math.min(a,s)})),{maxX:Number.NEGATIVE_INFINITY,maxY:Number.NEGATIVE_INFINITY,minX:Number.POSITIVE_INFINITY,minY:Number.POSITIVE_INFINITY});return[t.minX,t.minY,t.maxX-t.minX,t.maxY-t.minY]}function scalePoses(e,[t,n],[a,r]){const s=t/a,o=n/r;return e.map(((e,t)=>((e,t)=>({id:t,score:e.score,boxRaw:[e.box[0]/r,e.box[1]/a,e.box[2]/r,e.box[3]/a],box:[Math.trunc(e.box[0]*o),Math.trunc(e.box[1]*s),Math.trunc(e.box[2]*o),Math.trunc(e.box[3]*s)],keypoints:e.keypoints.map((({score:e,part:t,position:n})=>({score:e,part:t,position:[Math.trunc(n.x*o),Math.trunc(n.y*s)],positionRaw:[n.x/a,n.y/a]})))}))(e,t)))}var model17,MaxHeap=class{constructor(e,t){__publicField(this,"priorityQueue"),__publicField(this,"numberOfElements"),__publicField(this,"getElementValue"),this.priorityQueue=new Array(e),this.numberOfElements=-1,this.getElementValue=t}enqueue(e){this.priorityQueue[++this.numberOfElements]=e,this.swim(this.numberOfElements)}dequeue(){const e=this.priorityQueue[0];return this.exchange(0,this.numberOfElements--),this.sink(0),this.priorityQueue[this.numberOfElements+1]=null,e}empty(){return-1===this.numberOfElements}size(){return this.numberOfElements+1}all(){return this.priorityQueue.slice(0,this.numberOfElements+1)}max(){return this.priorityQueue[0]}swim(e){for(;e>0&&this.less(Math.floor(e/2),e);)this.exchange(e,Math.floor(e/2)),e=Math.floor(e/2)}sink(e){for(;2*e<=this.numberOfElements;){let t=2*e;if(t<this.numberOfElements&&this.less(t,t+1)&&t++,!this.less(e,t))break;this.exchange(e,t),e=t}}getValueAt(e){return this.getElementValue(this.priorityQueue[e])}less(e,t){return this.getValueAt(e)<this.getValueAt(t)}exchange(e,t){const n=this.priorityQueue[e];this.priorityQueue[e]=this.priorityQueue[t],this.priorityQueue[t]=n}};function getOffsetPoint(e,t,n,a){return{y:a.get(e,t,n),x:a.get(e,t,n+count2)}}function getImageCoords(e,t,n){const{heatmapY:a,heatmapX:r,id:s}=e,{y:o,x:i}=getOffsetPoint(a,r,s,n);return{x:e.heatmapX*t+i,y:e.heatmapY*t+o}}function clamp2(e,t,n){return e<t?t:e>n?n:e}function squaredDistance(e,t,n,a){const r=n-e,s=a-t;return r*r+s*s}function addVectors(e,t){return{x:e.x+t.x,y:e.y+t.y}}var model18,poseNetOutputs=["MobilenetV1/offset_2/BiasAdd","MobilenetV1/heatmap_2/BiasAdd","MobilenetV1/displacement_fwd_2/BiasAdd","MobilenetV1/displacement_bwd_2/BiasAdd"],localMaximumRadius=1,outputStride=16,squaredNmsRadius=2500;function traverse(e,t,n,a,r,s,o=2){const i=(e,t,n)=>({y:clamp2(Math.round(e.y/outputStride),0,t-1),x:clamp2(Math.round(e.x/outputStride),0,n-1)}),[l,u]=a.shape,c=i(t.position,l,u),d=(p=c,{y:s.get(p.y,p.x,e),x:s.get(p.y,p.x,s.shape[2]/2+e)});var p;let h=addVectors(t.position,d);for(let e=0;e<o;e++){const e=i(h,l,u),t=getOffsetPoint(e.y,e.x,n,r);h=addVectors({x:e.x*outputStride,y:e.y*outputStride},{x:t.x,y:t.y})}const m=i(h,l,u),f=a.get(m.y,m.x,n);return{position:h,part:partNames[n],score:f}}function decodePose(e,t,n,a,r){const s=poseChain.map((([e,t])=>[partIds[e],partIds[t]])),o=s.map((([,e])=>e)),i=s.map((([e])=>e)),l=t.shape[2],u=o.length,c=new Array(l),d=getImageCoords(e.part,outputStride,n);c[e.part.id]={score:e.score,part:partNames[e.part.id],position:d};for(let e=u-1;e>=0;--e){const a=o[e],s=i[e];c[a]&&!c[s]&&(c[s]=traverse(e,c[a],s,t,n,r))}for(let e=0;e<u;++e){const r=i[e],s=o[e];c[r]&&!c[s]&&(c[s]=traverse(e,c[r],s,t,n,a))}return c}function scoreIsMaximumInLocalWindow(e,t,n,a,r){const[s,o]=r.shape;let i=!0;const l=Math.max(n-localMaximumRadius,0),u=Math.min(n+localMaximumRadius+1,s);for(let n=l;n<u;++n){const s=Math.max(a-localMaximumRadius,0),l=Math.min(a+localMaximumRadius+1,o);for(let a=s;a<l;++a)if(r.get(n,a,e)>t){i=!1;break}if(!i)break}return i}function buildPartWithScoreQueue(e,t){const[n,a,r]=t.shape,s=new MaxHeap(n*a*r,(({score:e})=>e));for(let o=0;o<n;++o)for(let n=0;n<a;++n)for(let a=0;a<r;++a){const r=t.get(o,n,a);r<e||scoreIsMaximumInLocalWindow(a,r,o,n,t)&&s.enqueue({score:r,part:{heatmapY:o,heatmapX:n,id:a}})}return s}function withinRadius(e,{x:t,y:n},a){return e.some((({keypoints:e})=>{var r;const s=null==(r=e[a])?void 0:r.position;return!!s&&squaredDistance(n,t,s.y,s.x)<=squaredNmsRadius}))}function getInstanceScore(e,t){return t.reduce(((t,{position:n,score:a},r)=>(withinRadius(e,n,r)||(t+=a),t)),0)/t.length}function decode(e,t,n,a,r,s){const o=[],i=buildPartWithScoreQueue(s,t);for(;o.length<r&&!i.empty();){const r=i.dequeue();if(withinRadius(o,getImageCoords(r.part,outputStride,e),r.part.id))continue;let l=decodePose(r,t,e,n,a);l=l.filter((e=>e.score>s));const u=getInstanceScore(o,l),c=getBoundingBox(l);u>s&&o.push({keypoints:l,box:c,score:Math.round(100*u)/100})}return o}async function predict17(e,t){const n=tidy((()=>{if(!model17.inputs[0].shape)return[];const t=image.resizeBilinear(e,[model17.inputs[0].shape[2],model17.inputs[0].shape[1]]),n=sub(div(cast(t,"float32"),127.5),1),a=model17.execute(n,poseNetOutputs).map((e=>squeeze(e,[0])));return a[1]=a[1].sigmoid(),a})),a=await Promise.all(n.map((e=>e.buffer())));for(const e of n)dispose(e);const r=await decode(a[0],a[1],a[2],a[3],t.body.maxDetected,t.body.minConfidence);if(!model17.inputs[0].shape)return[];return scalePoses(r,[e.shape[1],e.shape[2]],[model17.inputs[0].shape[2],model17.inputs[0].shape[1]])}async function load17(e){return!model17||env2.initial?(model17=await loadGraphModel(join(e.modelBasePath,e.body.modelPath||"")))&&model17.modelUrl?e.debug&&log("load model:",model17.modelUrl):log("load model failed:",e.body.modelPath):e.debug&&log("cached model:",model17.modelUrl),model17}var busy=!1;async function load18(e){return!model18||env2.initial?(model18=await loadGraphModel(join(e.modelBasePath,e.segmentation.modelPath||"")))&&model18.modelUrl?e.debug&&log("load model:",model18.modelUrl):log("load model failed:",e.segmentation.modelPath):e.debug&&log("cached model:",model18.modelUrl),model18}async function process5(e,t,n){var a,r;if(busy)return{data:[],canvas:null,alpha:null};busy=!0,model18||await load18(n);const s=await process2(e,n),o=(null==(a=s.tensor)?void 0:a.shape[2])||0,i=(null==(r=s.tensor)?void 0:r.shape[1])||0;if(!s.tensor)return{data:[],canvas:null,alpha:null};const l={};l.resize=image.resizeBilinear(s.tensor,[model18.inputs[0].shape?model18.inputs[0].shape[1]:0,model18.inputs[0].shape?model18.inputs[0].shape[2]:0],!1),dispose(s.tensor),l.norm=div(l.resize,constants.tf255),l.res=model18.execute(l.norm),l.squeeze=squeeze(l.res,0),2===l.squeeze.shape[2]?(l.softmax=softmax(l.squeeze),[l.bg,l.fg]=unstack(l.softmax,2),l.expand=expandDims(l.fg,2),l.pad=expandDims(l.expand,0),l.crop=image.cropAndResize(l.pad,[[0,0,.5,.5]],[0],[o,i]),l.data=squeeze(l.crop,0)):l.data=image.resizeBilinear(l.squeeze,[i,o]);const u=Array.from(await l.data.data());if(env2.node&&!env2.Canvas&&"undefined"==typeof ImageData)return n.debug&&log("canvas support missing"),Object.keys(l).forEach((e=>dispose(l[e]))),{data:u,canvas:null,alpha:null};const c=canvas(o,i);await browser_exports.toPixels(l.data,c);const d=c.getContext("2d");n.segmentation.blur&&n.segmentation.blur>0&&(d.filter=`blur(${n.segmentation.blur}px)`);const p=d.getImageData(0,0,o,i),h=canvas(o,i),m=h.getContext("2d");s.canvas&&m.drawImage(s.canvas,0,0),m.globalCompositeOperation="darken",n.segmentation.blur&&n.segmentation.blur>0&&(m.filter=`blur(${n.segmentation.blur}px)`),m.drawImage(c,0,0),m.globalCompositeOperation="source-over",m.filter="none";const f=m.getImageData(0,0,o,i);for(let e=0;e<o*i;e++)f.data[4*e+3]=p.data[4*e+0];m.putImageData(f,0,0);let g=null;if(t&&h){g=canvas(o,i);const e=await process2(t,n);dispose(e.tensor);const a=g.getContext("2d");a.drawImage(e.canvas,0,0,g.width,g.height),a.drawImage(h,0,0)}return Object.keys(l).forEach((e=>dispose(l[e]))),busy=!1,{data:u,canvas:h,alpha:c}}var Models=class{constructor(){__publicField(this,"ssrnetage",null),__publicField(this,"gear",null),__publicField(this,"blazeposedetect",null),__publicField(this,"blazepose",null),__publicField(this,"centernet",null),__publicField(this,"efficientpose",null),__publicField(this,"mobilefacenet",null),__publicField(this,"emotion",null),__publicField(this,"facedetect",null),__publicField(this,"faceiris",null),__publicField(this,"facemesh",null),__publicField(this,"faceres",null),__publicField(this,"ssrnetgender",null),__publicField(this,"handpose",null),__publicField(this,"handskeleton",null),__publicField(this,"handtrack",null),__publicField(this,"liveness",null),__publicField(this,"movenet",null),__publicField(this,"nanodet",null),__publicField(this,"posenet",null),__publicField(this,"segmentation",null),__publicField(this,"antispoof",null)}};function reset(e){for(const t of Object.keys(e.models))e.models[t]=null}async function load19(e){var t,n,a,r,s,o,i,l,u,c,d,p,h,m,f,g,x,y,A,b,v,k,S,w,C,I,T,N,_,E,P,R,M;env2.initial&&reset(e),e.config.hand.enabled&&(!e.models.handpose&&(null==(n=null==(t=e.config.hand.detector)?void 0:t.modelPath)?void 0:n.includes("handdetect"))&&([e.models.handpose,e.models.handskeleton]=await load13(e.config)),!e.models.handskeleton&&e.config.hand.landmarks&&(null==(r=null==(a=e.config.hand.detector)?void 0:a.modelPath)?void 0:r.includes("handdetect"))&&([e.models.handpose,e.models.handskeleton]=await load13(e.config))),e.config.body.enabled&&!e.models.blazepose&&(null==(o=null==(s=e.config.body)?void 0:s.modelPath)?void 0:o.includes("blazepose"))&&(e.models.blazepose=loadPose(e.config)),e.config.body.enabled&&!e.models.blazeposedetect&&(null==(i=e.config.body.detector)?void 0:i.modelPath)&&(null==(u=null==(l=e.config.body)?void 0:l.modelPath)?void 0:u.includes("blazepose"))&&(e.models.blazeposedetect=loadDetect(e.config)),e.config.body.enabled&&!e.models.efficientpose&&(null==(d=null==(c=e.config.body)?void 0:c.modelPath)?void 0:d.includes("efficientpose"))&&(e.models.efficientpose=load7(e.config)),e.config.body.enabled&&!e.models.movenet&&(null==(h=null==(p=e.config.body)?void 0:p.modelPath)?void 0:h.includes("movenet"))&&(e.models.movenet=load15(e.config)),e.config.body.enabled&&!e.models.posenet&&(null==(f=null==(m=e.config.body)?void 0:m.modelPath)?void 0:f.includes("posenet"))&&(e.models.posenet=load17(e.config)),e.config.face.enabled&&!e.models.facedetect&&(e.models.facedetect=load5(e.config)),e.config.face.enabled&&(null==(g=e.config.face.antispoof)?void 0:g.enabled)&&!e.models.antispoof&&(e.models.antispoof=load4(e.config)),e.config.face.enabled&&(null==(x=e.config.face.liveness)?void 0:x.enabled)&&!e.models.liveness&&(e.models.liveness=load14(e.config)),e.config.face.enabled&&(null==(y=e.config.face.description)?void 0:y.enabled)&&!e.models.faceres&&(e.models.faceres=load12(e.config)),e.config.face.enabled&&(null==(A=e.config.face.emotion)?void 0:A.enabled)&&!e.models.emotion&&(e.models.emotion=load8(e.config)),e.config.face.enabled&&(null==(b=e.config.face.iris)?void 0:b.enabled)&&!e.models.faceiris&&(e.models.faceiris=load10(e.config)),e.config.face.enabled&&(null==(v=e.config.face.mesh)?void 0:v.enabled)&&!e.models.facemesh&&(e.models.facemesh=load11(e.config)),e.config.face.enabled&&(null==(k=e.config.face.gear)?void 0:k.enabled)&&!e.models.gear&&(e.models.gear=load(e.config)),e.config.face.enabled&&(null==(S=e.config.face.ssrnet)?void 0:S.enabled)&&!e.models.ssrnetage&&(e.models.ssrnetage=load2(e.config)),e.config.face.enabled&&(null==(w=e.config.face.ssrnet)?void 0:w.enabled)&&!e.models.ssrnetgender&&(e.models.ssrnetgender=load3(e.config)),e.config.face.enabled&&(null==(C=e.config.face.mobilefacenet)?void 0:C.enabled)&&!e.models.mobilefacenet&&(e.models.mobilefacenet=load9(e.config)),e.config.hand.enabled&&!e.models.handtrack&&(null==(T=null==(I=e.config.hand.detector)?void 0:I.modelPath)?void 0:T.includes("handtrack"))&&(e.models.handtrack=loadDetect2(e.config)),e.config.hand.enabled&&e.config.hand.landmarks&&!e.models.handskeleton&&(null==(_=null==(N=e.config.hand.detector)?void 0:N.modelPath)?void 0:_.includes("handtrack"))&&(e.models.handskeleton=loadSkeleton(e.config)),e.config.object.enabled&&!e.models.centernet&&(null==(P=null==(E=e.config.object)?void 0:E.modelPath)?void 0:P.includes("centernet"))&&(e.models.centernet=load6(e.config)),e.config.object.enabled&&!e.models.nanodet&&(null==(M=null==(R=e.config.object)?void 0:R.modelPath)?void 0:M.includes("nanodet"))&&(e.models.nanodet=load16(e.config)),e.config.segmentation.enabled&&!e.models.segmentation&&(e.models.segmentation=load18(e.config));for await(const t of Object.keys(e.models))e.models[t]&&void 0!==e.models[t]&&(e.models[t]=await e.models[t])}async function validate2(e){const t=["const","placeholder","noop","pad","squeeze","add","sub","mul","div"];for(const n of Object.keys(e.models))if(e.models[n]){let a=[];a=Array.isArray(e.models[n])?e.models[n].filter((e=>null!==e)).map((e=>e&&e.executor?e:e.model)):[e.models[n]];for(const r of a){if(!r){e.config.debug&&log("model marked as loaded but not defined:",n);continue}const a=[],s=null==r?void 0:r.executor;if(s&&s.graph.nodes)for(const e of Object.values(s.graph.nodes)){const t=e.op.toLowerCase();a.includes(t)||a.push(t)}else!s&&e.config.debug&&log("model signature not determined:",n);const o=[];for(const n of a)t.includes(n)||e.env.kernels.includes(n)||e.env.kernels.includes(n.replace("_",""))||e.env.kernels.includes(n.replace("native",""))||e.env.kernels.includes(n.replace("v2",""))||o.push(n);o.length>0&&e.config.debug&&log("model validation:",n,o)}}}var config2={name:"humangl",priority:999,canvas:null,gl:null,extensions:[],webGLattr:{alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!1,desynchronized:!0}};function extensions(){const e=config2.gl;e&&(config2.extensions=e.getSupportedExtensions())}async function register(e){var t;if("humangl"===e.config.backend&&(!(config2.name in engine().registry)||config2.gl&&config2.gl.getParameter(config2.gl.VERSION)||(log("error: humangl backend invalid context"),reset(e)),!findBackend(config2.name))){try{config2.canvas=await canvas(100,100)}catch(e){return void log("error: cannot create canvas:",e)}try{config2.gl=null==(t=config2.canvas)?void 0:t.getContext("webgl2",config2.webGLattr);if(!config2.gl.getParameter(config2.gl.VERSION).includes("2.0"))return log("override: using fallback webgl backend as webgl 2.0 is not detected"),void(e.config.backend="webgl");config2.canvas&&(config2.canvas.addEventListener("webglcontextlost",(async t=>{throw log("error: humangl:",t.type),log("possible browser memory leak using webgl or conflict with multiple backend registrations"),e.emit("error"),new Error("backend error: webgl context lost")})),config2.canvas.addEventListener("webglcontextrestored",(e=>{log("error: humangl context restored:",e)})),config2.canvas.addEventListener("webglcontextcreationerror",(e=>{log("error: humangl context create:",e)})))}catch(e){return void log("error: cannot get WebGL context:",e)}try{setWebGLContext(2,config2.gl)}catch(e){return void log("error: cannot set WebGL context:",e)}try{const e=new GPGPUContext(config2.gl);registerBackend(config2.name,(()=>new MathBackendWebGL(e)),config2.priority)}catch(e){return void log("error: cannot register WebGL backend:",e)}try{getKernelsForBackend("webgl").forEach((e=>{registerKernel({...e,backendName:config2.name})}))}catch(e){return void log("error: cannot update WebGL backend registration:",e)}const n=backend().getGPGPUContext?backend().getGPGPUContext().gl:null;if(!n)return void log("error: no current gl context:",n,config2.gl);log(`humangl webgl version:${n.getParameter(n.VERSION)} renderer:${n.getParameter(n.RENDERER)}`);try{ENV.set("WEBGL_VERSION",2)}catch(e){return void log("error: cannot set WebGL backend flags:",e)}extensions(),log("backend registered:",config2.name)}}function registerCustomOps(){if(!env2.kernels.includes("mod")){registerKernel({kernelName:"Mod",backendName:getBackend(),kernelFunc:e=>tidy((()=>sub(e.inputs.a,mul(div(e.inputs.a,e.inputs.b),e.inputs.b))))}),env2.kernels.push("mod")}if(!env2.kernels.includes("floormod")){registerKernel({kernelName:"FloorMod",backendName:getBackend(),kernelFunc:e=>tidy((()=>floorDiv(e.inputs.a/e.inputs.b)*e.inputs.b+mod(e.inputs.a,e.inputs.b)))}),env2.kernels.push("floormod")}}async function check(e,t=!1){if(e.state="backend",t||env2.initial||e.config.backend&&e.config.backend.length>0&&getBackend()!==e.config.backend){const t=now();if(e.config.backend&&e.config.backend.length>0){if("undefined"==typeof window&&"undefined"!=typeof WorkerGlobalScope&&e.config.debug&&e.config.debug&&log("running inside web worker"),env2.browser&&"tensorflow"===e.config.backend&&(e.config.debug&&log("override: backend set to tensorflow while running in browser"),e.config.backend="humangl"),!env2.node||"webgl"!==e.config.backend&&"humangl"!==e.config.backend||(e.config.debug&&log(`override: backend set to ${e.config.backend} while running in nodejs`),e.config.backend="tensorflow"),env2.browser&&"webgpu"===e.config.backend)if("undefined"==typeof navigator||void 0===navigator.gpu)log("override: backend set to webgpu but browser does not support webgpu"),e.config.backend="humangl";else{const t=await navigator.gpu.requestAdapter();e.config.debug&&log("enumerated webgpu adapter:",t)}"humangl"===e.config.backend&&await register(e);const t=Object.keys(engine().registryFactory);if(e.config.debug&&log("available backends:",t),t.includes(e.config.backend)||(log(`error: backend ${e.config.backend} not found in registry`),e.config.backend=env2.node?"tensorflow":"webgl",e.config.debug&&log(`override: setting backend ${e.config.backend}`)),e.config.debug&&log("setting backend:",e.config.backend),"wasm"===e.config.backend){if(e.config.debug&&log("wasm path:",e.config.wasmPath),void 0===(null==tfjs_esm_exports?void 0:tfjs_esm_exports.setWasmPaths))throw new Error("backend error: attempting to use wasm backend but wasm path is not set");await setWasmPaths(e.config.wasmPath);const t=await env().getAsync("WASM_HAS_SIMD_SUPPORT"),n=await env().getAsync("WASM_HAS_MULTITHREAD_SUPPORT");e.config.debug&&log(`wasm execution: ${t?"SIMD":"no SIMD"} ${n?"multithreaded":"singlethreaded"}`),e.config.debug&&!t&&log("warning: wasm simd support is not enabled")}try{await setBackend(e.config.backend),await ready(),init2()}catch(t){return log("error: cannot set backend:",e.config.backend,t),!1}}if("humangl"===getBackend()&&(ENV.set("CHECK_COMPUTATION_FOR_ERRORS",!1),ENV.set("WEBGL_CPU_FORWARD",!0),ENV.set("WEBGL_USE_SHAPES_UNIFORMS",!0),ENV.set("CPU_HANDOFF_SIZE_THRESHOLD",256),void 0!==e.config.deallocate&&e.config.deallocate&&(log("changing webgl: WEBGL_DELETE_TEXTURE_THRESHOLD:",!0),ENV.set("WEBGL_DELETE_TEXTURE_THRESHOLD",0)),backend().getGPGPUContext)){const t=await backend().getGPGPUContext().gl;e.config.debug&&log(`gl version:${t.getParameter(t.VERSION)} renderer:${t.getParameter(t.RENDERER)}`)}getBackend(),enableProdMode(),await ready(),e.performance.initBackend=Math.trunc(now()-t),e.config.backend=getBackend(),await env2.updateBackend(),registerCustomOps()}return!0}function fakeOps(e,t){for(const n of e){registerKernel({kernelName:n,backendName:t.backend,kernelFunc:()=>{t.debug&&log("kernelFunc",n,t.backend)}})}env2.kernels=getKernelsForBackend(getBackend()).map((e=>e.kernelName.toLowerCase()))}var options2={color:"rgba(173, 216, 230, 0.6)",labelColor:"rgba(173, 216, 230, 1)",shadowColor:"black",font:'small-caps 16px "Segoe UI"',lineHeight:18,lineWidth:4,pointSize:2,roundRect:8,drawPoints:!1,drawLabels:!0,drawBoxes:!0,drawGestures:!0,drawPolygons:!0,drawGaze:!0,fillPolygons:!1,useDepth:!0,useCurves:!1},drawTime=0,getCanvasContext=e=>{if(e)if(e.getContext){const t=e.getContext("2d");if(t)return t;log("draw error: cannot get canvas context")}else log("draw error: canvas context not defined");else log("draw error: invalid canvas");return null},rad2deg=e=>Math.round(180*e/Math.PI);function point(e,t,n,a,r){a=a||0,e.fillStyle=r.useDepth&&a?`rgba(${127.5+2*a}, ${127.5-2*a}, 255, 0.3)`:r.color,e.beginPath(),e.arc(t,n,r.pointSize,0,2*Math.PI),e.fill()}function rect(e,t,n,a,r,s){if(e.beginPath(),s.useCurves){const s=(t+t+a)/2,o=(n+n+r)/2;e.ellipse(s,o,a/2,r/2,0,0,2*Math.PI)}else e.lineWidth=s.lineWidth,e.moveTo(t+s.roundRect,n),e.lineTo(t+a-s.roundRect,n),e.quadraticCurveTo(t+a,n,t+a,n+s.roundRect),e.lineTo(t+a,n+r-s.roundRect),e.quadraticCurveTo(t+a,n+r,t+a-s.roundRect,n+r),e.lineTo(t+s.roundRect,n+r),e.quadraticCurveTo(t,n+r,t,n+r-s.roundRect),e.lineTo(t,n+s.roundRect),e.quadraticCurveTo(t,n,t+s.roundRect,n),e.closePath();e.stroke()}function lines(e,t,n){if(!(t.length<2)){e.beginPath(),e.moveTo(t[0][0],t[0][1]);for(const a of t){const t=a[2]||0;e.strokeStyle=n.useDepth&&0!==t?`rgba(${127.5+2*t}, ${127.5-2*t}, 255, 0.3)`:n.color,e.fillStyle=n.useDepth&&0!==t?`rgba(${127.5+2*t}, ${127.5-2*t}, 255, 0.3)`:n.color,e.lineTo(a[0],Math.round(a[1]))}e.stroke(),n.fillPolygons&&(e.closePath(),e.fill())}}function curves(e,t,n){if(!(t.length<2))if(!n.useCurves||t.length<=2)lines(e,t,n);else{e.moveTo(t[0][0],t[0][1]);for(let n=0;n<t.length-2;n++){const a=(t[n][0]+t[n+1][0])/2,r=(t[n][1]+t[n+1][1])/2;e.quadraticCurveTo(t[n][0],t[n][1],a,r)}e.quadraticCurveTo(t[t.length-2][0],t[t.length-2][1],t[t.length-1][0],t[t.length-1][1]),e.stroke(),n.fillPolygons&&(e.closePath(),e.fill())}}function arrow(e,t,n,a=5){let r,s,o;e.beginPath(),e.moveTo(t[0],t[1]),e.lineTo(n[0],n[1]),r=Math.atan2(n[1]-t[1],n[0]-t[0]),s=a*Math.cos(r)+n[0],o=a*Math.sin(r)+n[1],e.moveTo(s,o),r+=1/3*(2*Math.PI),s=a*Math.cos(r)+n[0],o=a*Math.sin(r)+n[1],e.lineTo(s,o),r+=1/3*(2*Math.PI),s=a*Math.cos(r)+n[0],o=a*Math.sin(r)+n[1],e.lineTo(s,o),e.closePath(),e.stroke(),e.fill()}async function gesture(e,t,n){const a=mergeDeep(options2,n);if(t&&e&&a.drawGestures){const n=getCanvasContext(e);if(!n)return;n.font=a.font,n.fillStyle=a.color;let r=1;for(let e=0;e<t.length;e++){let s=[],o=[];if([s,o]=Object.entries(t[e]),o.length>1&&o[1].length>0){const e=s[1]>0?`#${s[1]}`:"",t=`${s[0]} ${e}: ${o[1]}`;a.shadowColor&&""!==a.shadowColor&&(n.fillStyle=a.shadowColor,n.fillText(t,8,2+r*a.lineHeight)),n.fillStyle=a.labelColor,n.fillText(t,6,0+r*a.lineHeight),r+=1}}}}async function face(e,t,n){var a,r,s,o,i;const l=mergeDeep(options2,n);if(!t||!e)return;const u=getCanvasContext(e);if(u)for(const e of t){if(u.font=l.font,u.strokeStyle=l.color,u.fillStyle=l.color,l.drawBoxes&&rect(u,e.box[0],e.box[1],e.box[2],e.box[3],l),l.drawLabels){const t=[];if(t.push(`face: ${Math.trunc(100*e.score)}%`),e.genderScore&&t.push(`${e.gender||""} ${Math.trunc(100*e.genderScore)}%`),e.age&&t.push(`age: ${e.age||""}`),e.iris&&t.push(`distance: ${e.iris}`),e.real&&t.push(`real: ${Math.trunc(100*e.real)}%`),e.live&&t.push(`live: ${Math.trunc(100*e.live)}%`),e.emotion&&e.emotion.length>0){const n=e.emotion.map((e=>`${Math.trunc(100*e.score)}% ${e.emotion}`));n.length>3&&(n.length=3),t.push(n.join(" "))}e.rotation&&e.rotation.angle&&e.rotation.gaze&&(e.rotation.angle.roll&&t.push(`roll: ${rad2deg(e.rotation.angle.roll)}° yaw:${rad2deg(e.rotation.angle.yaw)}° pitch:${rad2deg(e.rotation.angle.pitch)}°`),e.rotation.gaze.bearing&&t.push(`gaze: ${rad2deg(e.rotation.gaze.bearing)}°`)),0===t.length&&t.push("face"),u.fillStyle=l.color;for(let n=t.length-1;n>=0;n--){const a=Math.max(e.box[0],0),r=n*l.lineHeight+e.box[1];l.shadowColor&&""!==l.shadowColor&&(u.fillStyle=l.shadowColor,u.fillText(t[n],a+5,r+16)),u.fillStyle=l.labelColor,u.fillText(t[n],a+4,r+15)}}if(u.lineWidth=1,e.mesh&&e.mesh.length>0){if(l.drawPoints)for(const t of e.mesh)point(u,t[0],t[1],t[2],l);if(l.drawPolygons){if(u.lineWidth=1,e.mesh.length>450)for(let t=0;t<TRI468.length/3;t++){lines(u,[TRI468[3*t+0],TRI468[3*t+1],TRI468[3*t+2]].map((t=>e.mesh[t])),l)}if(e.annotations&&e.annotations.leftEyeIris&&e.annotations.leftEyeIris[0]){u.strokeStyle=l.useDepth?"rgba(255, 200, 255, 0.3)":l.color,u.beginPath();const t=Math.abs(e.annotations.leftEyeIris[3][0]-e.annotations.leftEyeIris[1][0])/2,n=Math.abs(e.annotations.leftEyeIris[4][1]-e.annotations.leftEyeIris[2][1])/2;u.ellipse(e.annotations.leftEyeIris[0][0],e.annotations.leftEyeIris[0][1],t,n,0,0,2*Math.PI),u.stroke(),l.fillPolygons&&(u.fillStyle=l.useDepth?"rgba(255, 255, 200, 0.3)":l.color,u.fill())}if(e.annotations&&e.annotations.rightEyeIris&&e.annotations.rightEyeIris[0]){u.strokeStyle=l.useDepth?"rgba(255, 200, 255, 0.3)":l.color,u.beginPath();const t=Math.abs(e.annotations.rightEyeIris[3][0]-e.annotations.rightEyeIris[1][0])/2,n=Math.abs(e.annotations.rightEyeIris[4][1]-e.annotations.rightEyeIris[2][1])/2;u.ellipse(e.annotations.rightEyeIris[0][0],e.annotations.rightEyeIris[0][1],t,n,0,0,2*Math.PI),u.stroke(),l.fillPolygons&&(u.fillStyle=l.useDepth?"rgba(255, 255, 200, 0.3)":l.color,u.fill())}if(l.drawGaze&&(null==(a=e.rotation)?void 0:a.angle)&&"undefined"!=typeof Path2D){u.strokeStyle="pink";const t=e.box[0]+e.box[2]/2-e.box[3]*rad2deg(e.rotation.angle.yaw)/90,n=e.box[1]+e.box[3]/2+e.box[2]*rad2deg(e.rotation.angle.pitch)/90,a=new Path2D(`\n            M ${e.box[0]+e.box[2]/2} ${e.box[1]}\n            C\n              ${t} ${e.box[1]},\n              ${t} ${e.box[1]+e.box[3]},\n              ${e.box[0]+e.box[2]/2} ${e.box[1]+e.box[3]}\n          `),r=new Path2D(`\n            M ${e.box[0]} ${e.box[1]+e.box[3]/2}\n            C \n              ${e.box[0]} ${n},\n              ${e.box[0]+e.box[2]} ${n},\n              ${e.box[0]+e.box[2]} ${e.box[1]+e.box[3]/2}\n          `);u.stroke(r),u.stroke(a)}if(l.drawGaze&&(null==(s=null==(r=e.rotation)?void 0:r.gaze)?void 0:s.strength)&&(null==(i=null==(o=e.rotation)?void 0:o.gaze)?void 0:i.bearing)&&e.annotations.leftEyeIris&&e.annotations.rightEyeIris&&e.annotations.leftEyeIris[0]&&e.annotations.rightEyeIris[0]){u.strokeStyle="pink",u.fillStyle="pink";const t=[e.annotations.leftEyeIris[0][0]+Math.sin(e.rotation.gaze.bearing)*e.rotation.gaze.strength*e.box[3],e.annotations.leftEyeIris[0][1]+Math.cos(e.rotation.gaze.bearing)*e.rotation.gaze.strength*e.box[2]];arrow(u,[e.annotations.leftEyeIris[0][0],e.annotations.leftEyeIris[0][1]],[t[0],t[1]],4);const n=[e.annotations.rightEyeIris[0][0]+Math.sin(e.rotation.gaze.bearing)*e.rotation.gaze.strength*e.box[3],e.annotations.rightEyeIris[0][1]+Math.cos(e.rotation.gaze.bearing)*e.rotation.gaze.strength*e.box[2]];arrow(u,[e.annotations.rightEyeIris[0][0],e.annotations.rightEyeIris[0][1]],[n[0],n[1]],4)}}}}}async function body(e,t,n){var a;const r=mergeDeep(options2,n);if(!t||!e)return;const s=getCanvasContext(e);if(s){s.lineJoin="round";for(let e=0;e<t.length;e++){if(s.strokeStyle=r.color,s.fillStyle=r.color,s.lineWidth=r.lineWidth,s.font=r.font,r.drawBoxes&&t[e].box&&4===(null==(a=t[e].box)?void 0:a.length)&&(rect(s,t[e].box[0],t[e].box[1],t[e].box[2],t[e].box[3],r),r.drawLabels&&(r.shadowColor&&""!==r.shadowColor&&(s.fillStyle=r.shadowColor,s.fillText(`body ${100*t[e].score}%`,t[e].box[0]+3,1+t[e].box[1]+r.lineHeight,t[e].box[2])),s.fillStyle=r.labelColor,s.fillText(`body ${100*t[e].score}%`,t[e].box[0]+2,0+t[e].box[1]+r.lineHeight,t[e].box[2]))),r.drawPoints&&t[e].keypoints)for(let n=0;n<t[e].keypoints.length;n++)s.fillStyle=r.useDepth&&t[e].keypoints[n].position[2]?`rgba(${127.5+2*(t[e].keypoints[n].position[2]||0)}, ${127.5-2*(t[e].keypoints[n].position[2]||0)}, 255, 0.5)`:r.color,point(s,t[e].keypoints[n].position[0],t[e].keypoints[n].position[1],0,r);if(r.drawLabels&&t[e].keypoints){s.font=r.font;for(const n of t[e].keypoints)s.fillStyle=r.useDepth&&n.position[2]?`rgba(${127.5+2*n.position[2]}, ${127.5-2*n.position[2]}, 255, 0.5)`:r.color,s.fillText(`${n.part} ${Math.trunc(100*n.score)}%`,n.position[0]+4,n.position[1]+4)}if(r.drawPolygons&&t[e].keypoints&&t[e].annotations)for(const n of Object.values(t[e].annotations))for(const e of n)curves(s,e,r)}}}async function hand(e,t,n){const a=mergeDeep(options2,n);if(!t||!e)return;const r=getCanvasContext(e);if(r){r.lineJoin="round",r.font=a.font;for(const e of t){if(a.drawBoxes&&(r.strokeStyle=a.color,r.fillStyle=a.color,rect(r,e.box[0],e.box[1],e.box[2],e.box[3],a),a.drawLabels&&(a.shadowColor&&""!==a.shadowColor&&(r.fillStyle=a.shadowColor,r.fillText(`hand:${Math.trunc(100*e.score)}%`,e.box[0]+3,1+e.box[1]+a.lineHeight,e.box[2])),r.fillStyle=a.labelColor,r.fillText(`hand:${Math.trunc(100*e.score)}%`,e.box[0]+2,0+e.box[1]+a.lineHeight,e.box[2])),r.stroke()),a.drawPoints&&e.keypoints&&e.keypoints.length>0)for(const t of e.keypoints)r.fillStyle=a.useDepth?`rgba(${127.5+2*(t[2]||0)}, ${127.5-2*(t[2]||0)}, 255, 0.5)`:a.color,point(r,t[0],t[1],0,a);if(a.drawLabels&&e.annotations){const t=(e,t)=>{e&&0!==e.length&&e[0]&&(r.fillStyle=a.useDepth?`rgba(${127.5+2*e[e.length-1][2]}, ${127.5-2*e[e.length-1][2]}, 255, 0.5)`:a.color,r.fillText(t,e[e.length-1][0]+4,e[e.length-1][1]+4))};r.font=a.font,t(e.annotations.index,"index"),t(e.annotations.middle,"middle"),t(e.annotations.ring,"ring"),t(e.annotations.pinky,"pinky"),t(e.annotations.thumb,"thumb"),t(e.annotations.palm,"palm")}if(a.drawPolygons&&e.annotations){const t=e=>{if(e&&0!==e.length&&e[0])for(let t=0;t<e.length;t++)r.beginPath(),r.strokeStyle=a.useDepth?`rgba(${127.5+t*e[t][2]}, ${127.5-t*e[t][2]}, 255, 0.5)`:a.color,r.moveTo(e[t>0?t-1:0][0],e[t>0?t-1:0][1]),r.lineTo(e[t][0],e[t][1]),r.stroke()};r.lineWidth=a.lineWidth,t(e.annotations.index),t(e.annotations.middle),t(e.annotations.ring),t(e.annotations.pinky),t(e.annotations.thumb)}}}}async function object(e,t,n){const a=mergeDeep(options2,n);if(!t||!e)return;const r=getCanvasContext(e);if(r){r.lineJoin="round",r.font=a.font;for(const e of t)if(a.drawBoxes){if(r.strokeStyle=a.color,r.fillStyle=a.color,rect(r,e.box[0],e.box[1],e.box[2],e.box[3],a),a.drawLabels){const t=`${e.label} ${Math.round(100*e.score)}%`;a.shadowColor&&""!==a.shadowColor&&(r.fillStyle=a.shadowColor,r.fillText(t,e.box[0]+3,1+e.box[1]+a.lineHeight,e.box[2])),r.fillStyle=a.labelColor,r.fillText(t,e.box[0]+2,0+e.box[1]+a.lineHeight,e.box[2])}r.stroke()}}}async function person(e,t,n){const a=mergeDeep(options2,n);if(!t||!e)return;const r=getCanvasContext(e);if(r){r.lineJoin="round",r.font=a.font;for(let e=0;e<t.length;e++)if(a.drawBoxes){if(r.strokeStyle=a.color,r.fillStyle=a.color,rect(r,t[e].box[0],t[e].box[1],t[e].box[2],t[e].box[3],a),a.drawLabels){const n=`person #${e}`;a.shadowColor&&""!==a.shadowColor&&(r.fillStyle=a.shadowColor,r.fillText(n,t[e].box[0]+3,1+t[e].box[1]+a.lineHeight,t[e].box[2])),r.fillStyle=a.labelColor,r.fillText(n,t[e].box[0]+2,0+t[e].box[1]+a.lineHeight,t[e].box[2])}r.stroke()}}}async function canvas2(e,t){if(!e||!t)return;const n=getCanvasContext(t);n&&n.drawImage(e,0,0)}async function all5(e,t,n){if(!(t&&t.performance&&t&&e))return null;const a=now(),r=mergeDeep(options2,n),s=Promise.all([face(e,t.face,r),body(e,t.body,r),hand(e,t.hand,r),object(e,t.object,r),gesture(e,t.gesture,r)]);return drawTime=env2.perfadd?drawTime+Math.round(now()-a):Math.round(now()-a),t.performance.draw=drawTime,s}var expandFact=.1,alpha=.5;function insidePoly(e,t,n){let a=!1,r=n.length-1;for(let s=0;s<n.length;r=s++)n[s].y>t!=n[r].y>t&&e<(n[r].x-n[s].x)*(t-n[s].y)/(n[r].y-n[s].y)+n[s].x&&(a=!a);return a}async function mask(e){if(!e.tensor)return e.tensor;if(!e.mesh||e.mesh.length<100)return e.tensor;const t=e.tensor.shape[2]||0,n=e.tensor.shape[1]||0,a=await e.tensor.buffer();let r=[];for(const t of meshAnnotations.silhouette)r.push({x:(e.mesh[t][0]-e.box[0])/e.box[2],y:(e.mesh[t][1]-e.box[1])/e.box[3]});expandFact&&expandFact>0&&(r=r.map((e=>({x:e.x>.5?e.x+expandFact:e.x-expandFact,y:e.y>.5?e.y+expandFact:e.y-expandFact}))));for(let e=0;e<t;e++)for(let s=0;s<n;s++){insidePoly(e/t,s/t,r)||(a.set(alpha*a.get(0,s,e,0),0,s,e,0),a.set(alpha*a.get(0,s,e,1),0,s,e,1),a.set(alpha*a.get(0,s,e,2),0,s,e,2))}const s=a.toTensor();return dispose(a),s}var calculateGaze=e=>{if(!e.annotations.rightEyeIris||!e.annotations.leftEyeIris)return{bearing:0,strength:0};const t=[0,-.1],n=e.mesh[33][2]>e.mesh[263][2],a=n?e.mesh[473]:e.mesh[468],r=n?[(e.mesh[133][0]+e.mesh[33][0])/2,(e.mesh[133][1]+e.mesh[33][1])/2]:[(e.mesh[263][0]+e.mesh[362][0])/2,(e.mesh[263][1]+e.mesh[362][1])/2],s=n?[e.mesh[133][0]-e.mesh[33][0],e.mesh[23][1]-e.mesh[27][1]]:[e.mesh[263][0]-e.mesh[362][0],e.mesh[253][1]-e.mesh[257][1]],o=[(r[0]-a[0])/s[0]-t[0],1*(a[1]-r[1])/s[1]-t[1]];let i=Math.sqrt(o[0]**2+o[1]**2);i=Math.min(i,e.boxRaw[2]/2,e.boxRaw[3]/2);var l,u;return{bearing:(l=[0,0],u=o,(Math.atan2(l[1]-u[1],l[0]-u[0])+Math.PI/2)%Math.PI),strength:i}},calculateFaceAngle=(e,t)=>{const n=e=>{const t=Math.sqrt(e[0]*e[0]+e[1]*e[1]+e[2]*e[2]);return e[0]/=t,e[1]/=t,e[2]/=t,e},a=(e,t)=>[e[0]-t[0],e[1]-t[1],e[2]-t[2]],r=(e,t)=>[e[1]*t[2]-e[2]*t[1],e[2]*t[0]-e[0]*t[2],e[0]*t[1]-e[1]*t[0]],s=e.meshRaw;if(!s||s.length<300)return{angle:{pitch:0,yaw:0,roll:0},matrix:[1,0,0,0,1,0,0,0,1],gaze:{bearing:0,strength:0}};const o=Math.max(e.boxRaw[2]*t[0],e.boxRaw[3]*t[1])/1.5,i=[s[10],s[152],s[234],s[454]].map((e=>[e[0]*t[0]/o,e[1]*t[1]/o,e[2]])),l=n(a(i[1],i[0]));let u=n(a(i[3],i[2]));const c=n(r(u,l));u=r(l,c);const d=[u[0],u[1],u[2],l[0],l[1],l[2],c[0],c[1],c[2]];return{angle:(e=>{const[t,n,a,r,s,o,i,l,u]=e;let c,d,p;return r<1?r>-1?(p=Math.asin(r),d=Math.atan2(-i,t),c=Math.atan2(-o,s)):(p=-Math.PI/2,d=-Math.atan2(l,u),c=0):(p=Math.PI/2,d=Math.atan2(l,u),c=0),isNaN(c)&&(c=0),isNaN(d)&&(d=0),isNaN(p)&&(p=0),{pitch:2*-c,yaw:2*-d,roll:2*-p}})(d),matrix:d,gaze:478===s.length?calculateGaze(e):{bearing:0,strength:0}}},detectFace=async(e,t)=>{var n,a,r,s,o,i,l,u,c,d,p,h,m,f,g,x,y,A,b,v,k,S,w,C,I,T;let N,_,E,P,R,M,F,D,O;const z=[];e.state="run:face",N=now();const L=await predict10(t,e.config);if(e.performance.face=env2.perfadd?(e.performance.face||0)+Math.trunc(now()-N):Math.trunc(now()-N),!t.shape||4!==t.shape.length)return[];if(!L)return[];for(let $=0;$<L.length;$++){if(e.analyze("Get Face"),!L[$].tensor||L[$].tensor.isDisposedInternal){log("Face object is disposed:",L[$].tensor);continue}if(null==(n=e.config.face.detector)?void 0:n.mask){const e=await mask(L[$]);dispose(L[$].tensor),L[$].tensor=e}const B=L[$].mesh&&L[$].mesh.length>200?calculateFaceAngle(L[$],[t.shape[2],t.shape[1]]):null;e.analyze("Start Emotion:"),e.config.async?R=(null==(a=e.config.face.emotion)?void 0:a.enabled)?predict8(L[$].tensor||tensor([]),e.config,$,L.length):null:(e.state="run:emotion",N=now(),R=(null==(r=e.config.face.emotion)?void 0:r.enabled)?await predict8(L[$].tensor||tensor([]),e.config,$,L.length):null,e.performance.emotion=env2.perfadd?(e.performance.emotion||0)+Math.trunc(now()-N):Math.trunc(now()-N)),e.analyze("End Emotion:"),e.analyze("Start AntiSpoof:"),e.config.async?F=(null==(s=e.config.face.antispoof)?void 0:s.enabled)?predict4(L[$].tensor||tensor([]),e.config,$,L.length):null:(e.state="run:antispoof",N=now(),F=(null==(o=e.config.face.antispoof)?void 0:o.enabled)?await predict4(L[$].tensor||tensor([]),e.config,$,L.length):null,e.performance.antispoof=env2.perfadd?(e.performance.antispoof||0)+Math.trunc(now()-N):Math.trunc(now()-N)),e.analyze("End AntiSpoof:"),e.analyze("Start Liveness:"),e.config.async?D=(null==(i=e.config.face.liveness)?void 0:i.enabled)?predict14(L[$].tensor||tensor([]),e.config,$,L.length):null:(e.state="run:liveness",N=now(),D=(null==(l=e.config.face.liveness)?void 0:l.enabled)?await predict14(L[$].tensor||tensor([]),e.config,$,L.length):null,e.performance.liveness=env2.perfadd?(e.performance.antispoof||0)+Math.trunc(now()-N):Math.trunc(now()-N)),e.analyze("End Liveness:"),e.analyze("Start GEAR:"),e.config.async?E=(null==(u=e.config.face.gear)?void 0:u.enabled)?predict(L[$].tensor||tensor([]),e.config,$,L.length):{}:(e.state="run:gear",N=now(),E=(null==(c=e.config.face.gear)?void 0:c.enabled)?await predict(L[$].tensor||tensor([]),e.config,$,L.length):{},e.performance.gear=Math.trunc(now()-N)),e.analyze("End GEAR:"),e.analyze("Start SSRNet:"),e.config.async?(_=(null==(d=e.config.face.ssrnet)?void 0:d.enabled)?predict2(L[$].tensor||tensor([]),e.config,$,L.length):{},P=(null==(p=e.config.face.ssrnet)?void 0:p.enabled)?predict3(L[$].tensor||tensor([]),e.config,$,L.length):{}):(e.state="run:ssrnet",N=now(),_=(null==(h=e.config.face.ssrnet)?void 0:h.enabled)?await predict2(L[$].tensor||tensor([]),e.config,$,L.length):{},P=(null==(m=e.config.face.ssrnet)?void 0:m.enabled)?await predict3(L[$].tensor||tensor([]),e.config,$,L.length):{},e.performance.ssrnet=Math.trunc(now()-N)),e.analyze("End SSRNet:"),e.analyze("Start MobileFaceNet:"),e.config.async?M=(null==(f=e.config.face.mobilefacenet)?void 0:f.enabled)?predict9(L[$].tensor||tensor([]),e.config,$,L.length):{}:(e.state="run:mobilefacenet",N=now(),M=(null==(g=e.config.face.mobilefacenet)?void 0:g.enabled)?await predict9(L[$].tensor||tensor([]),e.config,$,L.length):{},e.performance.mobilefacenet=Math.trunc(now()-N)),e.analyze("End MobileFaceNet:"),e.analyze("Start Description:"),e.config.async?O=(null==(x=e.config.face.description)?void 0:x.enabled)?predict11(L[$].tensor||tensor([]),e.config,$,L.length):null:(e.state="run:description",N=now(),O=(null==(y=e.config.face.description)?void 0:y.enabled)?await predict11(L[$].tensor||tensor([]),e.config,$,L.length):null,e.performance.description=env2.perfadd?(e.performance.description||0)+Math.trunc(now()-N):Math.trunc(now()-N)),e.analyze("End Description:"),e.config.async&&([_,P,R,M,O,E,F,D]=await Promise.all([_,P,R,M,O,E,F,D])),e.analyze("Finish Face:"),(null==(A=e.config.face.ssrnet)?void 0:A.enabled)&&_&&P&&(O={age:_.age,gender:P.gender,genderScore:P.genderScore}),(null==(b=e.config.face.gear)?void 0:b.enabled)&&E&&(O={age:E.age,gender:E.gender,genderScore:E.genderScore,race:E.race}),(null==(v=e.config.face.mobilefacenet)?void 0:v.enabled)&&M&&(O.descriptor=M),!(null==(k=e.config.face.iris)?void 0:k.enabled)&&(null==(w=null==(S=L[$])?void 0:S.annotations)?void 0:w.leftEyeIris)&&(null==(I=null==(C=L[$])?void 0:C.annotations)?void 0:I.rightEyeIris)&&(delete L[$].annotations.leftEyeIris,delete L[$].annotations.rightEyeIris);const V=L[$].annotations&&L[$].annotations.leftEyeIris&&L[$].annotations.leftEyeIris[0]&&L[$].annotations.rightEyeIris&&L[$].annotations.rightEyeIris[0]&&L[$].annotations.leftEyeIris.length>0&&L[$].annotations.rightEyeIris.length>0&&null!==L[$].annotations.leftEyeIris[0]&&null!==L[$].annotations.rightEyeIris[0]?Math.max(Math.abs(L[$].annotations.leftEyeIris[3][0]-L[$].annotations.leftEyeIris[1][0]),Math.abs(L[$].annotations.rightEyeIris[4][1]-L[$].annotations.rightEyeIris[2][1]))/t.shape[2]:0,U=(null==(T=e.config.face.detector)?void 0:T.return)?squeeze(L[$].tensor):null;dispose(L[$].tensor),L[$].tensor&&delete L[$].tensor;const G={...L[$],id:$};(null==O?void 0:O.age)&&(G.age=O.age),(null==O?void 0:O.gender)&&(G.gender=O.gender),(null==O?void 0:O.genderScore)&&(G.genderScore=null==O?void 0:O.genderScore),(null==O?void 0:O.descriptor)&&(G.embedding=null==O?void 0:O.descriptor),(null==O?void 0:O.race)&&(G.race=null==O?void 0:O.race),R&&(G.emotion=R),F&&(G.real=F),D&&(G.live=D),V&&0!==V&&(G.iris=Math.trunc(500/V/11.7)/100),B&&(G.rotation=B),U&&(G.tensor=U),z.push(G),e.analyze("End Face")}return e.analyze("End FaceMesh:"),e.config.async&&(e.performance.face&&delete e.performance.face,e.performance.age&&delete e.performance.age,e.performance.gender&&delete e.performance.gender,e.performance.emotion&&delete e.performance.emotion),z},body2=e=>{if(!e)return[];const t=[];for(let n=0;n<e.length;n++){const a=e[n].keypoints.find((e=>"leftWrist"===e.part)),r=e[n].keypoints.find((e=>"rightWrist"===e.part)),s=e[n].keypoints.find((e=>"nose"===e.part));s&&a&&r&&a.position[1]<s.position[1]&&r.position[1]<s.position[1]?t.push({body:n,gesture:"i give up"}):s&&a&&a.position[1]<s.position[1]?t.push({body:n,gesture:"raise left hand"}):s&&r&&r.position[1]<s.position[1]&&t.push({body:n,gesture:"raise right hand"});const o=e[n].keypoints.find((e=>"leftShoulder"===e.part)),i=e[n].keypoints.find((e=>"rightShoulder"===e.part));o&&i&&Math.abs(o.positionRaw[1]-i.positionRaw[1])>.1&&t.push({body:n,gesture:"leaning "+(o.position[1]>i.position[1]?"left":"right")})}return t},face2=e=>{if(!e)return[];const t=[];for(let n=0;n<e.length;n++)if(e[n].mesh&&e[n].mesh.length>450){const a=e[n].mesh[33][2]-e[n].mesh[263][2],r=e[n].mesh[33][0]-e[n].mesh[263][0];Math.abs(a/r)<=.15?t.push({face:n,gesture:"facing center"}):t.push({face:n,gesture:"facing "+(a<0?"left":"right")});Math.abs(e[n].mesh[374][1]-e[n].mesh[386][1])/Math.abs(e[n].mesh[443][1]-e[n].mesh[450][1])<.2&&t.push({face:n,gesture:"blink left eye"});Math.abs(e[n].mesh[145][1]-e[n].mesh[159][1])/Math.abs(e[n].mesh[223][1]-e[n].mesh[230][1])<.2&&t.push({face:n,gesture:"blink right eye"});const s=Math.min(100,500*Math.abs(e[n].mesh[13][1]-e[n].mesh[14][1])/Math.abs(e[n].mesh[10][1]-e[n].mesh[152][1]));s>10&&t.push({face:n,gesture:`mouth ${Math.trunc(s)}% open`});const o=e[n].mesh[152][2];Math.abs(o)>10&&t.push({face:n,gesture:"head "+(o<0?"up":"down")})}return t},iris3=e=>{if(!e)return[];const t=[];for(let n=0;n<e.length;n++){if(!(e[n].annotations&&e[n].annotations.leftEyeIris&&e[n].annotations.leftEyeIris[0]&&e[n].annotations.rightEyeIris&&e[n].annotations.rightEyeIris[0]))continue;const a=e[n].annotations.leftEyeIris[3][0]-e[n].annotations.leftEyeIris[1][0],r=e[n].annotations.leftEyeIris[4][1]-e[n].annotations.leftEyeIris[2][1],s=Math.abs(a*r),o=e[n].annotations.rightEyeIris[3][0]-e[n].annotations.rightEyeIris[1][0],i=e[n].annotations.rightEyeIris[4][1]-e[n].annotations.rightEyeIris[2][1],l=Math.abs(o*i);let u=!1;Math.abs(s-l)/Math.max(s,l)<.25&&(u=!0,t.push({iris:n,gesture:"facing center"}));const c=Math.abs(e[n].mesh[263][0]-e[n].annotations.leftEyeIris[0][0])/e[n].box[2],d=Math.abs(e[n].mesh[33][0]-e[n].annotations.rightEyeIris[0][0])/e[n].box[2];(c>.06||d>.06)&&(u=!1),c>d?c>.05&&t.push({iris:n,gesture:"looking right"}):d>.05&&t.push({iris:n,gesture:"looking left"});const p=Math.abs(e[n].mesh[145][1]-e[n].annotations.rightEyeIris[0][1])/e[n].box[3],h=Math.abs(e[n].mesh[374][1]-e[n].annotations.leftEyeIris[0][1])/e[n].box[3];(h<.01||p<.01||h>.022||p>.022)&&(u=!1),(h<.01||p<.01)&&t.push({iris:n,gesture:"looking down"}),(h>.022||p>.022)&&t.push({iris:n,gesture:"looking up"}),u&&t.push({iris:n,gesture:"looking center"})}return t},hand2=e=>{if(!e)return[];const t=[];for(let n=0;n<e.length;n++){const a=[];if(e[n].annotations)for(const[t,r]of Object.entries(e[n].annotations))"palmBase"!==t&&Array.isArray(r)&&r[0]&&a.push({name:t.toLowerCase(),position:r[0]});if(a&&a.length>0){const e=a.reduce(((e,t)=>e.position[2]<t.position[2]?e:t));t.push({hand:n,gesture:`${e.name} forward`});const r=a.reduce(((e,t)=>e.position[1]<t.position[1]?e:t));t.push({hand:n,gesture:`${r.name} up`})}if(e[n].keypoints){const a=match(e[n].keypoints);for(const e of a)t.push({hand:n,gesture:e.name})}}return t},bufferedResult={face:[],body:[],hand:[],gesture:[],object:[],persons:[],performance:{},timestamp:0,error:null},interpolateTime=0;function calc2(e,t){var n,a,r,s,o,i,l,u,c,d,p,h,m,f,g,x,y,A,b,v,k,S,w,C,I,T,N;const _=now();if(!e)return{face:[],body:[],hand:[],gesture:[],object:[],persons:[],performance:{},timestamp:0,error:null};const E=Date.now()-e.timestamp,P=E<1e3?8-Math.log(E+1):1;if(e.canvas&&(bufferedResult.canvas=e.canvas),e.error&&(bufferedResult.error=e.error),bufferedResult.body&&e.body.length===bufferedResult.body.length)for(let l=0;l<e.body.length;l++){const u=e.body[l].box.map(((e,t)=>((P-1)*bufferedResult.body[l].box[t]+e)/P)),c=e.body[l].boxRaw.map(((e,t)=>((P-1)*bufferedResult.body[l].boxRaw[t]+e)/P)),d=e.body[l].keypoints.map(((e,t)=>({score:e.score,part:e.part,position:[bufferedResult.body[l].keypoints[t]?((P-1)*bufferedResult.body[l].keypoints[t].position[0]+e.position[0])/P:e.position[0],bufferedResult.body[l].keypoints[t]?((P-1)*bufferedResult.body[l].keypoints[t].position[1]+e.position[1])/P:e.position[1]],positionRaw:[bufferedResult.body[l].keypoints[t]?((P-1)*bufferedResult.body[l].keypoints[t].positionRaw[0]+e.positionRaw[0])/P:e.position[0],bufferedResult.body[l].keypoints[t]?((P-1)*bufferedResult.body[l].keypoints[t].positionRaw[1]+e.positionRaw[1])/P:e.position[1]]}))),p={};let h={connected:{}};(null==(a=null==(n=t.body)?void 0:n.modelPath)?void 0:a.includes("efficientpose"))?h=efficientposecoords_exports:(null==(s=null==(r=t.body)?void 0:r.modelPath)?void 0:s.includes("blazepose"))?h=blazeposecoords_exports:(null==(i=null==(o=t.body)?void 0:o.modelPath)?void 0:i.includes("movenet"))&&(h=movenetcoords_exports);for(const[e,n]of Object.entries(h.connected)){const a=[];for(let e=0;e<n.length-1;e++){const r=d.find((t=>t.part===n[e])),s=d.find((t=>t.part===n[e+1]));r&&s&&r.score>(t.body.minConfidence||0)&&s.score>(t.body.minConfidence||0)&&a.push([r.position,s.position])}p[e]=a}bufferedResult.body[l]={...e.body[l],box:u,boxRaw:c,keypoints:d,annotations:p}}else bufferedResult.body=JSON.parse(JSON.stringify(e.body));if(bufferedResult.hand&&e.hand.length===bufferedResult.hand.length)for(let t=0;t<e.hand.length;t++){const n=e.hand[t].box.map(((e,n)=>((P-1)*bufferedResult.hand[t].box[n]+e)/P)),a=e.hand[t].boxRaw.map(((e,n)=>((P-1)*bufferedResult.hand[t].boxRaw[n]+e)/P));bufferedResult.hand[t].keypoints.length!==e.hand[t].keypoints.length&&(bufferedResult.hand[t].keypoints=e.hand[t].keypoints);const r=e.hand[t].keypoints&&e.hand[t].keypoints.length>0?e.hand[t].keypoints.map(((e,n)=>e.map(((e,a)=>((P-1)*(bufferedResult.hand[t].keypoints[n][a]||1)+(e||0))/P)))):[];let s={};if(Object.keys(bufferedResult.hand[t].annotations).length!==Object.keys(e.hand[t].annotations).length)bufferedResult.hand[t].annotations=e.hand[t].annotations,s=bufferedResult.hand[t].annotations;else if(e.hand[t].annotations)for(const n of Object.keys(e.hand[t].annotations))s[n]=e.hand[t].annotations[n]&&e.hand[t].annotations[n][0]?e.hand[t].annotations[n].map(((e,a)=>e.map(((e,r)=>((P-1)*bufferedResult.hand[t].annotations[n][a][r]+e)/P)))):null;bufferedResult.hand[t]={...e.hand[t],box:n,boxRaw:a,keypoints:r,annotations:s}}else bufferedResult.hand=JSON.parse(JSON.stringify(e.hand));if(bufferedResult.face&&e.face.length===bufferedResult.face.length)for(let t=0;t<e.face.length;t++){const n=e.face[t].box.map(((e,n)=>((P-1)*bufferedResult.face[t].box[n]+e)/P)),a=e.face[t].boxRaw.map(((e,n)=>((P-1)*bufferedResult.face[t].boxRaw[n]+e)/P));if(e.face[t].rotation){const r={matrix:[0,0,0,0,0,0,0,0,0],angle:{roll:0,yaw:0,pitch:0},gaze:{bearing:0,strength:0}};r.matrix=null==(l=e.face[t].rotation)?void 0:l.matrix,r.angle={roll:((P-1)*((null==(c=null==(u=bufferedResult.face[t].rotation)?void 0:u.angle)?void 0:c.roll)||0)+((null==(p=null==(d=e.face[t].rotation)?void 0:d.angle)?void 0:p.roll)||0))/P,yaw:((P-1)*((null==(m=null==(h=bufferedResult.face[t].rotation)?void 0:h.angle)?void 0:m.yaw)||0)+((null==(g=null==(f=e.face[t].rotation)?void 0:f.angle)?void 0:g.yaw)||0))/P,pitch:((P-1)*((null==(y=null==(x=bufferedResult.face[t].rotation)?void 0:x.angle)?void 0:y.pitch)||0)+((null==(b=null==(A=e.face[t].rotation)?void 0:A.angle)?void 0:b.pitch)||0))/P},r.gaze={bearing:((P-1)*((null==(k=null==(v=bufferedResult.face[t].rotation)?void 0:v.gaze)?void 0:k.bearing)||0)+((null==(w=null==(S=e.face[t].rotation)?void 0:S.gaze)?void 0:w.bearing)||0))/P,strength:((P-1)*((null==(I=null==(C=bufferedResult.face[t].rotation)?void 0:C.gaze)?void 0:I.strength)||0)+((null==(N=null==(T=e.face[t].rotation)?void 0:T.gaze)?void 0:N.strength)||0))/P},bufferedResult.face[t]={...e.face[t],rotation:r,box:n,boxRaw:a}}bufferedResult.face[t]={...e.face[t],box:n,boxRaw:a}}else bufferedResult.face=JSON.parse(JSON.stringify(e.face));if(bufferedResult.object&&e.object.length===bufferedResult.object.length)for(let t=0;t<e.object.length;t++){const n=e.object[t].box.map(((e,n)=>((P-1)*bufferedResult.object[t].box[n]+e)/P)),a=e.object[t].boxRaw.map(((e,n)=>((P-1)*bufferedResult.object[t].boxRaw[n]+e)/P));bufferedResult.object[t]={...e.object[t],box:n,boxRaw:a}}else bufferedResult.object=JSON.parse(JSON.stringify(e.object));if(e.persons){const t=e.persons;if(bufferedResult.persons&&t.length===bufferedResult.persons.length)for(let e=0;e<t.length;e++)bufferedResult.persons[e].box=t[e].box.map(((t,n)=>((P-1)*bufferedResult.persons[e].box[n]+t)/P));else bufferedResult.persons=JSON.parse(JSON.stringify(t))}e.gesture&&(bufferedResult.gesture=e.gesture);const R=now();return interpolateTime=env2.perfadd?interpolateTime+Math.round(R-_):Math.round(R-_),e.performance&&(bufferedResult.performance={...e.performance,interpolate:interpolateTime}),bufferedResult}function distance(e,t,n={order:2,multiplier:25}){let a=0;for(let r=0;r<e.length;r++){const s=n.order&&2!==n.order?Math.abs(e[r]-t[r]):e[r]-t[r];a+=n.order&&2!==n.order?s**n.order:s*s}return(n.multiplier||20)*a}var normalizeDistance=(e,t,n,a)=>{if(0===e)return 1;const r=(1-(2===t?Math.sqrt(e):e**(1/t))/100-n)/(a-n);return Math.max(Math.min(r,1),0)};function similarity(e,t,n={order:2,multiplier:25,min:.2,max:.8}){const a=distance(e,t,n);return normalizeDistance(a,n.order||2,n.min||0,n.max||1)}function match2(e,t,n={order:2,multiplier:25,threshold:0,min:.2,max:.8}){if(!Array.isArray(e)||!Array.isArray(t)||e.length<64||0===t.length||e.length!==t[0].length)return{index:-1,distance:Number.POSITIVE_INFINITY,similarity:0};let a=Number.MAX_SAFE_INTEGER,r=-1;for(let s=0;s<t.length;s++){const o=distance(e,t[s],n);if(o<a&&(a=o,r=s),a<(n.threshold||0))break}return{index:r,distance:a,similarity:normalizeDistance(a,n.order||2,n.min||0,n.max||1)}}function join2(e,t,n,a,r){var s,o,i,l,u,c,d,p,h,m,f,g,x,y,A,b;let v=0;const k=[];for(const S of e){const e={id:v++,face:S,body:null,hands:{left:null,right:null},gestures:[],box:[0,0,0,0]};for(const n of t)S.box[0]>n.box[0]&&S.box[0]<n.box[0]+n.box[2]&&S.box[1]+S.box[3]>n.box[1]&&S.box[1]+S.box[3]<n.box[1]+n.box[3]&&(e.body=n);if(e.body)for(const t of n)t.box[0]+t.box[2]>e.body.box[0]&&t.box[0]+t.box[2]<e.body.box[0]+e.body.box[2]&&t.box[1]+t.box[3]>e.body.box[1]&&t.box[1]+t.box[3]<e.body.box[1]+e.body.box[3]&&e.hands&&(e.hands.left=t),t.box[0]<e.body.box[0]+e.body.box[2]&&t.box[0]>e.body.box[0]&&t.box[1]+t.box[3]>e.body.box[1]&&t.box[1]+t.box[3]<e.body.box[1]+e.body.box[3]&&e.hands&&(e.hands.right=t);for(const t of a)void 0!==t.face&&t.face===S.id?null==(s=e.gestures)||s.push(t):void 0!==t.iris&&t.iris===S.id?null==(o=e.gestures)||o.push(t):void 0!==t.body&&t.body===(null==(i=e.body)?void 0:i.id)?null==(l=e.gestures)||l.push(t):void 0!==t.hand&&t.hand===(null==(c=null==(u=e.hands)?void 0:u.left)?void 0:c.id)?null==(d=e.gestures)||d.push(t):void 0!==t.hand&&t.hand===(null==(h=null==(p=e.hands)?void 0:p.right)?void 0:h.id)&&(null==(m=e.gestures)||m.push(t));const w=[],C=[],I=e=>{e&&4===e.length&&(w.push(e[0],e[0]+e[2]),C.push(e[1],e[1]+e[3]))};I(null==(f=e.face)?void 0:f.box),I(null==(g=e.body)?void 0:g.box),I(null==(y=null==(x=e.hands)?void 0:x.left)?void 0:y.box),I(null==(b=null==(A=e.hands)?void 0:A.right)?void 0:b.box);const T=Math.min(...w),N=Math.min(...C);e.box=[T,N,Math.max(...w)-T,Math.max(...C)-N],r&&r[1]&&r[2]&&(e.boxRaw=[e.box[0]/r[2],e.box[1]/r[1],e.box[2]/r[2],e.box[3]/r[1]]),k.push(e)}return k}var _numTensors,_analyzeMemoryLeaks,_checkSanity,_sanity,face3="\n/9j/4AAQSkZJRgABAQEAYABgAAD/4QBoRXhpZgAATU0AKgAAAAgABAEaAAUAAAABAAAAPgEbAAUA\nAAABAAAARgEoAAMAAAABAAIAAAExAAIAAAARAAAATgAAAAAAAABgAAAAAQAAAGAAAAABcGFpbnQu\nbmV0IDQuMi4xMwAA/9sAQwAGBAUGBQQGBgUGBwcGCAoQCgoJCQoUDg8MEBcUGBgXFBYWGh0lHxob\nIxwWFiAsICMmJykqKRkfLTAtKDAlKCko/9sAQwEHBwcKCAoTCgoTKBoWGigoKCgoKCgoKCgoKCgo\nKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgo/8AAEQgBAAEAAwEhAAIRAQMRAf/E\nAB8AAAEFAQEBAQEBAAAAAAAAAAABAgMEBQYHCAkKC//EALUQAAIBAwMCBAMFBQQEAAABfQECAwAE\nEQUSITFBBhNRYQcicRQygZGhCCNCscEVUtHwJDNicoIJChYXGBkaJSYnKCkqNDU2Nzg5OkNERUZH\nSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6g4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1\ntre4ubrCw8TFxsfIycrS09TV1tfY2drh4uPk5ebn6Onq8fLz9PX29/j5+v/EAB8BAAMBAQEBAQEB\nAQEAAAAAAAABAgMEBQYHCAkKC//EALURAAIBAgQEAwQHBQQEAAECdwABAgMRBAUhMQYSQVEHYXET\nIjKBCBRCkaGxwQkjM1LwFWJy0QoWJDThJfEXGBkaJicoKSo1Njc4OTpDREVGR0hJSlNUVVZXWFla\nY2RlZmdoaWpzdHV2d3h5eoKDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXG\nx8jJytLT1NXW19jZ2uLj5OXm5+jp6vLz9PX29/j5+v/aAAwDAQACEQMRAD8A+qaKACigApGOKAML\nXp8xlF5A7V4X8RtYs7PzfNImnx8sa8Kp9z3q2tEgp6angWs62ZZ5CTGoJ6DArGNz5p+UrID6EUrF\nPUlW1EuN0XNW7PQ2L5j3JnoKXN0KijqNP0eYoqXBdgPuuo+ZPeupisWn2Jd4+0r924XgsQOCff3/\nAJ1FzRKxDqGii6m3siiQ8F1XGfXI6YNWLfRbiRQMkcZI9fpTDluT2/h6Qy8gDPbtmtG38JeY480Z\n5zSLUTZg8M28YwYxjAArXtdPt402qgHbpSaLWhma3o0Uqk7Nx9DWLaaVblgPs6qRyds2M/gRSQp9\nzZOni2iWS2hlQ+kjYz9OMGrdjq89vIPPVhj+8M/lQyDq9P1WOYBlMZz1AOD+VdDaTiReOKulK0jO\ntHmi0WDTlr0TyxRVhT8tJjIX+9SUxHXUV553BRQAVBcPhSBTSuxPY86+IGti0s5I7dsORy9fM3i6\n8e8mfDO5P90ZrWWiJicNPpZZtxV/xrW0jQt4DOv6Vk2dEEdTY6BHuB25rpbPSo0QARjP0qTRI17W\nwA/hFaMWmoQMgflQXYsDS142rU9tpqqenfNA7GgtihxkdKuRW6qMY/GkDZY8sY4Ap4hXbyB+VArk\nEtuH4wPyrk/EGkOm+a3jw3suRQLc5i38SX9hJ9nnY+XnBUdPyNdFY6pa3KkkAE9l6f8AfJ/pSJT6\nGhDmI+Zb4ZRycdv6ium0nUhKFydrelTsNnS2829RnrVgV6NKXNG55lWPLIM81Op+WrZkRMfmNNzT\nA7GivPO4KKAEY4XNYWt3vkwPg4OK0giJdjw/xrqhm87Zs8tc7pX5A+leSajf6aHYJ50kn4AZpTep\nrBWRm2Vobm4BXfyehPFdnpmnBFUY5rI2SN63tlToK0YI+KZpFF+3QdavwoKTLtoW0Toaswpk5pCb\nLCxipAhoIuP2dKevHXoaYDylRyxhlwRQI4nxVoCXWZI1GfpXGtbSWjYPGP73+NIGupt6TqMsLruZ\nih4xnP5V09mQ+JLd8gn0xSYJnVaVdkook69K34zuUGunDS3Rx4qOzHVIp4rrOMY3NJQI7GivPO8K\nKAILt9kZrz3xlebYiu8KCCWb0XvW0NFch6ysfO3jLVjfXLIn+pQkKorl7WxNxIPl71g2dUUdpo+l\npBGvHPet23iC8ihFosrxirkHQUFo0IF4FXI1O726CpKLacCrMJoJLYHAPpTwucHpSRJJ5e4AZI9x\nUqpxzVpCuOC8cUpQUMRnXttuB4rjNdsYyeVwfXpmpGmcvcQyafMCFJjPY10eg34BUg4DcZP8jUO4\nHaRq3lLNF+IHet7R7jz7c56rwa2wz9+xhiVeFy/T1PFegeaNPWigDsc0ZrzzvDNIaAM7VpNqdegr\nxL4l6kywyRhseZ19lrdfAZL4jxYg3Fw20d63tJsdrDI5rm3Z3R0R0Mce1eKnQYAplIkWrMJ45oZS\nNO3PHbNXIyfpSGWowSOasxLUiZdjFSqtNEMkUemKlAGKsRJjAppFAiORMjmsTVrNZEO4cfSoZSOD\n1eJ7WXBUzQZ+7nkfSo7e2Ei+ZaMzxntjBX2NSU1Y6/wxqojiEFzkA8KTXYaUoWRyv3W5rSjpNHPX\n+BmpSg8V6J5gUUAdhRXnneFFAGHrTfu5PpXzj8S70/aZtxzztXFbv4DKHxHI+H4GZiz9zxXXW8G3\nGBXMjvLRXAx0oPGPSmMVeOnWrMTYpFI0bcg1fh54xmgovRcD3qxETSIZcRvzp+/BpEkqsBUqsM9K\nq4Em4Gkxk0yRGXrVW6i8yFhkg+tJjRxGsWrxllkUMh9eK5uMz6bcebbnfG33kPcVkay2OntPKuo0\nnhXI67c8qa7Lw3c+adjcEDGK1paSRhVV4s6A0or0jyRRQ1AHX0V553hRQBz+vNtt5z3xXzX8Qbdm\nuic5YnOMdK3l8JnTXvlbwpYl+WySOgrp5YfLOOB9O1c62O7qQkc+9RsKChFPWp4DluOlSykaNruH\nArUgHShFNF2NT1qxGO3NBmyxGcE1N2560CFzjrUysO9JAPDDjFOVuKoQuSRTWouBkazbCa3cd8cV\nwF7IISQccHBzUSWpV9C3o1x5b5GAjdQD1rs9DjC3kckbEhqKfxIzn8LOupRXqnkPccBSkUAzraK8\n87wooA5rxMSI3HqK8B8bQl9Q8sffY5b/AAraXwkUviNrw9pH2W1ViMMRTdRjw4HpWNtDti9TPc4P\nFQs2M5qdyyMHLcfjV63HTAoBGtap0wK0YxigpsuRDtVhVYd6GQydVwwIqdRnqKCR23I5pCMUW6gD\nYNKuetAEise9KTxQBWuFyhrznxNZkXjFeN3I+tTIZg2OqmzmxNF0PO3vXp/g2+hukVl4zyPanTXv\nJmVR+60dpThXpnlPceopWFAbnV0V553hSGgRynjC5FujOey14Ssp1HxNmTnc+a3kvcIpv37HoEYQ\nQmMdVHSsnVbYJF5jVk0dsNzlruVIsl2wKxbjWrVHILjg1CRbZJb+ILHPzyhfStODWLQgFJFYd+el\nUJM27HUIXxhga1Y5lLVLKLkMnoauxnPPrSEx7ShF+Y/n2qrc6xBbhizDAqkK1zJuvG9nbg8ZA681\nly/Ei052RO3uKAsZlx8QGd8xxvt9Aa1NH8dK7AXMcip64zigdkdrZX8F7EJLdwwNXMkrz1qRMRly\nCK4TxmpidWI49felPYSOMmi80NIoOV6qRzXYeA5SskYPfirpfEjGr8LPWVHyD6U4CvQPL3ZItOYc\nUDOoNFeed4Uhpks4H4iE/Z5MeleMeGULeLgjds10S+BGdL+Jc9OSBU2Huc5Nc74yvUtrcDBrJnZF\n63PJdXvLy/lKWw46bvQVz82jXhkLO5Y+9ZlsYthcRnbIjY9R3q3awTRkEM3WmJI6C0ea3dGRsr1x\nXY6TqW9FLHnjrUs0izpLK5DDjofSta3ckH09KRUkZuuTvFGdvPauE1Y3U6Mqbssf/rUxHPTaJPK2\nZmJPbBqzY6DCZh5xJC9s9aBJHU6dpemJjfEmfetJtI0+VPkUr/unFOxdiextHs33W07YHQHk11mk\nXb3KbZ1xIvcd6LEyWho4Nct41sTPYb16ipexCPPZN+wYGCvH1rrPAEJmvkPoc1VL4kZVvgZ6yFwK\ncBXoHkkqinFaVyzo80GuE7WJRQSziPiGdthK5HQV4x4J/wBI8WPIewNdEvgRNL42emO/yj1UHNef\neNpRczbC+I17DvWT2OqJxc0sMK4TCisy41q0hfEkqj8aixdwTXNOlwvmqD9anS9tXH7uVG+hosO4\n/wC0oOhrR0+6G4YNIEzsNEuCxAPNdjZruA4xxUmjINSjURksOlcbqFykbnjFA1sYGoassaknCqO5\nrl7rxhGm7yBnBxuJq0rkSlYpw+NLlsfd5P8AerVsvHEqSBHwPVgcgVpyMyVXU3rXxcHYETAk+hru\n/DWti6ZSTyOKzZqndHaxvvUGq2rQ+dYyqR24qWI8dvbr7LqDxyDAzXpvw6FvIxePGSM06Xxoyr/A\nzviKFHNegeX1J41zUhXioGbuaSuM6wpCaBHG/EcA6HN/exxXjXw2jL67cv8A3Qa6H8CFR+NnoWpO\nI4XI44rxLxrqjQzSEsQM1gdSPM9U1uR1YbmWIdXHf2rmpIb67YS28UrRlsLI3c/jW0VZGUpO5pW1\njfLNOjahawzwReYI5cjzMkDavHJ5/SrVv9uhtPtVxCPLBwzxnlT9KGghLU3tKvvPjHzbl7EGuisJ\nGRxWLOg7nRXJEbDjmvSNK+aFSfSoZr0KutRkphc4NcRrdkVjL9aVio7Hk3iqS8ubhrWzUlsZY9kG\ncZNc5D4aee5MclzJIFTzHAO0MfatqSOWu7bFS1srDUZEis0vIZoUxPvfcC+4/dx2xjr712XiTwXb\nWmlQ6hol3cRhoFd4rlg3zY5wR0GelavQwjq7GD4etdVvSnk2wAB+9v8A8mvcfA2kXiRo0/UdcDis\nZnTTulqeoWqbUAJqWUb42X1FZlnjfjSwlGrr5S/eNdD4RkvLAAQ4yRyaUZcruVKl7TQ9I0G+mnzH\nckFwM8VuIK7ac3KF2eXiKapz5UWYxipNtMyNejNch0jSar3cjR27uoyQCRVRWom9DxTx54gu5fMi\nlbKdMVjfCZPNlv5v9rFbVHpYqjGzbOn8SzFI9o715L4u0r7arYzk+lYdTqSujy7U/C0u4vHk+WwO\nxuh9q3J9dgvbdVukMV1EwbDDgn04rZMwlHoZ+orZ6hfQ3RWVnQYCgZAq+8U0ln5NtBsV2yxYcfgK\nJtW0CnB31LlroVwJ1nQLGDjeP7w+lb0dsFxjrWB0tHS6NuWPJ6A16ToUm63T3Gallr4S7cxiTjrX\nPaxaF7dlVeSMUhxZ5jd+H7qCa4eF3DSE5x3zXN3Wk6jbyeaiFWUY6ZyPStYS5SalPmVipFbX0E4c\nW0alvmPHJrag0rVvEE6LdljGpG2NRtQD+tW5XMI0uU9M8NeFo9PiQhecDIIrtrOMIoG3H4VlJm9t\nC6CB06VPGM1IHLeItGS6uw+ORT7e3jsbQvj7gzUNam0JaWE+HN7NqOqX80n3FO1RXo8YzXdS+BHk\n4z+KyzGPapcU2YIv7qQtiuaxvcaWqG4O6FwfSrS1JbPnrxoxkv7qIfejcitj4V2f2exumI+8+aKn\nxHTT+G5d8Txlm4rjLxMsQwzWT3OiK0Mm6sEkVsAcjFc1d+FEmlGwEDPQVopaEuOpr6f4ZWNAu3tW\nvHpAj5ZQcUFIWaDjGMVUMQ3cVDBmvbhY7QAV2nh+T/R1yeKhlrY31+b61FcQK6nIoJMi401WblRi\nqr6PCw5UYq9y+YgOgWzNkRrx3xWjp+nx2v3FQcelAbmko9anQ4GBUNisPHWr1qMrQhS2K11HvmYV\nhamcxSRZ5xRIqluS/DKAQQXZxyXrvo2FdlL4EeZjH+/ZbjNSZpswLNBrE1Gt7VE4ODVIlnh/j61F\nj4lmeTGyUbq6LwdEqWbeX0YbhSqfEddP4Bddj4JIrhL5d8h7VjI6oLQqKNzelWre3yc4/ClFjaL6\nwqBxxUUxwCKu5BmXRA6c+9ZjP83FSBoQuPs4BrsNBlUW659KmRrDY6G1lyQtW3Hy0lqQ1qVJnAbm\noy3b9KYJCqRj3o4zRctIlhjLHmpSuOBRbQOpLGpPFaES7UqkZzKN1KsEc87/AHUUmvPLTVGv72aQ\nk7WJwKmRrQ3ud74Ltilgz4++2a6iNDXdS0gjyMU71my7GpqTbxSbMki3SViajTTHqkSeR/GeyZmg\nnQHkEE1S+F+oPPavBL96I4/Cia1udVF+4dVrkW+Fq8+v4tjMDWUkdVJ6WM0cNV+F+MVmjUcZgqnP\n1qpNNnkcVRLiZtxIS1UzzIF7mghlxUZpVQdq6nTVdAoAOKzkbQWhvwM6gMM1twOJYx3NOJE11Kt1\nH1/pVVlwBkk+9NocXoOQ45FPj+fkUJFF2NSB700v/hTEty5ZpkjvVyUgcCq6GM9zC14/8Se6GcZQ\n1574Xs5WkI2HBPHFQ1dm1KSSZ7Rotn9l0+KPHIHNacae1dy0Vjxaj5ptlhVp+2s2CJ9ppCKzuWNx\nzSFc1SYrHNeNdIGpaYw25ZeRXmvheyk0jVpEdcLJ0q3ZxNKTa0O3vQHg/DNcHrsJDmsmjspnNzNt\nfFIJ24GazOhC+azDmgZIOOKBsp3J2qSaZodubq58yQ4QAnmhGT3NO18pb7BORmu205LfYpyKVkWp\nOxr5gKYWoIZWgfGfloFq1qTPLubnGO1RPtxg4P0oBAkY/hBz6VNDDkZ6AU0W2WSdqkdKr9ZOaGSj\nVtcLHmnOcgmmYvcz7mBLy3MbdD1q9ouiRK6bUAVeelOC1InPlidSsWMDFOCEdq3uefykqrinYqGy\nrFvApMVka2DAowKAsMkRXQqwyDXn/iWyitNQ3qPl6itIvRoF8RXinW4tQ6HI6GuW8SIVBPalc6qe\n5x9x97r3qruwTjrWZ0ksZ9TUmcDNAmZ9/wAoao63rR0+w22MLPtAzt6mghmfofiB76LdJBJBIp5D\nd/oa7bSdWLIPnpDi9TM8TeKdas51XTbIyxd3J/pXS+E/EFxqNoFu7do5OmD60maHWrnZyDRkn/69\nMlEyOR0xntVoNx+FUgYjPxg4FLCuWDZyKQr2RoRnP0qO+nEFpJITgAUzLqZnhu6+0rknOTXpOmwJ\nFbrt5yMmnHYyr6Oxb2ijaKLnPYMClwKQWK3n0hn+lachHOJ9pNNN0apQFzsY10a4v4hXQh0xpieQ\nMA1XLZNjhK80cT8OdV+3Wl3A7ZZJCw+hrR1qLcjZ/CsbnfHRnFXseHJArOYYbrUs1uPhYbuatqFP\nByfSkMq3UIINYkto+87Tx6GkSxfsDbflGD7CtTw/pk4nzITtPIFMFudsukh4Rxz71paTpKwP5jcn\n0qTRy0NORMDgVCqewoJTJgAoxjntTiTu7fWmFxAcnn1q3EPl+X8KZMi4gKqB1Peob/Tv7Us5bfeU\nyOoq4R5nYxqT5I8xieH9J1DTbvyJELRg8ODwa9Ms5mSFV9BWiptbnNVrKdmif7Q1KLg96XIZc5Is\npNL5pqeUrmMtZs0jzV08phchaY00zH1p2ZNxjS1g+LdJOt6U9ssmxjyGp2urDjLlaZzng/wUPDqz\nTSTmWeTrjpVjVk3Rvjr2rnqQ5dDvo1XUd2cTqSNk9OKxXGCeKxZ1DAxHTr2q5C/y8GokUhsz54qu\nuCxzSQjQ0+FZblR2ro4bZYiMVQ0dBb7Qi5x0qzuG5QOh71LYErDufpSeWrHnimIXbjkUjLkH1Hem\ngGxryc+tXI19KYmWegq9YLiLJ7mtqS945cS7QsWehqxA9dEjz4krPSxyZqbFFhGxUm6smjRM55Lk\nHvSvNxXTY57kLT+9MNwKdhXGm5FIbkU7Bca1wMEVhaiuQcVhXWiZ14R6tHGanGBI2OtYkqEHjgVy\ns9ErEeo6UBsHipKEZs5qpPdRxcbhx70NCSuybTNWihc5brW9Fq6vjMnFSdEIdDRi8RRKygZbHFbu\nm6nb3RA3gMegNJhOm0jbXGOoxTuCc1Rz3FyoGKawz9KaAVcZqeMgCmIkB4FaUTbYwB6V00Fuzixb\n0SFMuDU8Mlbs4UPeXHeiOXkUrDuXYnyKk3cVk0ap6HMxxketSMhrcwRC0dMMZFMQ3yzSeVQAeUaz\n9Vj8uPd271nVV4m+GdpnHX67pCeKyLtBtNcR6xlk9RVeWTb3qRnO6trgttyIfm71z7ai8j7/AJmN\nDNqUVa5Yi1AnjynHuBV+11YJhWWXcP8AZNSzqgmaEerSsf3NtIQP4mGKtRavdRgMIpVI9KjU0a7n\nR6T43uYQI7qN2Tpkqciu503VVuQGAYZHQjFVc4alPlZrpKGAznpTwxOc9+lWjIlUACnM4XApiLNk\nnmvnsK0NvpXZRVonmYqV52GsmanhXitTmFkSiJTSAvwrxUxXIrJ7miOfjf1pzNWxkRlqYWpgJupu\n6gQbuahvIxPA6eo4pNXVioS5WmefakGhndH4INZs5DJXA10PaTurmLO21uKpSZqGMoXGnRzBiyjd\n9Kx5rcQS428fSkjanLoaOliHGZFB56VswW+mtPufcBsGOAfmxz+tFkd8HpoaUx09FAtFY8DO71qb\nSms/Nb7RbecG6AEjFLS5c78t+p0djpVs9wsyQiJAdyr1rW+zqjErzSe559Sbk9S3C+MA1bjbgE1S\nMSXzMVG0vNUI2tPKrAuCMnrVzNd0PhR49W/O2xrHmp4TxVMzQshpIzzQBehqesnuaI5VGzT2bitz\nFEbNTC1ADS1JupgG6l3UAc14s04yR/aYRll+8BXCtLncDXFWjys9TCz5oW7GddH5qqNzWDOgQnC8\nVSuo1kHzAGkPYopEY2+RWxV23Vzj5G/Kg3jWaNazhZuqNXS6TaKhB2c0jR1nJWOlhOxRxU4YkCgx\nY0OQatQyDbyaaFYe8uF4NY3iC9ltbVGj43NTIL3h7WzMihjzXVQXYYDdW9Cf2WcOJpfaRZ3g9KsQ\nmupnCLIabGeaAL0LcVY3cVmzRHIxtUhetzEjZqjLUAIWpN1ArhupwagAfDKQ3Q1594v0c2bm6tx+\n5Y8j+6ayrR5onThp8s7dzkZjuqAAmuBnqC7c0iwgtzSA0rWzjfGRW3ZadDu4AoNYo2rfS4v7orSh\n05UA2r0pDbsTm29KRottBNyJ0wpJ9KhD7f6U0ikNWffIFBz60zVUW52ow4UcUN6EPcx44WsbgOmd\nua7TT5Bd24KHnFKnLlZFSN4koluLdueRWvp14swweG9DXoxldHlTjYtzGoo25qzEvwtUxas2jRPQ\n5CNqkLVsYoYzUzdQA3dSFqBBmnqaBhuqhriCXTpVIzxUz+Fl03aSPI9QTypW2/dz0qKNw3SvOPZR\nMqin8VLKRcs3O4Cuk0w/MDjt1NBtHY6O2IIHY1pxgFaETIRwMkjtVSUEk4570MlFW5bap6dKzWm8\n1tqH8aY+hp2FvGoGayNevVt7/ap4xzUvYjqTLtvLPcvJxSaVcyWsxTnFZlnT2t15xHmCtOBYwQy4\nB9q7cPO+jPPxFO2qLEj5HWo42+aus4HpoX4W4FTF+KlotbHII9SFuK0MUNZqiLUDE3UbqBBupwag\nBc1DefPbyD/ZND2KjujyPWlKzuPesRZjHJXms9lMuw3StjnmphKDSLTJ7OfE3JrpbO4GQc9qlnRA\n3LO82k5NbFvdADkjBoCSHyXIIIzgVQvdRigT7wzjgUzO1jHknlvG7qnp61etYFQDIpCZoqVijzXn\n3iC8EmsOuaCGb/heR/s0ijkVv6fbxy3QMg5xmsnuX0Ldzut3+UYTPWk+2GJSe+M1pFtamcldalmx\n1eO4XaThhWnC+TXqR2PHqL3maUJ4qRjxSEjj42qXdxVmaGs1MJoATfSbqBAG5p6mgAzTJTmNvpQU\ntzzHXY83D/U1zF5FhjgV5r3Pa6FMsV5HWnLe7RhqBRdmTwagN2d2K2rPU1C5LAnPrUs6Iysbdrq6\nf3gK0BrUKj/WClY05iM6xLOcQAj3NT29uznfKSzHuadzNu7NSBFjHNSm5VO9IRnajqoWMhTzXFtA\nbvUfMduSeg702Qz0rS7FbTToQFwzjJqaGTFyfK5PQViyzUuFmuIdgGABya5u/vTaN5cnUHFUmLoZ\nzyskwlgJweSK6zQdUEwVJeGr0aUrxPLxEfe0OrhPAqVjxWhznGRtUwatDK4jNxURbmkAm6jNABup\n6tQAFqhupNtu59qUnZFwV5JHnWsHdIx96w5lz15rzT2uhRmt85xWbcxMnUGmZlB0bdxmrNvFIcfM\n350mWjbs7YkDJY/jW5ZWW4jikWkdNp9mqYJFaJdEHHakUULu/VB1rLn1Ld/FgetMGYd/qWSQmSa0\n/AemS32pfa7piLeLkg9z6UmQtz0W7uQ2cZx0A9BVzR7cAea6j2rPqX0L99KRat5A6Dk1wOoKZ52a\nYfMORTYRLujiGWEq6/NWza2yKQVHNdOHerRy4laJo6TTnbbtb8KuM3Fdh5z3OJjbmpt3FaMxAtUZ\nagBN1GaQBzTwaAAms3VbjERUGsa07RsdeFpuUuY4jUjljWTKK4j02RE4IpJYFk6imQkVl0xWarsO\nmAEcUi0bNnZBR0rWtoguMCkUi21wI161mXuocEKaYXMS4u+pY/hVCSWSY4HT0pEmlouiSahdpEBl\nmOceleiwWcNjClvHgJH97Hc1EmVFFi3Czy7mwIl/WtJbjP7uLgd/apQ2VNVvtsBhiPzdK5S4nAuR\nnqOCaTGi9pcytPlU+XpmumtWII44rah8ZjiNIXRuWeNvvViQ/LXpJWPJbu7nCRvVkNxVsxBmqJmo\nEPiXca0YLMuOlJsuKuPlsSi5IrNuG8s4HWs5VEkbwoOTKsk+FJY4rC1K53k1xTk5O7PSpwVNWRzt\n4cms+WpKICtSLTETQj5q0YeBSGiys23pUguGxQMq3E59ayrm4x3yaAKiRtO2WPHcmhruKFxFajzZ\nScA44qRHoXhuMaLpxaUg6hcDLMf4F9KlhuDeXGASIl+8azZslYma68y48m1+7nFW5rtbRNhb5z1p\niMKbUg0zuW4A4rPgb7VdKXOMmpA7HRbMS7nUYiUda0lkQOBngVrS+JGdbWLRt2bAx5BqeQ/LXpnj\nPQ4GJ+ashuK0MhWaoWcA0AaOmASMK7jRNPWYBmHyiuepO2x10qfcv6vYxCzYqoGK4HVYVTJrmb5l\nc6oaM5TUJ8EgGsG4kLNUHT0M64OaqMMikSRsuKbnFMRLG3zVehOaGNE445NNlnVFpDMu6uie9Vo1\n8z5mOAOST2pDK91cNN+5tsrH3PrW54a06KxT7fdrlh/q1Pc+tJ6IUdZGvHPLezMcnBOWbsPap5r3\nylFtbdT1xUWNWzU0/Zbwlgfmx8zGsHWtRHmMqE59aAMyNifvHPc1f0gtPdqkY5JosJHeNci2tktY\neuPnNY+oXWZEVJNrZ9aun8SIq/CzodHuriIokhDIR1ronbKZr0o6o8ipoz//2Q==",body3="\n/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAsICAoIBwsKCQoNDAsNERwSEQ8PESIZGhQcKSQrKigk\nJyctMkA3LTA9MCcnOEw5PUNFSElIKzZPVU5GVEBHSEX/2wBDAQwNDREPESESEiFFLicuRUVFRUVF\nRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUX/wAARCASwBLADASIA\nAhEBAxEB/8QAGwABAAIDAQEAAAAAAAAAAAAAAAEDAgQFBgf/xABDEAEAAgECBAMECQIDBgUFAQAA\nAQIDBBEFEiExE0FRBiJhcRQjMkJSgZGhsWLBJDNyFSVTY3OSNEPR4fAHFjWCokT/xAAYAQEAAwEA\nAAAAAAAAAAAAAAAAAQIDBP/EACARAQEBAQADAQEBAQEBAAAAAAABAhEDITFBEjJRIhP/2gAMAwEA\nAhEDEQA/APqYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAKNTq8OkxzfNkisQC8eb1XtRNbzXT4q7eU2nu0MntRq/D8StMccvW29ZmdvgjsTyvZjxOLj\n+s8WLxn8TFPXs6Oj9oct7c14rkxz22nrB2I49KOdTjelmszfmpMeUxv/AA28OqwZ4icWWtt/SUi4\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAmdo3nsPNe0Pt\nFh09Z0+DNWL7+9O/7A3eJcZppsV5raI27esvH6jX5ddM25p79Ilo59VbUZOe2Tm/PeGvfPfT2iKR\nPLv1+DO678XmW/a97U6TtOyzTbTF538/T9WjTNecm9a7126tqk3rSYxY5ta1plRZqZNXGjyZcPXl\nmZmsx+qjBrsuO16xM7eXRt04JrdTltk5OWJnfaWf0a2lty5MdZnfzSn+WOHiOutFpjHa9e8bQ2fp\n+alYy462pk7zXbuxjPesbRS0f6ZZV1ET1tErzXFLHo+A+1ddZf6NrI8PJHa1vN6iJi0bxMTHwfOa\nzhzd61v1846utwniM6DUdb3nBaNrVmd9vjC/ZVePYirBqMWppz4rxaPgtEAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAItaK1m09ojcHnvarjM8P0vh49+a/eY8ng9D\nh1fGM1rxjtGPfvbzdbjuTJxHX48cTPNltM/KsS9Dw7S49Jp6UpHaGe2vjz1y9J7LYK13vHWe7bj2\nex1tvM80ekuxW3RnW3Vm6P5jRx8H0+OYmMcb+bapo8GKPdpC6bQwtdHU8JpWkdJ/JweL6e23iU67\nd4dubSqyVi9Zi0bwIs68XGp36TtEq7ZJmZmevzdbifCKWtbJinkt6eTgZPFw32t+sRurbWVzxs1y\nRv6T8V1NZNPtfq0seTm+Kevr+SZuxXjvaPiV8N4viycto9HseG6+uu08W6Rkj7UPmFck1tE1nlmP\nLd3eA8V8HVVi1pjq6Ma/pnqce/ERMTETHaUrKgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAADW19+TQ5p/p2bLS4v04Zmt5VjeQeJ4bjnLqsupv+Ka1+ERLv4reTmcNxcuC\nvy3l0qdI2hlr66sT02ot0ZV7qqrInruzrVZLGSZ37JjqgYTG0K5lbaFVhDT1Ub456RPweY4hixWi\neSdpjvD1eWejz3FNHWYtkpvFo9EIseb3tS3SerOms22rfpPqZKzvvHSYUz70TExG6Gdbs2rljeJ/\nMx5L0vEzPaelnOi98c9J2bFNTFpit47+a+PVUvx9T9nOIfT+GV5p3yY/ds67wvsXqpxau+G09Lx+\nr3TqrEAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADV4ljnLw3U0jvO\nO0fs2lWqyUw6XLkyfYrWZkHldBEV09eveG3Fq1mI3jd4vPrOIaid8G9MP3Y38k6fNrt/rMk9Ou8s\ntfXXn49rGWInuy8SO/k5Gl1E3rG/fzbOe94wTy99mbRvTrMOOvNfJWsesywniukrG/jU6fF43WYN\nTmtEeJtEQ06aSmK2+bNtEd+qfSO17unF9Hmvy1y13XWyVmN4tExLxVK8PmNq5NrT58zawam+m/yc\n0Xj8NpRYSvQZ7xEOdqI3rPozxayNRXe0ct/ON03jmrKB5nV4q1yTO20Obmv4c+cx8HoeI6WZpNoj\nq83niYmYscU0r8aJ6T1n49zeJ+Meqm1drb9J+Kd5p136StGVem9l9TbHxLDFp7W7+sS+q1nesT6w\n+PcAzVjiGHftzQ+v4f8AJpv6On8jH9ZgIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAABp8VrW/C9TW0ztOO3b5Nxp8VmI4bn37TWYB8f1HFtTfUfR9FWJmsdZ9I7MtJxDX5s\nd8ta1y0xzteaR2277rcuhycP12SceLxMeWNpjttHwlu8I0mfQ1y+D7k5YmJmY36T36Ka43z/AF1t\ncI1ds+qxVj7/AEej19PCw9HJ4NoK4OIU5Y35YmZdzVTGebVZabx5jJS+Tmns81rNLm1Wrzc9rVw4\nYibbem72mXTTS0w0M3BvEta1bWrM95ie5EanY87wXgNOL6XPfxraXLhra/W28bR/dzYzarBqJxRe\nbzE7Rt5vWU9n8mPHOGmS0Ypnea1naJb+k9ncNLR7u2y/WcxXO4TOoyUrN6zD0FaW5Y3hu49FiwUi\nKxCvLMR0hlW0jn6ukWw3iXjOJzbDlneOj3GaN6zDzfFOH+LE7SRGo83XNSZ2lbG2/WfdlvaT2cy6\nrNFInlrv1mfJ37cK4PwTTxOoidRm2+/2/KFuyMp47XB4LivXiunrH2b2iH2qn2K/J8x4fGDNxTSZ\n9Nh8OviRvTyfT6xtWI+DeXs9MNZubypASqAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAOZx6/LoOWPvWiHTcf2hiZ0e8fc2mf1E5+vP/AEeuSd7RC2uKtI6QjHfeINTfwtPf\nJvty9WPfbt/lucP03gxfJf7d/wBoReYpm97zaNeLb4Ims9Nt94auDjem1Wo5PFi1onylS+1o7l8V\nbxvtupjDMdNkYtXS1+Stt+m63xImEJ4xjHER2ZxMUjeUTO3VRmydBbjLJqPi08mbeVOXJPq1sl5Q\nVbkz9+rRy35rxHqzmZlVEe/Ez5LRlW5iyfR6zffaIjq1OSNZps2a21rZInafSPJhxGMl9LStLRWM\nlorM/A4dkrWbYfLZC2W/7K6eubX6b4RzT+W76K8b7G6X62cu3Sten59nsm3j+OXz3/0ANGIAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA0OIYfpOHPijvNNo+fdvtXJO18k/\n/OwPFYbz2ls3jx8VqW6xMdWPEdP9D4lkx/dt79flLLHbkxTPwY6nt2512ORTRzE2x4/dpE7cvkme\nE4IrW3hRMxO8THRtU1FKWtvtvK2upx22rzRCtXkqzh2jtF7ZbT122b01ndnpuWuP3Z3+Ky20qDVv\nfauzVy3mejZzNK8dVjqi87KLRLYtXruqvXzkQp7Qoid88R6rcl+WGlW0/Sa22mfhCZOq2x082ix6\njkm822pO8VrPdr4dNObVeDo8XW3uzMbzK+mvxT7szE27cvnu9j7PcNjSaXx8mOIzZevbrEeic5tN\n+SZnpt8J4fHD9HXHO3PPW0x/DeBtJxx29vaAJQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAKNRim9Z5e89Nl4DzXtVh5babURHrSf7f3ec1+qnDorWrvvt5Pccb0n0zhmWk\nRvevv1+cPE2rGTFNZU26PFfxwa5dVkjelI2772nZnX6bbrEUq3o0d678u8wmuDL2ittvVjXdneeK\ncGv4jpJ6U56+kS7+j118+GLXpakzHaWlp9NNY3tv+bbiYiNoQy1y30uyZJlrWmZnuym6q1iIJnop\nyW2Te8bdWnnypQqzZOadokiIpSZntWN5lrxki19vNRxrUeBwnNNd+fJEY6/OejXLn3Xe/wDp9wyn\nE8uo4lqqxblv7lJ26T6vpD5X7G8QycKzeBMbzMRM1/FH/wA/h9QwZ6ajDXLitvWzRgsAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAeL45w+dDrZvWv1OWd4+E+j2jX\n12jx67TWw5Y6T2nzifU+rZ1y9eHwzDYxxEy18+DJodXfT5o96vafWPVbjyxDn1OOzHudbM0rt2UW\niI69mVtRXZq5tREb9VUoy2iIlRbJ0UX1VZ6btTLrI7V6yk62M2oisT1c7JmtkttVMUyZp6x0beDS\nRWOvdKijDimvWd3G9pNRMfRcNfvZOb9Hpb0itJeP47k/3hgjaZnbaP1XxWW3T0movbNS0W645nbf\n0nrMPpXs3xamoxdJiLbe/X1n8Uf3fKsOTw4jbaXo+EarJhtGTHMxeJ6xH7Sti9Zaj6x3HM4NxXFx\nDS1mtoi8dJrv2l011QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAGjxLhODieOIye7kr9m8d4eM4to9RwjPXFa0ZIvG9bR0fQXmPbDFvTTZPOJmEWS/V8bs9R43NxLL\nG8eFbePg1bajU5/s0l1ceKLx1hbjwRE9mOpx0y2uRTSZsm3PMw2aaKtIjo6kYo9EXpET0hVLXxYK\nxC6MZvyx1lFs0RHfaPiCnU12pLyHGNDbUajBekWma2npWN3p8+opa20e9LSyZLxExTlpM+vdOdcZ\na9tPS8MyUvFrzWlI6727u1pYxYrbVmb7x+TQx6au3Nqcl7/0rcmW9axGnwZJj1novmxnZXV0fFp4\nZxLBPgTGK8xzXr5fOH0bFlpmxVyY7Rato3iYfNuG2x56Wrqa8s2jz+7Lu8O12bS6jkwzN6THNNI6\ntvrN68Y4rxlx1vHa0bskAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAA4XtTTm0OKfTJ/aXdcL2pyRGjwU362yb7fkJz9eTxxyZJjyltRXzUZK7TFtl9Lbwy06YzrHwa+\nfJFd/wCVt8m0bQ0eS2qzcm+1K/an+zNZFL5M1pjFXeI72ky48eGnPkvNp27+TPU6nHpMfLXaIjpE\nerk5dRMxOfN1mPeisfshW1ne1a1577Y6x5R3U0zze31FOWI6ze0byU098kRlzbxM9qrMlPDpyRMR\nMd5Vt/Ihp5898mWZm1pjftE91uCt7fCI7dWeHDEW3t723l6rslqxWZnasR+SYhFbzhnfxJ2jyeq9\nlcGXWZcmW0zWKxHLaI7794eJx5fpfEKabT8t8l5isddo3l9S4VjrwrRUwzSJt3tav3pdOL6Y6dXD\nj8HFWm+/KsU4NRXPvtWazHquWVAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAa+fXYNP9u8b+kdZBsDkZOO135cWOZn4y5Wu4xqctbe9y19Kp4njt6vi+PDm8DFMWybbzPlV\n5PiGtz67UxbNbeKTtWIjaIXYpnwuaftT5tXJT3vmi1pMsrU5qIrG1V1a+5DCa7b9GFbRr5J6Wnbt\nCu+Wmk0m8956z8ZWZNorbfzcbX5rZslazPux3hUt41NTntktObJ13+zX1bek01r4/HzVm0bxPXy/\n+bNfDgjVa2uOY92kdfg6ufJOKvLXtttVVSqbcta2vM7zXtHpLQy5ZtMd+vWd+7Zy3mdJHXra3f0c\nvUarw7zFY5rT2hH1Lavnrgx81p3U49Pk4nE5L35MO/StfNRXR5tXnrS8W67WvfyiPSPi7uLHFK1p\njrtSsbR5Lc4RzsXBaYreP4l45esRD2HD9fnw6evvWvO3Tfr0aGk0U55ra0TFInv6uzgrXFXlx0i0\n77RPlC83Yj+JW7oddqr6vHzTTw9/f6dod+L1t9m0T8pcbFSmPHER3892W0zPuz+jSbVvidkcqmfP\nSel7bekrI4n4dZnPWIrHeYnZee2Wpy8dEaml4npNZblw5qzb8M9JbYgAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAABEzFYmZnaI7yCXL1XGa0jJXT0571nbee27DiXEprp8nhbxG20W8\n5cbD0ikfnKO+urTPvjoZdXqctdsmTaPSvRpWmsdZ6yztfaGplvv3lWW1tyRlz1x0vkn7Vo5atTNe\nY0+1o79V2KsZsvX7Ne5mwxnyTNvsx2iGneM/rCdRSuOsTasTt5kRFtpjqmOH4t4nk7estiMNa97R\nHwhna0iuKTEdmGWa4672nZtRele1N59Zlq6vLOSsYorEc07qcW65euzRvtXvPZy52naZ7ujr6fXV\nrWdukREK8+njHgmZmPc67bq6ivVWhxxgxZLztNrT1mZ/SP4VZs0zaOvfp84WUtNsXLvtv3699+rU\nz7+Jtt5qURqMnPpctaR1rMSw4ZoK57eNk6xHaJRh97Ltt7lo5Z+L1HAPZvVauZ2nFTSzMTzeJEz8\nto6xPfvsZntPZ9rXxabmxzefdrv0j1dXh/BcmstW1qxTHHasR3+b0GPhGl+kWmd64dNEVjf73T7X\ny8vy+Ddx6O3iRakxTH5RXrMw1/lX+3Itw2MFIraN48qRHdZi0cUjmmPen9noox1iO0fNzdXEYrTt\nstcmd9aX0bJ+HePmiKTitO8TMLZ1cVjrMfqpz6ys4pjfrPRWZ9rXXptUit6zO+23VyaRHEc05L1/\nw9J9ys/en1ljqdVbwYw452tlnl3jyjzbmmiMeKtYjpEbLeTXPUU8ee/+qjJpsV5rbkrFqzE1tEbT\nDpYNbW21Mnu29fKWna0KbqTdjXXjld0cvQ63ltGHNPSfs2n+HUbS9c2s2UASqAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAOVxPWe99HpP8ArmP4b+r1EabT3yT3iOkesvMVtN7za07zad5l\nXV5GmM9vVfEstvDx0jtaVVMlq+UJ18b5cMRvPeSuK87bUt+i2Z3PtG7zXpjkzXt6R+TXyTMzvM7t\nydHqZ+zhv1+Cv/ZuqvPTHMfOYaTMil1a1K2vHSLTELq2v+KWzThGo84rH5rq8JzedqR+ZeI7WnOS\n34pYTafWXR/2Pln/AMyrKOCWnvmiPyR6O1y9585lhWJvl557Q6eo4T4dYiMvW3b3UanhldHpJtGX\ne09unmjsT7eb1l4trI2t0hsZfrdNO0bzy+nzU20/+NmkzO9esz+TZxWis9dttvPv+Tn21jjaW8zn\n26bTG3mp1M/Wzv3t0jyWXiKZJmsTERaZhXXDbNl8WaztWenxZLstPp5pau8frDtVrNMM5cfTfpMf\n3aunxxbes9d/R09Dp8ebJi09ptFr3jtt2WyrW9wy1Jx132mK+Xq9PotT0iIU19ntLtExa3T47T+q\n6nBaYvsZstZ+cT/LeMnUi0TXffo1s2m8Ws2/OIMWk5Jib5L328rS2t94Sh5TV4ppklpW6PT6rh+P\nNbebTHyas8E081mZy5P2W6OFhjxNTE/hr/LoRO0Kvo9dPqctKzMxEx1la5t3tdnjnMs4noievcrO\nyZjeFF1OSnNV0OG62cn1GWffj7Mz5w05joovzY7xes7TE7w0xrjPeex6Ua+j1UarBFu1o6Wj0lsN\n3JfQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACrU5o0+nvlt92P3BxuM6nxNRGCs+7Tv8\n2hToxm1r3m9utrTvMsonqyt7XTmcja0u3O6FMfi5t/u0/lzdJM81p9O3zdvHTwsUR5+bfPqOfX1h\ndqV+3O7bs1+T31oqmI3TEM4rvCdkDGIIhlFd2daboS0NXG2bD6bufxXU1vlmu/u4us/N0+L1tTSx\nkr9qk7w89j1FNZMV3jxLzvaJ8mer+LSOZqK2xZotbvljfr/89U453rXt9lse081xZtNjx7TGKu0t\nDHlrevSevaN5Y6+tJ8c7VRNMt63n3ub+6/R54rERMztDYy4a5omclYmfxKcenrjtHLvtPrCnVmdb\neFe3JXmjy6eS/DrMuLVYsta9Mdt++6qLxO+0dEc8UmInr18iUfReHcXrqccb9Z27Q61Lb13eJ9nc\n1Z35rTvE9avY4bTkpG8xEfB05vYxqybc07R281naGMREdoT5JQqy9mply7Q3bV3iXG1eXw7TWSka\nc258t7+tpT5/BjT7MfHqndz12Z+M4lMMKyziUJJiN1WSu9fku23RaOgKNJqbaTU1t9yelo+D0cTE\nxEx1iXmM1Nt3W4PqvFweDaffx9vjDbGvxz+TP66QDRiAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAOJxzU73rp6z296zsZMkYsdr2naKxvLyObNOfNfJbvad1dXkaeOdpvsc2yuZVzfbfqybutwu\ns5s8R92J3dvJb3tnO4HSMegtmt3nfZvYp8SZl0z45NfSK7onH1bNcfRFqnUKJr0Y7dVtq7prjEsK\n0XVpEM6028mW20IHK41aPo3J6zs4ODhdcvPnvExFevNXpMOrxi/PlrTee7PLX6Pwa09uaNlKtHg9\ndM3z5d7ReOu02nu0JzZMfblrv5R5uvrcdImZ26T1mYhxs1Os7RH93PZ7axuafNfLitvbaYU3yZYt\nPXs9NwHhui1HBa5LVicsb81onrEuVqNNSuS8Y67dZ6xPZa59Il9uX41vEitImZme3q2Kxbxora0T\nMd/ROSa4Ztkj7c9OafL5LuGYubmyX3iu/TfbdSfVnpvZLT/XZK233+Mbbva1xRXyiPk8pwbH4N6T\nadq5a71n0tD1WDL4tPe6Xr0tDpz8YVnJHWEXYxbqlBedoef4tW0XraO09HdyztSZcbUz43C+ee9b\nSVMaeOfqq7+jGckQ1Yz7+7v2RN/WXPXZPjci2+2yyJaVMuy+uSJlA2d+pNoVRbeDcSxyTE+TDDlt\npdRXLTynrHrDOyiyZeVFnY9TjvXJjres71tG8MnJ4Nqt4tp7T1jrV1nRL1x2cvABKAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAHJ49qfD09cNZ97JPX5PPw2uI6j6Vrsl/ux7tfk1mWr7dOM8iLdm\nvfebREefRsWldw7SxqNbWbR7lPesrn3Vteo7dYjDpMGCvfbeXQ0uLlxRLRxROfUc34p6fCHYrXlr\nEejqrjY8uzCYW7MZjdVKqK9VlaxCYrsnYExBMRMJRPZA8/xPHtmpP9W2xx76vhWOInvt/C7ike7N\nvwzE9kcapGfhlevTaFbFo8RqJ5vy8/RoW09ek0msxHfp3dzNoLzp4zUmZpMbT8HJyYJi20X2n0lh\nZY1li/RaidBF4w2mK3jrHaFGp1lN+tptPp5IjBkid5mIp16TKu0abBPv33vPlM7z+iPdFNcWXU5I\ntkrNce/b1W5db1nTaf3ax9q0fxDW1ebNk2phty1mOu09VOm8W19orEz23j1TwfSeERFuEYMddptW\nd43dvBn21eKJ75KbW+cf/JcTgMxXTb3nbljz+TpcPmc2uyZO1KRtVtGVdi0bx07qJnllsRO6rNTe\nN4XVamsy8mnvPwc3R2jPwe8TPbdlxXNOPSZfhWWpwO85OFzv57qrODkzeHntSe8Sn6Rv0a3EZ218\n8nXekfr1a0ZLVnqx19dWb6demXybOO7lYMvNMdW9S/VVLo0us7tPHdtUtEwJiZU3jq2Jhham8CVG\nPNODNTJXvWd3qcWSubFXJWd4tG8PK3pPd1OB6veLaa89Y61/u2xfxh5c/rsgNHOAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAANLimq+i6O0xPv392rdeZ4rq/pOqnlnelOkIt5F8Z7Wj27I2I6sb25YY\nV1ImY3dbQ08LRc23vZp2j5OJG+XJWle9p2h6HHtbJXFT7OOIpX+7TxT31j5rycdTh+Dpz+XaG/sw\nw18PHWseULN2trBE9UcrJKBhFU7JAQi0dEomegNDUYovM7x3jb5tO1ZvpbaTLtzRExWfWPJ08kbT\nEx5NXWYYyV5omYtHWJieyeDzuizfRs19Jn6TM7Ru1uMcJxZqTkw+5f4ebqa7SV1MR4tdrx2vEfy1\naxqsNOTLjnLXytVXi3Xj8+nmsxTLM16d5npPyUzpekTtSK+U7vS6vQ/SYmK1vWPS1HOn2dvvvvE/\ntDO5XlcO+LbfHSd/W3o6/BdDOXPTnj3Kz38rS6Wm4FNrRyRzTH3p6RH/AKvR8L4dXSzE3jmtHn5I\nmbfqLV+m4dbLSsZInHjr3iI6zLpYaxS01rHuxHRHiT9mv6s67Vj1aqL6326MrWiYa+/Q54BxPaGe\nXRZpj8MquB4+Xg8zPnB7SX30to379GxpK1xcHiKz5IS8xr8PLPixH2bftLTy05o6dHYyVjLhy0t1\nizjZa3pMVv3iO/qz1G2L+NbSajbNyW7xLsY8kTDz+fJXFqKZN4iZnafi6WHL0iYlStI7OO+7axW2\ncrFl7dW9jvE9ULN+J3ZbdFGOy+AYWpEqN7afNXLj+1Wd23KrJVMvCzseh0+auow1yU7WhY4fCdV4\nOadPefcvPuz6S7jol649Tl4AJVAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAV581NPhtkvO0R+4NPi2\nr8DB4dJ9+/7Q83Po2NTqLanNbLfvPaPSFDHV66sZ5ET0hRknyW2lTtMyouz0c8usx2n7s7vScKwx\nzc1vu/y85p+maJh6Th+SOWeveXR4/wDLm8v+nX5mUWa9bbrInolmu5jdTNkxYFk2Isr3TuCzeGMz\n+THdEyDDJO9Ja823rt2XWnya946pGvktDXta0ztWu/ybvLE9dkcoOf4GbJPWK1j49VmLh9JtE33v\nMevb9G7WsW8l1ccREISophiJ2jpDYpijbaOjOuOJ8ujOdqxsgVcsUjaETYvbaFFrgu5lVsm0yUtu\nryg43H5m+GIj1XcJzePoL4pnrWGtxmfchr8JvfHS1622if3QljzTTLes+qrNjrkiYtCzPMxnm095\nYZJ6boS5teB49Tqscza97VtvWvlv8V/FOF34RrIxTM2xXjelp/eHoeA6XnzReY3ivX/0dfivDcfE\n9HbDbaLx1pb0lOs+jO7K8Lis3cN+0NKcd9PmthzV5clJ2mF9J9GHHVL108dm1SznYr/Ft0tuhLb8\nmNohFbMhLWy0mJ3rPXvDvcO1karBG8/WV6Wj+7kWrvDDBlvpdRGSnbzj1hpjX4z8mOx6UYYstc2O\nuSk71tG7Ns5AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACZ2jeXneJ62dVl5KT9VTt8Z9W9xbWclPo+O\nfft9qfSHEU1pv48ftYST23ZTDC/p0YtlVuvVjMbM5+LCZjYGWGdrTPxiHY4ffaf3cjTxz1v6xMS6\nOlty2iXVj/Dk8n+ndrkhnGRo1v8AFdW3RCrZ5uiYsqrboncSu508yjmZRYQt50TfowYTbYGVrKrT\nuTZjvukQnYhMIGVY2ZxPVWyrHVCWzXpVXkt3TE7Va+W4K7X3jv1auTNy3jdba0RZpamfroQN7Hk3\n6wr1GTaN2OOJiu6Mu98NvgDi8Wy74d/yZ8PiPAiO2zU4nb6qIn1bugjfFE/ASp1ke9u15mbbRDZ1\nMb823kx0Ontn1OOkedoJCvT8I03gaKsz9q/WW+isRWsVjtHRKyrhe0XCfpWL6Vgr9fjjrEfeh5fF\nfeH0V5Dj3DPoOo+k4a/U5J6xH3ZZ7z3228evytOk7NvFbo0cdols47bSybt7HbddHVqUs2aW3Qnq\nxVeu8LILR3SlZw3V/R8nhXn6u0/pLuPMXjeHT4Zruf6jLPvR9mZ8/g1xrvpz+TH7HUAaMAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAABRq9VXSYJyW79qx6yvmdo3l5viGs+maqYrO+OnSvx+KLeLZz2te1rZL2v\ned7WneZYWnZl5K72YV1xEyxmeqJljzIEWlVkszvbZp5soN3h2SJz3pP3odCnuWmPRxuERfJrZmtZ\nmtY96fR28kbX3dXj/wAuTyf6bmK+9YX1s0cNtm3Sd4LFY2K23W1s16StiUJW7bp22RW3RluBuruz\nmWEgrmCGWyNkoExKE1QlPmsqRDKeyBjaejWy2W3ttDUyz1QKslvehVqKTNosyyTvELabXptIJpaP\nB39Ia2mz+JGpr51jdZefDx2hzuHZObNq58poJaGtjxJ2+LoaKP8ADRPo5+T3skx5OhpOmC0fBNQ0\n5yTbn+bt8A0u9raiY6RHLVwY62mI6zMvaaHBGn0mPHt1iN5+aYVsACBXqMFNTgviyxvW0bSsAeE1\nmkvw7V2w5Ote9besJx2er4rw2nEdNNekZa9aW9JeQjnxZLYskTW9Z2mJY7zz26fHrrdpbZsY7NGt\nmxjvso1b9NmUwpx33XRO4K7VUTE1nmrvEx1bVo2VWiJE/XY4frY1WPlt0y17x6/FuPM0m+HJGTHO\n1qu9pNVXVYt46Xj7VfRtnXXL5MfzexsALsgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHM4jxOMFJphmJv529Dq\nZLfjDjPEIx450+K3v2+1MeUOHSOWFc3nJkmZnf4yujpVlqunOeFpV2nctLCZUXRM7MJtsWlRkv3Q\nky5NmpWt9RnrixVm17TtEQnJabXisRMzPSIew9n+CRoccajURvqLx5/chfOest642OGcIpoOG2w7\nROW9d72+LQvXevyejcPUU5M+SvpLeOataraw2a0dLbLqTtK1G3Es4lVWWUSoldFtmcXUbpidgXzK\nGEW3TuCUSncnsDFMMLSms9EC6J6FpVzbZE5ALy0809ZbFr9GtfrEoFMzuuwz0Ueey3HbaBLDXe7i\ntMOfwWnP9I+NZbuttvhs1uBRtXPb4SDm3iIvf57N7Dbl0VrS5+XrltEd+Z1Jx7cNms9N4TURRw3T\n+PrcO3WszEvZOD7P6aYiMlvu16S7y1QAIAABxOPcLnUY/pWCv1tI96I+9DtgmXl68Biy7/NtUu3+\nO8HnFa2s0tfd75KR5fFyMWTdhrPHVnX9R0cd21S3Rzsdm1iuqs256wrmGcT0RYSx5d047X02SMmO\nesd49YRE9WcdSXhZ2O1p89NRji9J+cei1xMc3wXi+KZj1j1dTTaqmor06WjvWW+ddcu8XK8BZmAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAMMmWmKu952UZ9XFZmuP3revlDTtzWnmvO8q3XGmfHb9ZanV3yxtWeWn7y4es\nvPNtDqZJ6Ts5mppvdl/XXRMyfGvSNlu/RVvtOzLfoipLT1VTKbSpvfogRkvtDVyZOhkyvQcA4Dzz\nXV6yvTvTHMfvK+c9U3rkW+zvA/D21urr789cdZ8vi9KDb45rejl8Rry6iJ/FV1HP4vXbBTJEfYt1\n+UpiHM295bXsqrO9l8QkZ0lZEqqLeyBZHZLGvZkhIndADKJ3TMoqWQMZ6pjsxll2jsCLSrmU2lFY\n36gieyu0LJk3jbsga0wdqzK20QpyztQGprL/AFMrOE05NLkt6qdVWZxNrSe5o9vWBLiUjnzXn0vL\nq555dHt8HOwV928/1z/LpzXxbYccRvzTB+jucOwxh0dI22mY3ltIrHLWIjyjZKyoAAAAACJiJjaY\n3iXleM8InR5J1GniZw2n3oj7s/8Ao9Wi9a3rNbRE1mNpifNFnVs65XhcWTdt47bnFuF24dm8TFEz\np7T0/pn0a+HJux1OOrOux08d1ndqY7tillVkzExLOk7yd4YxGwluViJhE45raL0na0dtlWO0+bZr\n1TKi+2zptZGTamT3b/tLacvJjiY3XaTWdYxZZ6/dtPm1zrv1z78fPcbwC7EAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABhkyV\nxUm152iAZWtFazNp2iGhm1Vss8uP3aevnKrNntqLdelI7VRHRnrX/HRjx/tZREVjZXeybW6KbWZt\npCZ6S08tN7Nmbb7zCrJtyoS5145bSx5mWafelr3tsKmS/o08uXyhlly7RPV2+AcBnPNdZrK+53pS\nfP4ytnPVda4y4BwHxOXV6uvu96Unz+MvVxG0bQRG0bR2G0nHLb2gCUDX12LxtFmpHeazt82wT1gH\nmMN4tWs+rcr2aEV8DU5sM/cvO3yb+O0csLUTSdrLphRE8tlkZI7Atr2ZMazDJVKTYSCawi7Ksq7z\n1QERvLK3ZGPrKbyCrbdnMcsbeaa18/RhvvM7oGEwTG0JmYYTIML22a2e28xELM19oURPNO4lOem+\nn3ZY5+prVnMc2GYU4/L4A0a15cNf6rz/AC6fC6+NxCPOuOu/5tHJTbHj+F5/l1+BYumXJMd9o3/d\nMRXYASgAAAAAAABhlxUz4rY8lYtS0bTEvH8R4ffhmo6bzhtPu29Pg9mq1Gnx6rDbFmrzVsizq2df\nzXkMWTeIbNL7tbXaHLwzUctvexWn3bmPL8WFnHVL326VZ91MfFVjvvVlz79kLrcf2m7j7bNHH3bl\nJ2SirLQoy4t1++7G0dBC/RanxI8PJPv18/WG241+alovSdrV6w6mDNGfFF4/OPSW2b1zeTPL1aAs\nzAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAVZ9RXBTe3WZ7R6iZOpzZq4ac1p+UermZMl89+a/byj0Ra9815ted59PQ32hlrXXRjH\nDpCLX6ML5NlNsm/ZRqstfdXzbsZt06sLZNvNB1Za8RDWyZdo7q8udq5Mu/mIMt4md2lmy7JzZuWJ\ndHgfBL8RvGo1MTXTxPSPx/8AstJ1XWpIs4BwSdbeNVqq/URPu0n73/s9hEREbRG0QUpWlYrWIisR\ntER5JbSccur2gCUAAAAPM8Sry8Uyz67fwuxbzVPGsE49XGbvF42V4M0TEL33ERnktsxpk3sumK2j\nadmFdPFZ33VS2Mdui2J3UU6LYlFSsN2O5NkCyJ6K7T1TEsbAsxdpReerKkTFGMxvYEz0rsqtbbpC\nb2VT1QEzuwtbaGUxspuJU3neWdKoiu8rq12gCI92YatLcublnzbEz1aOptyZqTuDHLfxN6R0+t5X\nqdJhjBp6UiPLeXl9NSMnEKxHa1+bb8nrlvxUAAAAAAAAAAABTqtNj1eC2LLXeto/R43VabJw/VTh\nydY+7b1h7ho8V4dXiGlmvbJXrS3xRZ1fGv5rzeHN02bEW3cys3xZJx5ImtqztMS3MeTeGFjqlb2O\n8btql3NpbZtYsnSBLeiWfdTjtutid+ghherHS5p0+f3vsX6T8Fkw181d4lMvEWdnHaGnw/UeNh5L\nT7+PpPxbjdyWcvAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAo1Oprgr63ntAmTqdRqK4K9etp7Q5d7Wy2m953lNrWyWm953mVd77R0\nZa1104xxlN9lV8qnJl2a9s3xUXX2ybsJyRDWtl3YWydEC+2VRkzeW6q+T4tbJm+KRdfK1cmWZnlr\nvNp7RC/R6HU8SycmCk7ed57Q9ZwvgOn4fEXtHi5/O9o7fJaZ6z1uRyOEezVstq6jiEbV71xevzer\nrWtKxWsRFY6REeSRrJxz22gCUAAAAAANbX6aNVpL0npMRvWfSXlKamsRMVvXm+EvZXjmpaPWHzfL\noNRjzXicfWJ8phfPxFejx72x7xMzK+sXiNoiXlq+Pi6fWV/VfTNqfLJl/WTg9Pji8R70LqvMV1Gq\nj/zcv6yz+lanzzZP1lWpelTET6S81Gp1P/Gyf90s412rjtnyfqql6asREdWM9+jz9eJ6yP8Az7uh\nodZqMt458tpB1JvEViI3/RhzRt13/R1MNaziiZiJn5K9ZNceKZiIiQcu/WekT+iYrWI3lzdTrs+8\n8uW0fJzcur1Np/zsn6g79phVaIeetqNR/wAXJ/3SwnUaj/i5P+6UD0ldonum161h5mNRqP8Ai5P1\nlNtRqJjacuT9Qd22WN5aGeZyZd/KHJy59RHbLf8AVq31Gp/4uT9ZEvS8Lr/vSs2npzRtL1z53wK+\noza/HW2XJNd99pmX0Rb8VAAAAAAAAAAAAAAcHj/C5yV+l4I9+v24jzj1cLFk8nu5jeNpeW41wmdL\nknU6ev1Vp96sfdn/ANFdTrXG+eq1q5F2LLtbZoY8m8d11bbSydErsYsm+zZrO/zcnBm226uhiyRK\nEtrvCrJDOJTeu8A1MWX6Lqq5N/dnpb5O5ExMbx2cPNTeJb/DM/iYPDtPvY+nzhri/jDy5/W6AuwA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAa2p1UYo5adbz+xbxMlvqJ1OqjDHLXree0ejmzNrWm953tPmTPWbWneZ7yoy5YhjrXXTjH8s75N\nmtkyxt0VZM2/m175N1V03yTKubMLXVXybeYLLX2VXy7eam+b0bOg4VquJW+rry4/O9uyZOq3UjVm\n9r25axMzPaIdvhns1kzbZddM0p5Y47z8/R2+HcF03Doi1a8+Xzvbv+TotJnjDXkt+K8ODHp8cY8N\nIpSO0RCwF2YAAAAAAAAACvUZYw6fJkntWN3k8dfHz2vLucdz8mkjFE9bz1+UOZosX1UzPm0nqI/W\nMYo9FlcPNklfFGeH/NshLGun+Cz6PtHZtVZWlRLS+jxPkRpIn7rdoupHTdA5s6SI+7H6Mfo+32Y2\n+To3neSIiZ7A0IjPXpXLePlMotGW3272t85datKzHZjbTVnsDj+FG/2Y/RlGP4R+jo20u7H6N1Ql\no+H8I/REY957R+jpfReiK6eOYHLtj2tttH6KrY/6Y/R2c+kjeJiFVtLG24hxpw7/AHY/RRkw9O37\nO99Hrt1YX0tfOBLjcGp4XF8c+u8fs9c4dcVcGemSI61nd3IneN1orQAAAAAAAAAAAAABFqxes1tE\nTE9JiUgPKcX4RbRXnNgiZwWnrH4XPi28PdXpW9JraImsxtMS8pxXhF9DecuGJtgmf+1TWW2N/la1\nL7N7T5e3Vy6W3hsYcvLbqzbO9jvvCzvDR0+XeO7crO6FmGSvRThy/RtVXJ92elvk2rRvDUzU7pl4\nizsd2J3jeBpcNz+Lg5LT7+Pp+Xk3W7js5eAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADs0NTrN96Yp6edkW8Wzm6+LNTq4pvTHO9vOfRoWtt\n1mes95YWvs1s2fZldddOczLPLn2ju0MmebT3YZc2/mpm3qqllN1drsbZIhr3yzvtHf4AsvlYYseb\nV5Yx4KTe0+UQ6nDvZ3UazbJqd8OKeu33peq0eh0+hxcmnxxWPOfOfm0mP+steT/ji8N9mKY9suum\nL37+HHaPm9DSlaVitKxWsdohI0Y22gAgAAAAAAAAAABXnyRhw3yT92Nwef4xm8bVzET0rPJH5d12\nCvLhho3rN9RWs9Z23n5y6O21YhrVYbdGOCfrrLPJRpv863zVS6FS09SvZj3lVZZRdPSqmnSWdrIE\nebOkK4ldTsgW1WKqd1oMZhEVZyRAImOjGI6rJ7IiATNd46qL02bHkiaxaoNGY2n4ImPgtyV2n0Vo\nGvlx7x2beiyTk08RPevSVUxux00+Fn2n7N+n5rRFb4AAAAAAAAAAAAAAACLVres1tETWekxKQHlu\nL8InR2nPp43wz3j8P/s5dLveWrFqzW0bxPeJeV4xwmdFec+CJnDM9Y/CrY1xv8qvTZ+WYdbDk5oh\n5zHk283U0eo3jaZZ2N5XYjrCnLSJhOK+8d1kxvCqzSwZvousrb7k9LfJ3nB1OLeJdLhufx9LEWn3\n6e7LXN9Ofy5/W4AuxAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAETaKxMzO0Qi9646Ta07RDmZ9VbPbaOlI7Qi3i+c3TPUaqcu9adKfy0722ZXvFa9\nXO1OrjrESxt66ZJmcjPUanlidmhkzTZVfLN5VWvsC2b7R3U3yqrZZtO1esz2h2+F+zWTUcuXXTNM\nfeKR3n5+iZLVbqRzNJo9TxHLyaekz62ntD1fDOA6fQbZL7Zc/wCKY6R8odLBgxabFGPDSKUjyiFj\nSZkYa3aALKAAAAAAAAAAAAAADQ4pl2pTFH3p3n5Q33E12Tn1eSfKscsLZ+orS00eJqbW+Lfnu1tF\nXaJnZsz3WpCfsyp00fWSvmPdVYOmSUDd8kR3InoQosy7JmUX7MdwZ17ro7KKT1XRPRAsrO0rYndr\n79V1ZBaQiJ6JgCSIJASwrO07MpV2nqBlrv1a1o2bf2qtfLXaQUTO0sb05o3jv3ZXhjS20xEphW5h\nyeJjjf7UdJWNKLziyRePsz0lux1SgAQAAAAAAAAAAAAAADG9K5KTS8Rato2mJZAPIcU4ZbQZuekT\nOC3afT4NXFkmlntc2GmoxWx5K71tG0vHa/RX0GpmlutJ61t6wrY2xr8dXS5uesN+tt4ef0eaa223\n2dnHk3juyreM81OaFGiy/RtZET9jJ7s/2bdutd2jqKeic3iNTsd8a2h1H0jTVtP2o6W+bZbOO+gA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABje9cdJt\nadohGTLXFTmvO0fy52bJfU23t0pHaqLeL5xdK9Rnvqb+cUjtCi94xxvK3JetKuHrdZvaa1ljb10y\ncnIs1Wt3naJc++TmVWvMz1YWybfMGdsm3eWek0mo4jm8PT0mfW3lDf4V7P5tdMZdRviwfvZ6/TaX\nDpMMYsFIpWPTzXmf+steT8jn8L4Dp+HxF77Zc/4pjpHydYGjC3oAAAAAAAAAAAAAAAAADG9opS1p\n7RG7zszN6WtPe0zLua+3Joss/wBOzhzG2OsL5+IrY09dsSyYRijbHEMvOChb7KjF0yS2LQ169Mso\nS24noyrPVXWejNVKbTuw3T3REdQWU6LYlVvsyiUDPfqupPRr79VuOQX1lZEqoZxIMksd0gT2VT0l\nbPZVbuCaW8i8bwr32WxbcGnkjaZa9p2ndv5qbw5+aNugLItF6TEtvTX5sMb969HMpfazc0d9stqe\nvVZDdAQAAAAAAAAAAAAAAAADV1+iprtPOO/2u9bektoB4TJTJpNRbHkja1Z6uto8viVht+0HDvpG\nH6Tjj6zHHvbecONw7Ltfkmeqmo6Ma69DXbbZTkr1mGWO3RneOaGbZRoM30fVzSelMnT83aef1FZ7\nx3h1tBqfpGnjmn369LNc3sc3kzy9bQCzIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAa+q1dNNXr7157VhGp1Xh70x+9f9ocy283m1p5rz3mVbrjXHjt91lz\n5c9+fJ1nyjyhdM8lZlOOIiqrUXikd+kMreunnI5XEdX4dZiZcG+XmtNl/F83PeeWWHDOGanieSKY\nq+5H2rz2hMzWd1Iqx1yajJXHhrNrW6REeb1nCPZumn2z62Ivl7xTyr/6uhwzhGn4Zj2xxzZJ+1kn\nvLoNJnjHW7TbbsAszAAAAAAAAAAAAAAAAAAAAaPFrbaSK/itEOXt0rDf4xb/ACa/GZacRvaF58Q2\nIjasQnzPIhCU92tMbZGzHmotG10C6nZkwpPRmipIllEbMIZIE7solgmJBnCyk9VMM6z1BtVllEqK\nz0WRILYlluriWcSDJVbusV27gwInaSWM9ECyZ3hqamnSWxFmOSOaqRx725bNnSZNs9J+OynVY+WZ\nYYr7TE+nVaIr0Ais81Yn1hKAAAAAAAAAAAAAAAAAABExvG09peU4nov9n66L0j6q/WPg9Y1OJaON\nZpL0+9HWs/EWzeVz9PbmrEtnyc3h9reHy26TWdnSr2YX6657ijLXpLX0+onSamL/AHJ6W+Tbv2aW\nekTv16JzeI1Ox6KJiYiY7Slz+E6jxdN4dp3vj6fl5Og2clnKACAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACZ2jeQRMxEbzO0Q08uqtkma4ulfO3r8lefUePMxWf\ncjy9WvlzVxV6T1Z61/x0Y8f7Wc7Ur1lqVy+LqOWJ2hp6rXddon5rOF1tfmz5OkT0qzb8dWbxjp1c\nbiuuilJ5Z6r+IcQrixzEy8zl1E6rNt1tMztFY81sztU1eRucN4ffi2p5esRM72n0h7rS6XFo8FcO\nCkVpX082nwXh3+z9FWLxHi36328vg6TZyW9ABAAAAAAAAAAAAAAAAAAAAAADj8Unm1tK/hqppHvw\ny1k8/EMk+m0GOPeafiFpCZYwolnXspvHvLa9mF46gmnZmwozRUiUCBKYYsoBLOFbKAX0llEqqyzi\nQXRLOJVRLOOwLIljZMEgrlhKyYYTAK5nZPN0RZjugUanHzVlz6xtLq361c+9eXItPpXX0dubTU+E\nbL2lw2++O1fSW6m/VYAISAAAAAAAAAAAAAAAAAp1GbwcfTreelYEydcuMcRrM/L9nnlsV6wqpi2r\ntv133mfWVkRyRtEdGFva7MzkYZNoamWN4bV4mYa9qztKIujhVppxGI8r1mJegeZpknBqKZY+7L0t\nLRekWrO8TG8Ns/HJ5ZypAWZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAADS12fp4VJ6z9qVuq1HgUiI+3bpDl589cOKZmevqprXPTbx477rDJlrhr1nq4+s182tMRP\nRqaziXiZJrWekNG17ZbxWJ336M5LXRbI3dLTJrs07RMY6fan1dHLrowY+X7MVjt6N3R6Kul0EbWm\ns7bz8Z+LnabQX43r7Y53php/mXj+Dnv0f1JO1x/8ZxbUzj02O15mfLtD13AvZqnDds+pmMmo26el\nXX0Wh0/D8EYtNjilY7+s/NstpOOTW7QBKgAAAAAAAAAAAAAAAAAAAAAADG88tLW9I3BwJtz6nNf1\nvK/DHVqYJ3pzT5y3MPZeojOWMQylEKpTVjZnDCwkqzYQyRRICATCITAJZQxhMAshnEq4ZQC2srKq\nqrIBZCWNZZgwswmFloVyCu0dFcx1WyrtCBhv5NTPHXds2U5o3hIz4ffbPt+KHUcTSW5c9Jme0u2v\nVYAKpAAAAAAAAAAAAAAAAYZctcVOa35R6tLrltN795/YvknNqrfhpPLH92V5isd9mWq6fHjk6rn0\nZxG8KK5Jm/wbVZiYZtqrmkqL023bkxvCiY3lJHNyRG81mHS4Rn5sNsNp64+3yaWaNrzOzHBl+i6q\nmT7s9J+S+ay8mex6EIneN47SNXKAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAImYiJme0JafEs3h6fkidrZOn5eaLeJk7eOdm1Hi2vmtPTry/CHmOJcUvmvOPF1n09Pm\n6HF9ZGm01qxO3R5vSY7XwzmzTy47zzTEd7en5Mfvt2/PURWdo3tvPrPlKymbktFqTtMTvHzbOLDG\nf63JXbFX7FdnoODcDprZpq9TjiMMTvSn4vj8l5fxnrk91saPSa7i2hpOfbTVt5x1m0fLydzR6PDo\ndPGHBXasd585n1lsRERG0dIF5OOe6tAEqgAAAAAAAAAAAAAAAAAAAAAAADX11+TRZrf0y2Gjxe22\ngtH4piP3TPpXKwxtjhuYo9xq442iIblI2pC1RET2ILd9kxCqRjZmwlCSEohIJAQAAJZISDKGUd2M\nMoBnVbVVCyAWVWeSuqyOwIlXZZKue4MJV2WWYT2QKbKL9YlfdRdIo35b7/Hd3KTzUrPrDh27uxpb\nc2mpPwX/ABX9XAKpAAAAAAAAAAAAAACekTIp1eTwtJmv+GkyJn1oafeazbfpMzLR4jq/o8b823zX\n6XNF8ERCvTcNpxLV5LauvPhx9Irv3lhztdtv8TtaWLicXrt03jzjzb2k1nid56ty3s/w+a7Uwzjn\n1raejlarhmbhl/FpbxMO/fzj5p/ixSeXOvTtRfeI280ZI26tfDm3pWe63LaZx7qtGvniJ6tPLvOK\nfOa9WzbJvTbza02jl3n5SSljscK1MajSxWZ96nSW88xw/VfQ9XMT9nfa3yemid43jtLeXsce88qQ\nEqAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADia3UTm1l4j7OP3Y/u\n7Vp2rM+kPJW1PhYcmS0+9MzKm/jbwz31weMzbV8UppazPL9q0/BF4rk1GLDSNqxPWPhCnHmnNrtT\nqPKteWPm6U6OdHaZvO+SaRNvhv12Ub/q3FhtrNVj0uKOt56z6R5y9zix1w4qY6RtWsREOJ7L6OKa\nS2rvX6zNM7T6Vh3mmZyOfya7eACzIAAAAAAAAAAAAAAAAAAAAAAAAAAczjVvqMVfW/8AZ03I41bf\nLp6/OVs/UVrY47NyOzUxd4bUJpEbb3Z7IiOrKIVSjZhMLJYyhKIgmGUQSDESIEbJEgQmCITEAmGU\nIiGUAyhZVhDOoM4Wx2VQtqBKuyyWEgqlhKyyuyBVaGtkbNmvk7A15l1eH2300R6TMORPSXT4ZO+O\n8fFefEX63gEAAAAAAAAAAAAAAAq1WPxdLlp+Kkx+y1Fvsz8gjhaDauGK8sx07y3OE3m1tT6RaP4c\nvU6yMNKUx73zT0ilY3l2eF6a+m0kRl/zbzz3+Ez5M8z26fJruW6wzYq5sV8d43raNpZjRzPPaTmx\n5b6bJ9rHO3zb2WJ8GWPEscY9bgzxH2t62n19GWW0eHOzHU5XbjXZ1x8WTnz2iZ7S2M1IjH2+LX0V\nKTqs8zO9ot0j8nUthi1J3UaOFMTfLFo6xMbS9BwHWTqdHOO8+/hnln5eTjYMFo1WTH5VnePzXcIm\n2k4zlpPSmXy/hfF5eMfJns69OA2cgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAADG/2LfJ874rW845mubliY7bPoto5qzHrDz0+yePNF41OotaJ7RWNtpV1OtfHqZ715fhu\nj8adNpcVfeyzE2/vLuanhOu1nEctIxTTFa/+ZPbZ3eHcF0vDbTfFE2yzG03t32+DokynXl9+leDB\nTTYKYccbUpWIhYCzEAAAAAAAAAAAAAAAAAAAAAAAAAAAAcXjE/4zDH9M/wAu04XF5/3jj/0f3Wz9\nRUYmzDWxS2I7FSyjuzY1ZKpRKEygEwiWUIkGIk2QJNhKQhMIhkCYZQxhlAMoZwwZwgWQshVCyATL\nCWc9ldpBhZXLOVdpQK7NfJPRdaWvknoDVvPvOnwuel4+TlXn3nS4VPvXj4QtEV0wAAAAAAAAAAAA\nAAAAAVV02CmTxK4qRf8AFFeq0AAAanEsfPpZmO9Ji0NDLfkwdOsulrumiyzHlVzJrz4Ovoy26vB8\ncTBa9NffLtMY77Rv8Yegx5ImkKdJoY1HC81Y+3OSbVn0mGGkmbY45u6tnrrTOu2xGO0RxCd+nNVj\nqKxTV1vH2pjaGtnyzXXYdo96ZmGXEMk15b7/AGZiVerWPTYckZcNbx5wzc7hGbnxXxzPWk7x8pdF\n0S9jh1OXgAlUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAcPjEf4/FP9H93ccXjMf4vDP9Mx+62fqKrx+S+GvibEFSsqyYwlVK\nZYsmIMoRKYJQIPIEiQ2ATCUQygCGUIhMAyhnDCGUIFkLIV1ZxIMpVWWSrsCuyqyyyq09ECq8tfJK\n66jJ2Bp5J6upwn7dv9Lk5J951uE/av8AJaIrqAAAAAAAAAAAAAAAAAAAAAAq1Mc2myxPnWf4cmtu\nXT9fR0tffk0WSe28bfq5Wbamm3326MtunwfK6PCv/AxPraZ/dz9PO97/AOqf5dHhdZrw7Dv3mOb9\nXOxRFM+avpe38mvkPHf/AFWlrKba7Tzt99ZxKkfR7euyNXMTrtPHfa0z+zPiM/UR8Zj+Wbdu8HpN\nM2bfzrV13M4dO2pyR61dNvj44/J/oAWZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADj8bj63BPzdhyeNx0wz8ZWz9RWri7Nmv\nVrYu0NmqaRZHZlDGGSiwxZSgCEkCBCQSCQBMJRCYgEsoYx3Z17AlMIhlCBnDOGEM4AlhZZKq4KrK\n7LLKrIFN2vdfZReAaObu6/CO9vk5OePR1uEd7fJeIrqAIAAAAAAAAAAAAAAAAAAAAGtxCk5NFliI\n3mI32+XVyNTyZOHTee946PQKPoeDffw4777eW/yVs60xv+ZxOnr4Okx1t05KRv8Ao41Z5q3yed5m\nXY1szXRZ5jvFJ/hxItP0aOSN9q7yrtr4f2tHFM5+KT16Yq/vK/iGSbXw4vO14UcPx5MGfNbPG18m\n1oj4THRsTw7VanPXVYpi3gzMcnrvCnG11JOupwuN8+a3pEQ6jT4divjxWnJExa09pbjbM5HHu90A\nJUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAHM41H1GOf6nTc/jEf4Ws+lls/UX45uGekNujTwdm5RNIthKIZKLDFlsiQIShIC\nEgCUJ7AmGTGO7IDzZQhMSDJMMYZQgZwzhhDOATuqssmVdgVWVWWyqtCBTeVF19lF+wNLNG7q8I+9\n8nLyupwnt+S8RXUAQAAAAAAAAAAAAAAAAAAAAAAItWL1mto3iY2lyrcLyUxzix2ia2nvPeK+jrCL\nOrTVnxpanhuPPemSs8l6RtE7dJj0ldpNP9GwRSZ3neZmV4cR/Vs4AJQAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANHi1d9H\nM+kt5ra+vPoskfDdOfqK4mn7Q3aNHBPZu0W0RdDOGFWcKLCJZeTGQQlCQSgASBsCYZQxhlAJTAmA\nTsmAgGcM4YQyjsgRLC3VnaVcgwsrt3Z2V2QK7tbJ1bN5a9waeWO7p8Knt8nNyebpcK8vkvlFdQBA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAK9RXmwZI+ErEWjesx6wQeZwejeo0cccuW8\nelpblJaaRGxVnCuss4ZrMvJEgCAASISCQIBlCYYpieoM0wx8k7gzIRueYM4Z79FcSy3QEsLJmWFp\nBjaVVpZWlXMoGNmvkXXlr3kGtknu6XCf7OXkl1OEdl8orqgIAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAHmskcmtzV/rls0U62OXiWX4zErcc9GmkRfWVkSqqziWayxCPIANwBIhIJSxS\nCRG6dwZwlhEs4BluMdzfqgZxLLdXuy3AmVdpZTKuZBjaVVpWWV2QlhZRdfZRcGpl7urwfrzfJy8r\nrcH61vPyWitdMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHA4nHLxKZ9awnH2ZcY\njbW459aq8fZpfiI2IZwrqzhmsz3Ebm4JN0AMhCQSIASndiAziWUSriWcAyRujc80DM3RCfIETLCW\nUsZEsJYSslXZAwlTddPZTkBp5e7r8Gj6rJPxhx8k9Xa4PG2C8/FaK10QAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAcfjcbZMFvnDWx9m5x2PqcNvS+zSxT7sNPxH62YZQwqzhRZO6UCB\nKUAJTux3SDIRuAncQAmJZRLBMSgZ7iIAZRKd2DICUSlAljLCYWMLIFVukNfI2bNbIDTyT7zu8Ijb\nSz/qcG/2nf4T/wCE/wD2WnxWt4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHL9oL\n+Hw2cm28VvEuPptfgyVj6yIn0no7/FtJfW8NzYMe3PaPd39d3iMug1WktNc2C9dvPbeP1aZ9xF+v\nT471tHu2iflK2HkqWmvaZj5Surqc9Ps5bx+alTHqYHm68S1Vf/NmfnC2vGNTXvyT84Ql6A3cSvHM\nsfaxVn5Ssrxyv3sM/lKB1xza8bwT3pePyWV4tpZ+/MfOEjfGrXiGlt2zV/PotrqcN/s5aT/+wLRj\nFontMSlAlKEgndO6IAZQljDIEgeQljLCzOVdkCu/SGrkbF56NPNeKxMzMRHxENe0+89DwuNtHHzl\n5PJr8NcnLW3Pbf7r1nCZm2gpae8zMrz4i/W6AgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAETETG0xukB4HVaeMHEtRi26RedvkyjBSfX9W77QYvC4xz7dMlYlrU7M929dWJLFc6aPK0q\n7YLxPS0S22FlP6q38Zac0yR92s/KVc3tHfFf8tpbcsLRvB/dR/8ALLVnU0r9uL1+dZI1mnmdvGpv\n6TOy6ym+Oto2tWJ+cJ/tW+KLK5KW+zes/KU7tG+h01p64qx8Y6NXNo6Y+uPJlp8rLf0rfG7MXtHa\n0x8pZxqs9e2a8f8A7Oj7HaTHn0+f6RWM23LETfr6vRW4PoL99NT8ui7F4+vEdXXtnt+fVbXjGsr/\nAOZE/OsPS29nuH27YrV+VpeV9pdPXhOtw49NG9Mld55+vXcTPd42I47qo7xSfyWV9oM8d8VJ/VxM\nd8l46xWF9cV7en6o/qLfxp2I9ob+eCv/AHMo9op89P8A/wBORGmyT5R+qfo2X8P7n9Q/jTsx7RR5\n6ef+4/8AuHftg/8A6cWcOSO9J/WEbWr3pY7Efzp2Lcfv5YK/9zWy8d1E/ZpSv5Oba1/+Hb9lc+LP\nbFt87I7E/wAabWbiurvEx4nL/pjZzc2bJkn372t85ZXx55/BX85lucC0vPxnTxlnnjm32mOiZqUu\nLJ2p4TwnVavNWaYbRTfre0bQ99pcH0bT0xb78vmtiIiNojaErMwAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAHnfarF7umzRHaZrLjYrdIen9ocPi8JyTt1xzF4eUw23rCm3R4r6bMy\nwt6kdTaWLdjswmNoZontsCm0K5XWjopnuDC0dGpqG5bs08/daKV672MjbSaif6oh6Z5f2LtvptRX\n0tEvUN3Jfo8f7cYve0eX4zV7B5z20xc/C8eSPuZIRficfXlcPaG7ino08HWIbePpLF2NuiyOyrHK\n3fZFSwuovHVfaVF4QK5YWTM9UT0EKry6Ps1Tn4zjn8NZn9nOtLseydObiWW34cf918fWfk+PYANn\nKAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAq1WKM+ly4p+/WYeBxTNd6zG0xO0\nvobw3FcP0bi2em20Tbmj5Srr418V9sa2Z7qKyzi07MXUylhaU7yjqhLCeiq3ddaFNxFYW7NLNG8t\nzya+WO6Va9J7FW66mvwidnrXiPY3Ny8RyUn71Jj9Ht3RPjk19HK9pMHj8D1ER3rHN+jqqtTjjNps\nuOe16zAifXzfTz7kNyndpYazS9qT0mszDdoxrsi6m8LazMq6zDOsq1ZEyrt1WWlXaUCqyq0rbKbi\nFdp6PReyFd8uqv8ACsfy83aXrPZHHto89/xX2/SP/dpj6y8vx6EBq5gAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAB5n2q03LfDqqx39y39npmlxbS/TOG5se29tuavzgWzeV4mtui2\nO3RRSY2hdVhqO2MvI36iu9lUsrSrvDHn6spnmSiq5jooyV6tq1VV69RC32byTh43h8otMx+r6I+Z\naK/g8TwX7bXh9Mid4iW+fjl8n1ICWb57xLBOm4zqse20Tbmj8+qKdnS9q8PhcTw5tumSm0/OHMxz\n0Za+uzx3sX1t0Zxurr1ZxvspWiZYWZbsbT0QK7KLrZVZJFaqt5vbezNOTg9J/FaZeJns93wCvLwb\nT/GJn92uGHldIBowAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADuAPA67F9H4l\nqMW20VvO3yRWW97T4fC4rXJHSMtI/WGhVlue3b473K2KzMML4+62tujG9pnozXaOSOVFMnVbmq1t\ntrJRW5E7wwvUxTvCyY6CHOt7moxz6Wh9PxTzYaT61h8x1MbZK/OH0zTf+Fxf6I/htj45vL9WgLMn\nmvbPFvocGWO9L7fq85p5maw9d7VYvE4JkmPu2if3eW0+PasdFNOnxfF1Y2hlykRsmY+LJ0MZjZXa\neq2eyi8oQTO0KLdZWzPRjWu6VaqtHR73g0bcI0sf0Q8Nkq93wqNuFaWP+XDTDDytwBowAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAef9q8HNpcGaI60vtPyl56k9Iew49j8ThGe\nPwxFv0l4zH2U26fDfTYiyJljvsjf4sm6vJ1hrXjq2MkqLdZEVbgbMx0auGdmzNt6iHN1Ub5af6of\nTdPG2nxx6Vj+HzaaTm1+nx/iyVj930ysbViPRrj45vL9SAuyc7j1efguqj+jd4/T33rD3HEcPj8O\n1GP8WOY/Z4TTT7sKadHhbcsZnaCJ3TPZk6VdrKbTutmP0U2nqgrGOsr8deiuI2X09EqKM1dt3uuG\nf/jdN/06/wAPE546S9rwud+Gaaf+XH8NMMPK2wGjAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAABrcRp4nDtRWPPHP8PCYusPoWSvNjtX1iYfPuWaXtX8MzCuvjfw32siu8ptXoxi\n0wy5t4YulReqmazu2skbquURWFInddM7VYRGyL291KFnCcfj8e0le/Lbmn8n0N4b2Ur4nHLWmPsY\n5e5a5+OXyXugBZmiY3iY9Xz7NjnTa3Ph/BeYj5PoTxftFg8Hjk2iOmWkW/Psrr418V5WrWd2faFc\nV2jdnEMXWxntupmN7NiYU27iWML6dVMVnddjgVqMsdHr+CW5uE6f4Rt+7yuSsTDv+zWXn0WTHP3L\n/tK+GHl+O0A1c4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8Dn93W56/wDM\nt/L3z59qp24jn+OS38lnpr4r7ZxHQ2TEstt3PXUrt27K57rr1VT0BjKnJPRbMqMs7QlV2fYvHvrd\nVknyrEfu9m8f7FZI8fVU85iJewbT45NfQBKo817W4eulzxHaZrL0rje09ItwqbfhtBVs3leai8RD\nKLw1sduesL606dWFdsZT1jdhNeq6K9DlhCVUU6s4jZnt1YzAhnM71dH2bycmszY/K1d/0c6OzY4R\nfwuK4p8rTstn6z8k7HrwGzkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHz3\nVxvr80/8y38voTwGpj/F5/8AqT/JfjTx/WVeyY6FPspc9dZPVXaOq2WEwIUTVRmjo2rNfLHRI3vZ\nDJycXtX8dZh7t879nsnhcbwz23tt+r6I2nxyb+gCVBzuPY/E4PqI9K7ui19fTxNBnp60n+Aj5/pJ\n3jZu1aOnnltMNussdfXbm+l3ZM9URHREdZVXTuT1Nk7boQiOkJw28PU47/htEp5eivJPLMTCZ9Vv\nx7mJ3iJ9UqNHk8XR4b+tIXuhxAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD\nweqjbWZ4/wCZP8vePCaz/wDIaiP+Zb+UX408f0r9lOxWOifJhXWjfyYWllPRXYQxnrCrJHRd3YZI\n6A1NJecHEsN/S0T+76bE7xE+r5dk93LW3pL6ZpMni6PDf8VIn9m2fjm8s9rgFmQxvHNS0esbMiew\nPnHLyai9fS0w2aNfUTtrs3+uf5bGPqy068fF227KtSsdFlKqNGMV6myyY6sbdIQI8tlOWOi6Jhhk\nj3RD0vA8nicMx9etZmHRcT2Zyb6XNT8N9/2dt0T449T2AJVAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAHhdfG3E9TH9cvdPEcXjk4zqI/q3L8aeP6xr2TsxpLOekMK6mFo6qpXSrm\nOqBixvHSVmzC4OfqK7S9/wAByeLwbTW9K7fo8Fqo6Paeyl+fglI/Da0NcMPK7QC7AAB8313TiOf/\nAKk/y2MHWrX4jG3E9R/1Lfyv0/aFNOrHxuU7LI7MMayGTVlHWUXhNe6Z6wIUsb9d1m20q7dkDpez\nN9tRqKT5xEvRvKez9+Xis1/FSYerb5+OTyf6AFlAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAB43j9eXjN/jWJ/Z7J5L2mry8Upb8VIF8f6aGOey2eynHvOy7bowrrYSxZSwQJ2YXZ\n92N4BoanrEvVexmTm4blr+HJ/aHltRHSXofYm/1Wrp5RaJaYY+X49WA0c4AD51xONuKan/qW/lbp\n+0MOLRtxbU/9SU4J7KadWPjep2WQrr2WRPRk1TvsndXMpiRCb9FNu0rbTuqvKBscCjfi9PhWZeue\nV9n434rafTHL1TfPxy+T/QAszAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHmv\navHtfTZfnV6VxPajHzcNrf8ABeJFs/XnMcr4no18c+6vr2YadkY2YM57sEDLyY37Mo7MMnYGlqO0\nvQ+xNfqNVb1tEfs87qZ2rL0/sVX/AHdnt65P7Q0wx8vx6UBo5wAHz/jUbcX1PT78qtO2vaCnJxjP\n8Zif2amnnspp04+OjWejKJ6MKdmcMmyJn4m5ZHzEVPMwtJv0VZLbQDqezcb8RzT6Y/7vUPM+ytZt\nn1OTyiIh6Ztn45N/6AFlAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABocbxeLw\nnUR5xXm/Rvq8+OMuDJjntaswEeBxT0bNZ6NatZpNqz3rO0rqsdO3PxlaWEMpY+aqWXkryT0ZT2V3\n7A0dVPuy9f7G124NM/iyT/Z4zWT7sw957MYfB4Fp4/FE2/WWmGHldcBowAAeM9qKcvFeb8VIly9P\n0nq7ntbTbVYL+tJj93CwT76unR4/jo0nozhhTsy3Y1sWljM9Ce7HyQIm3RRlttVbaWrnt0Sh6n2U\nx8vD8mSfv3/h3XN4Bi8Lg2nj8Uc36y6TeOPXugCUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAPD8RxeBxXUU26Tbmj8+quro+02Lw+I4ssdslNvzhzazvDPbq8d7GW7Dfqz2VzG\n0s2qd+iu/Zn5Ksk9BVztX1mI8930zh2LwOHabH+HHWP2fNYp4+vwYvxXiP3fUqxtWIjyjZtj45/L\nfaQFmQADzftfj3w6fJ6WmHmsP23rvaqnNwqLfhvEvIYZ+sV038bo0noy36MK9oZQxrdMyrlnMbMZ\nQKrS1M07zEestq/RRjr4utwY/wAV4j91p9V18fQdJj8LR4ccfdpEfsuREbREJbuMAAAAAAAAAAAA\nBAJAAAAEAJEAJQAJQAJEAJQAJQAJEACUJAQlAJEAJQAJQJAAAEAJEAJBAAAJAABAJEJAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwvanDzaPFmjvjv8A\ntLztJ3h7HjGHx+FainnFeaPnHV4vFbeIU038VbHeGF+kso7Mb9mTdhKnLK3dRm7SIrHhGPxeP6Sv\n9cT/AHfSnz72Zx+J7Q45/BWZ/Z9BbZ+OXyfQBZQABzeP4/E4NqI9Ii36S8Ng/wAx9C4jTxOH6ivr\njn+Hz3B/mQi/GvjdCnWNlsdI2V07LIlg6USrt2ZzZXMoFV+zPhGLxeOaavpbm/RVltEN72Yx+Jxm\nb7dKUmf7L5+s9/HtRA2cqRACRACRACRACUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAACQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQCQQCRACRACRCQBCQBCQB\nACRACRACRACRACL1i9LVntMbPATTwdRkxT3pea/u+gPE8Xx+DxrPHlaYt+qNfGvjvtXXsi0dOrKk\ndEXjZg6VMtbP2bMtXUdpEV0/Y2nNxbNf8OP+727xvsXH+N1U/wBEfy9k3nxyb+gCVQAGOWvNivX1\nrMPnGGOXNNfOJ2fSZ6w+dZKeHxDPX8N7R+6L8a+L63KdoZ7q6zvEMpnowdKJ6ywmWUyqvIKM0vQ+\nx+D6rU55+9aKx+TzWa36vbezmDwODYenW+95/Nphj5L6dQBo5wAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAEiAAAEoA\nAAAAAAAAAAAAAEAkEAkRuAkQbgkQAkQAkQAkQAl5T2nx8nEMOT8dNv0l6pwfarHvpcGWPu32/WCr\nYvK4mOem6b9mGKd4Z3idmFdka0y1c892zfpMtLPaNpEV6D2Kj/Eauf6YeweQ9ieuTVz8K/3evbT4\n5NfQBKoAA8FxCvJxrUx/XMvevD8Zry8fz/Haf2RfjTx/6RSOnRMyypHu9kXjowrqVSrvPRnZVl6V\nkK0775MsUjvadn0nT4ow6bFijtSsVfPuFYvpPGtNTy54mfy6vorXDm8l9pEC7JIgBIgBIgBIgBIg\nBIgBIhIAgBIhIAgBIgBIIBIAAhIAhIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJAAAAAAAAAAAAAAA\nAAAAAAAAABAJQkAEAAAAAAAAAAjc3BIjdG4Mkbo5kcwMjdhzHMDPc3V8xzAs3N1fMjmBZubq+Y5g\nWbm6vmOYFm5ur5jmBZubq+Y5gWbm6vmOYFm5ur5jmBZubq+Y5gWbm6vmTzAz3N2HMnmBlu5ftFTx\nOEZJ/DMW/d0t2rxKni8N1FPWkiZ9eS08e7Cy8dGGn6UhZaJljXZGnmc3UT3dPP2cnUT78xCIV6j2\nH/8A9c/6f7vXPI+w8bU1U+vL/d63du5NfUiDcVSIAS8b7RV5eOb/AIqRL2TyXtNX/e2KfXH/AHlF\n+NPH/pr4+2xcxx0hFpY11K7R16KM32ZWz3UaidqSgrc9kcPicWyZJjfw6T+727y3sXh2xarN+K0V\nh6lvPjj3e0ASqAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJQAAAAAkQAkQAkAAAAAAAAAAAAAAA\nEgAAAAAAAAAAAAAAAAAAAAAgAAABKDcAN0bgkY8xzAyRux5kcwM9zdXNkTcFm6OZXzMeYFvMibKu\nZHMC2bo51U2RuC2bom6rc3BZzom6sBZzI52ADPnOdggFnMc6skFnMc6rc3BbznOp3RzAv50c6nml\nHMC/nOf4qOY5wX85zqOc5wbHOc7X5znBsc6edr85zg2ec52vzpi4NjmY5bROG+/bllVzsNTk5dLl\nn0pP8BHmMHWNmzt0aum8obm08vVjfrtnxztR0mXHzTvaZdjVRMTLkZo6yiFen9iZ2pqY/wBP93rN\n3kPY+/LfPX1rE/u9XzN3HfqzdO6vmTuIZ7m7Hc3Bnu8t7TR/vHBP9E/y9Pu837SV31umn+if5Rfi\n/j/01MMb1hjkrtKzBG0bMsmOZY11tOYamr6Und0LUc7XT7u3rJPqL8er9lcPhcFpbzyWm39v7O00\n+FYvA4Zpsc94xxu227jv1IAgAAAAAAAAABKAAAASgASgBIgBIgBIgBIhIAAAAAAAAAAAAAAAAAAC\nUACUJAAAAAAAAAAAABIAAAAAAAAAAAAAAAAAAAAg3AEbomQZbo3YzLGbAz3RNlc3YzcFs2YzdVN2\nM2Bdzom6nmNwW86JurTAMuY3REJ2BB1ZRVMVBhsbSsiqeUFXLucq3lTygp5TlXcpygp5TlXcpygp\n5TlXcqOUFXKjlXcrGYBXysdlswiYBVMdUTCyY6sZBWxlnMMZgGLGZZSwkDdHMiWO4MuY5mEyjcFn\nN1OdVzHMC3nTzqeY5gX85zqOZPMC+Lqdbk20eb/RKOZr8QybaK/XvtH7iZ9aGlp2luzT3fg19NHS\nOjbmPcYX67XH1XSZ9XIzRvMuzrK7zLkZYmYnciunb9lZ5dTk+OP+71cXeP8AZnJ/ip2nf3J/l6iL\n/Fu5L9bMWZczXi6YuIbEWTzKIuyiwLt3nuO25uI4a/hx7/rLuczg8TicvFLbfdpEK6+NPH/phhjo\nstLGkctUWnoxrrU3j1cnWTzZq1jzl1clo5Zcu8c+txR63iP3Tn6pv4+g4o5cVI9IiGe7CJ2iE7t3\nGyN2O6dwSINwSISAlAAlACRAAlAAlACRACRCQAAAAAAAAAASgASISAAAAAAAAAAAAACQAAAAAAAA\nAAAAAASAAAAAAAAAAAAAAAAIAAAQCAJljuljsCJlhMs9mOwMJYys5TkBVsjZdyHICrZPKt5E8oK4\nqmKrOVOwMIqyirPY2Bjyp2ZbAI2NmSARsbMgEbI2ZAMdjZICNkbMkSCNmOzJEgx2YyzljMAwlhKy\nWEwCuWErJhhMArlhLOWEgxljMpljIImWMyTKJA3N0IBO5vux3NwZbnMx3NwZczT4jf3MdPW27a3a\nfJOq1XNP2KdIRfi+J2trSYfcjeF+Wm1OicVeWIiN9kai8xjY12ORqultnI1Ecsujq79XP1FovWYI\nrTgeq+j8QrWZ+3Mx+r2UXeC0WG2Ti2kiN5mL807eUREvbzbaejefHJv62Iv8WUXa0WTFhVtRdlF2\nrz9WUXBtc7jR9dqc2T1ttHyhvZMvJitb0jdq6XHNcNenWVN3028U99WRj6Kb02be3Tq18/SN2Lpc\n3UdN9nOmZrqKX/DaJ/d0svvTLRzV3jomK6+Pd1vvWJj0ZczT0mXxNJht60hfFnQ4qu3N1cWTEgs3\nTur5k7gz3N2O5uDM3Y7m4MtxBuCQASIASIASAAAAAAACRCQAAAAAAAAEoSAAAAAAAAAAAlAAlCQA\nAAAAAAAAAAASAAAAAAAAAAAAIASgAAAEJAQJQCNkbMgGOyOVnsAw5TlZ7GwMOVPKy2NgY7GzIBGx\nskA2AAAAAAAAAAQkBAEghEskAxYzDPZGwK5hjMLJhjMAqmGEwumrCagomFcw2JqqtUFEsLLrV82F\no7gqljKyYYTGwMZRKUSCAQAboJnaN5Bjkneu0d5W4ccViIiOzHFWbTzNumP1Zarr8eeRMbxDW1Mx\nNO67NbkhzNVnmInqzaOZrL93JyZeV0M1++7S02jvxDWxhxx033tPpC8Z6rrezWjmZyazJG2/u03h\n2vFibTHoqvamiwVwY+nLGzV0+SZ1Mx8G0/45tOhzJ5lXMc3UVXRdlF1HP+iYsDPLPPy49/tz1+Te\npSIr0ho6ak5Ms5J8o2q6NImOrHV7XX488ypzTtHXo0s9t6zG7c1G1qz6ubeZiZ3UatXJG3yauSO7\ncvMTEx5tPLb3prPRMVr0HB8vicNxf0+7+kt+LOJwTJyY/Bnz3tH93X36N58cWvq6LSyiyndMSlC7\nmZcymLJiwLosmJVRLKLAtiU7q4lMSCzc3YxJuDMRuAlKAEgAAAlAkAAAAAABKAEgAAAAAJAAAAAA\nAAAAAAAEgAAAAAAAAAAAAAkAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAhIAAACAAAASgAAAAAAEAAAA\nhGzJAImGMwzQDDZjNVuyNgUTVhNGxysZqDVmiu1G5NN2M4waM0+DCaN2cbGcQNGaMZq3JxMJxA1J\nqx2bU4kU09slorWNwa20z02RXHbJbl26QvtFovbHWkxEdJt5y2MOHlr2U1W3jx+1hiw8vSO63lmI\nXRTaEWmtY6snRHO1VpmJ+DjavpSZl2s8b7y4HFcnh0n0gha5ebJN55KRM2mdoiPN6fh+kpwXh0Wy\nRHj5Otp/s5Ps1p62y31+em9aTMYt/OfVfxTiPjZ52naI7fBrI5t66xz5+a1rW7yx0eSL6iZjtEOX\nqNbSletom3lENjh2fbHzbbWt3iVozruc+5ztWubf4M4ybpQ2Oboyrva0Vjza8WdDR4OkXt3n9ldX\nkaePP9VtYqctYhdvt5oivTeCZ2YOxXk6ubqMfV0b9mrljfqlFcq88k7z2U5axeItDa1OPessuC8P\nya7XRWYnwqdbT/ZMilvIu4dpslNdixXja8Y5tt85djZdbDWnGOesRtXFtuw6T27No5Kx2OrKYQlC\nExKJgBnEpiyvdlEgsizKLKollFgWxLKJVRLKJBbEp3VxLKJBnuMWQJEbpBIAAAJAAAABIAAAAAAA\nlAJAAAAAAAAAAAAAASAAAAAAAAAAAAAJAAAABAJABAlAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAA\nAAABAJQAAAAgAABAAI2EoBGyJhkgGPKxmqxAKpownHC+YRMdN5BrTj67R3bOn01o7p01Iv71u89o\nb9a7LfBTfS1vWI2jf12VfQPSW8KX2mas+NC2iv6xMNfJpMnLtEbuuxtMRCtzF55NR5rPps1N/ctP\ny6uHreE6nXZ4pak48X3rT06fB7fNeI33cbX6mI32R/MWu7XF116aDSRhxbRERs8f499bkyZeeKae\nkzE2mdon81/tfxDLGOunwbzlzbx08oaHBvZHJlx48mrvaa94pu04y617576rNGLRRM0397JEd/lu\n9Dw/S3x4qxffo6mm4NjwUiKY4iI9Ib1dHFY6QIaNabbrYrLfrpJtaK1rMzPZb/s+05IpP59OyLeJ\nk7eNfRaOc1ue32I7fGXYpi5Y77M8OGMeOKxHSFsU3Y29deZMzirl6dlVvhLatCjJHeYQv1rXnps1\n8k9/VsW6qLVmZIi1rzitlvFKRvaZ2h6TSaenC9FFY+3brM+sqeG8Prp4+kZ+lvuxPkr1mqm95nfp\nDXM459676a2q1dsV7XietvNno78+CJn1cjX6mOeIm0bR33dfRU5NJjidt9t5afjG/V6JZ7I2QMNh\nnyo2BhsMuVG3wAhMSbbQRAMolnE+iuGUSCyJZRKuGUSCyJZK4llEgyZMYTuCUsYSCQASISAAAlCQ\nAAAAAAEoASCASAAAAAAAAAAAAlACRACQAAAAAAAAAEgCEoASCAAAAAAAAAAAAAAAAAAAAAAABAAA\nAAAAAAAISAIAAAAAAQAAACASgAAAQJAQAAhIDHZhln3do7z0WS18mWsajHjmes7pg3dNi5aRMNqO\nyvDHTpPRaigHZhN4hHRlaVN59JY3zRENLUavaO+yq0iNVlitJ6vNcR1MVi0zO0era1/Ea0rPvbz5\nPM5MWp45qvo2GZrhmfrsnpHpHzTCseEcM/2vrr8Q1Eb4qzy44nziPN63HpYiIiI7LNHoqabBTFii\nIpSNohuVxrKtWMEejPwY9G1FFmHB4mWJn7MdfnIM9JpIx15to5pbUaas/a6rqViI7MxPxqX0UT1r\nO3wVzpbR2hviP5i03Y5s6a879FNtHljydhExCv8AMTPJXBnRZbz0iG5ptFjwe/l96zctMVamTJtE\nyTMibu1VrdTzRMR0j0ed4lr64MVpm0RERvMz5NvX62uOJ69XhOKX1HH9bHDtFvNYnfJeOy0Z2ojX\n6jjnEq6fRUmccTvN/J9H0eKcOnx45neaxEbubwHgOHg+milI3vP2resu3Wu0JQmITsmISDHZHKz2\nJgFc1RMLJhGwK9iIZ7MZgEdgmAEwyiWCdwWRLKJVxKYsC2JTuriWUSDNlEsIlMAySx3SCRCQSIAS\nAAACRACQAAAAAAASIASAAAAAAAAAAAAAAACRACRACQASIAAAAAAAAAAAAAAAAAAAAAAAAQCUAAAA\nAAAAAAIAAAAAAAAQAAAAAACBICBICAAEJAQJQCJcLjuS2ny6fPG/LWdpd1o8T0X07SXx/e7wCdJx\nWa0jmneHQpxPDMdZmJfNtZm49weZrh0/j4o7VtSZ2+Uw0/8A7o49k92vBLc/ntFohFW9PqGXimOI\n6Tu1L8T3eCx6r2t1O3JwvHjifO99v7t/Bwf2l1PXU6rS6eJ8qUm8x+so5TsekzcSjbvs4mt4rzW5\nK2mbT0itesy2cHsvbvqtbmyz5xERWP2jd1tJwrTaONsOKtZ8585+cnDrzmn4Rq+IZObUROHD32n7\nVv8A0ej0uhxaXFGPFSK1j0bkY4jyZRVZVXFGUVWbGwKsk8mObekNrSW3pWf1a2aYjHbm7bNnQ1id\nPW0TvuDdhJEbQABMsLW2R0ZTMQrvfbz2YWzVhpanUxEd0dWkW5c8R5uXxDX1w4pnfr5Q19XxKuOJ\n2neXltVqtVxbV/RdJ715+1bypANfiOu1HENV9C0MTfNeesx2rD1PAeBYuE6aKx72W3W9/WVnBuB4\neF4dqRzZbdb5J72l160WVK02ZxCYhOwI23TsnY2BGxsnYBjsiYZsZBjMMZZSgGEolMsQDdG6NwZ7\npiVe6YkFsSziVMWZRILolMSriWUSCyJTuwhMSDMRCQSI3SAlACRCQAAEoAEoASAAAAAAAAACUACR\nACQAAAAAAAAAAAAASAAAAAAAAAAAAAAAAAAACAAAAAAAAAAAAAABAAAAAAAAAAAAACBKAAAAAAAQ\nJQAAAhICEbJAYTWJ7wx8KvpC0BV4ceieWGewDHlNmWwCNjZICNhIDmcZredBecdpiY69FXCOLW+i\nUiZidukulmxxlx2paN4mNng+K4+I8Hy2yaTfl37TXetoCPfRxfp1qi3F48ofKMvtvxak8s6LDv61\nrZji9rPaLUf5PC+bfttS0q8q3p9W/wBrRMdpUZuKdN99nzvFqPbTVz7nD8OKs+do2/mW3h4D7Xaq\nZnPrtNpqz35aRaYOHY9Zk4pNt9rR+rl6zi+OnS+WN57Rv1lXp/YrNaYtruL6zNPnGO3hxP6O5w/2\nf0HDuun09Yv55Le9afznqcOvO4tBreMTHu30unnva0bWt8on+70nDuE4OHYYx4Kbesz3tPrMuhGO\nIjpDOKrK9YVpsyiGUQnYGOyUgI2SlAIEmwMWMs9kTAMJYzDOYRMArmGErZhhMArlHmzmGMwDE3Ts\nbAbs4swj5pgFkSziVcM4BZEsolXDKAZwyhjCYBkACQhIAAAAAAAJAAAAAAAAAAAAAAAAAAAShIAA\nAAAAAAJAAAAAAAAAAAAAABAJEAAAAAAAAAAAAAAAIEoBKAAAAAAAAAAAAAAABAlAAAAAAAIAAAAA\nBAkBAkBAkBAlACEgMZjdjbFW8bWrEx8YWANb6Fp+bfwab+vLDKMFK9qxH5L0bAr8OPRPKz2AY7J2\nSbAjYZAI2E7AIEgIEgIEgMdkSy2NgY7MdlmyNoBXsxmFuyNgVTVjNV3KjlBRNTlXTVHKCrlIqt5T\nlBhEMohlFerLlBjEMohMVTEARDKCITsAk2AEgAAAkAAAAAAAAAAAAAAAAAAAAAAAASAAAAAAAAD/\n2Q==";async function warmupBitmap(e){const t=(e,t="application/octet-stream")=>fetch(`data:${t};base64,${e}`).then((e=>e.blob()));let n,a;switch(e.config.warmup){case"face":n=await t(face3);break;case"body":case"full":n=await t(body3);break;default:n=null}if(n){const t=await createImageBitmap(n);a=await e.detect(t,e.config),t.close()}return a}async function warmupCanvas(e){return new Promise((t=>{let n,a;switch(e.config.warmup){case"face":n="data:image/jpeg;base64,"+face3;break;case"full":case"body":n="data:image/jpeg;base64,"+body3;break;default:n=null}"undefined"!=typeof Image?a=new Image:env2.Image&&(a=new env2.Image),a.onload=async()=>{const n=canvas(a.naturalWidth,a.naturalHeight);if(n){const r=n.getContext("2d");r&&r.drawImage(a,0,0);const s=await e.image(n),o=await e.detect(s.tensor,e.config);t(o)}else log("Warmup: Canvas not found"),t({})},n?a.src=n:t(null)}))}async function warmupNode(e){const t=e=>Buffer.from(e,"base64");let n,a;return"face"===e.config.warmup&&(n=t(face3)),"body"!==e.config.warmup&&"full"!==e.config.warmup||(n=t(body3)),n?(e.config.debug&&log("Warmup tfjs-node not loaded"),a):null}async function warmup(e,t){const n=now();if(e.state="warmup",t&&(e.config=mergeDeep(e.config,t)),!e.config.warmup||0===e.config.warmup.length||"none"===e.config.warmup)return{error:"null"};let a;return new Promise((async t=>{a="function"==typeof createImageBitmap?await warmupBitmap(e):"undefined"!=typeof Image||void 0!==env2.Canvas?await warmupCanvas(e):await warmupNode(e);const r=now();e.config.debug&&log("Warmup",e.config.warmup,Math.round(r-n),"ms"),e.emit("warmup"),t(a)}))}var Human=class{constructor(e){__publicField(this,"version"),__publicField(this,"config"),__publicField(this,"result"),__publicField(this,"state"),__publicField(this,"process"),__publicField(this,"tf"),__publicField(this,"env"),__publicField(this,"draw"),__publicField(this,"models"),__publicField(this,"events"),__publicField(this,"faceTriangulation"),__publicField(this,"faceUVMap"),__publicField(this,"performance"),__privateAdd(this,_numTensors,void 0),__privateAdd(this,_analyzeMemoryLeaks,void 0),__privateAdd(this,_checkSanity,void 0),__publicField(this,"gl"),__publicField(this,"analyze",((...e)=>{if(!__privateGet(this,_analyzeMemoryLeaks))return;const t=this.tf.engine().state.numTensors,n=__privateGet(this,_numTensors);__privateSet(this,_numTensors,t);const a=t-n;0!==a&&log(...e,a)})),__privateAdd(this,_sanity,(e=>{if(!__privateGet(this,_checkSanity))return null;if(!e)return"input is not defined";if(this.env.node&&!(e instanceof Tensor))return"input must be a tensor";try{this.tf.getBackend()}catch(e){return"backend not loaded"}return null})),__publicField(this,"similarity",similarity),__publicField(this,"distance",distance),__publicField(this,"match",match2),__publicField(this,"emit",(e=>{var t;this.events&&this.events.dispatchEvent&&(null==(t=this.events)||t.dispatchEvent(new Event(e)))})),this.env=env2,config.wasmPath=version_core.includes("-")?"https://vladmandic.github.io/tfjs/dist/":`https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-wasm@${version_core}/dist/`,config.modelBasePath=env2.browser?"../models/":"file://models/",config.backend=env2.browser?"humangl":"tensorflow",this.version=version,Object.defineProperty(this,"version",{value:version}),this.config=JSON.parse(JSON.stringify(config)),Object.seal(this.config),e&&(this.config=mergeDeep(this.config,e)),this.tf=tfjs_esm_exports,this.state="idle",__privateSet(this,_numTensors,0),__privateSet(this,_analyzeMemoryLeaks,!1),__privateSet(this,_checkSanity,!1),this.performance={},this.events="undefined"!=typeof EventTarget?new EventTarget:void 0,this.models=new Models,this.draw={options:options2,canvas:(e,t)=>canvas2(e,t),face:(e,t,n)=>face(e,t,n),body:(e,t,n)=>body(e,t,n),hand:(e,t,n)=>hand(e,t,n),gesture:(e,t,n)=>gesture(e,t,n),object:(e,t,n)=>object(e,t,n),person:(e,t,n)=>person(e,t,n),all:(e,t,n)=>all5(e,t,n)},this.result={face:[],body:[],hand:[],gesture:[],object:[],performance:{},timestamp:0,persons:[],error:null},this.process={tensor:null,canvas:null},this.faceTriangulation=triangulation,this.faceUVMap=uvmap,this.gl=config2,this.emit("create")}reset(){const e=this.config.backend;this.config=JSON.parse(JSON.stringify(config)),this.config.backend=e}validate(e){return validate(config,e||this.config)}now(){return now()}image(e,t=!0){return process2(e,this.config,t)}async segmentation(e,t){return process5(e,t,this.config)}enhance(e){return enhance2(e)}compare(e,t){return compare(this.config,e,t)}async init(){await check(this,!0),await this.tf.ready()}async load(e){this.state="load";const t=now(),n=Object.values(this.models).filter((e=>e)).length;e&&(this.config=mergeDeep(this.config,e)),this.env.initial&&(this.config.debug&&log(`version: ${this.version}`),this.config.debug&&log(`tfjs version: ${this.tf.version_core}`),await check(this)||log("error: backend check failed"),await ready(),this.env.browser&&(this.config.debug&&log("configuration:",this.config),this.config.debug&&log("environment:",this.env),this.config.debug&&log("tf flags:",this.tf.ENV.flags))),await load19(this),this.env.initial&&this.config.debug&&log("tf engine state:",this.tf.engine().state.numBytes,"bytes",this.tf.engine().state.numTensors,"tensors"),this.env.initial=!1;Object.values(this.models).filter((e=>e)).length!==n&&(await validate2(this),this.emit("load"));const a=Math.trunc(now()-t);a>(this.performance.loadModels||0)&&(this.performance.loadModels=this.env.perfadd?(this.performance.loadModels||0)+a:a)}next(e=this.result){return calc2(e,this.config)}async warmup(e){const t=now(),n=await warmup(this,e),a=now();return this.performance.warmup=Math.trunc(a-t),n}async profile(e,t){const n=await this.tf.profile((()=>this.detect(e,t))),a={};for(const e of n.kernels)a[e.name]?a[e.name]+=e.kernelTimeMs:a[e.name]=e.kernelTimeMs;const r=[];Object.entries(a).forEach((e=>r.push({name:e[0],ms:e[1]}))),r.sort(((e,t)=>t.ms-e.ms)),r.length=20;const s={};for(const e of r)s[e.name]=e.ms;return s}async detect(e,t){return this.state="detect",new Promise((async n=>{var a,r,s,o,i,l,u,c,d,p,h,m,f,g,x,y,A,b,v,k,S,w;let C;this.state="config",this.config=mergeDeep(this.config,t),this.state="check";const I=__privateGet(this,_sanity).call(this,e);I&&(log(I,e),this.emit("error"),n({face:[],body:[],hand:[],gesture:[],object:[],performance:this.performance,timestamp:now(),persons:[],error:I}));const T=now();await check(this),await this.load(),C=now(),this.state="image";const N=await process2(e,this.config);if(this.process=N,this.performance.inputProcess=this.env.perfadd?(this.performance.inputProcess||0)+Math.trunc(now()-C):Math.trunc(now()-C),this.analyze("Get Image:"),!N.tensor)return this.config.debug&&log("could not convert input to tensor"),this.emit("error"),void n({face:[],body:[],hand:[],gesture:[],object:[],performance:this.performance,timestamp:now(),persons:[],error:"could not convert input to tensor"});this.emit("image"),C=now(),this.config.skipAllowed=await skip(this.config,N.tensor),this.performance.totalFrames||(this.performance.totalFrames=0),this.performance.cachedFrames||(this.performance.cachedFrames=0),this.performance.totalFrames++,this.config.skipAllowed&&this.performance.cachedFrames++,this.performance.cacheCheck=this.env.perfadd?(this.performance.cacheCheck||0)+Math.trunc(now()-C):Math.trunc(now()-C),this.analyze("Check Changed:");let _=[],E=[],P=[],R=[];this.state="detect:face",this.config.async?(_=this.config.face.enabled?detectFace(this,N.tensor):[],this.performance.face&&delete this.performance.face):(C=now(),_=this.config.face.enabled?await detectFace(this,N.tensor):[],this.performance.face=this.env.perfadd?(this.performance.face||0)+Math.trunc(now()-C):Math.trunc(now()-C)),!this.config.async||-1!==this.config.body.maxDetected&&-1!==this.config.hand.maxDetected||(_=await _),this.analyze("Start Body:"),this.state="detect:body";const M=-1===this.config.body.maxDetected?mergeDeep(this.config,{body:{maxDetected:this.config.face.enabled?1*_.length:1}}):this.config;this.config.async?((null==(a=this.config.body.modelPath)?void 0:a.includes("posenet"))?E=this.config.body.enabled?predict17(N.tensor,M):[]:(null==(r=this.config.body.modelPath)?void 0:r.includes("blazepose"))?E=this.config.body.enabled?predict5(N.tensor,M):[]:(null==(s=this.config.body.modelPath)?void 0:s.includes("efficientpose"))?E=this.config.body.enabled?predict7(N.tensor,M):[]:(null==(o=this.config.body.modelPath)?void 0:o.includes("movenet"))&&(E=this.config.body.enabled?predict15(N.tensor,M):[]),this.performance.body&&delete this.performance.body):(C=now(),(null==(i=this.config.body.modelPath)?void 0:i.includes("posenet"))?E=this.config.body.enabled?await predict17(N.tensor,M):[]:(null==(l=this.config.body.modelPath)?void 0:l.includes("blazepose"))?E=this.config.body.enabled?await predict5(N.tensor,M):[]:(null==(u=this.config.body.modelPath)?void 0:u.includes("efficientpose"))?E=this.config.body.enabled?await predict7(N.tensor,M):[]:(null==(c=this.config.body.modelPath)?void 0:c.includes("movenet"))&&(E=this.config.body.enabled?await predict15(N.tensor,M):[]),this.performance.body=this.env.perfadd?(this.performance.body||0)+Math.trunc(now()-C):Math.trunc(now()-C)),this.analyze("End Body:"),this.analyze("Start Hand:"),this.state="detect:hand";const F=-1===this.config.hand.maxDetected?mergeDeep(this.config,{hand:{maxDetected:this.config.face.enabled?2*_.length:1}}):this.config;this.config.async?((null==(p=null==(d=this.config.hand.detector)?void 0:d.modelPath)?void 0:p.includes("handdetect"))?P=this.config.hand.enabled?predict12(N.tensor,F):[]:(null==(m=null==(h=this.config.hand.detector)?void 0:h.modelPath)?void 0:m.includes("handtrack"))&&(P=this.config.hand.enabled?predict13(N.tensor,F):[]),this.performance.hand&&delete this.performance.hand):(C=now(),(null==(g=null==(f=this.config.hand.detector)?void 0:f.modelPath)?void 0:g.includes("handdetect"))?P=this.config.hand.enabled?await predict12(N.tensor,F):[]:(null==(y=null==(x=this.config.hand.detector)?void 0:x.modelPath)?void 0:y.includes("handtrack"))&&(P=this.config.hand.enabled?await predict13(N.tensor,F):[]),this.performance.hand=this.env.perfadd?(this.performance.hand||0)+Math.trunc(now()-C):Math.trunc(now()-C)),this.analyze("End Hand:"),this.analyze("Start Object:"),this.state="detect:object",this.config.async?((null==(A=this.config.object.modelPath)?void 0:A.includes("nanodet"))?R=this.config.object.enabled?predict16(N.tensor,this.config):[]:(null==(b=this.config.object.modelPath)?void 0:b.includes("centernet"))&&(R=this.config.object.enabled?predict6(N.tensor,this.config):[]),this.performance.object&&delete this.performance.object):(C=now(),(null==(v=this.config.object.modelPath)?void 0:v.includes("nanodet"))?R=this.config.object.enabled?await predict16(N.tensor,this.config):[]:(null==(k=this.config.object.modelPath)?void 0:k.includes("centernet"))&&(R=this.config.object.enabled?await predict6(N.tensor,this.config):[]),this.performance.object=this.env.perfadd?(this.performance.object||0)+Math.trunc(now()-C):Math.trunc(now()-C)),this.analyze("End Object:"),this.state="detect:await",this.config.async&&([_,E,P,R]=await Promise.all([_,E,P,R])),this.state="detect:gesture";let D=[];this.config.gesture.enabled&&(C=now(),D=[...face2(_),...body2(E),...hand2(P),...iris3(_)],this.config.async?this.performance.gesture&&delete this.performance.gesture:this.performance.gesture=this.env.perfadd?(this.performance.gesture||0)+Math.trunc(now()-C):Math.trunc(now()-C)),this.performance.total=this.env.perfadd?(this.performance.total||0)+Math.trunc(now()-T):Math.trunc(now()-T);const O=(null==(w=null==(S=this.process)?void 0:S.tensor)?void 0:w.shape)||[];this.result={face:_,body:E,hand:P,gesture:D,object:R,performance:this.performance,canvas:this.process.canvas,timestamp:Date.now(),error:null,get persons(){return join2(_,E,P,D,O)}},dispose(N.tensor),this.emit("detect"),this.state="idle",n(this.result)}))}};_numTensors=new WeakMap,_analyzeMemoryLeaks=new WeakMap,_checkSanity=new WeakMap,_sanity=new WeakMap;export{Human,Human as default,config as defaults,env2 as env};
