const debug=!0;async function log(...e){{const t=new Date,n=`${t.getHours().toString().padStart(2,"0")}:${t.getMinutes().toString().padStart(2,"0")}:${t.getSeconds().toString().padStart(2,"0")}.${t.getMilliseconds().toString().padStart(3,"0")}`;console.log(n,"webrtc",...e)}}async function webRTC(e,t,n){const o=t;log("client starting"),log(`server: ${e} stream: ${o}`);const a=new MediaStream,c=new RTCPeerConnection;c.oniceconnectionstatechange=()=>log("connection",c.iceConnectionState),c.onnegotiationneeded=async()=>{let t;if(c.localDescription){t=await c.createOffer(),await c.setLocalDescription(t);await fetch(`${e}/stream/receiver/${o}`,{method:"POST",headers:{"Content-Type":"application/x-www-form-urlencoded; charset=UTF-8"},body:new URLSearchParams({suuid:`${o}`,data:`${btoa(c.localDescription.sdp||"")}`})})}const n=r&&r.ok?await r.text():"";0!==n.length&&t?(c.setRemoteDescription(new RTCSessionDescription({type:"answer",sdp:atob(n)})),log("negotiation start:",t)):log("cannot connect:",e)},c.ontrack=e=>{a.addTrack(e.track);const t="string"==typeof n?document.getElementById(n):n;t instanceof HTMLVideoElement?t.srcObject=a:log("element is not a video element:",n),log("received track:",e.track)};const r=await fetch(`${e}/stream/codec/${o}`),s=r&&r.ok?await r.json():[];0===s.length?log("received no streams"):log("received streams:",s);for(const e of s)c.addTransceiver(e.Type,{direction:"sendrecv"});const i=c.createDataChannel(o,{maxRetransmits:10});i.onmessage=e=>log("channel message:",i.label,"payload",e.data),i.onerror=e=>log("channel error:",i.label,"payload",e),i.onclose=()=>log("channel close",i.label),i.onopen=()=>{log("channel open",i.label),setInterval((()=>i.send("ping")),1e3)}}export default webRTC;
